#[cfg(target_family = "wasm")]
pub mod paper {
    #[cfg(target_family = "wasm")]
    pub mod dist {
        #[cfg(target_family = "wasm")]
        pub mod paper_core {
            #[allow(unused)]
            use wasm_bindgen::prelude::*;
        }
        #[cfg(target_family = "wasm")]
        pub mod paper {
            #[allow(unused)]
            use wasm_bindgen::prelude::*;
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ViewOnMouseDown {
                TsBindgenRtNullCase,
                JsValueCase(JsValue),
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                # [wasm_bindgen (js_name = "Raster" , extends = Item_Class)]
                type Raster_Class;
                # [wasm_bindgen (method , structural , getter = resolution , js_class = "Raster")]
                fn resolution(this: &Raster_Class) -> Size;
                # [wasm_bindgen (method , structural , setter = resolution , js_class = "Raster")]
                fn set_resolution(this: &Raster_Class, value: Size);
                # [wasm_bindgen (method , structural , getter = smoothing , js_class = "Raster")]
                fn smoothing(this: &Raster_Class) -> String;
                # [wasm_bindgen (method , structural , setter = smoothing , js_class = "Raster")]
                fn set_smoothing(this: &Raster_Class, value: String);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getSubRaster , method , js_class = "Raster" , catch)]
                fn __TSB_get_sub_raster(
                    this: &Raster_Class,
                    rect: Rectangle,
                ) -> std::result::Result<Raster, JsValue>;
                # [wasm_bindgen (method , structural , getter = size , js_class = "Raster")]
                fn size(this: &Raster_Class) -> Size;
                # [wasm_bindgen (method , structural , setter = size , js_class = "Raster")]
                fn set_size(this: &Raster_Class, value: Size);
                # [wasm_bindgen (method , structural , getter = width , js_class = "Raster")]
                fn width(this: &Raster_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = width , js_class = "Raster")]
                fn set_width(this: &Raster_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getSubCanvas , method , js_class = "Raster" , catch)]
                fn __TSB_get_sub_canvas(
                    this: &Raster_Class,
                    rect: Rectangle,
                ) -> std::result::Result<JsValue, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = drawImage , method , js_class = "Raster" , catch)]
                fn __TSB_draw_image(
                    this: &Raster_Class,
                    image: JsValue,
                    point: Point,
                ) -> std::result::Result<(), JsValue>;
                # [wasm_bindgen (method , structural , getter = source , js_class = "Raster")]
                fn source(this: &Raster_Class) -> RasterSource;
                # [wasm_bindgen (method , structural , setter = source , js_class = "Raster")]
                fn set_source(this: &Raster_Class, value: RasterSource);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getAverageColor , method , js_class = "Raster" , catch)]
                fn __TSB_get_average_color(
                    this: &Raster_Class,
                    object: JsValue,
                ) -> std::result::Result<Color, JsValue>;
                # [wasm_bindgen (method , structural , getter = onError , js_class = "Raster")]
                fn on_error(this: &Raster_Class) -> RasterOnError;
                # [wasm_bindgen (method , structural , setter = onError , js_class = "Raster")]
                fn set_on_error(this: &Raster_Class, value: RasterOnError);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = setImageData , method , js_class = "Raster" , catch)]
                fn __TSB_set_image_data(
                    this: &Raster_Class,
                    data: JsValue,
                    point: Point,
                ) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getPixel , method , js_class = "Raster" , catch)]
                fn __TSB_get_pixel(
                    this: &Raster_Class,
                    point: Point,
                ) -> std::result::Result<Color, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getImageData , method , js_class = "Raster" , catch)]
                fn __TSB_get_image_data(
                    this: &Raster_Class,
                    rect: Rectangle,
                ) -> std::result::Result<JsValue, JsValue>;
                #[wasm_bindgen(constructor, js_class = "Raster")]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Raster_Class;
                # [wasm_bindgen (method , structural , getter = image , js_class = "Raster")]
                fn image(this: &Raster_Class) -> RasterImage;
                # [wasm_bindgen (method , structural , setter = image , js_class = "Raster")]
                fn set_image(this: &Raster_Class, value: RasterImage);
                # [wasm_bindgen (method , structural , getter = context , js_class = "Raster")]
                fn context(this: &Raster_Class) -> JsValue;
                # [wasm_bindgen (method , structural , setter = context , js_class = "Raster")]
                fn set_context(this: &Raster_Class, value: JsValue);
                # [wasm_bindgen (method , structural , getter = canvas , js_class = "Raster")]
                fn canvas(this: &Raster_Class) -> JsValue;
                # [wasm_bindgen (method , structural , setter = canvas , js_class = "Raster")]
                fn set_canvas(this: &Raster_Class, value: JsValue);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = setPixel , method , js_class = "Raster" , catch)]
                fn __TSB_set_pixel(
                    this: &Raster_Class,
                    point: Point,
                    color: Color,
                ) -> std::result::Result<(), JsValue>;
                # [wasm_bindgen (method , structural , getter = loaded , js_class = "Raster")]
                fn loaded(this: &Raster_Class) -> bool;
                # [wasm_bindgen (method , structural , setter = loaded , js_class = "Raster")]
                fn set_loaded(this: &Raster_Class, value: bool);
                # [wasm_bindgen (method , structural , getter = crossOrigin , js_class = "Raster")]
                fn cross_origin(this: &Raster_Class) -> String;
                # [wasm_bindgen (method , structural , setter = crossOrigin , js_class = "Raster")]
                fn set_cross_origin(this: &Raster_Class, value: String);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = clear , method , js_class = "Raster" , catch)]
                fn __TSB_clear(this: &Raster_Class) -> std::result::Result<(), JsValue>;
                # [wasm_bindgen (method , structural , getter = onLoad , js_class = "Raster")]
                fn on_load(this: &Raster_Class) -> RasterOnLoad;
                # [wasm_bindgen (method , structural , setter = onLoad , js_class = "Raster")]
                fn set_on_load(this: &Raster_Class, value: RasterOnLoad);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = createImageData , method , js_class = "Raster" , catch)]
                fn __TSB_create_image_data(
                    this: &Raster_Class,
                    size: Size,
                ) -> std::result::Result<JsValue, JsValue>;
                # [wasm_bindgen (method , structural , getter = height , js_class = "Raster")]
                fn height(this: &Raster_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = height , js_class = "Raster")]
                fn set_height(this: &Raster_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = toDataURL , method , js_class = "Raster" , catch)]
                fn __TSB_to_data_url(this: &Raster_Class) -> std::result::Result<String, JsValue>;
            }
            #[derive(std :: clone :: Clone)]
            struct Raster(pub Raster_Class);
            impl std::convert::From<&Raster> for Item {
                fn from(src: &Raster) -> Item {
                    let src: &Item_Class = src.0.as_ref();
                    Item(src.clone())
                }
            }
            impl std::convert::From<&mut Raster> for Item {
                fn from(src: &mut Raster) -> Item {
                    let src: &Item_Class = src.0.as_ref();
                    Item(src.clone())
                }
            }
            impl Raster {
                #[allow(dead_code)]
                pub fn resolution(&self) -> Size {
                    let result = self.0.resolution();
                    result
                }
                #[allow(dead_code)]
                pub fn set_resolution(&self, value: Size) -> () {
                    let result = self.0.set_resolution(value);
                    result
                }
                #[allow(dead_code)]
                pub fn smoothing(&self) -> String {
                    let result = self.0.smoothing();
                    result
                }
                #[allow(dead_code)]
                pub fn set_smoothing(&self, value: String) -> () {
                    let result = self.0.set_smoothing(value);
                    result
                }
                #[allow(dead_code)]
                pub fn get_sub_raster(
                    &self,
                    rect: Rectangle,
                ) -> std::result::Result<Raster, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_sub_raster(rect)?);
                    result
                }
                #[allow(dead_code)]
                pub fn size(&self) -> Size {
                    let result = self.0.size();
                    result
                }
                #[allow(dead_code)]
                pub fn set_size(&self, value: Size) -> () {
                    let result = self.0.set_size(value);
                    result
                }
                #[allow(dead_code)]
                pub fn width(&self) -> f64 {
                    let result = self.0.width();
                    result
                }
                #[allow(dead_code)]
                pub fn set_width(&self, value: f64) -> () {
                    let result = self.0.set_width(value);
                    result
                }
                #[allow(dead_code)]
                pub fn get_sub_canvas(
                    &self,
                    rect: Rectangle,
                ) -> std::result::Result<JsValue, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_sub_canvas(rect)?);
                    result
                }
                #[allow(dead_code)]
                pub fn draw_image(
                    &self,
                    image: JsValue,
                    point: Point,
                ) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_draw_image(image, point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn source(&self) -> RasterSource {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.source()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_source(&self, value: RasterSource) -> () {
                    let result = self.0.set_source(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn get_average_color(
                    &self,
                    object: RasterGetAverageColorParamsObjectParam,
                ) -> std::result::Result<Color, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_average_color(
                        ts_bindgen_rt::to_jsvalue(&object).map_err(ts_bindgen_rt::Error::from)?,
                    )?);
                    result
                }
                #[allow(dead_code)]
                pub fn on_error(&self) -> RasterOnError {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.on_error()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_on_error(&self, value: RasterOnError) -> () {
                    let result = self.0.set_on_error(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn set_image_data(
                    &self,
                    data: JsValue,
                    point: Point,
                ) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_set_image_data(data, point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_pixel(&self, point: Point) -> std::result::Result<Color, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_pixel(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_image_data(
                    &self,
                    rect: Rectangle,
                ) -> std::result::Result<JsValue, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_image_data(rect)?);
                    result
                }
                #[allow(dead_code)]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Raster {
                    let result = Raster_Class::new(object);
                    let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                    Raster(result)
                }
                #[allow(dead_code)]
                pub fn image(&self) -> RasterImage {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.image()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_image(&self, value: RasterImage) -> () {
                    let result = self.0.set_image(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn context(&self) -> JsValue {
                    let result = self.0.context();
                    result
                }
                #[allow(dead_code)]
                pub fn set_context(&self, value: JsValue) -> () {
                    let result = self.0.set_context(value);
                    result
                }
                #[allow(dead_code)]
                pub fn canvas(&self) -> JsValue {
                    let result = self.0.canvas();
                    result
                }
                #[allow(dead_code)]
                pub fn set_canvas(&self, value: JsValue) -> () {
                    let result = self.0.set_canvas(value);
                    result
                }
                #[allow(dead_code)]
                pub fn set_pixel(
                    &self,
                    point: Point,
                    color: Color,
                ) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_set_pixel(point, color)?);
                    result
                }
                #[allow(dead_code)]
                pub fn loaded(&self) -> bool {
                    let result = self.0.loaded();
                    result
                }
                #[allow(dead_code)]
                pub fn set_loaded(&self, value: bool) -> () {
                    let result = self.0.set_loaded(value);
                    result
                }
                #[allow(dead_code)]
                pub fn cross_origin(&self) -> String {
                    let result = self.0.cross_origin();
                    result
                }
                #[allow(dead_code)]
                pub fn set_cross_origin(&self, value: String) -> () {
                    let result = self.0.set_cross_origin(value);
                    result
                }
                #[allow(dead_code)]
                pub fn clear(&self) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_clear()?);
                    result
                }
                #[allow(dead_code)]
                pub fn on_load(&self) -> RasterOnLoad {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.on_load()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_on_load(&self, value: RasterOnLoad) -> () {
                    let result = self.0.set_on_load(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn create_image_data(
                    &self,
                    size: Size,
                ) -> std::result::Result<JsValue, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_create_image_data(size)?);
                    result
                }
                #[allow(dead_code)]
                pub fn height(&self) -> f64 {
                    let result = self.0.height();
                    result
                }
                #[allow(dead_code)]
                pub fn set_height(&self, value: f64) -> () {
                    let result = self.0.set_height(value);
                    result
                }
                #[allow(dead_code)]
                pub fn to_data_url(&self) -> std::result::Result<String, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_to_data_url()?);
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for Raster {
                fn describe() {
                    <Raster_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for Raster {
                type Abi = <Raster_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Raster {
                type Abi = <&'a Raster_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for Raster {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Raster {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: Raster_Class =
                        <Raster_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait Raster_Trait: Item_Trait {
                fn resolution(&self) -> Size;
                fn set_resolution(&mut self, value: Size) -> ();
                fn smoothing(&self) -> String;
                fn set_smoothing(&mut self, value: String) -> ();
                fn get_sub_raster(&self, rect: Rectangle) -> std::result::Result<Raster, JsValue>;
                fn size(&self) -> Size;
                fn set_size(&mut self, value: Size) -> ();
                fn width(&self) -> f64;
                fn set_width(&mut self, value: f64) -> ();
                fn get_sub_canvas(&self, rect: Rectangle) -> std::result::Result<JsValue, JsValue>;
                fn draw_image(
                    &self,
                    image: JsValue,
                    point: Point,
                ) -> std::result::Result<(), JsValue>;
                fn source(&self) -> RasterSource;
                fn set_source(&mut self, value: RasterSource) -> ();
                fn get_average_color(
                    &self,
                    object: RasterGetAverageColorParamsObjectParam,
                ) -> std::result::Result<Color, JsValue>;
                fn on_error(&self) -> RasterOnError;
                fn set_on_error(&mut self, value: RasterOnError) -> ();
                fn set_image_data(
                    &self,
                    data: JsValue,
                    point: Point,
                ) -> std::result::Result<(), JsValue>;
                fn get_pixel(&self, point: Point) -> std::result::Result<Color, JsValue>;
                fn get_image_data(&self, rect: Rectangle) -> std::result::Result<JsValue, JsValue>;
                fn new(object: std::collections::HashMap<String, JsValue>) -> Raster;
                fn image(&self) -> RasterImage;
                fn set_image(&mut self, value: RasterImage) -> ();
                fn context(&self) -> JsValue;
                fn set_context(&mut self, value: JsValue) -> ();
                fn canvas(&self) -> JsValue;
                fn set_canvas(&mut self, value: JsValue) -> ();
                fn set_pixel(&self, point: Point, color: Color)
                    -> std::result::Result<(), JsValue>;
                fn loaded(&self) -> bool;
                fn set_loaded(&mut self, value: bool) -> ();
                fn cross_origin(&self) -> String;
                fn set_cross_origin(&mut self, value: String) -> ();
                fn clear(&self) -> std::result::Result<(), JsValue>;
                fn on_load(&self) -> RasterOnLoad;
                fn set_on_load(&mut self, value: RasterOnLoad) -> ();
                fn create_image_data(&self, size: Size) -> std::result::Result<JsValue, JsValue>;
                fn height(&self) -> f64;
                fn set_height(&mut self, value: f64) -> ();
                fn to_data_url(&self) -> std::result::Result<String, JsValue>;
            }
            impl Item_Trait for Raster {
                fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::insert_below(&target, item)
                }
                fn on_double_click(&self) -> ItemOnDoubleClick {
                    let target: Item = self.into();
                    Item::on_double_click(&target)
                }
                fn set_on_double_click(&mut self, value: ItemOnDoubleClick) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_double_click(&mut target, value)
                }
                fn view(&self) -> View {
                    let target: Item = self.into();
                    Item::view(&target)
                }
                fn set_view(&mut self, value: View) -> () {
                    let mut target: Item = self.into();
                    Item::set_view(&mut target, value)
                }
                fn blend_mode(&self) -> String {
                    let target: Item = self.into();
                    Item::blend_mode(&target)
                }
                fn set_blend_mode(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_blend_mode(&mut target, value)
                }
                fn name(&self) -> String {
                    let target: Item = self.into();
                    Item::name(&target)
                }
                fn set_name(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_name(&mut target, value)
                }
                fn project(&self) -> Project {
                    let target: Item = self.into();
                    Item::project(&target)
                }
                fn set_project(&mut self, value: Project) -> () {
                    let mut target: Item = self.into();
                    Item::set_project(&mut target, value)
                }
                fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_child(&target, item)
                }
                fn global_matrix(&self) -> Matrix {
                    let target: Item = self.into();
                    Item::global_matrix(&target)
                }
                fn set_global_matrix(&mut self, value: Matrix) -> () {
                    let mut target: Item = self.into();
                    Item::set_global_matrix(&mut target, value)
                }
                fn on_mouse_leave(&self) -> ItemOnMouseLeave {
                    let target: Item = self.into();
                    Item::on_mouse_leave(&target)
                }
                fn set_on_mouse_leave(&mut self, value: ItemOnMouseLeave) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_leave(&mut target, value)
                }
                fn has_children(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_children(&target)
                }
                fn selected(&self) -> bool {
                    let target: Item = self.into();
                    Item::selected(&target)
                }
                fn set_selected(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_selected(&mut target, value)
                }
                fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::global_to_local(&target, point)
                }
                fn shadow_blur(&self) -> f64 {
                    let target: Item = self.into();
                    Item::shadow_blur(&target)
                }
                fn set_shadow_blur(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_shadow_blur(&mut target, value)
                }
                fn children(&self) -> Vec<Item> {
                    let target: Item = self.into();
                    Item::children(&target)
                }
                fn set_children(&mut self, value: Vec<Item>) -> () {
                    let mut target: Item = self.into();
                    Item::set_children(&mut target, value)
                }
                fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::replace_with(&target, item)
                }
                fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::import_json(&target, json)
                }
                fn insert_child(
                    &self,
                    index: f64,
                    item: Item,
                ) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::insert_child(&target, index, item)
                }
                fn stroke_join(&self) -> String {
                    let target: Item = self.into();
                    Item::stroke_join(&target)
                }
                fn set_stroke_join(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_join(&mut target, value)
                }
                fn rotation(&self) -> f64 {
                    let target: Item = self.into();
                    Item::rotation(&target)
                }
                fn set_rotation(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_rotation(&mut target, value)
                }
                fn scaling(&self) -> Point {
                    let target: Item = self.into();
                    Item::scaling(&target)
                }
                fn set_scaling(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_scaling(&mut target, value)
                }
                fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_ancestor(&target, item)
                }
                fn emit(
                    &self,
                    type_: String,
                    event: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::emit(&target, type_, event)
                }
                fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_up(&target)
                }
                fn add_to(
                    &self,
                    owner: ItemAddToParamsOwnerParam,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::add_to(&target, owner)
                }
                fn stroke_cap(&self) -> String {
                    let target: Item = self.into();
                    Item::stroke_cap(&target)
                }
                fn set_stroke_cap(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_cap(&mut target, value)
                }
                fn on_mouse_drag(&self) -> ItemOnMouseDrag {
                    let target: Item = self.into();
                    Item::on_mouse_drag(&target)
                }
                fn set_on_mouse_drag(&mut self, value: ItemOnMouseDrag) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_drag(&mut target, value)
                }
                fn set(
                    &self,
                    props: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::set(&target, props)
                }
                fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::reverse_children(&target)
                }
                fn matches(
                    &self,
                    name: String,
                    compare: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::matches(&target, name, compare)
                }
                fn on_mouse_enter(&self) -> ItemOnMouseEnter {
                    let target: Item = self.into();
                    Item::on_mouse_enter(&target)
                }
                fn set_on_mouse_enter(&mut self, value: ItemOnMouseEnter) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_enter(&mut target, value)
                }
                fn shadow_offset(&self) -> Point {
                    let target: Item = self.into();
                    Item::shadow_offset(&target)
                }
                fn set_shadow_offset(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_shadow_offset(&mut target, value)
                }
                fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_stroke(&target)
                }
                fn view_matrix(&self) -> Matrix {
                    let target: Item = self.into();
                    Item::view_matrix(&target)
                }
                fn set_view_matrix(&mut self, value: Matrix) -> () {
                    let mut target: Item = self.into();
                    Item::set_view_matrix(&mut target, value)
                }
                fn on_frame(&self) -> ItemOnFrame {
                    let target: Item = self.into();
                    Item::on_frame(&target)
                }
                fn set_on_frame(&mut self, value: ItemOnFrame) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_frame(&mut target, value)
                }
                fn on_mouse_down(&self) -> ItemOnMouseDown {
                    let target: Item = self.into();
                    Item::on_mouse_down(&target)
                }
                fn set_on_mouse_down(&mut self, value: ItemOnMouseDown) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_down(&mut target, value)
                }
                fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_sibling(&target, item)
                }
                fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::local_to_global(&target, point)
                }
                fn first_child(&self) -> Item {
                    let target: Item = self.into();
                    Item::first_child(&target)
                }
                fn set_first_child(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_first_child(&mut target, value)
                }
                fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::send_to_back(&target)
                }
                fn clip_mask(&self) -> bool {
                    let target: Item = self.into();
                    Item::clip_mask(&target)
                }
                fn set_clip_mask(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_clip_mask(&mut target, value)
                }
                fn next_sibling(&self) -> Item {
                    let target: Item = self.into();
                    Item::next_sibling(&target)
                }
                fn set_next_sibling(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_next_sibling(&mut target, value)
                }
                fn off(
                    &self,
                    object: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::off(&target, object)
                }
                fn rotate(&self, angle: f64, center: Point) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::rotate(&target, angle, center)
                }
                fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::add_child(&target, item)
                }
                fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_grouped_with(&target, item)
                }
                fn scale(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::scale(&target, hor, ver, center)
                }
                fn hit_test_all(
                    &self,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Vec<HitResult>, JsValue> {
                    let target: Item = self.into();
                    Item::hit_test_all(&target, point, options)
                }
                fn insert_children(
                    &self,
                    index: f64,
                    items: Vec<Item>,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::insert_children(&target, index, items)
                }
                fn style(&self) -> Style {
                    let target: Item = self.into();
                    Item::style(&target)
                }
                fn set_style(&mut self, value: Style) -> () {
                    let mut target: Item = self.into();
                    Item::set_style(&mut target, value)
                }
                fn position(&self) -> Point {
                    let target: Item = self.into();
                    Item::position(&target)
                }
                fn set_position(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_position(&mut target, value)
                }
                fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::transform(&target, matrix)
                }
                fn fill_color(&self) -> ItemFillColor {
                    let target: Item = self.into();
                    Item::fill_color(&target)
                }
                fn set_fill_color(&mut self, value: ItemFillColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_fill_color(&mut target, value)
                }
                fn matrix(&self) -> Matrix {
                    let target: Item = self.into();
                    Item::matrix(&target)
                }
                fn set_matrix(&mut self, value: Matrix) -> () {
                    let mut target: Item = self.into();
                    Item::set_matrix(&mut target, value)
                }
                fn id(&self) -> f64 {
                    let target: Item = self.into();
                    Item::id(&target)
                }
                fn set_id(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_id(&mut target, value)
                }
                fn tween(
                    &self,
                    options: ItemTweenParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let target: Item = self.into();
                    Item::tween(&target, options)
                }
                fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::reduce(&target, options)
                }
                fn internal_bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::internal_bounds(&target)
                }
                fn set_internal_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_internal_bounds(&mut target, value)
                }
                fn fill_rule(&self) -> String {
                    let target: Item = self.into();
                    Item::fill_rule(&target)
                }
                fn set_fill_rule(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_fill_rule(&mut target, value)
                }
                fn shadow_color(&self) -> ItemShadowColor {
                    let target: Item = self.into();
                    Item::shadow_color(&target)
                }
                fn set_shadow_color(&mut self, value: ItemShadowColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_shadow_color(&mut target, value)
                }
                fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::insert_above(&target, item)
                }
                fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::responds(&target, type_)
                }
                fn handle_bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::handle_bounds(&target)
                }
                fn set_handle_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_handle_bounds(&mut target, value)
                }
                fn skew(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::skew(&target, hor, ver, center)
                }
                fn on_click(&self) -> ItemOnClick {
                    let target: Item = self.into();
                    Item::on_click(&target)
                }
                fn set_on_click(&mut self, value: ItemOnClick) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_click(&mut target, value)
                }
                fn get_items(
                    &self,
                    options: ItemGetItemsParamsOptionsParam,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::get_items(&target, options)
                }
                fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_inserted(&target)
                }
                fn get_item(
                    &self,
                    options: ItemGetItemParamsOptionsParam,
                ) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::get_item(&target, options)
                }
                fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_fill(&target)
                }
                fn shear(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::shear(&target, hor, ver, center)
                }
                fn visible(&self) -> bool {
                    let target: Item = self.into();
                    Item::visible(&target)
                }
                fn set_visible(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_visible(&mut target, value)
                }
                fn previous_sibling(&self) -> Item {
                    let target: Item = self.into();
                    Item::previous_sibling(&target)
                }
                fn set_previous_sibling(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_previous_sibling(&mut target, value)
                }
                fn hit_test(
                    &self,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<HitResult, JsValue> {
                    let target: Item = self.into();
                    Item::hit_test(&target, point, options)
                }
                fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_descendant(&target, item)
                }
                fn locked(&self) -> bool {
                    let target: Item = self.into();
                    Item::locked(&target)
                }
                fn set_locked(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_locked(&mut target, value)
                }
                fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_parent(&target, item)
                }
                fn copy_attributes(
                    &self,
                    source: Item,
                    exclude_matrix: bool,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::copy_attributes(&target, source, exclude_matrix)
                }
                fn last_child(&self) -> Item {
                    let target: Item = self.into();
                    Item::last_child(&target)
                }
                fn set_last_child(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_last_child(&mut target, value)
                }
                fn stroke_width(&self) -> f64 {
                    let target: Item = self.into();
                    Item::stroke_width(&target)
                }
                fn set_stroke_width(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_width(&mut target, value)
                }
                fn parent(&self) -> Item {
                    let target: Item = self.into();
                    Item::parent(&target)
                }
                fn set_parent(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_parent(&mut target, value)
                }
                fn stroke_bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::stroke_bounds(&target)
                }
                fn set_stroke_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_bounds(&mut target, value)
                }
                fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::translate(&target, delta)
                }
                fn remove(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::remove(&target)
                }
                fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::parent_to_local(&target, point)
                }
                fn bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::bounds(&target)
                }
                fn set_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_bounds(&mut target, value)
                }
                fn add_children(
                    &self,
                    items: Vec<Item>,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::add_children(&target, items)
                }
                fn dash_array(&self) -> Vec<f64> {
                    let target: Item = self.into();
                    Item::dash_array(&target)
                }
                fn set_dash_array(&mut self, value: Vec<f64>) -> () {
                    let mut target: Item = self.into();
                    Item::set_dash_array(&mut target, value)
                }
                fn on_mouse_up(&self) -> ItemOnMouseUp {
                    let target: Item = self.into();
                    Item::on_mouse_up(&target)
                }
                fn set_on_mouse_up(&mut self, value: ItemOnMouseUp) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_up(&mut target, value)
                }
                fn on(
                    &self,
                    object: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::on(&target, object)
                }
                fn remove_on(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on(&target, options)
                }
                fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_below(&target, item)
                }
                fn apply_matrix(&self) -> bool {
                    let target: Item = self.into();
                    Item::apply_matrix(&target)
                }
                fn set_apply_matrix(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_apply_matrix(&mut target, value)
                }
                fn clone(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::clone(&target, options)
                }
                fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::contains(&target, point)
                }
                fn export_json(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<String, JsValue> {
                    let target: Item = self.into();
                    Item::export_json(&target, options)
                }
                fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::bring_to_front(&target)
                }
                fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_above(&target, item)
                }
                fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_drag(&target)
                }
                fn data(&self) -> JsValue {
                    let target: Item = self.into();
                    Item::data(&target)
                }
                fn set_data(&mut self, value: JsValue) -> () {
                    let mut target: Item = self.into();
                    Item::set_data(&mut target, value)
                }
                fn import_svg(
                    &self,
                    svg: ItemImportSvgParamsSvgParam,
                    on_load: JsValue,
                ) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::import_svg(&target, svg, on_load)
                }
                fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_shadow(&target)
                }
                fn selected_color(&self) -> ItemSelectedColor {
                    let target: Item = self.into();
                    Item::selected_color(&target)
                }
                fn set_selected_color(&mut self, value: ItemSelectedColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_selected_color(&mut target, value)
                }
                fn class_name(&self) -> String {
                    let target: Item = self.into();
                    Item::class_name(&target)
                }
                fn set_class_name(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_class_name(&mut target, value)
                }
                fn export_svg(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                    let target: Item = self.into();
                    Item::export_svg(&target, options)
                }
                fn tween_to(
                    &self,
                    to: std::collections::HashMap<String, JsValue>,
                    options: ItemTweenToParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let target: Item = self.into();
                    Item::tween_to(&target, to, options)
                }
                fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_inside(&target, rect)
                }
                fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_empty(&target, recursively)
                }
                fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::copy_content(&target, source)
                }
                fn rasterize(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Raster, JsValue> {
                    let target: Item = self.into();
                    Item::rasterize(&target, options)
                }
                fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_move(&target)
                }
                fn tween_from(
                    &self,
                    from: std::collections::HashMap<String, JsValue>,
                    options: ItemTweenFromParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let target: Item = self.into();
                    Item::tween_from(&target, from, options)
                }
                fn opacity(&self) -> f64 {
                    let target: Item = self.into();
                    Item::opacity(&target)
                }
                fn set_opacity(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_opacity(&mut target, value)
                }
                fn dash_offset(&self) -> f64 {
                    let target: Item = self.into();
                    Item::dash_offset(&target)
                }
                fn set_dash_offset(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_dash_offset(&mut target, value)
                }
                fn remove_children(
                    &self,
                    start: f64,
                    end: f64,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::remove_children(&target, start, end)
                }
                fn on_mouse_move(&self) -> ItemOnMouseMove {
                    let target: Item = self.into();
                    Item::on_mouse_move(&target)
                }
                fn set_on_mouse_move(&mut self, value: ItemOnMouseMove) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_move(&mut target, value)
                }
                fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::intersects(&target, item)
                }
                fn pivot(&self) -> Point {
                    let target: Item = self.into();
                    Item::pivot(&target)
                }
                fn set_pivot(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_pivot(&mut target, value)
                }
                fn copy_to(
                    &self,
                    owner: ItemCopyToParamsOwnerParam,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::copy_to(&target, owner)
                }
                fn index(&self) -> f64 {
                    let target: Item = self.into();
                    Item::index(&target)
                }
                fn set_index(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_index(&mut target, value)
                }
                fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::local_to_parent(&target, point)
                }
                fn stroke_color(&self) -> ItemStrokeColor {
                    let target: Item = self.into();
                    Item::stroke_color(&target)
                }
                fn set_stroke_color(&mut self, value: ItemStrokeColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_color(&mut target, value)
                }
                fn layer(&self) -> Layer {
                    let target: Item = self.into();
                    Item::layer(&target)
                }
                fn set_layer(&mut self, value: Layer) -> () {
                    let mut target: Item = self.into();
                    Item::set_layer(&mut target, value)
                }
                fn stroke_scaling(&self) -> bool {
                    let target: Item = self.into();
                    Item::stroke_scaling(&target)
                }
                fn set_stroke_scaling(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_scaling(&mut target, value)
                }
                fn fit_bounds(
                    &self,
                    rectangle: Rectangle,
                    fill: bool,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::fit_bounds(&target, rectangle, fill)
                }
                fn miter_limit(&self) -> f64 {
                    let target: Item = self.into();
                    Item::miter_limit(&target)
                }
                fn set_miter_limit(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_miter_limit(&mut target, value)
                }
                fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_down(&target)
                }
            }
            impl Raster_Trait for Raster {}
            impl std::clone::Clone for Raster_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for Raster_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Raster_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum PathAddReturn {
                SegmentCase(Segment),
                VecOfSegmentCase(Vec<Segment>),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ItemOnMouseMove {
                TsBindgenRtNullCase,
                JsValueCase(JsValue),
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                #[wasm_bindgen(js_name = "Curve")]
                type Curve_Class;
                # [wasm_bindgen (method , structural , getter = path , js_class = "Curve")]
                fn path(this: &Curve_Class) -> Path;
                # [wasm_bindgen (method , structural , setter = path , js_class = "Curve")]
                fn set_path(this: &Curve_Class, value: Path);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = divideAtTime , method , js_class = "Curve" , catch)]
                fn __TSB_divide_at_time(
                    this: &Curve_Class,
                    time: f64,
                ) -> std::result::Result<Curve, JsValue>;
                # [wasm_bindgen (method , structural , getter = selected , js_class = "Curve")]
                fn selected(this: &Curve_Class) -> bool;
                # [wasm_bindgen (method , structural , setter = selected , js_class = "Curve")]
                fn set_selected(this: &Curve_Class, value: bool);
                # [wasm_bindgen (method , structural , getter = area , js_class = "Curve")]
                fn area(this: &Curve_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = area , js_class = "Curve")]
                fn set_area(this: &Curve_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getIntersections , method , js_class = "Curve" , catch)]
                fn __TSB_get_intersections(
                    this: &Curve_Class,
                    curve: Curve,
                ) -> std::result::Result<Vec<CurveLocation>, JsValue>;
                # [wasm_bindgen (method , structural , getter = next , js_class = "Curve")]
                fn next(this: &Curve_Class) -> Curve;
                # [wasm_bindgen (method , structural , setter = next , js_class = "Curve")]
                fn set_next(this: &Curve_Class, value: Curve);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getWeightedTangentAtTime , method , js_class = "Curve" , catch)]
                fn __TSB_get_weighted_tangent_at_time(
                    this: &Curve_Class,
                    time: f64,
                ) -> std::result::Result<Point, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = splitAtTime , method , js_class = "Curve" , catch)]
                fn __TSB_split_at_time(
                    this: &Curve_Class,
                    time: f64,
                ) -> std::result::Result<Path, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isStraight , method , js_class = "Curve" , catch)]
                fn __TSB_is_straight(this: &Curve_Class) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getNearestLocation , method , js_class = "Curve" , catch)]
                fn __TSB_get_nearest_location(
                    this: &Curve_Class,
                    point: Point,
                ) -> std::result::Result<CurveLocation, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getTimeOf , method , js_class = "Curve" , catch)]
                fn __TSB_get_time_of(
                    this: &Curve_Class,
                    point: Point,
                ) -> std::result::Result<f64, JsValue>;
                # [wasm_bindgen (method , structural , getter = bounds , js_class = "Curve")]
                fn bounds(this: &Curve_Class) -> Rectangle;
                # [wasm_bindgen (method , structural , setter = bounds , js_class = "Curve")]
                fn set_bounds(this: &Curve_Class, value: Rectangle);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getTimeAt , method , js_class = "Curve" , catch)]
                fn __TSB_get_time_at(
                    this: &Curve_Class,
                    offset: f64,
                    start: f64,
                ) -> std::result::Result<f64, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getWeightedNormalAt , method , js_class = "Curve" , catch)]
                fn __TSB_get_weighted_normal_at(
                    this: &Curve_Class,
                    location: JsValue,
                ) -> std::result::Result<Point, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getNormalAtTime , method , js_class = "Curve" , catch)]
                fn __TSB_get_normal_at_time(
                    this: &Curve_Class,
                    time: f64,
                ) -> std::result::Result<Point, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = hasLength , method , js_class = "Curve" , catch)]
                fn __TSB_has_length(
                    this: &Curve_Class,
                    epsilon: f64,
                ) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getTimesWithTangent , method , js_class = "Curve" , catch)]
                fn __TSB_get_times_with_tangent(
                    this: &Curve_Class,
                    tangent: Point,
                ) -> std::result::Result<Vec<f64>, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getPointAtTime , method , js_class = "Curve" , catch)]
                fn __TSB_get_point_at_time(
                    this: &Curve_Class,
                    time: f64,
                ) -> std::result::Result<Point, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = splitAt , method , js_class = "Curve" , catch)]
                fn __TSB_split_at(
                    this: &Curve_Class,
                    location: JsValue,
                ) -> std::result::Result<Path, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getLocationAtTime , method , js_class = "Curve" , catch)]
                fn __TSB_get_location_at_time(
                    this: &Curve_Class,
                    time: f64,
                ) -> std::result::Result<CurveLocation, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getNormalAt , method , js_class = "Curve" , catch)]
                fn __TSB_get_normal_at(
                    this: &Curve_Class,
                    location: JsValue,
                ) -> std::result::Result<Point, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isLinear , method , js_class = "Curve" , catch)]
                fn __TSB_is_linear(this: &Curve_Class) -> std::result::Result<bool, JsValue>;
                # [wasm_bindgen (method , structural , getter = point2 , js_class = "Curve")]
                fn point2(this: &Curve_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = point2 , js_class = "Curve")]
                fn set_point2(this: &Curve_Class, value: Point);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = reversed , method , js_class = "Curve" , catch)]
                fn __TSB_reversed(this: &Curve_Class) -> std::result::Result<Curve, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getOffsetOf , method , js_class = "Curve" , catch)]
                fn __TSB_get_offset_of(
                    this: &Curve_Class,
                    point: Point,
                ) -> std::result::Result<f64, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getOffsetAtTime , method , js_class = "Curve" , catch)]
                fn __TSB_get_offset_at_time(
                    this: &Curve_Class,
                    time: f64,
                ) -> std::result::Result<f64, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getLocationOf , method , js_class = "Curve" , catch)]
                fn __TSB_get_location_of(
                    this: &Curve_Class,
                    point: Point,
                ) -> std::result::Result<CurveLocation, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getNearestPoint , method , js_class = "Curve" , catch)]
                fn __TSB_get_nearest_point(
                    this: &Curve_Class,
                    point: Point,
                ) -> std::result::Result<Point, JsValue>;
                # [wasm_bindgen (method , structural , getter = strokeBounds , js_class = "Curve")]
                fn stroke_bounds(this: &Curve_Class) -> Rectangle;
                # [wasm_bindgen (method , structural , setter = strokeBounds , js_class = "Curve")]
                fn set_stroke_bounds(this: &Curve_Class, value: Rectangle);
                # [wasm_bindgen (method , structural , getter = handle1 , js_class = "Curve")]
                fn handle1(this: &Curve_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = handle1 , js_class = "Curve")]
                fn set_handle1(this: &Curve_Class, value: Point);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getPart , method , js_class = "Curve" , catch)]
                fn __TSB_get_part(
                    this: &Curve_Class,
                    from: f64,
                    to: f64,
                ) -> std::result::Result<Curve, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isFirst , method , js_class = "Curve" , catch)]
                fn __TSB_is_first(this: &Curve_Class) -> std::result::Result<bool, JsValue>;
                # [wasm_bindgen (method , structural , getter = index , js_class = "Curve")]
                fn index(this: &Curve_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = index , js_class = "Curve")]
                fn set_index(this: &Curve_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = previous , js_class = "Curve")]
                fn previous(this: &Curve_Class) -> Curve;
                # [wasm_bindgen (method , structural , setter = previous , js_class = "Curve")]
                fn set_previous(this: &Curve_Class, value: Curve);
                # [wasm_bindgen (method , structural , getter = segment2 , js_class = "Curve")]
                fn segment2(this: &Curve_Class) -> Segment;
                # [wasm_bindgen (method , structural , setter = segment2 , js_class = "Curve")]
                fn set_segment2(this: &Curve_Class, value: Segment);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = hasHandles , method , js_class = "Curve" , catch)]
                fn __TSB_has_handles(this: &Curve_Class) -> std::result::Result<bool, JsValue>;
                # [wasm_bindgen (method , structural , getter = handleBounds , js_class = "Curve")]
                fn handle_bounds(this: &Curve_Class) -> Rectangle;
                # [wasm_bindgen (method , structural , setter = handleBounds , js_class = "Curve")]
                fn set_handle_bounds(this: &Curve_Class, value: Rectangle);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isCollinear , method , js_class = "Curve" , catch)]
                fn __TSB_is_collinear(
                    this: &Curve_Class,
                    curve: Curve,
                ) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getPointAt , method , js_class = "Curve" , catch)]
                fn __TSB_get_point_at(
                    this: &Curve_Class,
                    location: JsValue,
                ) -> std::result::Result<Point, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getWeightedNormalAtTime , method , js_class = "Curve" , catch)]
                fn __TSB_get_weighted_normal_at_time(
                    this: &Curve_Class,
                    time: f64,
                ) -> std::result::Result<Point, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = classify , method , js_class = "Curve" , catch)]
                fn __TSB_classify(
                    this: &Curve_Class,
                ) -> std::result::Result<std::collections::HashMap<String, JsValue>, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getCurvatureAtTime , method , js_class = "Curve" , catch)]
                fn __TSB_get_curvature_at_time(
                    this: &Curve_Class,
                    time: f64,
                ) -> std::result::Result<f64, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isLast , method , js_class = "Curve" , catch)]
                fn __TSB_is_last(this: &Curve_Class) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getCurvatureAt , method , js_class = "Curve" , catch)]
                fn __TSB_get_curvature_at(
                    this: &Curve_Class,
                    location: JsValue,
                ) -> std::result::Result<f64, JsValue>;
                # [wasm_bindgen (method , structural , getter = segment1 , js_class = "Curve")]
                fn segment1(this: &Curve_Class) -> Segment;
                # [wasm_bindgen (method , structural , setter = segment1 , js_class = "Curve")]
                fn set_segment1(this: &Curve_Class, value: Segment);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isHorizontal , method , js_class = "Curve" , catch)]
                fn __TSB_is_horizontal(this: &Curve_Class) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = toString , method , js_class = "Curve" , catch)]
                fn __TSB_to_string(this: &Curve_Class) -> std::result::Result<String, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = clearHandles , method , js_class = "Curve" , catch)]
                fn __TSB_clear_handles(this: &Curve_Class) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getLocationAt , method , js_class = "Curve" , catch)]
                fn __TSB_get_location_at(
                    this: &Curve_Class,
                    offset: f64,
                ) -> std::result::Result<CurveLocation, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getTangentAtTime , method , js_class = "Curve" , catch)]
                fn __TSB_get_tangent_at_time(
                    this: &Curve_Class,
                    time: f64,
                ) -> std::result::Result<Point, JsValue>;
                # [wasm_bindgen (method , structural , getter = length , js_class = "Curve")]
                fn length(this: &Curve_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = length , js_class = "Curve")]
                fn set_length(this: &Curve_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = divideAt , method , js_class = "Curve" , catch)]
                fn __TSB_divide_at(
                    this: &Curve_Class,
                    location: JsValue,
                ) -> std::result::Result<Curve, JsValue>;
                # [wasm_bindgen (method , structural , getter = handle2 , js_class = "Curve")]
                fn handle2(this: &Curve_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = handle2 , js_class = "Curve")]
                fn set_handle2(this: &Curve_Class, value: Point);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = clone , method , js_class = "Curve" , catch)]
                fn __TSB_clone(this: &Curve_Class) -> std::result::Result<Curve, JsValue>;
                # [wasm_bindgen (method , structural , getter = values , js_class = "Curve")]
                fn values(this: &Curve_Class) -> Vec<f64>;
                # [wasm_bindgen (method , structural , setter = values , js_class = "Curve")]
                fn set_values(this: &Curve_Class, value: Vec<f64>);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getWeightedTangentAt , method , js_class = "Curve" , catch)]
                fn __TSB_get_weighted_tangent_at(
                    this: &Curve_Class,
                    location: JsValue,
                ) -> std::result::Result<Point, JsValue>;
                #[wasm_bindgen(constructor, js_class = "Curve")]
                pub fn new(
                    point1: Point,
                    handle1: Point,
                    handle2: Point,
                    point2: Point,
                ) -> Curve_Class;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = remove , method , js_class = "Curve" , catch)]
                fn __TSB_remove(this: &Curve_Class) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isVertical , method , js_class = "Curve" , catch)]
                fn __TSB_is_vertical(this: &Curve_Class) -> std::result::Result<bool, JsValue>;
                # [wasm_bindgen (method , structural , getter = point1 , js_class = "Curve")]
                fn point1(this: &Curve_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = point1 , js_class = "Curve")]
                fn set_point1(this: &Curve_Class, value: Point);
                # [wasm_bindgen (method , structural , getter = points , js_class = "Curve")]
                fn points(this: &Curve_Class) -> Vec<Point>;
                # [wasm_bindgen (method , structural , setter = points , js_class = "Curve")]
                fn set_points(this: &Curve_Class, value: Vec<Point>);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getTangentAt , method , js_class = "Curve" , catch)]
                fn __TSB_get_tangent_at(
                    this: &Curve_Class,
                    location: JsValue,
                ) -> std::result::Result<Point, JsValue>;
            }
            #[derive(std :: clone :: Clone)]
            struct Curve(pub Curve_Class);
            impl Curve {
                #[allow(dead_code)]
                pub fn path(&self) -> Path {
                    let result = self.0.path();
                    result
                }
                #[allow(dead_code)]
                pub fn set_path(&self, value: Path) -> () {
                    let result = self.0.set_path(value);
                    result
                }
                #[allow(dead_code)]
                pub fn divide_at_time(&self, time: f64) -> std::result::Result<Curve, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_divide_at_time(time)?);
                    result
                }
                #[allow(dead_code)]
                pub fn selected(&self) -> bool {
                    let result = self.0.selected();
                    result
                }
                #[allow(dead_code)]
                pub fn set_selected(&self, value: bool) -> () {
                    let result = self.0.set_selected(value);
                    result
                }
                #[allow(dead_code)]
                pub fn area(&self) -> f64 {
                    let result = self.0.area();
                    result
                }
                #[allow(dead_code)]
                pub fn set_area(&self, value: f64) -> () {
                    let result = self.0.set_area(value);
                    result
                }
                #[allow(dead_code)]
                pub fn get_intersections(
                    &self,
                    curve: Curve,
                ) -> std::result::Result<Vec<CurveLocation>, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_intersections(curve)?);
                    result
                }
                #[allow(dead_code)]
                pub fn next(&self) -> Curve {
                    let result = self.0.next();
                    result
                }
                #[allow(dead_code)]
                pub fn set_next(&self, value: Curve) -> () {
                    let result = self.0.set_next(value);
                    result
                }
                #[allow(dead_code)]
                pub fn get_weighted_tangent_at_time(
                    &self,
                    time: f64,
                ) -> std::result::Result<Point, JsValue> {
                    let result =
                        std::result::Result::Ok(self.0.__TSB_get_weighted_tangent_at_time(time)?);
                    result
                }
                #[allow(dead_code)]
                pub fn split_at_time(&self, time: f64) -> std::result::Result<Path, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_split_at_time(time)?);
                    result
                }
                #[allow(dead_code)]
                pub fn is_straight(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_straight()?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_nearest_location(
                    &self,
                    point: Point,
                ) -> std::result::Result<CurveLocation, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_nearest_location(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_time_of(&self, point: Point) -> std::result::Result<f64, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_time_of(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn bounds(&self) -> Rectangle {
                    let result = self.0.bounds();
                    result
                }
                #[allow(dead_code)]
                pub fn set_bounds(&self, value: Rectangle) -> () {
                    let result = self.0.set_bounds(value);
                    result
                }
                #[allow(dead_code)]
                pub fn get_time_at(
                    &self,
                    offset: f64,
                    start: f64,
                ) -> std::result::Result<f64, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_time_at(offset, start)?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_weighted_normal_at(
                    &self,
                    location: CurveGetWeightedNormalAtParamsLocationParam,
                ) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_weighted_normal_at(
                        ts_bindgen_rt::to_jsvalue(&location).map_err(ts_bindgen_rt::Error::from)?,
                    )?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_normal_at_time(&self, time: f64) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_normal_at_time(time)?);
                    result
                }
                #[allow(dead_code)]
                pub fn has_length(&self, epsilon: f64) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_has_length(epsilon)?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_times_with_tangent(
                    &self,
                    tangent: Point,
                ) -> std::result::Result<Vec<f64>, JsValue> {
                    let result =
                        std::result::Result::Ok(self.0.__TSB_get_times_with_tangent(tangent)?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_point_at_time(&self, time: f64) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_point_at_time(time)?);
                    result
                }
                #[allow(dead_code)]
                pub fn split_at(
                    &self,
                    location: CurveSplitAtParamsLocationParam,
                ) -> std::result::Result<Path, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_split_at(
                        ts_bindgen_rt::to_jsvalue(&location).map_err(ts_bindgen_rt::Error::from)?,
                    )?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_location_at_time(
                    &self,
                    time: f64,
                ) -> std::result::Result<CurveLocation, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_location_at_time(time)?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_normal_at(
                    &self,
                    location: CurveGetNormalAtParamsLocationParam,
                ) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_normal_at(
                        ts_bindgen_rt::to_jsvalue(&location).map_err(ts_bindgen_rt::Error::from)?,
                    )?);
                    result
                }
                #[allow(dead_code)]
                pub fn is_linear(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_linear()?);
                    result
                }
                #[allow(dead_code)]
                pub fn point2(&self) -> Point {
                    let result = self.0.point2();
                    result
                }
                #[allow(dead_code)]
                pub fn set_point2(&self, value: Point) -> () {
                    let result = self.0.set_point2(value);
                    result
                }
                #[allow(dead_code)]
                pub fn reversed(&self) -> std::result::Result<Curve, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_reversed()?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_offset_of(&self, point: Point) -> std::result::Result<f64, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_offset_of(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_offset_at_time(&self, time: f64) -> std::result::Result<f64, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_offset_at_time(time)?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_location_of(
                    &self,
                    point: Point,
                ) -> std::result::Result<CurveLocation, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_location_of(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_nearest_point(
                    &self,
                    point: Point,
                ) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_nearest_point(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn stroke_bounds(&self) -> Rectangle {
                    let result = self.0.stroke_bounds();
                    result
                }
                #[allow(dead_code)]
                pub fn set_stroke_bounds(&self, value: Rectangle) -> () {
                    let result = self.0.set_stroke_bounds(value);
                    result
                }
                #[allow(dead_code)]
                pub fn handle1(&self) -> Point {
                    let result = self.0.handle1();
                    result
                }
                #[allow(dead_code)]
                pub fn set_handle1(&self, value: Point) -> () {
                    let result = self.0.set_handle1(value);
                    result
                }
                #[allow(dead_code)]
                pub fn get_part(&self, from: f64, to: f64) -> std::result::Result<Curve, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_part(from, to)?);
                    result
                }
                #[allow(dead_code)]
                pub fn is_first(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_first()?);
                    result
                }
                #[allow(dead_code)]
                pub fn index(&self) -> f64 {
                    let result = self.0.index();
                    result
                }
                #[allow(dead_code)]
                pub fn set_index(&self, value: f64) -> () {
                    let result = self.0.set_index(value);
                    result
                }
                #[allow(dead_code)]
                pub fn previous(&self) -> Curve {
                    let result = self.0.previous();
                    result
                }
                #[allow(dead_code)]
                pub fn set_previous(&self, value: Curve) -> () {
                    let result = self.0.set_previous(value);
                    result
                }
                #[allow(dead_code)]
                pub fn segment2(&self) -> Segment {
                    let result = self.0.segment2();
                    result
                }
                #[allow(dead_code)]
                pub fn set_segment2(&self, value: Segment) -> () {
                    let result = self.0.set_segment2(value);
                    result
                }
                #[allow(dead_code)]
                pub fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_has_handles()?);
                    result
                }
                #[allow(dead_code)]
                pub fn handle_bounds(&self) -> Rectangle {
                    let result = self.0.handle_bounds();
                    result
                }
                #[allow(dead_code)]
                pub fn set_handle_bounds(&self, value: Rectangle) -> () {
                    let result = self.0.set_handle_bounds(value);
                    result
                }
                #[allow(dead_code)]
                pub fn is_collinear(&self, curve: Curve) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_collinear(curve)?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_point_at(
                    &self,
                    location: CurveGetPointAtParamsLocationParam,
                ) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_point_at(
                        ts_bindgen_rt::to_jsvalue(&location).map_err(ts_bindgen_rt::Error::from)?,
                    )?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_weighted_normal_at_time(
                    &self,
                    time: f64,
                ) -> std::result::Result<Point, JsValue> {
                    let result =
                        std::result::Result::Ok(self.0.__TSB_get_weighted_normal_at_time(time)?);
                    result
                }
                #[allow(dead_code)]
                pub fn classify(
                    &self,
                ) -> std::result::Result<std::collections::HashMap<String, JsValue>, JsValue>
                {
                    let result = std::result::Result::Ok(self.0.__TSB_classify()?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_curvature_at_time(
                    &self,
                    time: f64,
                ) -> std::result::Result<f64, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_curvature_at_time(time)?);
                    result
                }
                #[allow(dead_code)]
                pub fn is_last(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_last()?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_curvature_at(
                    &self,
                    location: CurveGetCurvatureAtParamsLocationParam,
                ) -> std::result::Result<f64, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_curvature_at(
                        ts_bindgen_rt::to_jsvalue(&location).map_err(ts_bindgen_rt::Error::from)?,
                    )?);
                    result
                }
                #[allow(dead_code)]
                pub fn segment1(&self) -> Segment {
                    let result = self.0.segment1();
                    result
                }
                #[allow(dead_code)]
                pub fn set_segment1(&self, value: Segment) -> () {
                    let result = self.0.set_segment1(value);
                    result
                }
                #[allow(dead_code)]
                pub fn is_horizontal(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_horizontal()?);
                    result
                }
                #[allow(dead_code)]
                pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_to_string()?);
                    result
                }
                #[allow(dead_code)]
                pub fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_clear_handles()?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_location_at(
                    &self,
                    offset: f64,
                ) -> std::result::Result<CurveLocation, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_location_at(offset)?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_tangent_at_time(
                    &self,
                    time: f64,
                ) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_tangent_at_time(time)?);
                    result
                }
                #[allow(dead_code)]
                pub fn length(&self) -> f64 {
                    let result = self.0.length();
                    result
                }
                #[allow(dead_code)]
                pub fn set_length(&self, value: f64) -> () {
                    let result = self.0.set_length(value);
                    result
                }
                #[allow(dead_code)]
                pub fn divide_at(
                    &self,
                    location: CurveDivideAtParamsLocationParam,
                ) -> std::result::Result<Curve, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_divide_at(
                        ts_bindgen_rt::to_jsvalue(&location).map_err(ts_bindgen_rt::Error::from)?,
                    )?);
                    result
                }
                #[allow(dead_code)]
                pub fn handle2(&self) -> Point {
                    let result = self.0.handle2();
                    result
                }
                #[allow(dead_code)]
                pub fn set_handle2(&self, value: Point) -> () {
                    let result = self.0.set_handle2(value);
                    result
                }
                #[allow(dead_code)]
                pub fn clone(&self) -> std::result::Result<Curve, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_clone()?);
                    result
                }
                #[allow(dead_code)]
                pub fn values(&self) -> Vec<f64> {
                    let result = self.0.values();
                    result
                }
                #[allow(dead_code)]
                pub fn set_values(&self, value: Vec<f64>) -> () {
                    let result = self.0.set_values(value);
                    result
                }
                #[allow(dead_code)]
                pub fn get_weighted_tangent_at(
                    &self,
                    location: CurveGetWeightedTangentAtParamsLocationParam,
                ) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_weighted_tangent_at(
                        ts_bindgen_rt::to_jsvalue(&location).map_err(ts_bindgen_rt::Error::from)?,
                    )?);
                    result
                }
                #[allow(dead_code)]
                pub fn new(point1: Point, handle1: Point, handle2: Point, point2: Point) -> Curve {
                    let result = Curve_Class::new(point1, handle1, handle2, point2);
                    let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                    Curve(result)
                }
                #[allow(dead_code)]
                pub fn remove(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_remove()?);
                    result
                }
                #[allow(dead_code)]
                pub fn is_vertical(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_vertical()?);
                    result
                }
                #[allow(dead_code)]
                pub fn point1(&self) -> Point {
                    let result = self.0.point1();
                    result
                }
                #[allow(dead_code)]
                pub fn set_point1(&self, value: Point) -> () {
                    let result = self.0.set_point1(value);
                    result
                }
                #[allow(dead_code)]
                pub fn points(&self) -> Vec<Point> {
                    let result = self.0.points();
                    result
                }
                #[allow(dead_code)]
                pub fn set_points(&self, value: Vec<Point>) -> () {
                    let result = self.0.set_points(value);
                    result
                }
                #[allow(dead_code)]
                pub fn get_tangent_at(
                    &self,
                    location: CurveGetTangentAtParamsLocationParam,
                ) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_tangent_at(
                        ts_bindgen_rt::to_jsvalue(&location).map_err(ts_bindgen_rt::Error::from)?,
                    )?);
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for Curve {
                fn describe() {
                    <Curve_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for Curve {
                type Abi = <Curve_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Curve {
                type Abi = <&'a Curve_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for Curve {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Curve {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: Curve_Class =
                        <Curve_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait Curve_Trait {
                fn path(&self) -> Path;
                fn set_path(&mut self, value: Path) -> ();
                fn divide_at_time(&self, time: f64) -> std::result::Result<Curve, JsValue>;
                fn selected(&self) -> bool;
                fn set_selected(&mut self, value: bool) -> ();
                fn area(&self) -> f64;
                fn set_area(&mut self, value: f64) -> ();
                fn get_intersections(
                    &self,
                    curve: Curve,
                ) -> std::result::Result<Vec<CurveLocation>, JsValue>;
                fn next(&self) -> Curve;
                fn set_next(&mut self, value: Curve) -> ();
                fn get_weighted_tangent_at_time(
                    &self,
                    time: f64,
                ) -> std::result::Result<Point, JsValue>;
                fn split_at_time(&self, time: f64) -> std::result::Result<Path, JsValue>;
                fn is_straight(&self) -> std::result::Result<bool, JsValue>;
                fn get_nearest_location(
                    &self,
                    point: Point,
                ) -> std::result::Result<CurveLocation, JsValue>;
                fn get_time_of(&self, point: Point) -> std::result::Result<f64, JsValue>;
                fn bounds(&self) -> Rectangle;
                fn set_bounds(&mut self, value: Rectangle) -> ();
                fn get_time_at(&self, offset: f64, start: f64)
                    -> std::result::Result<f64, JsValue>;
                fn get_weighted_normal_at(
                    &self,
                    location: CurveGetWeightedNormalAtParamsLocationParam,
                ) -> std::result::Result<Point, JsValue>;
                fn get_normal_at_time(&self, time: f64) -> std::result::Result<Point, JsValue>;
                fn has_length(&self, epsilon: f64) -> std::result::Result<bool, JsValue>;
                fn get_times_with_tangent(
                    &self,
                    tangent: Point,
                ) -> std::result::Result<Vec<f64>, JsValue>;
                fn get_point_at_time(&self, time: f64) -> std::result::Result<Point, JsValue>;
                fn split_at(
                    &self,
                    location: CurveSplitAtParamsLocationParam,
                ) -> std::result::Result<Path, JsValue>;
                fn get_location_at_time(
                    &self,
                    time: f64,
                ) -> std::result::Result<CurveLocation, JsValue>;
                fn get_normal_at(
                    &self,
                    location: CurveGetNormalAtParamsLocationParam,
                ) -> std::result::Result<Point, JsValue>;
                fn is_linear(&self) -> std::result::Result<bool, JsValue>;
                fn point2(&self) -> Point;
                fn set_point2(&mut self, value: Point) -> ();
                fn reversed(&self) -> std::result::Result<Curve, JsValue>;
                fn get_offset_of(&self, point: Point) -> std::result::Result<f64, JsValue>;
                fn get_offset_at_time(&self, time: f64) -> std::result::Result<f64, JsValue>;
                fn get_location_of(
                    &self,
                    point: Point,
                ) -> std::result::Result<CurveLocation, JsValue>;
                fn get_nearest_point(&self, point: Point) -> std::result::Result<Point, JsValue>;
                fn stroke_bounds(&self) -> Rectangle;
                fn set_stroke_bounds(&mut self, value: Rectangle) -> ();
                fn handle1(&self) -> Point;
                fn set_handle1(&mut self, value: Point) -> ();
                fn get_part(&self, from: f64, to: f64) -> std::result::Result<Curve, JsValue>;
                fn is_first(&self) -> std::result::Result<bool, JsValue>;
                fn index(&self) -> f64;
                fn set_index(&mut self, value: f64) -> ();
                fn previous(&self) -> Curve;
                fn set_previous(&mut self, value: Curve) -> ();
                fn segment2(&self) -> Segment;
                fn set_segment2(&mut self, value: Segment) -> ();
                fn has_handles(&self) -> std::result::Result<bool, JsValue>;
                fn handle_bounds(&self) -> Rectangle;
                fn set_handle_bounds(&mut self, value: Rectangle) -> ();
                fn is_collinear(&self, curve: Curve) -> std::result::Result<bool, JsValue>;
                fn get_point_at(
                    &self,
                    location: CurveGetPointAtParamsLocationParam,
                ) -> std::result::Result<Point, JsValue>;
                fn get_weighted_normal_at_time(
                    &self,
                    time: f64,
                ) -> std::result::Result<Point, JsValue>;
                fn classify(
                    &self,
                ) -> std::result::Result<std::collections::HashMap<String, JsValue>, JsValue>;
                fn get_curvature_at_time(&self, time: f64) -> std::result::Result<f64, JsValue>;
                fn is_last(&self) -> std::result::Result<bool, JsValue>;
                fn get_curvature_at(
                    &self,
                    location: CurveGetCurvatureAtParamsLocationParam,
                ) -> std::result::Result<f64, JsValue>;
                fn segment1(&self) -> Segment;
                fn set_segment1(&mut self, value: Segment) -> ();
                fn is_horizontal(&self) -> std::result::Result<bool, JsValue>;
                fn to_string(&self) -> std::result::Result<String, JsValue>;
                fn clear_handles(&self) -> std::result::Result<(), JsValue>;
                fn get_location_at(
                    &self,
                    offset: f64,
                ) -> std::result::Result<CurveLocation, JsValue>;
                fn get_tangent_at_time(&self, time: f64) -> std::result::Result<Point, JsValue>;
                fn length(&self) -> f64;
                fn set_length(&mut self, value: f64) -> ();
                fn divide_at(
                    &self,
                    location: CurveDivideAtParamsLocationParam,
                ) -> std::result::Result<Curve, JsValue>;
                fn handle2(&self) -> Point;
                fn set_handle2(&mut self, value: Point) -> ();
                fn clone(&self) -> std::result::Result<Curve, JsValue>;
                fn values(&self) -> Vec<f64>;
                fn set_values(&mut self, value: Vec<f64>) -> ();
                fn get_weighted_tangent_at(
                    &self,
                    location: CurveGetWeightedTangentAtParamsLocationParam,
                ) -> std::result::Result<Point, JsValue>;
                fn new(point1: Point, handle1: Point, handle2: Point, point2: Point) -> Curve;
                fn remove(&self) -> std::result::Result<bool, JsValue>;
                fn is_vertical(&self) -> std::result::Result<bool, JsValue>;
                fn point1(&self) -> Point;
                fn set_point1(&mut self, value: Point) -> ();
                fn points(&self) -> Vec<Point>;
                fn set_points(&mut self, value: Vec<Point>) -> ();
                fn get_tangent_at(
                    &self,
                    location: CurveGetTangentAtParamsLocationParam,
                ) -> std::result::Result<Point, JsValue>;
            }
            impl std::clone::Clone for Curve_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for Curve_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Curve_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum HitResultColor {
                ColorCase(Color),
                TsBindgenRtNullCase,
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                #[wasm_bindgen(js_name = "HitResult")]
                type HitResult_Class;
                # [wasm_bindgen (method , structural , getter = color , js_class = "HitResult")]
                fn color(this: &HitResult_Class) -> HitResultColor;
                # [wasm_bindgen (method , structural , setter = color , js_class = "HitResult")]
                fn set_color(this: &HitResult_Class, value: HitResultColor);
                # [wasm_bindgen (method , structural , getter = name , js_class = "HitResult")]
                fn name(this: &HitResult_Class) -> String;
                # [wasm_bindgen (method , structural , setter = name , js_class = "HitResult")]
                fn set_name(this: &HitResult_Class, value: String);
                # [wasm_bindgen (method , structural , getter = segment , js_class = "HitResult")]
                fn segment(this: &HitResult_Class) -> Segment;
                # [wasm_bindgen (method , structural , setter = segment , js_class = "HitResult")]
                fn set_segment(this: &HitResult_Class, value: Segment);
                # [wasm_bindgen (method , structural , getter = item , js_class = "HitResult")]
                fn item(this: &HitResult_Class) -> Item;
                # [wasm_bindgen (method , structural , setter = item , js_class = "HitResult")]
                fn set_item(this: &HitResult_Class, value: Item);
                # [wasm_bindgen (method , structural , getter = location , js_class = "HitResult")]
                fn location(this: &HitResult_Class) -> CurveLocation;
                # [wasm_bindgen (method , structural , setter = location , js_class = "HitResult")]
                fn set_location(this: &HitResult_Class, value: CurveLocation);
                # [wasm_bindgen (method , structural , getter = type , js_class = "HitResult")]
                fn type_(this: &HitResult_Class) -> String;
                # [wasm_bindgen (method , structural , setter = type , js_class = "HitResult")]
                fn set_type_(this: &HitResult_Class, value: String);
                # [wasm_bindgen (method , structural , getter = point , js_class = "HitResult")]
                fn point(this: &HitResult_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = point , js_class = "HitResult")]
                fn set_point(this: &HitResult_Class, value: Point);
            }
            #[derive(std :: clone :: Clone)]
            struct HitResult(pub HitResult_Class);
            impl HitResult {
                #[allow(dead_code)]
                pub fn color(&self) -> HitResultColor {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.color()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_color(&self, value: HitResultColor) -> () {
                    let result = self.0.set_color(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn name(&self) -> String {
                    let result = self.0.name();
                    result
                }
                #[allow(dead_code)]
                pub fn set_name(&self, value: String) -> () {
                    let result = self.0.set_name(value);
                    result
                }
                #[allow(dead_code)]
                pub fn segment(&self) -> Segment {
                    let result = self.0.segment();
                    result
                }
                #[allow(dead_code)]
                pub fn set_segment(&self, value: Segment) -> () {
                    let result = self.0.set_segment(value);
                    result
                }
                #[allow(dead_code)]
                pub fn item(&self) -> Item {
                    let result = self.0.item();
                    result
                }
                #[allow(dead_code)]
                pub fn set_item(&self, value: Item) -> () {
                    let result = self.0.set_item(value);
                    result
                }
                #[allow(dead_code)]
                pub fn location(&self) -> CurveLocation {
                    let result = self.0.location();
                    result
                }
                #[allow(dead_code)]
                pub fn set_location(&self, value: CurveLocation) -> () {
                    let result = self.0.set_location(value);
                    result
                }
                #[allow(dead_code)]
                pub fn type_(&self) -> String {
                    let result = self.0.type_();
                    result
                }
                #[allow(dead_code)]
                pub fn set_type_(&self, value: String) -> () {
                    let result = self.0.set_type_(value);
                    result
                }
                #[allow(dead_code)]
                pub fn point(&self) -> Point {
                    let result = self.0.point();
                    result
                }
                #[allow(dead_code)]
                pub fn set_point(&self, value: Point) -> () {
                    let result = self.0.set_point(value);
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for HitResult {
                fn describe() {
                    <HitResult_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for HitResult {
                type Abi = <HitResult_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a HitResult {
                type Abi = <&'a HitResult_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for HitResult {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for HitResult {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: HitResult_Class =
                        <HitResult_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait HitResult_Trait {
                fn color(&self) -> HitResultColor;
                fn set_color(&mut self, value: HitResultColor) -> ();
                fn name(&self) -> String;
                fn set_name(&mut self, value: String) -> ();
                fn segment(&self) -> Segment;
                fn set_segment(&mut self, value: Segment) -> ();
                fn item(&self) -> Item;
                fn set_item(&mut self, value: Item) -> ();
                fn location(&self) -> CurveLocation;
                fn set_location(&mut self, value: CurveLocation) -> ();
                fn type_(&self) -> String;
                fn set_type(&mut self, value: String) -> ();
                fn point(&self) -> Point;
                fn set_point(&mut self, value: Point) -> ();
            }
            impl std::clone::Clone for HitResult_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for HitResult_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for HitResult_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum StyleShadowColor {
                ColorCase(Color),
                TsBindgenRtNullCase,
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ItemOnMouseEnter {
                TsBindgenRtNullCase,
                JsValueCase(JsValue),
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                #[wasm_bindgen(js_name = "Project")]
                type Project_Class;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = remove , method , js_class = "Project" , catch)]
                fn __TSB_remove(this: &Project_Class) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = exportJSON , method , js_class = "Project" , catch)]
                fn __TSB_export_json(
                    this: &Project_Class,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<String, JsValue>;
                # [wasm_bindgen (method , structural , getter = currentStyle , js_class = "Project")]
                fn current_style(this: &Project_Class) -> Style;
                # [wasm_bindgen (method , structural , setter = currentStyle , js_class = "Project")]
                fn set_current_style(this: &Project_Class, value: Style);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = hitTest , method , js_class = "Project" , catch)]
                fn __TSB_hit_test(
                    this: &Project_Class,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<HitResult, JsValue>;
                # [wasm_bindgen (method , structural , getter = activeLayer , js_class = "Project")]
                fn active_layer(this: &Project_Class) -> Layer;
                # [wasm_bindgen (method , structural , setter = activeLayer , js_class = "Project")]
                fn set_active_layer(this: &Project_Class, value: Layer);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getItems , method , js_class = "Project" , catch)]
                fn __TSB_get_items(
                    this: &Project_Class,
                    options: JsValue,
                ) -> std::result::Result<Vec<Item>, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = addLayer , method , js_class = "Project" , catch)]
                fn __TSB_add_layer(
                    this: &Project_Class,
                    layer: Layer,
                ) -> std::result::Result<Layer, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = importJSON , method , js_class = "Project" , catch)]
                fn __TSB_import_json(
                    this: &Project_Class,
                    json: String,
                ) -> std::result::Result<Item, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = activate , method , js_class = "Project" , catch)]
                fn __TSB_activate(this: &Project_Class) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = selectAll , method , js_class = "Project" , catch)]
                fn __TSB_select_all(this: &Project_Class) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isEmpty , method , js_class = "Project" , catch)]
                fn __TSB_is_empty(this: &Project_Class) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = exportSVG , method , js_class = "Project" , catch)]
                fn __TSB_export_svg(
                    this: &Project_Class,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = clear , method , js_class = "Project" , catch)]
                fn __TSB_clear(this: &Project_Class) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getItem , method , js_class = "Project" , catch)]
                fn __TSB_get_item(
                    this: &Project_Class,
                    options: JsValue,
                ) -> std::result::Result<Item, JsValue>;
                # [wasm_bindgen (method , structural , getter = index , js_class = "Project")]
                fn index(this: &Project_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = index , js_class = "Project")]
                fn set_index(this: &Project_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = insertLayer , method , js_class = "Project" , catch)]
                fn __TSB_insert_layer(
                    this: &Project_Class,
                    index: f64,
                    layer: Layer,
                ) -> std::result::Result<Layer, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = hitTestAll , method , js_class = "Project" , catch)]
                fn __TSB_hit_test_all(
                    this: &Project_Class,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Vec<HitResult>, JsValue>;
                # [wasm_bindgen (method , structural , getter = view , js_class = "Project")]
                fn view(this: &Project_Class) -> View;
                # [wasm_bindgen (method , structural , setter = view , js_class = "Project")]
                fn set_view(this: &Project_Class, value: View);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = importSVG , method , js_class = "Project" , catch)]
                fn __TSB_import_svg(
                    this: &Project_Class,
                    svg: JsValue,
                    on_load: JsValue,
                ) -> std::result::Result<Item, JsValue>;
                # [wasm_bindgen (method , structural , getter = selectedItems , js_class = "Project")]
                fn selected_items(this: &Project_Class) -> Vec<Item>;
                # [wasm_bindgen (method , structural , setter = selectedItems , js_class = "Project")]
                fn set_selected_items(this: &Project_Class, value: Vec<Item>);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = deselectAll , method , js_class = "Project" , catch)]
                fn __TSB_deselect_all(this: &Project_Class) -> std::result::Result<(), JsValue>;
                # [wasm_bindgen (method , structural , getter = symbolDefinitions , js_class = "Project")]
                fn symbol_definitions(this: &Project_Class) -> Vec<SymbolDefinition>;
                # [wasm_bindgen (method , structural , setter = symbolDefinitions , js_class = "Project")]
                fn set_symbol_definitions(this: &Project_Class, value: Vec<SymbolDefinition>);
                #[wasm_bindgen(constructor, js_class = "Project")]
                pub fn new(element: ProjectConstructorElementParam) -> Project_Class;
                # [wasm_bindgen (method , structural , getter = layers , js_class = "Project")]
                fn layers(this: &Project_Class) -> Vec<Layer>;
                # [wasm_bindgen (method , structural , setter = layers , js_class = "Project")]
                fn set_layers(this: &Project_Class, value: Vec<Layer>);
            }
            #[derive(std :: clone :: Clone)]
            struct Project(pub Project_Class);
            impl Project {
                #[allow(dead_code)]
                pub fn remove(&self) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_remove()?);
                    result
                }
                #[allow(dead_code)]
                pub fn export_json(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<String, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_export_json(options)?);
                    result
                }
                #[allow(dead_code)]
                pub fn current_style(&self) -> Style {
                    let result = self.0.current_style();
                    result
                }
                #[allow(dead_code)]
                pub fn set_current_style(&self, value: Style) -> () {
                    let result = self.0.set_current_style(value);
                    result
                }
                #[allow(dead_code)]
                pub fn hit_test(
                    &self,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<HitResult, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_hit_test(point, options)?);
                    result
                }
                #[allow(dead_code)]
                pub fn active_layer(&self) -> Layer {
                    let result = self.0.active_layer();
                    result
                }
                #[allow(dead_code)]
                pub fn set_active_layer(&self, value: Layer) -> () {
                    let result = self.0.set_active_layer(value);
                    result
                }
                #[allow(dead_code)]
                pub fn get_items(
                    &self,
                    options: ProjectGetItemsParamsOptionsParam,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_items(
                        ts_bindgen_rt::to_jsvalue(&options).map_err(ts_bindgen_rt::Error::from)?,
                    )?);
                    result
                }
                #[allow(dead_code)]
                pub fn add_layer(&self, layer: Layer) -> std::result::Result<Layer, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_add_layer(layer)?);
                    result
                }
                #[allow(dead_code)]
                pub fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_import_json(json)?);
                    result
                }
                #[allow(dead_code)]
                pub fn activate(&self) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_activate()?);
                    result
                }
                #[allow(dead_code)]
                pub fn select_all(&self) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_select_all()?);
                    result
                }
                #[allow(dead_code)]
                pub fn is_empty(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_empty()?);
                    result
                }
                #[allow(dead_code)]
                pub fn export_svg(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<ProjectExportSvgReturn, JsValue> {
                    let result = std::result::Result::Ok(
                        ts_bindgen_rt::from_jsvalue(&self.0.__TSB_export_svg(options)?).unwrap(),
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn clear(&self) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_clear()?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_item(
                    &self,
                    options: ProjectGetItemParamsOptionsParam,
                ) -> std::result::Result<Item, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_item(
                        ts_bindgen_rt::to_jsvalue(&options).map_err(ts_bindgen_rt::Error::from)?,
                    )?);
                    result
                }
                #[allow(dead_code)]
                pub fn index(&self) -> f64 {
                    let result = self.0.index();
                    result
                }
                #[allow(dead_code)]
                pub fn set_index(&self, value: f64) -> () {
                    let result = self.0.set_index(value);
                    result
                }
                #[allow(dead_code)]
                pub fn insert_layer(
                    &self,
                    index: f64,
                    layer: Layer,
                ) -> std::result::Result<Layer, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_insert_layer(index, layer)?);
                    result
                }
                #[allow(dead_code)]
                pub fn hit_test_all(
                    &self,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Vec<HitResult>, JsValue> {
                    let result =
                        std::result::Result::Ok(self.0.__TSB_hit_test_all(point, options)?);
                    result
                }
                #[allow(dead_code)]
                pub fn view(&self) -> View {
                    let result = self.0.view();
                    result
                }
                #[allow(dead_code)]
                pub fn set_view(&self, value: View) -> () {
                    let result = self.0.set_view(value);
                    result
                }
                #[allow(dead_code)]
                pub fn import_svg(
                    &self,
                    svg: ProjectImportSvgParamsSvgParam,
                    on_load: JsValue,
                ) -> std::result::Result<Item, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_import_svg(
                        ts_bindgen_rt::to_jsvalue(&svg).map_err(ts_bindgen_rt::Error::from)?,
                        on_load,
                    )?);
                    result
                }
                #[allow(dead_code)]
                pub fn selected_items(&self) -> Vec<Item> {
                    let result = self.0.selected_items();
                    result
                }
                #[allow(dead_code)]
                pub fn set_selected_items(&self, value: Vec<Item>) -> () {
                    let result = self.0.set_selected_items(value);
                    result
                }
                #[allow(dead_code)]
                pub fn deselect_all(&self) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_deselect_all()?);
                    result
                }
                #[allow(dead_code)]
                pub fn symbol_definitions(&self) -> Vec<SymbolDefinition> {
                    let result = self.0.symbol_definitions();
                    result
                }
                #[allow(dead_code)]
                pub fn set_symbol_definitions(&self, value: Vec<SymbolDefinition>) -> () {
                    let result = self.0.set_symbol_definitions(value);
                    result
                }
                #[allow(dead_code)]
                pub fn new(element: ProjectConstructorElementParam) -> Project {
                    let result = Project_Class::new(
                        ts_bindgen_rt::to_jsvalue(&element).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                    Project(result)
                }
                #[allow(dead_code)]
                pub fn layers(&self) -> Vec<Layer> {
                    let result = self.0.layers();
                    result
                }
                #[allow(dead_code)]
                pub fn set_layers(&self, value: Vec<Layer>) -> () {
                    let result = self.0.set_layers(value);
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for Project {
                fn describe() {
                    <Project_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for Project {
                type Abi = <Project_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Project {
                type Abi = <&'a Project_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for Project {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Project {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: Project_Class =
                        <Project_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait Project_Trait {
                fn remove(&self) -> std::result::Result<(), JsValue>;
                fn export_json(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<String, JsValue>;
                fn current_style(&self) -> Style;
                fn set_current_style(&mut self, value: Style) -> ();
                fn hit_test(
                    &self,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<HitResult, JsValue>;
                fn active_layer(&self) -> Layer;
                fn set_active_layer(&mut self, value: Layer) -> ();
                fn get_items(
                    &self,
                    options: ProjectGetItemsParamsOptionsParam,
                ) -> std::result::Result<Vec<Item>, JsValue>;
                fn add_layer(&self, layer: Layer) -> std::result::Result<Layer, JsValue>;
                fn import_json(&self, json: String) -> std::result::Result<Item, JsValue>;
                fn activate(&self) -> std::result::Result<(), JsValue>;
                fn select_all(&self) -> std::result::Result<(), JsValue>;
                fn is_empty(&self) -> std::result::Result<bool, JsValue>;
                fn export_svg(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<ProjectExportSvgReturn, JsValue>;
                fn clear(&self) -> std::result::Result<(), JsValue>;
                fn get_item(
                    &self,
                    options: ProjectGetItemParamsOptionsParam,
                ) -> std::result::Result<Item, JsValue>;
                fn index(&self) -> f64;
                fn set_index(&mut self, value: f64) -> ();
                fn insert_layer(
                    &self,
                    index: f64,
                    layer: Layer,
                ) -> std::result::Result<Layer, JsValue>;
                fn hit_test_all(
                    &self,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Vec<HitResult>, JsValue>;
                fn view(&self) -> View;
                fn set_view(&mut self, value: View) -> ();
                fn import_svg(
                    &self,
                    svg: ProjectImportSvgParamsSvgParam,
                    on_load: JsValue,
                ) -> std::result::Result<Item, JsValue>;
                fn selected_items(&self) -> Vec<Item>;
                fn set_selected_items(&mut self, value: Vec<Item>) -> ();
                fn deselect_all(&self) -> std::result::Result<(), JsValue>;
                fn symbol_definitions(&self) -> Vec<SymbolDefinition>;
                fn set_symbol_definitions(&mut self, value: Vec<SymbolDefinition>) -> ();
                fn new(element: ProjectConstructorElementParam) -> Project;
                fn layers(&self) -> Vec<Layer>;
                fn set_layers(&mut self, value: Vec<Layer>) -> ();
            }
            impl std::clone::Clone for Project_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for Project_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Project_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                # [wasm_bindgen (js_name = "Ellipse" , extends = Path_Class)]
                type Ellipse_Class;
                #[wasm_bindgen(constructor, js_class = "Ellipse")]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Ellipse_Class;
            }
            #[derive(std :: clone :: Clone)]
            struct Ellipse(pub Ellipse_Class);
            impl std::convert::From<&Ellipse> for Path {
                fn from(src: &Ellipse) -> Path {
                    let src: &Path_Class = src.0.as_ref();
                    Path(src.clone())
                }
            }
            impl std::convert::From<&mut Ellipse> for Path {
                fn from(src: &mut Ellipse) -> Path {
                    let src: &Path_Class = src.0.as_ref();
                    Path(src.clone())
                }
            }
            impl Ellipse {
                #[allow(dead_code)]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Ellipse {
                    let result = Ellipse_Class::new(object);
                    let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                    Ellipse(result)
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for Ellipse {
                fn describe() {
                    <Ellipse_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for Ellipse {
                type Abi = <Ellipse_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Ellipse {
                type Abi = <&'a Ellipse_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for Ellipse {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Ellipse {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: Ellipse_Class =
                        <Ellipse_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait Ellipse_Trait: Path_Trait {
                fn new(object: std::collections::HashMap<String, JsValue>) -> Ellipse;
            }
            impl Path_Trait for Ellipse {}
            impl Ellipse_Trait for Ellipse {}
            impl std::clone::Clone for Ellipse_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for Ellipse_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Ellipse_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum TextItemLeading {
                StringCase(String),
                F64Case(f64),
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                #[wasm_bindgen(js_name = "Color")]
                type Color_Class;
                # [wasm_bindgen (method , structural , getter = blue , js_class = "Color")]
                fn blue(this: &Color_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = blue , js_class = "Color")]
                fn set_blue(this: &Color_Class, value: f64);
                #[wasm_bindgen(constructor, js_class = "Color")]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Color_Class;
                # [wasm_bindgen (method , structural , getter = red , js_class = "Color")]
                fn red(this: &Color_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = red , js_class = "Color")]
                fn set_red(this: &Color_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = lightness , js_class = "Color")]
                fn lightness(this: &Color_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = lightness , js_class = "Color")]
                fn set_lightness(this: &Color_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = gradient , js_class = "Color")]
                fn gradient(this: &Color_Class) -> Gradient;
                # [wasm_bindgen (method , structural , setter = gradient , js_class = "Color")]
                fn set_gradient(this: &Color_Class, value: Gradient);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = clone , method , js_class = "Color" , catch)]
                fn __TSB_clone(this: &Color_Class) -> std::result::Result<Color, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = transform , method , js_class = "Color" , catch)]
                fn __TSB_transform(
                    this: &Color_Class,
                    matrix: Matrix,
                ) -> std::result::Result<(), JsValue>;
                # [wasm_bindgen (method , structural , getter = green , js_class = "Color")]
                fn green(this: &Color_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = green , js_class = "Color")]
                fn set_green(this: &Color_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = hasAlpha , method , js_class = "Color" , catch)]
                fn __TSB_has_alpha(this: &Color_Class) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = subtract , method , js_class = "Color" , catch)]
                fn __TSB_subtract(
                    this: &Color_Class,
                    color: Color,
                ) -> std::result::Result<Color, JsValue>;
                # [wasm_bindgen (method , structural , getter = highlight , js_class = "Color")]
                fn highlight(this: &Color_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = highlight , js_class = "Color")]
                fn set_highlight(this: &Color_Class, value: Point);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = toCSS , method , js_class = "Color" , catch)]
                fn __TSB_to_css(
                    this: &Color_Class,
                    hex: bool,
                ) -> std::result::Result<String, JsValue>;
                # [wasm_bindgen (method , structural , getter = hue , js_class = "Color")]
                fn hue(this: &Color_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = hue , js_class = "Color")]
                fn set_hue(this: &Color_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = multiply , method , js_class = "Color" , catch)]
                fn __TSB_multiply(
                    this: &Color_Class,
                    color: Color,
                ) -> std::result::Result<Color, JsValue>;
                # [wasm_bindgen (method , structural , getter = type , js_class = "Color")]
                fn type_(this: &Color_Class) -> String;
                # [wasm_bindgen (method , structural , setter = type , js_class = "Color")]
                fn set_type_(this: &Color_Class, value: String);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = convert , method , js_class = "Color" , catch)]
                fn __TSB_convert(
                    this: &Color_Class,
                    type_: String,
                ) -> std::result::Result<Color, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = add , method , js_class = "Color" , catch)]
                fn __TSB_add(
                    this: &Color_Class,
                    color: Color,
                ) -> std::result::Result<Color, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = equals , method , js_class = "Color" , catch)]
                fn __TSB_equals(
                    this: &Color_Class,
                    color: Color,
                ) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = set , method , js_class = "Color" , catch , variadic)]
                fn __TSB_set(
                    this: &Color_Class,
                    values: &[JsValue],
                ) -> std::result::Result<Color, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = divide , method , js_class = "Color" , catch)]
                fn __TSB_divide(
                    this: &Color_Class,
                    color: Color,
                ) -> std::result::Result<Color, JsValue>;
                # [wasm_bindgen (method , structural , getter = components , js_class = "Color")]
                fn components(this: &Color_Class) -> Vec<f64>;
                # [wasm_bindgen (method , structural , setter = components , js_class = "Color")]
                fn set_components(this: &Color_Class, value: Vec<f64>);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = toString , method , js_class = "Color" , catch)]
                fn __TSB_to_string(this: &Color_Class) -> std::result::Result<String, JsValue>;
                # [wasm_bindgen (method , structural , getter = brightness , js_class = "Color")]
                fn brightness(this: &Color_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = brightness , js_class = "Color")]
                fn set_brightness(this: &Color_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = alpha , js_class = "Color")]
                fn alpha(this: &Color_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = alpha , js_class = "Color")]
                fn set_alpha(this: &Color_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = random , method , js_class = "Color" , catch)]
                fn __TSB_random(this: &Color_Class) -> std::result::Result<Color, JsValue>;
                # [wasm_bindgen (method , structural , getter = gray , js_class = "Color")]
                fn gray(this: &Color_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = gray , js_class = "Color")]
                fn set_gray(this: &Color_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = saturation , js_class = "Color")]
                fn saturation(this: &Color_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = saturation , js_class = "Color")]
                fn set_saturation(this: &Color_Class, value: f64);
            }
            #[derive(std :: clone :: Clone)]
            struct Color(pub Color_Class);
            impl Color {
                #[allow(dead_code)]
                pub fn blue(&self) -> f64 {
                    let result = self.0.blue();
                    result
                }
                #[allow(dead_code)]
                pub fn set_blue(&self, value: f64) -> () {
                    let result = self.0.set_blue(value);
                    result
                }
                #[allow(dead_code)]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Color {
                    let result = Color_Class::new(object);
                    let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                    Color(result)
                }
                #[allow(dead_code)]
                pub fn red(&self) -> f64 {
                    let result = self.0.red();
                    result
                }
                #[allow(dead_code)]
                pub fn set_red(&self, value: f64) -> () {
                    let result = self.0.set_red(value);
                    result
                }
                #[allow(dead_code)]
                pub fn lightness(&self) -> f64 {
                    let result = self.0.lightness();
                    result
                }
                #[allow(dead_code)]
                pub fn set_lightness(&self, value: f64) -> () {
                    let result = self.0.set_lightness(value);
                    result
                }
                #[allow(dead_code)]
                pub fn gradient(&self) -> Gradient {
                    let result = self.0.gradient();
                    result
                }
                #[allow(dead_code)]
                pub fn set_gradient(&self, value: Gradient) -> () {
                    let result = self.0.set_gradient(value);
                    result
                }
                #[allow(dead_code)]
                pub fn clone(&self) -> std::result::Result<Color, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_clone()?);
                    result
                }
                #[allow(dead_code)]
                pub fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_transform(matrix)?);
                    result
                }
                #[allow(dead_code)]
                pub fn green(&self) -> f64 {
                    let result = self.0.green();
                    result
                }
                #[allow(dead_code)]
                pub fn set_green(&self, value: f64) -> () {
                    let result = self.0.set_green(value);
                    result
                }
                #[allow(dead_code)]
                pub fn has_alpha(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_has_alpha()?);
                    result
                }
                #[allow(dead_code)]
                pub fn subtract(&self, color: Color) -> std::result::Result<Color, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_subtract(color)?);
                    result
                }
                #[allow(dead_code)]
                pub fn highlight(&self) -> Point {
                    let result = self.0.highlight();
                    result
                }
                #[allow(dead_code)]
                pub fn set_highlight(&self, value: Point) -> () {
                    let result = self.0.set_highlight(value);
                    result
                }
                #[allow(dead_code)]
                pub fn to_css(&self, hex: bool) -> std::result::Result<String, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_to_css(hex)?);
                    result
                }
                #[allow(dead_code)]
                pub fn hue(&self) -> f64 {
                    let result = self.0.hue();
                    result
                }
                #[allow(dead_code)]
                pub fn set_hue(&self, value: f64) -> () {
                    let result = self.0.set_hue(value);
                    result
                }
                #[allow(dead_code)]
                pub fn multiply(&self, color: Color) -> std::result::Result<Color, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_multiply(color)?);
                    result
                }
                #[allow(dead_code)]
                pub fn type_(&self) -> String {
                    let result = self.0.type_();
                    result
                }
                #[allow(dead_code)]
                pub fn set_type_(&self, value: String) -> () {
                    let result = self.0.set_type_(value);
                    result
                }
                #[allow(dead_code)]
                pub fn convert(&self, type_: String) -> std::result::Result<Color, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_convert(type_)?);
                    result
                }
                #[allow(dead_code)]
                pub fn add(&self, color: Color) -> std::result::Result<Color, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_add(color)?);
                    result
                }
                #[allow(dead_code)]
                pub fn equals(&self, color: Color) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_equals(color)?);
                    result
                }
                #[allow(dead_code)]
                pub fn set(&self, values: &[JsValue]) -> std::result::Result<Color, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_set(values)?);
                    result
                }
                #[allow(dead_code)]
                pub fn divide(&self, color: Color) -> std::result::Result<Color, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_divide(color)?);
                    result
                }
                #[allow(dead_code)]
                pub fn components(&self) -> Vec<f64> {
                    let result = self.0.components();
                    result
                }
                #[allow(dead_code)]
                pub fn set_components(&self, value: Vec<f64>) -> () {
                    let result = self.0.set_components(value);
                    result
                }
                #[allow(dead_code)]
                pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_to_string()?);
                    result
                }
                #[allow(dead_code)]
                pub fn brightness(&self) -> f64 {
                    let result = self.0.brightness();
                    result
                }
                #[allow(dead_code)]
                pub fn set_brightness(&self, value: f64) -> () {
                    let result = self.0.set_brightness(value);
                    result
                }
                #[allow(dead_code)]
                pub fn alpha(&self) -> f64 {
                    let result = self.0.alpha();
                    result
                }
                #[allow(dead_code)]
                pub fn set_alpha(&self, value: f64) -> () {
                    let result = self.0.set_alpha(value);
                    result
                }
                #[allow(dead_code)]
                pub fn random(&self) -> std::result::Result<Color, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_random()?);
                    result
                }
                #[allow(dead_code)]
                pub fn gray(&self) -> f64 {
                    let result = self.0.gray();
                    result
                }
                #[allow(dead_code)]
                pub fn set_gray(&self, value: f64) -> () {
                    let result = self.0.set_gray(value);
                    result
                }
                #[allow(dead_code)]
                pub fn saturation(&self) -> f64 {
                    let result = self.0.saturation();
                    result
                }
                #[allow(dead_code)]
                pub fn set_saturation(&self, value: f64) -> () {
                    let result = self.0.set_saturation(value);
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for Color {
                fn describe() {
                    <Color_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for Color {
                type Abi = <Color_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Color {
                type Abi = <&'a Color_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for Color {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Color {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: Color_Class =
                        <Color_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait Color_Trait {
                fn blue(&self) -> f64;
                fn set_blue(&mut self, value: f64) -> ();
                fn new(object: std::collections::HashMap<String, JsValue>) -> Color;
                fn red(&self) -> f64;
                fn set_red(&mut self, value: f64) -> ();
                fn lightness(&self) -> f64;
                fn set_lightness(&mut self, value: f64) -> ();
                fn gradient(&self) -> Gradient;
                fn set_gradient(&mut self, value: Gradient) -> ();
                fn clone(&self) -> std::result::Result<Color, JsValue>;
                fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue>;
                fn green(&self) -> f64;
                fn set_green(&mut self, value: f64) -> ();
                fn has_alpha(&self) -> std::result::Result<bool, JsValue>;
                fn subtract(&self, color: Color) -> std::result::Result<Color, JsValue>;
                fn highlight(&self) -> Point;
                fn set_highlight(&mut self, value: Point) -> ();
                fn to_css(&self, hex: bool) -> std::result::Result<String, JsValue>;
                fn hue(&self) -> f64;
                fn set_hue(&mut self, value: f64) -> ();
                fn multiply(&self, color: Color) -> std::result::Result<Color, JsValue>;
                fn type_(&self) -> String;
                fn set_type(&mut self, value: String) -> ();
                fn convert(&self, type_: String) -> std::result::Result<Color, JsValue>;
                fn add(&self, color: Color) -> std::result::Result<Color, JsValue>;
                fn equals(&self, color: Color) -> std::result::Result<bool, JsValue>;
                fn set(&self, values: &[JsValue]) -> std::result::Result<Color, JsValue>;
                fn divide(&self, color: Color) -> std::result::Result<Color, JsValue>;
                fn components(&self) -> Vec<f64>;
                fn set_components(&mut self, value: Vec<f64>) -> ();
                fn to_string(&self) -> std::result::Result<String, JsValue>;
                fn brightness(&self) -> f64;
                fn set_brightness(&mut self, value: f64) -> ();
                fn alpha(&self) -> f64;
                fn set_alpha(&mut self, value: f64) -> ();
                fn random(&self) -> std::result::Result<Color, JsValue>;
                fn gray(&self) -> f64;
                fn set_gray(&mut self, value: f64) -> ();
                fn saturation(&self) -> f64;
                fn set_saturation(&mut self, value: f64) -> ();
            }
            impl std::clone::Clone for Color_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for Color_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Color_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ItemAddToParamsOwnerParam {
                CompoundPathCase(CompoundPath),
                LayerCase(Layer),
                GroupCase(Group),
                ProjectCase(Project),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum CurveDivideAtParamsLocationParam {
                CurveLocationCase(CurveLocation),
                F64Case(f64),
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                #[wasm_bindgen(js_name = "CurveLocation")]
                type CurveLocation_Class;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isTouching , method , js_class = "CurveLocation" , catch)]
                fn __TSB_is_touching(
                    this: &CurveLocation_Class,
                ) -> std::result::Result<bool, JsValue>;
                # [wasm_bindgen (method , structural , getter = curvature , js_class = "CurveLocation")]
                fn curvature(this: &CurveLocation_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = curvature , js_class = "CurveLocation")]
                fn set_curvature(this: &CurveLocation_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = time , js_class = "CurveLocation")]
                fn time(this: &CurveLocation_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = time , js_class = "CurveLocation")]
                fn set_time(this: &CurveLocation_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isCrossing , method , js_class = "CurveLocation" , catch)]
                fn __TSB_is_crossing(
                    this: &CurveLocation_Class,
                ) -> std::result::Result<bool, JsValue>;
                # [wasm_bindgen (method , structural , getter = offset , js_class = "CurveLocation")]
                fn offset(this: &CurveLocation_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = offset , js_class = "CurveLocation")]
                fn set_offset(this: &CurveLocation_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = normal , js_class = "CurveLocation")]
                fn normal(this: &CurveLocation_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = normal , js_class = "CurveLocation")]
                fn set_normal(this: &CurveLocation_Class, value: Point);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = toString , method , js_class = "CurveLocation" , catch)]
                fn __TSB_to_string(
                    this: &CurveLocation_Class,
                ) -> std::result::Result<String, JsValue>;
                # [wasm_bindgen (method , structural , getter = point , js_class = "CurveLocation")]
                fn point(this: &CurveLocation_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = point , js_class = "CurveLocation")]
                fn set_point(this: &CurveLocation_Class, value: Point);
                # [wasm_bindgen (method , structural , getter = curveOffset , js_class = "CurveLocation")]
                fn curve_offset(this: &CurveLocation_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = curveOffset , js_class = "CurveLocation")]
                fn set_curve_offset(this: &CurveLocation_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = hasOverlap , method , js_class = "CurveLocation" , catch)]
                fn __TSB_has_overlap(
                    this: &CurveLocation_Class,
                ) -> std::result::Result<bool, JsValue>;
                # [wasm_bindgen (method , structural , getter = intersection , js_class = "CurveLocation")]
                fn intersection(this: &CurveLocation_Class) -> CurveLocation;
                # [wasm_bindgen (method , structural , setter = intersection , js_class = "CurveLocation")]
                fn set_intersection(this: &CurveLocation_Class, value: CurveLocation);
                # [wasm_bindgen (method , structural , getter = distance , js_class = "CurveLocation")]
                fn distance(this: &CurveLocation_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = distance , js_class = "CurveLocation")]
                fn set_distance(this: &CurveLocation_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = curve , js_class = "CurveLocation")]
                fn curve(this: &CurveLocation_Class) -> Curve;
                # [wasm_bindgen (method , structural , setter = curve , js_class = "CurveLocation")]
                fn set_curve(this: &CurveLocation_Class, value: Curve);
                # [wasm_bindgen (method , structural , getter = path , js_class = "CurveLocation")]
                fn path(this: &CurveLocation_Class) -> Path;
                # [wasm_bindgen (method , structural , setter = path , js_class = "CurveLocation")]
                fn set_path(this: &CurveLocation_Class, value: Path);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = equals , method , js_class = "CurveLocation" , catch)]
                fn __TSB_equals(
                    this: &CurveLocation_Class,
                    location: CurveLocation,
                ) -> std::result::Result<bool, JsValue>;
                #[wasm_bindgen(constructor, js_class = "CurveLocation")]
                pub fn new(curve: Curve, time: f64, point: Point) -> CurveLocation_Class;
                # [wasm_bindgen (method , structural , getter = tangent , js_class = "CurveLocation")]
                fn tangent(this: &CurveLocation_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = tangent , js_class = "CurveLocation")]
                fn set_tangent(this: &CurveLocation_Class, value: Point);
                # [wasm_bindgen (method , structural , getter = index , js_class = "CurveLocation")]
                fn index(this: &CurveLocation_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = index , js_class = "CurveLocation")]
                fn set_index(this: &CurveLocation_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = segment , js_class = "CurveLocation")]
                fn segment(this: &CurveLocation_Class) -> Segment;
                # [wasm_bindgen (method , structural , setter = segment , js_class = "CurveLocation")]
                fn set_segment(this: &CurveLocation_Class, value: Segment);
            }
            #[derive(std :: clone :: Clone)]
            struct CurveLocation(pub CurveLocation_Class);
            impl CurveLocation {
                #[allow(dead_code)]
                pub fn is_touching(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_touching()?);
                    result
                }
                #[allow(dead_code)]
                pub fn curvature(&self) -> f64 {
                    let result = self.0.curvature();
                    result
                }
                #[allow(dead_code)]
                pub fn set_curvature(&self, value: f64) -> () {
                    let result = self.0.set_curvature(value);
                    result
                }
                #[allow(dead_code)]
                pub fn time(&self) -> f64 {
                    let result = self.0.time();
                    result
                }
                #[allow(dead_code)]
                pub fn set_time(&self, value: f64) -> () {
                    let result = self.0.set_time(value);
                    result
                }
                #[allow(dead_code)]
                pub fn is_crossing(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_crossing()?);
                    result
                }
                #[allow(dead_code)]
                pub fn offset(&self) -> f64 {
                    let result = self.0.offset();
                    result
                }
                #[allow(dead_code)]
                pub fn set_offset(&self, value: f64) -> () {
                    let result = self.0.set_offset(value);
                    result
                }
                #[allow(dead_code)]
                pub fn normal(&self) -> Point {
                    let result = self.0.normal();
                    result
                }
                #[allow(dead_code)]
                pub fn set_normal(&self, value: Point) -> () {
                    let result = self.0.set_normal(value);
                    result
                }
                #[allow(dead_code)]
                pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_to_string()?);
                    result
                }
                #[allow(dead_code)]
                pub fn point(&self) -> Point {
                    let result = self.0.point();
                    result
                }
                #[allow(dead_code)]
                pub fn set_point(&self, value: Point) -> () {
                    let result = self.0.set_point(value);
                    result
                }
                #[allow(dead_code)]
                pub fn curve_offset(&self) -> f64 {
                    let result = self.0.curve_offset();
                    result
                }
                #[allow(dead_code)]
                pub fn set_curve_offset(&self, value: f64) -> () {
                    let result = self.0.set_curve_offset(value);
                    result
                }
                #[allow(dead_code)]
                pub fn has_overlap(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_has_overlap()?);
                    result
                }
                #[allow(dead_code)]
                pub fn intersection(&self) -> CurveLocation {
                    let result = self.0.intersection();
                    result
                }
                #[allow(dead_code)]
                pub fn set_intersection(&self, value: CurveLocation) -> () {
                    let result = self.0.set_intersection(value);
                    result
                }
                #[allow(dead_code)]
                pub fn distance(&self) -> f64 {
                    let result = self.0.distance();
                    result
                }
                #[allow(dead_code)]
                pub fn set_distance(&self, value: f64) -> () {
                    let result = self.0.set_distance(value);
                    result
                }
                #[allow(dead_code)]
                pub fn curve(&self) -> Curve {
                    let result = self.0.curve();
                    result
                }
                #[allow(dead_code)]
                pub fn set_curve(&self, value: Curve) -> () {
                    let result = self.0.set_curve(value);
                    result
                }
                #[allow(dead_code)]
                pub fn path(&self) -> Path {
                    let result = self.0.path();
                    result
                }
                #[allow(dead_code)]
                pub fn set_path(&self, value: Path) -> () {
                    let result = self.0.set_path(value);
                    result
                }
                #[allow(dead_code)]
                pub fn equals(
                    &self,
                    location: CurveLocation,
                ) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_equals(location)?);
                    result
                }
                #[allow(dead_code)]
                pub fn new(curve: Curve, time: f64, point: Point) -> CurveLocation {
                    let result = CurveLocation_Class::new(curve, time, point);
                    let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                    CurveLocation(result)
                }
                #[allow(dead_code)]
                pub fn tangent(&self) -> Point {
                    let result = self.0.tangent();
                    result
                }
                #[allow(dead_code)]
                pub fn set_tangent(&self, value: Point) -> () {
                    let result = self.0.set_tangent(value);
                    result
                }
                #[allow(dead_code)]
                pub fn index(&self) -> f64 {
                    let result = self.0.index();
                    result
                }
                #[allow(dead_code)]
                pub fn set_index(&self, value: f64) -> () {
                    let result = self.0.set_index(value);
                    result
                }
                #[allow(dead_code)]
                pub fn segment(&self) -> Segment {
                    let result = self.0.segment();
                    result
                }
                #[allow(dead_code)]
                pub fn set_segment(&self, value: Segment) -> () {
                    let result = self.0.set_segment(value);
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for CurveLocation {
                fn describe() {
                    <CurveLocation_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for CurveLocation {
                type Abi = <CurveLocation_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a CurveLocation {
                type Abi = <&'a CurveLocation_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for CurveLocation {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for CurveLocation {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: CurveLocation_Class =
                        <CurveLocation_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait CurveLocation_Trait {
                fn is_touching(&self) -> std::result::Result<bool, JsValue>;
                fn curvature(&self) -> f64;
                fn set_curvature(&mut self, value: f64) -> ();
                fn time(&self) -> f64;
                fn set_time(&mut self, value: f64) -> ();
                fn is_crossing(&self) -> std::result::Result<bool, JsValue>;
                fn offset(&self) -> f64;
                fn set_offset(&mut self, value: f64) -> ();
                fn normal(&self) -> Point;
                fn set_normal(&mut self, value: Point) -> ();
                fn to_string(&self) -> std::result::Result<String, JsValue>;
                fn point(&self) -> Point;
                fn set_point(&mut self, value: Point) -> ();
                fn curve_offset(&self) -> f64;
                fn set_curve_offset(&mut self, value: f64) -> ();
                fn has_overlap(&self) -> std::result::Result<bool, JsValue>;
                fn intersection(&self) -> CurveLocation;
                fn set_intersection(&mut self, value: CurveLocation) -> ();
                fn distance(&self) -> f64;
                fn set_distance(&mut self, value: f64) -> ();
                fn curve(&self) -> Curve;
                fn set_curve(&mut self, value: Curve) -> ();
                fn path(&self) -> Path;
                fn set_path(&mut self, value: Path) -> ();
                fn equals(&self, location: CurveLocation) -> std::result::Result<bool, JsValue>;
                fn new(curve: Curve, time: f64, point: Point) -> CurveLocation;
                fn tangent(&self) -> Point;
                fn set_tangent(&mut self, value: Point) -> ();
                fn index(&self) -> f64;
                fn set_index(&mut self, value: f64) -> ();
                fn segment(&self) -> Segment;
                fn set_segment(&mut self, value: Segment) -> ();
            }
            impl std::clone::Clone for CurveLocation_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for CurveLocation_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for CurveLocation_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ItemImportSvgParamsSvgParam {
                StringCase(String),
                JsValueCase(JsValue),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ViewOnDoubleClick {
                TsBindgenRtNullCase,
                JsValueCase(JsValue),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum PathDivideAtParamsLocationParam {
                CurveLocationCase(CurveLocation),
                F64Case(f64),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ToolOnMouseMove {
                TsBindgenRtNullCase,
                JsValueCase(JsValue),
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                # [wasm_bindgen (js_name = "CompoundPath" , extends = PathItem_Class)]
                type CompoundPath_Class;
                # [wasm_bindgen (method , structural , getter = lastCurve , js_class = "CompoundPath")]
                fn last_curve(this: &CompoundPath_Class) -> Curve;
                # [wasm_bindgen (method , structural , setter = lastCurve , js_class = "CompoundPath")]
                fn set_last_curve(this: &CompoundPath_Class, value: Curve);
                # [wasm_bindgen (method , structural , getter = area , js_class = "CompoundPath")]
                fn area(this: &CompoundPath_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = area , js_class = "CompoundPath")]
                fn set_area(this: &CompoundPath_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = curves , js_class = "CompoundPath")]
                fn curves(this: &CompoundPath_Class) -> Vec<Curve>;
                # [wasm_bindgen (method , structural , setter = curves , js_class = "CompoundPath")]
                fn set_curves(this: &CompoundPath_Class, value: Vec<Curve>);
                # [wasm_bindgen (method , structural , getter = firstCurve , js_class = "CompoundPath")]
                fn first_curve(this: &CompoundPath_Class) -> Curve;
                # [wasm_bindgen (method , structural , setter = firstCurve , js_class = "CompoundPath")]
                fn set_first_curve(this: &CompoundPath_Class, value: Curve);
                # [wasm_bindgen (method , structural , getter = lastSegment , js_class = "CompoundPath")]
                fn last_segment(this: &CompoundPath_Class) -> Segment;
                # [wasm_bindgen (method , structural , setter = lastSegment , js_class = "CompoundPath")]
                fn set_last_segment(this: &CompoundPath_Class, value: Segment);
                #[wasm_bindgen(constructor, js_class = "CompoundPath")]
                pub fn new(
                    object: std::collections::HashMap<String, JsValue>,
                ) -> CompoundPath_Class;
                # [wasm_bindgen (method , structural , getter = firstSegment , js_class = "CompoundPath")]
                fn first_segment(this: &CompoundPath_Class) -> Segment;
                # [wasm_bindgen (method , structural , setter = firstSegment , js_class = "CompoundPath")]
                fn set_first_segment(this: &CompoundPath_Class, value: Segment);
                # [wasm_bindgen (method , structural , getter = length , js_class = "CompoundPath")]
                fn length(this: &CompoundPath_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = length , js_class = "CompoundPath")]
                fn set_length(this: &CompoundPath_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = closed , js_class = "CompoundPath")]
                fn closed(this: &CompoundPath_Class) -> bool;
                # [wasm_bindgen (method , structural , setter = closed , js_class = "CompoundPath")]
                fn set_closed(this: &CompoundPath_Class, value: bool);
            }
            #[derive(std :: clone :: Clone)]
            struct CompoundPath(pub CompoundPath_Class);
            impl std::convert::From<&CompoundPath> for PathItem {
                fn from(src: &CompoundPath) -> PathItem {
                    let src: &PathItem_Class = src.0.as_ref();
                    PathItem(src.clone())
                }
            }
            impl std::convert::From<&mut CompoundPath> for PathItem {
                fn from(src: &mut CompoundPath) -> PathItem {
                    let src: &PathItem_Class = src.0.as_ref();
                    PathItem(src.clone())
                }
            }
            impl CompoundPath {
                #[allow(dead_code)]
                pub fn last_curve(&self) -> Curve {
                    let result = self.0.last_curve();
                    result
                }
                #[allow(dead_code)]
                pub fn set_last_curve(&self, value: Curve) -> () {
                    let result = self.0.set_last_curve(value);
                    result
                }
                #[allow(dead_code)]
                pub fn area(&self) -> f64 {
                    let result = self.0.area();
                    result
                }
                #[allow(dead_code)]
                pub fn set_area(&self, value: f64) -> () {
                    let result = self.0.set_area(value);
                    result
                }
                #[allow(dead_code)]
                pub fn curves(&self) -> Vec<Curve> {
                    let result = self.0.curves();
                    result
                }
                #[allow(dead_code)]
                pub fn set_curves(&self, value: Vec<Curve>) -> () {
                    let result = self.0.set_curves(value);
                    result
                }
                #[allow(dead_code)]
                pub fn first_curve(&self) -> Curve {
                    let result = self.0.first_curve();
                    result
                }
                #[allow(dead_code)]
                pub fn set_first_curve(&self, value: Curve) -> () {
                    let result = self.0.set_first_curve(value);
                    result
                }
                #[allow(dead_code)]
                pub fn last_segment(&self) -> Segment {
                    let result = self.0.last_segment();
                    result
                }
                #[allow(dead_code)]
                pub fn set_last_segment(&self, value: Segment) -> () {
                    let result = self.0.set_last_segment(value);
                    result
                }
                #[allow(dead_code)]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> CompoundPath {
                    let result = CompoundPath_Class::new(object);
                    let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                    CompoundPath(result)
                }
                #[allow(dead_code)]
                pub fn first_segment(&self) -> Segment {
                    let result = self.0.first_segment();
                    result
                }
                #[allow(dead_code)]
                pub fn set_first_segment(&self, value: Segment) -> () {
                    let result = self.0.set_first_segment(value);
                    result
                }
                #[allow(dead_code)]
                pub fn length(&self) -> f64 {
                    let result = self.0.length();
                    result
                }
                #[allow(dead_code)]
                pub fn set_length(&self, value: f64) -> () {
                    let result = self.0.set_length(value);
                    result
                }
                #[allow(dead_code)]
                pub fn closed(&self) -> bool {
                    let result = self.0.closed();
                    result
                }
                #[allow(dead_code)]
                pub fn set_closed(&self, value: bool) -> () {
                    let result = self.0.set_closed(value);
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for CompoundPath {
                fn describe() {
                    <CompoundPath_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for CompoundPath {
                type Abi = <CompoundPath_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a CompoundPath {
                type Abi = <&'a CompoundPath_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for CompoundPath {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for CompoundPath {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: CompoundPath_Class =
                        <CompoundPath_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait CompoundPath_Trait: PathItem_Trait {
                fn last_curve(&self) -> Curve;
                fn set_last_curve(&mut self, value: Curve) -> ();
                fn area(&self) -> f64;
                fn set_area(&mut self, value: f64) -> ();
                fn curves(&self) -> Vec<Curve>;
                fn set_curves(&mut self, value: Vec<Curve>) -> ();
                fn first_curve(&self) -> Curve;
                fn set_first_curve(&mut self, value: Curve) -> ();
                fn last_segment(&self) -> Segment;
                fn set_last_segment(&mut self, value: Segment) -> ();
                fn new(object: std::collections::HashMap<String, JsValue>) -> CompoundPath;
                fn first_segment(&self) -> Segment;
                fn set_first_segment(&mut self, value: Segment) -> ();
                fn length(&self) -> f64;
                fn set_length(&mut self, value: f64) -> ();
                fn closed(&self) -> bool;
                fn set_closed(&mut self, value: bool) -> ();
            }
            impl PathItem_Trait for CompoundPath
            where
                CompoundPath: Item_Trait,
            {
                fn cubic_curve_by(
                    &self,
                    handle1: Point,
                    handle2: Point,
                    to: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::cubic_curve_by(&target, handle1, handle2, to)
                }
                fn curve_by(
                    &self,
                    through: Point,
                    to: Point,
                    time: f64,
                ) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::curve_by(&target, through, to, time)
                }
                fn close_path(&self) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::close_path(&target)
                }
                fn simplify(&self, tolerance: f64) -> std::result::Result<bool, JsValue> {
                    let target: PathItem = self.into();
                    PathItem::simplify(&target, tolerance)
                }
                fn reverse(&self) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::reverse(&target)
                }
                fn quadratic_curve_by(
                    &self,
                    handle: Point,
                    to: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::quadratic_curve_by(&target, handle, to)
                }
                fn get_intersections(
                    &self,
                    path: PathItem,
                    include: JsValue,
                ) -> std::result::Result<Vec<CurveLocation>, JsValue> {
                    let target: PathItem = self.into();
                    PathItem::get_intersections(&target, path, include)
                }
                fn get_nearest_point(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: PathItem = self.into();
                    PathItem::get_nearest_point(&target, point)
                }
                fn move_to(&self, point: Point) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::move_to(&target, point)
                }
                fn exclude(
                    &self,
                    path: PathItem,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<PathItem, JsValue> {
                    let target: PathItem = self.into();
                    PathItem::exclude(&target, path, options)
                }
                fn interpolate(
                    &self,
                    from: PathItem,
                    to: PathItem,
                    factor: f64,
                ) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::interpolate(&target, from, to, factor)
                }
                fn compare(&self, path: PathItem) -> std::result::Result<bool, JsValue> {
                    let target: PathItem = self.into();
                    PathItem::compare(&target, path)
                }
                fn arc_by(&self, to: Point, clockwise: bool) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::arc_by(&target, to, clockwise)
                }
                fn line_to(&self, point: Point) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::line_to(&target, point)
                }
                fn line_by(&self, point: Point) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::line_by(&target, point)
                }
                fn path_data(&self) -> String {
                    let target: PathItem = self.into();
                    PathItem::path_data(&target)
                }
                fn set_path_data(&mut self, value: String) -> () {
                    let mut target: PathItem = self.into();
                    PathItem::set_path_data(&mut target, value)
                }
                fn interior_point(&self) -> Point {
                    let target: PathItem = self.into();
                    PathItem::interior_point(&target)
                }
                fn set_interior_point(&mut self, value: Point) -> () {
                    let mut target: PathItem = self.into();
                    PathItem::set_interior_point(&mut target, value)
                }
                fn clockwise(&self) -> bool {
                    let target: PathItem = self.into();
                    PathItem::clockwise(&target)
                }
                fn set_clockwise(&mut self, value: bool) -> () {
                    let mut target: PathItem = self.into();
                    PathItem::set_clockwise(&mut target, value)
                }
                fn smooth(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::smooth(&target, options)
                }
                fn get_nearest_location(
                    &self,
                    point: Point,
                ) -> std::result::Result<CurveLocation, JsValue> {
                    let target: PathItem = self.into();
                    PathItem::get_nearest_location(&target, point)
                }
                fn divide(
                    &self,
                    path: PathItem,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<PathItem, JsValue> {
                    let target: PathItem = self.into();
                    PathItem::divide(&target, path, options)
                }
                fn cubic_curve_to(
                    &self,
                    handle1: Point,
                    handle2: Point,
                    to: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::cubic_curve_to(&target, handle1, handle2, to)
                }
                fn subtract(
                    &self,
                    path: PathItem,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<PathItem, JsValue> {
                    let target: PathItem = self.into();
                    PathItem::subtract(&target, path, options)
                }
                fn move_by(&self, to: Point) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::move_by(&target, to)
                }
                fn quadratic_curve_to(
                    &self,
                    handle: Point,
                    to: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::quadratic_curve_to(&target, handle, to)
                }
                fn get_crossings(
                    &self,
                    path: PathItem,
                ) -> std::result::Result<Vec<CurveLocation>, JsValue> {
                    let target: PathItem = self.into();
                    PathItem::get_crossings(&target, path)
                }
                fn curve_to(
                    &self,
                    through: Point,
                    to: Point,
                    time: f64,
                ) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::curve_to(&target, through, to, time)
                }
                fn arc_to(&self, to: Point, clockwise: bool) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::arc_to(&target, to, clockwise)
                }
                fn unite(
                    &self,
                    path: PathItem,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<PathItem, JsValue> {
                    let target: PathItem = self.into();
                    PathItem::unite(&target, path, options)
                }
                fn flatten(&self, flatness: f64) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::flatten(&target, flatness)
                }
                fn intersect(
                    &self,
                    path: PathItem,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<PathItem, JsValue> {
                    let target: PathItem = self.into();
                    PathItem::intersect(&target, path, options)
                }
                fn reorient(
                    &self,
                    non_zero: bool,
                    clockwise: bool,
                ) -> std::result::Result<PathItem, JsValue> {
                    let target: PathItem = self.into();
                    PathItem::reorient(&target, non_zero, clockwise)
                }
                fn create(
                    &self,
                    object: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<PathItemCreateReturn, JsValue> {
                    let target: PathItem = self.into();
                    PathItem::create(&target, object)
                }
            }
            impl Item_Trait for CompoundPath {
                fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::insert_below(&target, item)
                }
                fn on_double_click(&self) -> ItemOnDoubleClick {
                    let target: Item = self.into();
                    Item::on_double_click(&target)
                }
                fn set_on_double_click(&mut self, value: ItemOnDoubleClick) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_double_click(&mut target, value)
                }
                fn view(&self) -> View {
                    let target: Item = self.into();
                    Item::view(&target)
                }
                fn set_view(&mut self, value: View) -> () {
                    let mut target: Item = self.into();
                    Item::set_view(&mut target, value)
                }
                fn blend_mode(&self) -> String {
                    let target: Item = self.into();
                    Item::blend_mode(&target)
                }
                fn set_blend_mode(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_blend_mode(&mut target, value)
                }
                fn name(&self) -> String {
                    let target: Item = self.into();
                    Item::name(&target)
                }
                fn set_name(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_name(&mut target, value)
                }
                fn project(&self) -> Project {
                    let target: Item = self.into();
                    Item::project(&target)
                }
                fn set_project(&mut self, value: Project) -> () {
                    let mut target: Item = self.into();
                    Item::set_project(&mut target, value)
                }
                fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_child(&target, item)
                }
                fn global_matrix(&self) -> Matrix {
                    let target: Item = self.into();
                    Item::global_matrix(&target)
                }
                fn set_global_matrix(&mut self, value: Matrix) -> () {
                    let mut target: Item = self.into();
                    Item::set_global_matrix(&mut target, value)
                }
                fn on_mouse_leave(&self) -> ItemOnMouseLeave {
                    let target: Item = self.into();
                    Item::on_mouse_leave(&target)
                }
                fn set_on_mouse_leave(&mut self, value: ItemOnMouseLeave) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_leave(&mut target, value)
                }
                fn has_children(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_children(&target)
                }
                fn selected(&self) -> bool {
                    let target: Item = self.into();
                    Item::selected(&target)
                }
                fn set_selected(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_selected(&mut target, value)
                }
                fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::global_to_local(&target, point)
                }
                fn shadow_blur(&self) -> f64 {
                    let target: Item = self.into();
                    Item::shadow_blur(&target)
                }
                fn set_shadow_blur(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_shadow_blur(&mut target, value)
                }
                fn children(&self) -> Vec<Item> {
                    let target: Item = self.into();
                    Item::children(&target)
                }
                fn set_children(&mut self, value: Vec<Item>) -> () {
                    let mut target: Item = self.into();
                    Item::set_children(&mut target, value)
                }
                fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::replace_with(&target, item)
                }
                fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::import_json(&target, json)
                }
                fn insert_child(
                    &self,
                    index: f64,
                    item: Item,
                ) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::insert_child(&target, index, item)
                }
                fn stroke_join(&self) -> String {
                    let target: Item = self.into();
                    Item::stroke_join(&target)
                }
                fn set_stroke_join(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_join(&mut target, value)
                }
                fn rotation(&self) -> f64 {
                    let target: Item = self.into();
                    Item::rotation(&target)
                }
                fn set_rotation(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_rotation(&mut target, value)
                }
                fn scaling(&self) -> Point {
                    let target: Item = self.into();
                    Item::scaling(&target)
                }
                fn set_scaling(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_scaling(&mut target, value)
                }
                fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_ancestor(&target, item)
                }
                fn emit(
                    &self,
                    type_: String,
                    event: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::emit(&target, type_, event)
                }
                fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_up(&target)
                }
                fn add_to(
                    &self,
                    owner: ItemAddToParamsOwnerParam,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::add_to(&target, owner)
                }
                fn stroke_cap(&self) -> String {
                    let target: Item = self.into();
                    Item::stroke_cap(&target)
                }
                fn set_stroke_cap(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_cap(&mut target, value)
                }
                fn on_mouse_drag(&self) -> ItemOnMouseDrag {
                    let target: Item = self.into();
                    Item::on_mouse_drag(&target)
                }
                fn set_on_mouse_drag(&mut self, value: ItemOnMouseDrag) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_drag(&mut target, value)
                }
                fn set(
                    &self,
                    props: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::set(&target, props)
                }
                fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::reverse_children(&target)
                }
                fn matches(
                    &self,
                    name: String,
                    compare: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::matches(&target, name, compare)
                }
                fn on_mouse_enter(&self) -> ItemOnMouseEnter {
                    let target: Item = self.into();
                    Item::on_mouse_enter(&target)
                }
                fn set_on_mouse_enter(&mut self, value: ItemOnMouseEnter) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_enter(&mut target, value)
                }
                fn shadow_offset(&self) -> Point {
                    let target: Item = self.into();
                    Item::shadow_offset(&target)
                }
                fn set_shadow_offset(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_shadow_offset(&mut target, value)
                }
                fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_stroke(&target)
                }
                fn view_matrix(&self) -> Matrix {
                    let target: Item = self.into();
                    Item::view_matrix(&target)
                }
                fn set_view_matrix(&mut self, value: Matrix) -> () {
                    let mut target: Item = self.into();
                    Item::set_view_matrix(&mut target, value)
                }
                fn on_frame(&self) -> ItemOnFrame {
                    let target: Item = self.into();
                    Item::on_frame(&target)
                }
                fn set_on_frame(&mut self, value: ItemOnFrame) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_frame(&mut target, value)
                }
                fn on_mouse_down(&self) -> ItemOnMouseDown {
                    let target: Item = self.into();
                    Item::on_mouse_down(&target)
                }
                fn set_on_mouse_down(&mut self, value: ItemOnMouseDown) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_down(&mut target, value)
                }
                fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_sibling(&target, item)
                }
                fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::local_to_global(&target, point)
                }
                fn first_child(&self) -> Item {
                    let target: Item = self.into();
                    Item::first_child(&target)
                }
                fn set_first_child(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_first_child(&mut target, value)
                }
                fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::send_to_back(&target)
                }
                fn clip_mask(&self) -> bool {
                    let target: Item = self.into();
                    Item::clip_mask(&target)
                }
                fn set_clip_mask(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_clip_mask(&mut target, value)
                }
                fn next_sibling(&self) -> Item {
                    let target: Item = self.into();
                    Item::next_sibling(&target)
                }
                fn set_next_sibling(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_next_sibling(&mut target, value)
                }
                fn off(
                    &self,
                    object: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::off(&target, object)
                }
                fn rotate(&self, angle: f64, center: Point) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::rotate(&target, angle, center)
                }
                fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::add_child(&target, item)
                }
                fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_grouped_with(&target, item)
                }
                fn scale(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::scale(&target, hor, ver, center)
                }
                fn hit_test_all(
                    &self,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Vec<HitResult>, JsValue> {
                    let target: Item = self.into();
                    Item::hit_test_all(&target, point, options)
                }
                fn insert_children(
                    &self,
                    index: f64,
                    items: Vec<Item>,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::insert_children(&target, index, items)
                }
                fn style(&self) -> Style {
                    let target: Item = self.into();
                    Item::style(&target)
                }
                fn set_style(&mut self, value: Style) -> () {
                    let mut target: Item = self.into();
                    Item::set_style(&mut target, value)
                }
                fn position(&self) -> Point {
                    let target: Item = self.into();
                    Item::position(&target)
                }
                fn set_position(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_position(&mut target, value)
                }
                fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::transform(&target, matrix)
                }
                fn fill_color(&self) -> ItemFillColor {
                    let target: Item = self.into();
                    Item::fill_color(&target)
                }
                fn set_fill_color(&mut self, value: ItemFillColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_fill_color(&mut target, value)
                }
                fn matrix(&self) -> Matrix {
                    let target: Item = self.into();
                    Item::matrix(&target)
                }
                fn set_matrix(&mut self, value: Matrix) -> () {
                    let mut target: Item = self.into();
                    Item::set_matrix(&mut target, value)
                }
                fn id(&self) -> f64 {
                    let target: Item = self.into();
                    Item::id(&target)
                }
                fn set_id(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_id(&mut target, value)
                }
                fn tween(
                    &self,
                    options: ItemTweenParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let target: Item = self.into();
                    Item::tween(&target, options)
                }
                fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::reduce(&target, options)
                }
                fn internal_bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::internal_bounds(&target)
                }
                fn set_internal_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_internal_bounds(&mut target, value)
                }
                fn fill_rule(&self) -> String {
                    let target: Item = self.into();
                    Item::fill_rule(&target)
                }
                fn set_fill_rule(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_fill_rule(&mut target, value)
                }
                fn shadow_color(&self) -> ItemShadowColor {
                    let target: Item = self.into();
                    Item::shadow_color(&target)
                }
                fn set_shadow_color(&mut self, value: ItemShadowColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_shadow_color(&mut target, value)
                }
                fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::insert_above(&target, item)
                }
                fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::responds(&target, type_)
                }
                fn handle_bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::handle_bounds(&target)
                }
                fn set_handle_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_handle_bounds(&mut target, value)
                }
                fn skew(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::skew(&target, hor, ver, center)
                }
                fn on_click(&self) -> ItemOnClick {
                    let target: Item = self.into();
                    Item::on_click(&target)
                }
                fn set_on_click(&mut self, value: ItemOnClick) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_click(&mut target, value)
                }
                fn get_items(
                    &self,
                    options: ItemGetItemsParamsOptionsParam,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::get_items(&target, options)
                }
                fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_inserted(&target)
                }
                fn get_item(
                    &self,
                    options: ItemGetItemParamsOptionsParam,
                ) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::get_item(&target, options)
                }
                fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_fill(&target)
                }
                fn shear(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::shear(&target, hor, ver, center)
                }
                fn visible(&self) -> bool {
                    let target: Item = self.into();
                    Item::visible(&target)
                }
                fn set_visible(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_visible(&mut target, value)
                }
                fn previous_sibling(&self) -> Item {
                    let target: Item = self.into();
                    Item::previous_sibling(&target)
                }
                fn set_previous_sibling(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_previous_sibling(&mut target, value)
                }
                fn hit_test(
                    &self,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<HitResult, JsValue> {
                    let target: Item = self.into();
                    Item::hit_test(&target, point, options)
                }
                fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_descendant(&target, item)
                }
                fn locked(&self) -> bool {
                    let target: Item = self.into();
                    Item::locked(&target)
                }
                fn set_locked(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_locked(&mut target, value)
                }
                fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_parent(&target, item)
                }
                fn copy_attributes(
                    &self,
                    source: Item,
                    exclude_matrix: bool,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::copy_attributes(&target, source, exclude_matrix)
                }
                fn last_child(&self) -> Item {
                    let target: Item = self.into();
                    Item::last_child(&target)
                }
                fn set_last_child(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_last_child(&mut target, value)
                }
                fn stroke_width(&self) -> f64 {
                    let target: Item = self.into();
                    Item::stroke_width(&target)
                }
                fn set_stroke_width(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_width(&mut target, value)
                }
                fn parent(&self) -> Item {
                    let target: Item = self.into();
                    Item::parent(&target)
                }
                fn set_parent(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_parent(&mut target, value)
                }
                fn stroke_bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::stroke_bounds(&target)
                }
                fn set_stroke_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_bounds(&mut target, value)
                }
                fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::translate(&target, delta)
                }
                fn remove(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::remove(&target)
                }
                fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::parent_to_local(&target, point)
                }
                fn bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::bounds(&target)
                }
                fn set_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_bounds(&mut target, value)
                }
                fn add_children(
                    &self,
                    items: Vec<Item>,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::add_children(&target, items)
                }
                fn dash_array(&self) -> Vec<f64> {
                    let target: Item = self.into();
                    Item::dash_array(&target)
                }
                fn set_dash_array(&mut self, value: Vec<f64>) -> () {
                    let mut target: Item = self.into();
                    Item::set_dash_array(&mut target, value)
                }
                fn on_mouse_up(&self) -> ItemOnMouseUp {
                    let target: Item = self.into();
                    Item::on_mouse_up(&target)
                }
                fn set_on_mouse_up(&mut self, value: ItemOnMouseUp) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_up(&mut target, value)
                }
                fn on(
                    &self,
                    object: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::on(&target, object)
                }
                fn remove_on(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on(&target, options)
                }
                fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_below(&target, item)
                }
                fn apply_matrix(&self) -> bool {
                    let target: Item = self.into();
                    Item::apply_matrix(&target)
                }
                fn set_apply_matrix(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_apply_matrix(&mut target, value)
                }
                fn clone(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::clone(&target, options)
                }
                fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::contains(&target, point)
                }
                fn export_json(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<String, JsValue> {
                    let target: Item = self.into();
                    Item::export_json(&target, options)
                }
                fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::bring_to_front(&target)
                }
                fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_above(&target, item)
                }
                fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_drag(&target)
                }
                fn data(&self) -> JsValue {
                    let target: Item = self.into();
                    Item::data(&target)
                }
                fn set_data(&mut self, value: JsValue) -> () {
                    let mut target: Item = self.into();
                    Item::set_data(&mut target, value)
                }
                fn import_svg(
                    &self,
                    svg: ItemImportSvgParamsSvgParam,
                    on_load: JsValue,
                ) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::import_svg(&target, svg, on_load)
                }
                fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_shadow(&target)
                }
                fn selected_color(&self) -> ItemSelectedColor {
                    let target: Item = self.into();
                    Item::selected_color(&target)
                }
                fn set_selected_color(&mut self, value: ItemSelectedColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_selected_color(&mut target, value)
                }
                fn class_name(&self) -> String {
                    let target: Item = self.into();
                    Item::class_name(&target)
                }
                fn set_class_name(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_class_name(&mut target, value)
                }
                fn export_svg(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                    let target: Item = self.into();
                    Item::export_svg(&target, options)
                }
                fn tween_to(
                    &self,
                    to: std::collections::HashMap<String, JsValue>,
                    options: ItemTweenToParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let target: Item = self.into();
                    Item::tween_to(&target, to, options)
                }
                fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_inside(&target, rect)
                }
                fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_empty(&target, recursively)
                }
                fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::copy_content(&target, source)
                }
                fn rasterize(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Raster, JsValue> {
                    let target: Item = self.into();
                    Item::rasterize(&target, options)
                }
                fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_move(&target)
                }
                fn tween_from(
                    &self,
                    from: std::collections::HashMap<String, JsValue>,
                    options: ItemTweenFromParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let target: Item = self.into();
                    Item::tween_from(&target, from, options)
                }
                fn opacity(&self) -> f64 {
                    let target: Item = self.into();
                    Item::opacity(&target)
                }
                fn set_opacity(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_opacity(&mut target, value)
                }
                fn dash_offset(&self) -> f64 {
                    let target: Item = self.into();
                    Item::dash_offset(&target)
                }
                fn set_dash_offset(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_dash_offset(&mut target, value)
                }
                fn remove_children(
                    &self,
                    start: f64,
                    end: f64,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::remove_children(&target, start, end)
                }
                fn on_mouse_move(&self) -> ItemOnMouseMove {
                    let target: Item = self.into();
                    Item::on_mouse_move(&target)
                }
                fn set_on_mouse_move(&mut self, value: ItemOnMouseMove) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_move(&mut target, value)
                }
                fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::intersects(&target, item)
                }
                fn pivot(&self) -> Point {
                    let target: Item = self.into();
                    Item::pivot(&target)
                }
                fn set_pivot(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_pivot(&mut target, value)
                }
                fn copy_to(
                    &self,
                    owner: ItemCopyToParamsOwnerParam,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::copy_to(&target, owner)
                }
                fn index(&self) -> f64 {
                    let target: Item = self.into();
                    Item::index(&target)
                }
                fn set_index(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_index(&mut target, value)
                }
                fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::local_to_parent(&target, point)
                }
                fn stroke_color(&self) -> ItemStrokeColor {
                    let target: Item = self.into();
                    Item::stroke_color(&target)
                }
                fn set_stroke_color(&mut self, value: ItemStrokeColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_color(&mut target, value)
                }
                fn layer(&self) -> Layer {
                    let target: Item = self.into();
                    Item::layer(&target)
                }
                fn set_layer(&mut self, value: Layer) -> () {
                    let mut target: Item = self.into();
                    Item::set_layer(&mut target, value)
                }
                fn stroke_scaling(&self) -> bool {
                    let target: Item = self.into();
                    Item::stroke_scaling(&target)
                }
                fn set_stroke_scaling(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_scaling(&mut target, value)
                }
                fn fit_bounds(
                    &self,
                    rectangle: Rectangle,
                    fill: bool,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::fit_bounds(&target, rectangle, fill)
                }
                fn miter_limit(&self) -> f64 {
                    let target: Item = self.into();
                    Item::miter_limit(&target)
                }
                fn set_miter_limit(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_miter_limit(&mut target, value)
                }
                fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_down(&target)
                }
            }
            impl CompoundPath_Trait for CompoundPath {}
            impl std::clone::Clone for CompoundPath_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for CompoundPath_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for CompoundPath_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum CurveGetPointAtParamsLocationParam {
                CurveLocationCase(CurveLocation),
                F64Case(f64),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ViewOnMouseMove {
                TsBindgenRtNullCase,
                JsValueCase(JsValue),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ItemOnDoubleClick {
                TsBindgenRtNullCase,
                JsValueCase(JsValue),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum CurveGetCurvatureAtParamsLocationParam {
                CurveLocationCase(CurveLocation),
                F64Case(f64),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum TweenConstructorEasingParam {
                JsValueCase(JsValue),
                StringCase(String),
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                # [wasm_bindgen (js_name = "KeyEvent" , extends = Event_Class)]
                type KeyEvent_Class;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = toString , method , js_class = "KeyEvent" , catch)]
                fn __TSB_to_string(this: &KeyEvent_Class) -> std::result::Result<String, JsValue>;
                # [wasm_bindgen (method , structural , getter = type , js_class = "KeyEvent")]
                fn type_(this: &KeyEvent_Class) -> String;
                # [wasm_bindgen (method , structural , setter = type , js_class = "KeyEvent")]
                fn set_type_(this: &KeyEvent_Class, value: String);
                # [wasm_bindgen (method , structural , getter = character , js_class = "KeyEvent")]
                fn character(this: &KeyEvent_Class) -> String;
                # [wasm_bindgen (method , structural , setter = character , js_class = "KeyEvent")]
                fn set_character(this: &KeyEvent_Class, value: String);
                # [wasm_bindgen (method , structural , getter = key , js_class = "KeyEvent")]
                fn key(this: &KeyEvent_Class) -> String;
                # [wasm_bindgen (method , structural , setter = key , js_class = "KeyEvent")]
                fn set_key(this: &KeyEvent_Class, value: String);
            }
            #[derive(std :: clone :: Clone)]
            struct KeyEvent(pub KeyEvent_Class);
            impl std::convert::From<&KeyEvent> for Event {
                fn from(src: &KeyEvent) -> Event {
                    let src: &Event_Class = src.0.as_ref();
                    Event(src.clone())
                }
            }
            impl std::convert::From<&mut KeyEvent> for Event {
                fn from(src: &mut KeyEvent) -> Event {
                    let src: &Event_Class = src.0.as_ref();
                    Event(src.clone())
                }
            }
            impl KeyEvent {
                #[allow(dead_code)]
                pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_to_string()?);
                    result
                }
                #[allow(dead_code)]
                pub fn type_(&self) -> String {
                    let result = self.0.type_();
                    result
                }
                #[allow(dead_code)]
                pub fn set_type_(&self, value: String) -> () {
                    let result = self.0.set_type_(value);
                    result
                }
                #[allow(dead_code)]
                pub fn character(&self) -> String {
                    let result = self.0.character();
                    result
                }
                #[allow(dead_code)]
                pub fn set_character(&self, value: String) -> () {
                    let result = self.0.set_character(value);
                    result
                }
                #[allow(dead_code)]
                pub fn key(&self) -> String {
                    let result = self.0.key();
                    result
                }
                #[allow(dead_code)]
                pub fn set_key(&self, value: String) -> () {
                    let result = self.0.set_key(value);
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for KeyEvent {
                fn describe() {
                    <KeyEvent_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for KeyEvent {
                type Abi = <KeyEvent_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a KeyEvent {
                type Abi = <&'a KeyEvent_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for KeyEvent {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for KeyEvent {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: KeyEvent_Class =
                        <KeyEvent_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait KeyEvent_Trait: Event_Trait {
                fn to_string(&self) -> std::result::Result<String, JsValue>;
                fn type_(&self) -> String;
                fn set_type(&mut self, value: String) -> ();
                fn character(&self) -> String;
                fn set_character(&mut self, value: String) -> ();
                fn key(&self) -> String;
                fn set_key(&mut self, value: String) -> ();
            }
            impl Event_Trait for KeyEvent {
                fn prevent_default(&self) -> std::result::Result<(), JsValue> {
                    let target: Event = self.into();
                    Event::prevent_default(&target)
                }
                fn time_stamp(&self) -> f64 {
                    let target: Event = self.into();
                    Event::time_stamp(&target)
                }
                fn set_time_stamp(&mut self, value: f64) -> () {
                    let mut target: Event = self.into();
                    Event::set_time_stamp(&mut target, value)
                }
                fn stop(&self) -> std::result::Result<(), JsValue> {
                    let target: Event = self.into();
                    Event::stop(&target)
                }
                fn modifiers(&self) -> JsValue {
                    let target: Event = self.into();
                    Event::modifiers(&target)
                }
                fn set_modifiers(&mut self, value: JsValue) -> () {
                    let mut target: Event = self.into();
                    Event::set_modifiers(&mut target, value)
                }
                fn stop_propagation(&self) -> std::result::Result<(), JsValue> {
                    let target: Event = self.into();
                    Event::stop_propagation(&target)
                }
            }
            impl KeyEvent_Trait for KeyEvent {}
            impl std::clone::Clone for KeyEvent_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for KeyEvent_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for KeyEvent_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                #[wasm_bindgen(js_name = "Item")]
                type Item_Class;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = insertBelow , method , js_class = "Item" , catch)]
                fn __TSB_insert_below(
                    this: &Item_Class,
                    item: Item,
                ) -> std::result::Result<Item, JsValue>;
                # [wasm_bindgen (method , structural , getter = onDoubleClick , js_class = "Item")]
                fn on_double_click(this: &Item_Class) -> ItemOnDoubleClick;
                # [wasm_bindgen (method , structural , setter = onDoubleClick , js_class = "Item")]
                fn set_on_double_click(this: &Item_Class, value: ItemOnDoubleClick);
                # [wasm_bindgen (method , structural , getter = view , js_class = "Item")]
                fn view(this: &Item_Class) -> View;
                # [wasm_bindgen (method , structural , setter = view , js_class = "Item")]
                fn set_view(this: &Item_Class, value: View);
                # [wasm_bindgen (method , structural , getter = blendMode , js_class = "Item")]
                fn blend_mode(this: &Item_Class) -> String;
                # [wasm_bindgen (method , structural , setter = blendMode , js_class = "Item")]
                fn set_blend_mode(this: &Item_Class, value: String);
                # [wasm_bindgen (method , structural , getter = name , js_class = "Item")]
                fn name(this: &Item_Class) -> String;
                # [wasm_bindgen (method , structural , setter = name , js_class = "Item")]
                fn set_name(this: &Item_Class, value: String);
                # [wasm_bindgen (method , structural , getter = project , js_class = "Item")]
                fn project(this: &Item_Class) -> Project;
                # [wasm_bindgen (method , structural , setter = project , js_class = "Item")]
                fn set_project(this: &Item_Class, value: Project);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isChild , method , js_class = "Item" , catch)]
                fn __TSB_is_child(
                    this: &Item_Class,
                    item: Item,
                ) -> std::result::Result<bool, JsValue>;
                # [wasm_bindgen (method , structural , getter = globalMatrix , js_class = "Item")]
                fn global_matrix(this: &Item_Class) -> Matrix;
                # [wasm_bindgen (method , structural , setter = globalMatrix , js_class = "Item")]
                fn set_global_matrix(this: &Item_Class, value: Matrix);
                # [wasm_bindgen (method , structural , getter = onMouseLeave , js_class = "Item")]
                fn on_mouse_leave(this: &Item_Class) -> ItemOnMouseLeave;
                # [wasm_bindgen (method , structural , setter = onMouseLeave , js_class = "Item")]
                fn set_on_mouse_leave(this: &Item_Class, value: ItemOnMouseLeave);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = hasChildren , method , js_class = "Item" , catch)]
                fn __TSB_has_children(this: &Item_Class) -> std::result::Result<bool, JsValue>;
                # [wasm_bindgen (method , structural , getter = selected , js_class = "Item")]
                fn selected(this: &Item_Class) -> bool;
                # [wasm_bindgen (method , structural , setter = selected , js_class = "Item")]
                fn set_selected(this: &Item_Class, value: bool);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = globalToLocal , method , js_class = "Item" , catch)]
                fn __TSB_global_to_local(
                    this: &Item_Class,
                    point: Point,
                ) -> std::result::Result<Point, JsValue>;
                # [wasm_bindgen (method , structural , getter = shadowBlur , js_class = "Item")]
                fn shadow_blur(this: &Item_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = shadowBlur , js_class = "Item")]
                fn set_shadow_blur(this: &Item_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = children , js_class = "Item")]
                fn children(this: &Item_Class) -> Vec<Item>;
                # [wasm_bindgen (method , structural , setter = children , js_class = "Item")]
                fn set_children(this: &Item_Class, value: Vec<Item>);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = replaceWith , method , js_class = "Item" , catch)]
                fn __TSB_replace_with(
                    this: &Item_Class,
                    item: Item,
                ) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = importJSON , method , js_class = "Item" , catch)]
                fn __TSB_import_json(
                    this: &Item_Class,
                    json: String,
                ) -> std::result::Result<Item, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = insertChild , method , js_class = "Item" , catch)]
                fn __TSB_insert_child(
                    this: &Item_Class,
                    index: f64,
                    item: Item,
                ) -> std::result::Result<Item, JsValue>;
                # [wasm_bindgen (method , structural , getter = strokeJoin , js_class = "Item")]
                fn stroke_join(this: &Item_Class) -> String;
                # [wasm_bindgen (method , structural , setter = strokeJoin , js_class = "Item")]
                fn set_stroke_join(this: &Item_Class, value: String);
                # [wasm_bindgen (method , structural , getter = rotation , js_class = "Item")]
                fn rotation(this: &Item_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = rotation , js_class = "Item")]
                fn set_rotation(this: &Item_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = scaling , js_class = "Item")]
                fn scaling(this: &Item_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = scaling , js_class = "Item")]
                fn set_scaling(this: &Item_Class, value: Point);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isAncestor , method , js_class = "Item" , catch)]
                fn __TSB_is_ancestor(
                    this: &Item_Class,
                    item: Item,
                ) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = emit , method , js_class = "Item" , catch)]
                fn __TSB_emit(
                    this: &Item_Class,
                    type_: String,
                    event: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = removeOnUp , method , js_class = "Item" , catch)]
                fn __TSB_remove_on_up(this: &Item_Class) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = addTo , method , js_class = "Item" , catch)]
                fn __TSB_add_to(
                    this: &Item_Class,
                    owner: JsValue,
                ) -> std::result::Result<JsValue, JsValue>;
                # [wasm_bindgen (method , structural , getter = strokeCap , js_class = "Item")]
                fn stroke_cap(this: &Item_Class) -> String;
                # [wasm_bindgen (method , structural , setter = strokeCap , js_class = "Item")]
                fn set_stroke_cap(this: &Item_Class, value: String);
                # [wasm_bindgen (method , structural , getter = onMouseDrag , js_class = "Item")]
                fn on_mouse_drag(this: &Item_Class) -> ItemOnMouseDrag;
                # [wasm_bindgen (method , structural , setter = onMouseDrag , js_class = "Item")]
                fn set_on_mouse_drag(this: &Item_Class, value: ItemOnMouseDrag);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = set , method , js_class = "Item" , catch)]
                fn __TSB_set(
                    this: &Item_Class,
                    props: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = reverseChildren , method , js_class = "Item" , catch)]
                fn __TSB_reverse_children(this: &Item_Class) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = matches , method , js_class = "Item" , catch)]
                fn __TSB_matches(
                    this: &Item_Class,
                    name: String,
                    compare: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue>;
                # [wasm_bindgen (method , structural , getter = onMouseEnter , js_class = "Item")]
                fn on_mouse_enter(this: &Item_Class) -> ItemOnMouseEnter;
                # [wasm_bindgen (method , structural , setter = onMouseEnter , js_class = "Item")]
                fn set_on_mouse_enter(this: &Item_Class, value: ItemOnMouseEnter);
                # [wasm_bindgen (method , structural , getter = shadowOffset , js_class = "Item")]
                fn shadow_offset(this: &Item_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = shadowOffset , js_class = "Item")]
                fn set_shadow_offset(this: &Item_Class, value: Point);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = hasStroke , method , js_class = "Item" , catch)]
                fn __TSB_has_stroke(this: &Item_Class) -> std::result::Result<bool, JsValue>;
                # [wasm_bindgen (method , structural , getter = viewMatrix , js_class = "Item")]
                fn view_matrix(this: &Item_Class) -> Matrix;
                # [wasm_bindgen (method , structural , setter = viewMatrix , js_class = "Item")]
                fn set_view_matrix(this: &Item_Class, value: Matrix);
                # [wasm_bindgen (method , structural , getter = onFrame , js_class = "Item")]
                fn on_frame(this: &Item_Class) -> ItemOnFrame;
                # [wasm_bindgen (method , structural , setter = onFrame , js_class = "Item")]
                fn set_on_frame(this: &Item_Class, value: ItemOnFrame);
                # [wasm_bindgen (method , structural , getter = onMouseDown , js_class = "Item")]
                fn on_mouse_down(this: &Item_Class) -> ItemOnMouseDown;
                # [wasm_bindgen (method , structural , setter = onMouseDown , js_class = "Item")]
                fn set_on_mouse_down(this: &Item_Class, value: ItemOnMouseDown);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isSibling , method , js_class = "Item" , catch)]
                fn __TSB_is_sibling(
                    this: &Item_Class,
                    item: Item,
                ) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = localToGlobal , method , js_class = "Item" , catch)]
                fn __TSB_local_to_global(
                    this: &Item_Class,
                    point: Point,
                ) -> std::result::Result<Point, JsValue>;
                # [wasm_bindgen (method , structural , getter = firstChild , js_class = "Item")]
                fn first_child(this: &Item_Class) -> Item;
                # [wasm_bindgen (method , structural , setter = firstChild , js_class = "Item")]
                fn set_first_child(this: &Item_Class, value: Item);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = sendToBack , method , js_class = "Item" , catch)]
                fn __TSB_send_to_back(this: &Item_Class) -> std::result::Result<(), JsValue>;
                # [wasm_bindgen (method , structural , getter = clipMask , js_class = "Item")]
                fn clip_mask(this: &Item_Class) -> bool;
                # [wasm_bindgen (method , structural , setter = clipMask , js_class = "Item")]
                fn set_clip_mask(this: &Item_Class, value: bool);
                # [wasm_bindgen (method , structural , getter = nextSibling , js_class = "Item")]
                fn next_sibling(this: &Item_Class) -> Item;
                # [wasm_bindgen (method , structural , setter = nextSibling , js_class = "Item")]
                fn set_next_sibling(this: &Item_Class, value: Item);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = off , method , js_class = "Item" , catch)]
                fn __TSB_off(
                    this: &Item_Class,
                    object: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = rotate , method , js_class = "Item" , catch)]
                fn __TSB_rotate(
                    this: &Item_Class,
                    angle: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = addChild , method , js_class = "Item" , catch)]
                fn __TSB_add_child(
                    this: &Item_Class,
                    item: Item,
                ) -> std::result::Result<Item, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isGroupedWith , method , js_class = "Item" , catch)]
                fn __TSB_is_grouped_with(
                    this: &Item_Class,
                    item: Item,
                ) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = scale , method , js_class = "Item" , catch)]
                fn __TSB_scale(
                    this: &Item_Class,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = hitTestAll , method , js_class = "Item" , catch)]
                fn __TSB_hit_test_all(
                    this: &Item_Class,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Vec<HitResult>, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = insertChildren , method , js_class = "Item" , catch)]
                fn __TSB_insert_children(
                    this: &Item_Class,
                    index: f64,
                    items: Vec<Item>,
                ) -> std::result::Result<Vec<Item>, JsValue>;
                # [wasm_bindgen (method , structural , getter = style , js_class = "Item")]
                fn style(this: &Item_Class) -> Style;
                # [wasm_bindgen (method , structural , setter = style , js_class = "Item")]
                fn set_style(this: &Item_Class, value: Style);
                # [wasm_bindgen (method , structural , getter = position , js_class = "Item")]
                fn position(this: &Item_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = position , js_class = "Item")]
                fn set_position(this: &Item_Class, value: Point);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = transform , method , js_class = "Item" , catch)]
                fn __TSB_transform(
                    this: &Item_Class,
                    matrix: Matrix,
                ) -> std::result::Result<(), JsValue>;
                # [wasm_bindgen (method , structural , getter = fillColor , js_class = "Item")]
                fn fill_color(this: &Item_Class) -> ItemFillColor;
                # [wasm_bindgen (method , structural , setter = fillColor , js_class = "Item")]
                fn set_fill_color(this: &Item_Class, value: ItemFillColor);
                # [wasm_bindgen (method , structural , getter = matrix , js_class = "Item")]
                fn matrix(this: &Item_Class) -> Matrix;
                # [wasm_bindgen (method , structural , setter = matrix , js_class = "Item")]
                fn set_matrix(this: &Item_Class, value: Matrix);
                # [wasm_bindgen (method , structural , getter = id , js_class = "Item")]
                fn id(this: &Item_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = id , js_class = "Item")]
                fn set_id(this: &Item_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = tween , method , js_class = "Item" , catch)]
                fn __TSB_tween(
                    this: &Item_Class,
                    options: JsValue,
                ) -> std::result::Result<Tween, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = reduce , method , js_class = "Item" , catch)]
                fn __TSB_reduce(
                    this: &Item_Class,
                    options: JsValue,
                ) -> std::result::Result<Item, JsValue>;
                # [wasm_bindgen (method , structural , getter = internalBounds , js_class = "Item")]
                fn internal_bounds(this: &Item_Class) -> Rectangle;
                # [wasm_bindgen (method , structural , setter = internalBounds , js_class = "Item")]
                fn set_internal_bounds(this: &Item_Class, value: Rectangle);
                # [wasm_bindgen (method , structural , getter = fillRule , js_class = "Item")]
                fn fill_rule(this: &Item_Class) -> String;
                # [wasm_bindgen (method , structural , setter = fillRule , js_class = "Item")]
                fn set_fill_rule(this: &Item_Class, value: String);
                # [wasm_bindgen (method , structural , getter = shadowColor , js_class = "Item")]
                fn shadow_color(this: &Item_Class) -> ItemShadowColor;
                # [wasm_bindgen (method , structural , setter = shadowColor , js_class = "Item")]
                fn set_shadow_color(this: &Item_Class, value: ItemShadowColor);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = insertAbove , method , js_class = "Item" , catch)]
                fn __TSB_insert_above(
                    this: &Item_Class,
                    item: Item,
                ) -> std::result::Result<Item, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = responds , method , js_class = "Item" , catch)]
                fn __TSB_responds(
                    this: &Item_Class,
                    type_: String,
                ) -> std::result::Result<bool, JsValue>;
                # [wasm_bindgen (method , structural , getter = handleBounds , js_class = "Item")]
                fn handle_bounds(this: &Item_Class) -> Rectangle;
                # [wasm_bindgen (method , structural , setter = handleBounds , js_class = "Item")]
                fn set_handle_bounds(this: &Item_Class, value: Rectangle);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = skew , method , js_class = "Item" , catch)]
                fn __TSB_skew(
                    this: &Item_Class,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue>;
                # [wasm_bindgen (method , structural , getter = onClick , js_class = "Item")]
                fn on_click(this: &Item_Class) -> ItemOnClick;
                # [wasm_bindgen (method , structural , setter = onClick , js_class = "Item")]
                fn set_on_click(this: &Item_Class, value: ItemOnClick);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getItems , method , js_class = "Item" , catch)]
                fn __TSB_get_items(
                    this: &Item_Class,
                    options: JsValue,
                ) -> std::result::Result<Vec<Item>, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isInserted , method , js_class = "Item" , catch)]
                fn __TSB_is_inserted(this: &Item_Class) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getItem , method , js_class = "Item" , catch)]
                fn __TSB_get_item(
                    this: &Item_Class,
                    options: JsValue,
                ) -> std::result::Result<Item, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = hasFill , method , js_class = "Item" , catch)]
                fn __TSB_has_fill(this: &Item_Class) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = shear , method , js_class = "Item" , catch)]
                fn __TSB_shear(
                    this: &Item_Class,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue>;
                # [wasm_bindgen (method , structural , getter = visible , js_class = "Item")]
                fn visible(this: &Item_Class) -> bool;
                # [wasm_bindgen (method , structural , setter = visible , js_class = "Item")]
                fn set_visible(this: &Item_Class, value: bool);
                # [wasm_bindgen (method , structural , getter = previousSibling , js_class = "Item")]
                fn previous_sibling(this: &Item_Class) -> Item;
                # [wasm_bindgen (method , structural , setter = previousSibling , js_class = "Item")]
                fn set_previous_sibling(this: &Item_Class, value: Item);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = hitTest , method , js_class = "Item" , catch)]
                fn __TSB_hit_test(
                    this: &Item_Class,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<HitResult, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isDescendant , method , js_class = "Item" , catch)]
                fn __TSB_is_descendant(
                    this: &Item_Class,
                    item: Item,
                ) -> std::result::Result<bool, JsValue>;
                # [wasm_bindgen (method , structural , getter = locked , js_class = "Item")]
                fn locked(this: &Item_Class) -> bool;
                # [wasm_bindgen (method , structural , setter = locked , js_class = "Item")]
                fn set_locked(this: &Item_Class, value: bool);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isParent , method , js_class = "Item" , catch)]
                fn __TSB_is_parent(
                    this: &Item_Class,
                    item: Item,
                ) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = copyAttributes , method , js_class = "Item" , catch)]
                fn __TSB_copy_attributes(
                    this: &Item_Class,
                    source: Item,
                    exclude_matrix: bool,
                ) -> std::result::Result<(), JsValue>;
                # [wasm_bindgen (method , structural , getter = lastChild , js_class = "Item")]
                fn last_child(this: &Item_Class) -> Item;
                # [wasm_bindgen (method , structural , setter = lastChild , js_class = "Item")]
                fn set_last_child(this: &Item_Class, value: Item);
                # [wasm_bindgen (method , structural , getter = strokeWidth , js_class = "Item")]
                fn stroke_width(this: &Item_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = strokeWidth , js_class = "Item")]
                fn set_stroke_width(this: &Item_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = parent , js_class = "Item")]
                fn parent(this: &Item_Class) -> Item;
                # [wasm_bindgen (method , structural , setter = parent , js_class = "Item")]
                fn set_parent(this: &Item_Class, value: Item);
                # [wasm_bindgen (method , structural , getter = strokeBounds , js_class = "Item")]
                fn stroke_bounds(this: &Item_Class) -> Rectangle;
                # [wasm_bindgen (method , structural , setter = strokeBounds , js_class = "Item")]
                fn set_stroke_bounds(this: &Item_Class, value: Rectangle);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = translate , method , js_class = "Item" , catch)]
                fn __TSB_translate(
                    this: &Item_Class,
                    delta: Point,
                ) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = remove , method , js_class = "Item" , catch)]
                fn __TSB_remove(this: &Item_Class) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = parentToLocal , method , js_class = "Item" , catch)]
                fn __TSB_parent_to_local(
                    this: &Item_Class,
                    point: Point,
                ) -> std::result::Result<Point, JsValue>;
                # [wasm_bindgen (method , structural , getter = bounds , js_class = "Item")]
                fn bounds(this: &Item_Class) -> Rectangle;
                # [wasm_bindgen (method , structural , setter = bounds , js_class = "Item")]
                fn set_bounds(this: &Item_Class, value: Rectangle);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = addChildren , method , js_class = "Item" , catch)]
                fn __TSB_add_children(
                    this: &Item_Class,
                    items: Vec<Item>,
                ) -> std::result::Result<Vec<Item>, JsValue>;
                # [wasm_bindgen (method , structural , getter = dashArray , js_class = "Item")]
                fn dash_array(this: &Item_Class) -> Vec<f64>;
                # [wasm_bindgen (method , structural , setter = dashArray , js_class = "Item")]
                fn set_dash_array(this: &Item_Class, value: Vec<f64>);
                # [wasm_bindgen (method , structural , getter = onMouseUp , js_class = "Item")]
                fn on_mouse_up(this: &Item_Class) -> ItemOnMouseUp;
                # [wasm_bindgen (method , structural , setter = onMouseUp , js_class = "Item")]
                fn set_on_mouse_up(this: &Item_Class, value: ItemOnMouseUp);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = on , method , js_class = "Item" , catch)]
                fn __TSB_on(
                    this: &Item_Class,
                    object: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = removeOn , method , js_class = "Item" , catch)]
                fn __TSB_remove_on(
                    this: &Item_Class,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isBelow , method , js_class = "Item" , catch)]
                fn __TSB_is_below(
                    this: &Item_Class,
                    item: Item,
                ) -> std::result::Result<bool, JsValue>;
                # [wasm_bindgen (method , structural , getter = applyMatrix , js_class = "Item")]
                fn apply_matrix(this: &Item_Class) -> bool;
                # [wasm_bindgen (method , structural , setter = applyMatrix , js_class = "Item")]
                fn set_apply_matrix(this: &Item_Class, value: bool);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = clone , method , js_class = "Item" , catch)]
                fn __TSB_clone(
                    this: &Item_Class,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = contains , method , js_class = "Item" , catch)]
                fn __TSB_contains(
                    this: &Item_Class,
                    point: Point,
                ) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = exportJSON , method , js_class = "Item" , catch)]
                fn __TSB_export_json(
                    this: &Item_Class,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<String, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = bringToFront , method , js_class = "Item" , catch)]
                fn __TSB_bring_to_front(this: &Item_Class) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isAbove , method , js_class = "Item" , catch)]
                fn __TSB_is_above(
                    this: &Item_Class,
                    item: Item,
                ) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = removeOnDrag , method , js_class = "Item" , catch)]
                fn __TSB_remove_on_drag(this: &Item_Class) -> std::result::Result<(), JsValue>;
                # [wasm_bindgen (method , structural , getter = data , js_class = "Item")]
                fn data(this: &Item_Class) -> JsValue;
                # [wasm_bindgen (method , structural , setter = data , js_class = "Item")]
                fn set_data(this: &Item_Class, value: JsValue);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = importSVG , method , js_class = "Item" , catch)]
                fn __TSB_import_svg(
                    this: &Item_Class,
                    svg: JsValue,
                    on_load: JsValue,
                ) -> std::result::Result<Item, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = hasShadow , method , js_class = "Item" , catch)]
                fn __TSB_has_shadow(this: &Item_Class) -> std::result::Result<bool, JsValue>;
                # [wasm_bindgen (method , structural , getter = selectedColor , js_class = "Item")]
                fn selected_color(this: &Item_Class) -> ItemSelectedColor;
                # [wasm_bindgen (method , structural , setter = selectedColor , js_class = "Item")]
                fn set_selected_color(this: &Item_Class, value: ItemSelectedColor);
                # [wasm_bindgen (method , structural , getter = className , js_class = "Item")]
                fn class_name(this: &Item_Class) -> String;
                # [wasm_bindgen (method , structural , setter = className , js_class = "Item")]
                fn set_class_name(this: &Item_Class, value: String);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = exportSVG , method , js_class = "Item" , catch)]
                fn __TSB_export_svg(
                    this: &Item_Class,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = tweenTo , method , js_class = "Item" , catch)]
                fn __TSB_tween_to(
                    this: &Item_Class,
                    to: std::collections::HashMap<String, JsValue>,
                    options: JsValue,
                ) -> std::result::Result<Tween, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isInside , method , js_class = "Item" , catch)]
                fn __TSB_is_inside(
                    this: &Item_Class,
                    rect: Rectangle,
                ) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isEmpty , method , js_class = "Item" , catch)]
                fn __TSB_is_empty(
                    this: &Item_Class,
                    recursively: bool,
                ) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = copyContent , method , js_class = "Item" , catch)]
                fn __TSB_copy_content(
                    this: &Item_Class,
                    source: Item,
                ) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = rasterize , method , js_class = "Item" , catch)]
                fn __TSB_rasterize(
                    this: &Item_Class,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Raster, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = removeOnMove , method , js_class = "Item" , catch)]
                fn __TSB_remove_on_move(this: &Item_Class) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = tweenFrom , method , js_class = "Item" , catch)]
                fn __TSB_tween_from(
                    this: &Item_Class,
                    from: std::collections::HashMap<String, JsValue>,
                    options: JsValue,
                ) -> std::result::Result<Tween, JsValue>;
                # [wasm_bindgen (method , structural , getter = opacity , js_class = "Item")]
                fn opacity(this: &Item_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = opacity , js_class = "Item")]
                fn set_opacity(this: &Item_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = dashOffset , js_class = "Item")]
                fn dash_offset(this: &Item_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = dashOffset , js_class = "Item")]
                fn set_dash_offset(this: &Item_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = removeChildren , method , js_class = "Item" , catch)]
                fn __TSB_remove_children(
                    this: &Item_Class,
                    start: f64,
                    end: f64,
                ) -> std::result::Result<Vec<Item>, JsValue>;
                # [wasm_bindgen (method , structural , getter = onMouseMove , js_class = "Item")]
                fn on_mouse_move(this: &Item_Class) -> ItemOnMouseMove;
                # [wasm_bindgen (method , structural , setter = onMouseMove , js_class = "Item")]
                fn set_on_mouse_move(this: &Item_Class, value: ItemOnMouseMove);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = intersects , method , js_class = "Item" , catch)]
                fn __TSB_intersects(
                    this: &Item_Class,
                    item: Item,
                ) -> std::result::Result<bool, JsValue>;
                # [wasm_bindgen (method , structural , getter = pivot , js_class = "Item")]
                fn pivot(this: &Item_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = pivot , js_class = "Item")]
                fn set_pivot(this: &Item_Class, value: Point);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = copyTo , method , js_class = "Item" , catch)]
                fn __TSB_copy_to(
                    this: &Item_Class,
                    owner: JsValue,
                ) -> std::result::Result<JsValue, JsValue>;
                # [wasm_bindgen (method , structural , getter = index , js_class = "Item")]
                fn index(this: &Item_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = index , js_class = "Item")]
                fn set_index(this: &Item_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = localToParent , method , js_class = "Item" , catch)]
                fn __TSB_local_to_parent(
                    this: &Item_Class,
                    point: Point,
                ) -> std::result::Result<Point, JsValue>;
                # [wasm_bindgen (method , structural , getter = strokeColor , js_class = "Item")]
                fn stroke_color(this: &Item_Class) -> ItemStrokeColor;
                # [wasm_bindgen (method , structural , setter = strokeColor , js_class = "Item")]
                fn set_stroke_color(this: &Item_Class, value: ItemStrokeColor);
                # [wasm_bindgen (method , structural , getter = layer , js_class = "Item")]
                fn layer(this: &Item_Class) -> Layer;
                # [wasm_bindgen (method , structural , setter = layer , js_class = "Item")]
                fn set_layer(this: &Item_Class, value: Layer);
                # [wasm_bindgen (method , structural , getter = strokeScaling , js_class = "Item")]
                fn stroke_scaling(this: &Item_Class) -> bool;
                # [wasm_bindgen (method , structural , setter = strokeScaling , js_class = "Item")]
                fn set_stroke_scaling(this: &Item_Class, value: bool);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = fitBounds , method , js_class = "Item" , catch)]
                fn __TSB_fit_bounds(
                    this: &Item_Class,
                    rectangle: Rectangle,
                    fill: bool,
                ) -> std::result::Result<(), JsValue>;
                # [wasm_bindgen (method , structural , getter = miterLimit , js_class = "Item")]
                fn miter_limit(this: &Item_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = miterLimit , js_class = "Item")]
                fn set_miter_limit(this: &Item_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = removeOnDown , method , js_class = "Item" , catch)]
                fn __TSB_remove_on_down(this: &Item_Class) -> std::result::Result<(), JsValue>;
            }
            #[derive(std :: clone :: Clone)]
            struct Item(pub Item_Class);
            impl Item {
                #[allow(dead_code)]
                pub fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_insert_below(item)?);
                    result
                }
                #[allow(dead_code)]
                pub fn on_double_click(&self) -> ItemOnDoubleClick {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.on_double_click()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_on_double_click(&self, value: ItemOnDoubleClick) -> () {
                    let result = self.0.set_on_double_click(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn view(&self) -> View {
                    let result = self.0.view();
                    result
                }
                #[allow(dead_code)]
                pub fn set_view(&self, value: View) -> () {
                    let result = self.0.set_view(value);
                    result
                }
                #[allow(dead_code)]
                pub fn blend_mode(&self) -> String {
                    let result = self.0.blend_mode();
                    result
                }
                #[allow(dead_code)]
                pub fn set_blend_mode(&self, value: String) -> () {
                    let result = self.0.set_blend_mode(value);
                    result
                }
                #[allow(dead_code)]
                pub fn name(&self) -> String {
                    let result = self.0.name();
                    result
                }
                #[allow(dead_code)]
                pub fn set_name(&self, value: String) -> () {
                    let result = self.0.set_name(value);
                    result
                }
                #[allow(dead_code)]
                pub fn project(&self) -> Project {
                    let result = self.0.project();
                    result
                }
                #[allow(dead_code)]
                pub fn set_project(&self, value: Project) -> () {
                    let result = self.0.set_project(value);
                    result
                }
                #[allow(dead_code)]
                pub fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_child(item)?);
                    result
                }
                #[allow(dead_code)]
                pub fn global_matrix(&self) -> Matrix {
                    let result = self.0.global_matrix();
                    result
                }
                #[allow(dead_code)]
                pub fn set_global_matrix(&self, value: Matrix) -> () {
                    let result = self.0.set_global_matrix(value);
                    result
                }
                #[allow(dead_code)]
                pub fn on_mouse_leave(&self) -> ItemOnMouseLeave {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_leave()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_on_mouse_leave(&self, value: ItemOnMouseLeave) -> () {
                    let result = self.0.set_on_mouse_leave(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn has_children(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_has_children()?);
                    result
                }
                #[allow(dead_code)]
                pub fn selected(&self) -> bool {
                    let result = self.0.selected();
                    result
                }
                #[allow(dead_code)]
                pub fn set_selected(&self, value: bool) -> () {
                    let result = self.0.set_selected(value);
                    result
                }
                #[allow(dead_code)]
                pub fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_global_to_local(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn shadow_blur(&self) -> f64 {
                    let result = self.0.shadow_blur();
                    result
                }
                #[allow(dead_code)]
                pub fn set_shadow_blur(&self, value: f64) -> () {
                    let result = self.0.set_shadow_blur(value);
                    result
                }
                #[allow(dead_code)]
                pub fn children(&self) -> Vec<Item> {
                    let result = self.0.children();
                    result
                }
                #[allow(dead_code)]
                pub fn set_children(&self, value: Vec<Item>) -> () {
                    let result = self.0.set_children(value);
                    result
                }
                #[allow(dead_code)]
                pub fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_replace_with(item)?);
                    result
                }
                #[allow(dead_code)]
                pub fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_import_json(json)?);
                    result
                }
                #[allow(dead_code)]
                pub fn insert_child(
                    &self,
                    index: f64,
                    item: Item,
                ) -> std::result::Result<Item, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_insert_child(index, item)?);
                    result
                }
                #[allow(dead_code)]
                pub fn stroke_join(&self) -> String {
                    let result = self.0.stroke_join();
                    result
                }
                #[allow(dead_code)]
                pub fn set_stroke_join(&self, value: String) -> () {
                    let result = self.0.set_stroke_join(value);
                    result
                }
                #[allow(dead_code)]
                pub fn rotation(&self) -> f64 {
                    let result = self.0.rotation();
                    result
                }
                #[allow(dead_code)]
                pub fn set_rotation(&self, value: f64) -> () {
                    let result = self.0.set_rotation(value);
                    result
                }
                #[allow(dead_code)]
                pub fn scaling(&self) -> Point {
                    let result = self.0.scaling();
                    result
                }
                #[allow(dead_code)]
                pub fn set_scaling(&self, value: Point) -> () {
                    let result = self.0.set_scaling(value);
                    result
                }
                #[allow(dead_code)]
                pub fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_ancestor(item)?);
                    result
                }
                #[allow(dead_code)]
                pub fn emit(
                    &self,
                    type_: String,
                    event: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_emit(type_, event)?);
                    result
                }
                #[allow(dead_code)]
                pub fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_remove_on_up()?);
                    result
                }
                #[allow(dead_code)]
                pub fn add_to(
                    &self,
                    owner: ItemAddToParamsOwnerParam,
                ) -> std::result::Result<JsValue, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_add_to(
                        ts_bindgen_rt::to_jsvalue(&owner).map_err(ts_bindgen_rt::Error::from)?,
                    )?);
                    result
                }
                #[allow(dead_code)]
                pub fn stroke_cap(&self) -> String {
                    let result = self.0.stroke_cap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_stroke_cap(&self, value: String) -> () {
                    let result = self.0.set_stroke_cap(value);
                    result
                }
                #[allow(dead_code)]
                pub fn on_mouse_drag(&self) -> ItemOnMouseDrag {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_drag()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_on_mouse_drag(&self, value: ItemOnMouseDrag) -> () {
                    let result = self.0.set_on_mouse_drag(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn set(
                    &self,
                    props: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_set(props)?);
                    result
                }
                #[allow(dead_code)]
                pub fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_reverse_children()?);
                    result
                }
                #[allow(dead_code)]
                pub fn matches(
                    &self,
                    name: String,
                    compare: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_matches(name, compare)?);
                    result
                }
                #[allow(dead_code)]
                pub fn on_mouse_enter(&self) -> ItemOnMouseEnter {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_enter()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_on_mouse_enter(&self, value: ItemOnMouseEnter) -> () {
                    let result = self.0.set_on_mouse_enter(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn shadow_offset(&self) -> Point {
                    let result = self.0.shadow_offset();
                    result
                }
                #[allow(dead_code)]
                pub fn set_shadow_offset(&self, value: Point) -> () {
                    let result = self.0.set_shadow_offset(value);
                    result
                }
                #[allow(dead_code)]
                pub fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_has_stroke()?);
                    result
                }
                #[allow(dead_code)]
                pub fn view_matrix(&self) -> Matrix {
                    let result = self.0.view_matrix();
                    result
                }
                #[allow(dead_code)]
                pub fn set_view_matrix(&self, value: Matrix) -> () {
                    let result = self.0.set_view_matrix(value);
                    result
                }
                #[allow(dead_code)]
                pub fn on_frame(&self) -> ItemOnFrame {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.on_frame()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_on_frame(&self, value: ItemOnFrame) -> () {
                    let result = self.0.set_on_frame(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn on_mouse_down(&self) -> ItemOnMouseDown {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_down()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_on_mouse_down(&self, value: ItemOnMouseDown) -> () {
                    let result = self.0.set_on_mouse_down(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_sibling(item)?);
                    result
                }
                #[allow(dead_code)]
                pub fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_local_to_global(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn first_child(&self) -> Item {
                    let result = self.0.first_child();
                    result
                }
                #[allow(dead_code)]
                pub fn set_first_child(&self, value: Item) -> () {
                    let result = self.0.set_first_child(value);
                    result
                }
                #[allow(dead_code)]
                pub fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_send_to_back()?);
                    result
                }
                #[allow(dead_code)]
                pub fn clip_mask(&self) -> bool {
                    let result = self.0.clip_mask();
                    result
                }
                #[allow(dead_code)]
                pub fn set_clip_mask(&self, value: bool) -> () {
                    let result = self.0.set_clip_mask(value);
                    result
                }
                #[allow(dead_code)]
                pub fn next_sibling(&self) -> Item {
                    let result = self.0.next_sibling();
                    result
                }
                #[allow(dead_code)]
                pub fn set_next_sibling(&self, value: Item) -> () {
                    let result = self.0.set_next_sibling(value);
                    result
                }
                #[allow(dead_code)]
                pub fn off(
                    &self,
                    object: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_off(object)?);
                    result
                }
                #[allow(dead_code)]
                pub fn rotate(
                    &self,
                    angle: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_rotate(angle, center)?);
                    result
                }
                #[allow(dead_code)]
                pub fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_add_child(item)?);
                    result
                }
                #[allow(dead_code)]
                pub fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_grouped_with(item)?);
                    result
                }
                #[allow(dead_code)]
                pub fn scale(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_scale(hor, ver, center)?);
                    result
                }
                #[allow(dead_code)]
                pub fn hit_test_all(
                    &self,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Vec<HitResult>, JsValue> {
                    let result =
                        std::result::Result::Ok(self.0.__TSB_hit_test_all(point, options)?);
                    result
                }
                #[allow(dead_code)]
                pub fn insert_children(
                    &self,
                    index: f64,
                    items: Vec<Item>,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let result =
                        std::result::Result::Ok(self.0.__TSB_insert_children(index, items)?);
                    result
                }
                #[allow(dead_code)]
                pub fn style(&self) -> Style {
                    let result = self.0.style();
                    result
                }
                #[allow(dead_code)]
                pub fn set_style(&self, value: Style) -> () {
                    let result = self.0.set_style(value);
                    result
                }
                #[allow(dead_code)]
                pub fn position(&self) -> Point {
                    let result = self.0.position();
                    result
                }
                #[allow(dead_code)]
                pub fn set_position(&self, value: Point) -> () {
                    let result = self.0.set_position(value);
                    result
                }
                #[allow(dead_code)]
                pub fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_transform(matrix)?);
                    result
                }
                #[allow(dead_code)]
                pub fn fill_color(&self) -> ItemFillColor {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.fill_color()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_fill_color(&self, value: ItemFillColor) -> () {
                    let result = self.0.set_fill_color(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn matrix(&self) -> Matrix {
                    let result = self.0.matrix();
                    result
                }
                #[allow(dead_code)]
                pub fn set_matrix(&self, value: Matrix) -> () {
                    let result = self.0.set_matrix(value);
                    result
                }
                #[allow(dead_code)]
                pub fn id(&self) -> f64 {
                    let result = self.0.id();
                    result
                }
                #[allow(dead_code)]
                pub fn set_id(&self, value: f64) -> () {
                    let result = self.0.set_id(value);
                    result
                }
                #[allow(dead_code)]
                pub fn tween(
                    &self,
                    options: ItemTweenParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_tween(
                        ts_bindgen_rt::to_jsvalue(&options).map_err(ts_bindgen_rt::Error::from)?,
                    )?);
                    result
                }
                #[allow(dead_code)]
                pub fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_reduce(options)?);
                    result
                }
                #[allow(dead_code)]
                pub fn internal_bounds(&self) -> Rectangle {
                    let result = self.0.internal_bounds();
                    result
                }
                #[allow(dead_code)]
                pub fn set_internal_bounds(&self, value: Rectangle) -> () {
                    let result = self.0.set_internal_bounds(value);
                    result
                }
                #[allow(dead_code)]
                pub fn fill_rule(&self) -> String {
                    let result = self.0.fill_rule();
                    result
                }
                #[allow(dead_code)]
                pub fn set_fill_rule(&self, value: String) -> () {
                    let result = self.0.set_fill_rule(value);
                    result
                }
                #[allow(dead_code)]
                pub fn shadow_color(&self) -> ItemShadowColor {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.shadow_color()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_shadow_color(&self, value: ItemShadowColor) -> () {
                    let result = self.0.set_shadow_color(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_insert_above(item)?);
                    result
                }
                #[allow(dead_code)]
                pub fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_responds(type_)?);
                    result
                }
                #[allow(dead_code)]
                pub fn handle_bounds(&self) -> Rectangle {
                    let result = self.0.handle_bounds();
                    result
                }
                #[allow(dead_code)]
                pub fn set_handle_bounds(&self, value: Rectangle) -> () {
                    let result = self.0.set_handle_bounds(value);
                    result
                }
                #[allow(dead_code)]
                pub fn skew(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_skew(hor, ver, center)?);
                    result
                }
                #[allow(dead_code)]
                pub fn on_click(&self) -> ItemOnClick {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.on_click()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_on_click(&self, value: ItemOnClick) -> () {
                    let result = self.0.set_on_click(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn get_items(
                    &self,
                    options: ItemGetItemsParamsOptionsParam,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_items(
                        ts_bindgen_rt::to_jsvalue(&options).map_err(ts_bindgen_rt::Error::from)?,
                    )?);
                    result
                }
                #[allow(dead_code)]
                pub fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_inserted()?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_item(
                    &self,
                    options: ItemGetItemParamsOptionsParam,
                ) -> std::result::Result<Item, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_item(
                        ts_bindgen_rt::to_jsvalue(&options).map_err(ts_bindgen_rt::Error::from)?,
                    )?);
                    result
                }
                #[allow(dead_code)]
                pub fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_has_fill()?);
                    result
                }
                #[allow(dead_code)]
                pub fn shear(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_shear(hor, ver, center)?);
                    result
                }
                #[allow(dead_code)]
                pub fn visible(&self) -> bool {
                    let result = self.0.visible();
                    result
                }
                #[allow(dead_code)]
                pub fn set_visible(&self, value: bool) -> () {
                    let result = self.0.set_visible(value);
                    result
                }
                #[allow(dead_code)]
                pub fn previous_sibling(&self) -> Item {
                    let result = self.0.previous_sibling();
                    result
                }
                #[allow(dead_code)]
                pub fn set_previous_sibling(&self, value: Item) -> () {
                    let result = self.0.set_previous_sibling(value);
                    result
                }
                #[allow(dead_code)]
                pub fn hit_test(
                    &self,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<HitResult, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_hit_test(point, options)?);
                    result
                }
                #[allow(dead_code)]
                pub fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_descendant(item)?);
                    result
                }
                #[allow(dead_code)]
                pub fn locked(&self) -> bool {
                    let result = self.0.locked();
                    result
                }
                #[allow(dead_code)]
                pub fn set_locked(&self, value: bool) -> () {
                    let result = self.0.set_locked(value);
                    result
                }
                #[allow(dead_code)]
                pub fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_parent(item)?);
                    result
                }
                #[allow(dead_code)]
                pub fn copy_attributes(
                    &self,
                    source: Item,
                    exclude_matrix: bool,
                ) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(
                        self.0.__TSB_copy_attributes(source, exclude_matrix)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn last_child(&self) -> Item {
                    let result = self.0.last_child();
                    result
                }
                #[allow(dead_code)]
                pub fn set_last_child(&self, value: Item) -> () {
                    let result = self.0.set_last_child(value);
                    result
                }
                #[allow(dead_code)]
                pub fn stroke_width(&self) -> f64 {
                    let result = self.0.stroke_width();
                    result
                }
                #[allow(dead_code)]
                pub fn set_stroke_width(&self, value: f64) -> () {
                    let result = self.0.set_stroke_width(value);
                    result
                }
                #[allow(dead_code)]
                pub fn parent(&self) -> Item {
                    let result = self.0.parent();
                    result
                }
                #[allow(dead_code)]
                pub fn set_parent(&self, value: Item) -> () {
                    let result = self.0.set_parent(value);
                    result
                }
                #[allow(dead_code)]
                pub fn stroke_bounds(&self) -> Rectangle {
                    let result = self.0.stroke_bounds();
                    result
                }
                #[allow(dead_code)]
                pub fn set_stroke_bounds(&self, value: Rectangle) -> () {
                    let result = self.0.set_stroke_bounds(value);
                    result
                }
                #[allow(dead_code)]
                pub fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_translate(delta)?);
                    result
                }
                #[allow(dead_code)]
                pub fn remove(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_remove()?);
                    result
                }
                #[allow(dead_code)]
                pub fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_parent_to_local(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn bounds(&self) -> Rectangle {
                    let result = self.0.bounds();
                    result
                }
                #[allow(dead_code)]
                pub fn set_bounds(&self, value: Rectangle) -> () {
                    let result = self.0.set_bounds(value);
                    result
                }
                #[allow(dead_code)]
                pub fn add_children(
                    &self,
                    items: Vec<Item>,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_add_children(items)?);
                    result
                }
                #[allow(dead_code)]
                pub fn dash_array(&self) -> Vec<f64> {
                    let result = self.0.dash_array();
                    result
                }
                #[allow(dead_code)]
                pub fn set_dash_array(&self, value: Vec<f64>) -> () {
                    let result = self.0.set_dash_array(value);
                    result
                }
                #[allow(dead_code)]
                pub fn on_mouse_up(&self) -> ItemOnMouseUp {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_up()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_on_mouse_up(&self, value: ItemOnMouseUp) -> () {
                    let result = self.0.set_on_mouse_up(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn on(
                    &self,
                    object: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_on(object)?);
                    result
                }
                #[allow(dead_code)]
                pub fn remove_on(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_remove_on(options)?);
                    result
                }
                #[allow(dead_code)]
                pub fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_below(item)?);
                    result
                }
                #[allow(dead_code)]
                pub fn apply_matrix(&self) -> bool {
                    let result = self.0.apply_matrix();
                    result
                }
                #[allow(dead_code)]
                pub fn set_apply_matrix(&self, value: bool) -> () {
                    let result = self.0.set_apply_matrix(value);
                    result
                }
                #[allow(dead_code)]
                pub fn clone(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_clone(options)?);
                    result
                }
                #[allow(dead_code)]
                pub fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_contains(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn export_json(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<String, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_export_json(options)?);
                    result
                }
                #[allow(dead_code)]
                pub fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_bring_to_front()?);
                    result
                }
                #[allow(dead_code)]
                pub fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_above(item)?);
                    result
                }
                #[allow(dead_code)]
                pub fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_remove_on_drag()?);
                    result
                }
                #[allow(dead_code)]
                pub fn data(&self) -> JsValue {
                    let result = self.0.data();
                    result
                }
                #[allow(dead_code)]
                pub fn set_data(&self, value: JsValue) -> () {
                    let result = self.0.set_data(value);
                    result
                }
                #[allow(dead_code)]
                pub fn import_svg(
                    &self,
                    svg: ItemImportSvgParamsSvgParam,
                    on_load: JsValue,
                ) -> std::result::Result<Item, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_import_svg(
                        ts_bindgen_rt::to_jsvalue(&svg).map_err(ts_bindgen_rt::Error::from)?,
                        on_load,
                    )?);
                    result
                }
                #[allow(dead_code)]
                pub fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_has_shadow()?);
                    result
                }
                #[allow(dead_code)]
                pub fn selected_color(&self) -> ItemSelectedColor {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.selected_color()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_selected_color(&self, value: ItemSelectedColor) -> () {
                    let result = self.0.set_selected_color(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn class_name(&self) -> String {
                    let result = self.0.class_name();
                    result
                }
                #[allow(dead_code)]
                pub fn set_class_name(&self, value: String) -> () {
                    let result = self.0.set_class_name(value);
                    result
                }
                #[allow(dead_code)]
                pub fn export_svg(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                    let result = std::result::Result::Ok(
                        ts_bindgen_rt::from_jsvalue(&self.0.__TSB_export_svg(options)?).unwrap(),
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn tween_to(
                    &self,
                    to: std::collections::HashMap<String, JsValue>,
                    options: ItemTweenToParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_tween_to(
                        to,
                        ts_bindgen_rt::to_jsvalue(&options).map_err(ts_bindgen_rt::Error::from)?,
                    )?);
                    result
                }
                #[allow(dead_code)]
                pub fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_inside(rect)?);
                    result
                }
                #[allow(dead_code)]
                pub fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_empty(recursively)?);
                    result
                }
                #[allow(dead_code)]
                pub fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_copy_content(source)?);
                    result
                }
                #[allow(dead_code)]
                pub fn rasterize(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Raster, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_rasterize(options)?);
                    result
                }
                #[allow(dead_code)]
                pub fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_remove_on_move()?);
                    result
                }
                #[allow(dead_code)]
                pub fn tween_from(
                    &self,
                    from: std::collections::HashMap<String, JsValue>,
                    options: ItemTweenFromParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_tween_from(
                        from,
                        ts_bindgen_rt::to_jsvalue(&options).map_err(ts_bindgen_rt::Error::from)?,
                    )?);
                    result
                }
                #[allow(dead_code)]
                pub fn opacity(&self) -> f64 {
                    let result = self.0.opacity();
                    result
                }
                #[allow(dead_code)]
                pub fn set_opacity(&self, value: f64) -> () {
                    let result = self.0.set_opacity(value);
                    result
                }
                #[allow(dead_code)]
                pub fn dash_offset(&self) -> f64 {
                    let result = self.0.dash_offset();
                    result
                }
                #[allow(dead_code)]
                pub fn set_dash_offset(&self, value: f64) -> () {
                    let result = self.0.set_dash_offset(value);
                    result
                }
                #[allow(dead_code)]
                pub fn remove_children(
                    &self,
                    start: f64,
                    end: f64,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_remove_children(start, end)?);
                    result
                }
                #[allow(dead_code)]
                pub fn on_mouse_move(&self) -> ItemOnMouseMove {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_move()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_on_mouse_move(&self, value: ItemOnMouseMove) -> () {
                    let result = self.0.set_on_mouse_move(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_intersects(item)?);
                    result
                }
                #[allow(dead_code)]
                pub fn pivot(&self) -> Point {
                    let result = self.0.pivot();
                    result
                }
                #[allow(dead_code)]
                pub fn set_pivot(&self, value: Point) -> () {
                    let result = self.0.set_pivot(value);
                    result
                }
                #[allow(dead_code)]
                pub fn copy_to(
                    &self,
                    owner: ItemCopyToParamsOwnerParam,
                ) -> std::result::Result<JsValue, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_copy_to(
                        ts_bindgen_rt::to_jsvalue(&owner).map_err(ts_bindgen_rt::Error::from)?,
                    )?);
                    result
                }
                #[allow(dead_code)]
                pub fn index(&self) -> f64 {
                    let result = self.0.index();
                    result
                }
                #[allow(dead_code)]
                pub fn set_index(&self, value: f64) -> () {
                    let result = self.0.set_index(value);
                    result
                }
                #[allow(dead_code)]
                pub fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_local_to_parent(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn stroke_color(&self) -> ItemStrokeColor {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.stroke_color()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_stroke_color(&self, value: ItemStrokeColor) -> () {
                    let result = self.0.set_stroke_color(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn layer(&self) -> Layer {
                    let result = self.0.layer();
                    result
                }
                #[allow(dead_code)]
                pub fn set_layer(&self, value: Layer) -> () {
                    let result = self.0.set_layer(value);
                    result
                }
                #[allow(dead_code)]
                pub fn stroke_scaling(&self) -> bool {
                    let result = self.0.stroke_scaling();
                    result
                }
                #[allow(dead_code)]
                pub fn set_stroke_scaling(&self, value: bool) -> () {
                    let result = self.0.set_stroke_scaling(value);
                    result
                }
                #[allow(dead_code)]
                pub fn fit_bounds(
                    &self,
                    rectangle: Rectangle,
                    fill: bool,
                ) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_fit_bounds(rectangle, fill)?);
                    result
                }
                #[allow(dead_code)]
                pub fn miter_limit(&self) -> f64 {
                    let result = self.0.miter_limit();
                    result
                }
                #[allow(dead_code)]
                pub fn set_miter_limit(&self, value: f64) -> () {
                    let result = self.0.set_miter_limit(value);
                    result
                }
                #[allow(dead_code)]
                pub fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_remove_on_down()?);
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for Item {
                fn describe() {
                    <Item_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for Item {
                type Abi = <Item_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Item {
                type Abi = <&'a Item_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for Item {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Item {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: Item_Class =
                        <Item_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait Item_Trait {
                fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue>;
                fn on_double_click(&self) -> ItemOnDoubleClick;
                fn set_on_double_click(&mut self, value: ItemOnDoubleClick) -> ();
                fn view(&self) -> View;
                fn set_view(&mut self, value: View) -> ();
                fn blend_mode(&self) -> String;
                fn set_blend_mode(&mut self, value: String) -> ();
                fn name(&self) -> String;
                fn set_name(&mut self, value: String) -> ();
                fn project(&self) -> Project;
                fn set_project(&mut self, value: Project) -> ();
                fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue>;
                fn global_matrix(&self) -> Matrix;
                fn set_global_matrix(&mut self, value: Matrix) -> ();
                fn on_mouse_leave(&self) -> ItemOnMouseLeave;
                fn set_on_mouse_leave(&mut self, value: ItemOnMouseLeave) -> ();
                fn has_children(&self) -> std::result::Result<bool, JsValue>;
                fn selected(&self) -> bool;
                fn set_selected(&mut self, value: bool) -> ();
                fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue>;
                fn shadow_blur(&self) -> f64;
                fn set_shadow_blur(&mut self, value: f64) -> ();
                fn children(&self) -> Vec<Item>;
                fn set_children(&mut self, value: Vec<Item>) -> ();
                fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue>;
                fn import_json(&self, json: String) -> std::result::Result<Item, JsValue>;
                fn insert_child(
                    &self,
                    index: f64,
                    item: Item,
                ) -> std::result::Result<Item, JsValue>;
                fn stroke_join(&self) -> String;
                fn set_stroke_join(&mut self, value: String) -> ();
                fn rotation(&self) -> f64;
                fn set_rotation(&mut self, value: f64) -> ();
                fn scaling(&self) -> Point;
                fn set_scaling(&mut self, value: Point) -> ();
                fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue>;
                fn emit(
                    &self,
                    type_: String,
                    event: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue>;
                fn remove_on_up(&self) -> std::result::Result<(), JsValue>;
                fn add_to(
                    &self,
                    owner: ItemAddToParamsOwnerParam,
                ) -> std::result::Result<JsValue, JsValue>;
                fn stroke_cap(&self) -> String;
                fn set_stroke_cap(&mut self, value: String) -> ();
                fn on_mouse_drag(&self) -> ItemOnMouseDrag;
                fn set_on_mouse_drag(&mut self, value: ItemOnMouseDrag) -> ();
                fn set(
                    &self,
                    props: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue>;
                fn reverse_children(&self) -> std::result::Result<(), JsValue>;
                fn matches(
                    &self,
                    name: String,
                    compare: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue>;
                fn on_mouse_enter(&self) -> ItemOnMouseEnter;
                fn set_on_mouse_enter(&mut self, value: ItemOnMouseEnter) -> ();
                fn shadow_offset(&self) -> Point;
                fn set_shadow_offset(&mut self, value: Point) -> ();
                fn has_stroke(&self) -> std::result::Result<bool, JsValue>;
                fn view_matrix(&self) -> Matrix;
                fn set_view_matrix(&mut self, value: Matrix) -> ();
                fn on_frame(&self) -> ItemOnFrame;
                fn set_on_frame(&mut self, value: ItemOnFrame) -> ();
                fn on_mouse_down(&self) -> ItemOnMouseDown;
                fn set_on_mouse_down(&mut self, value: ItemOnMouseDown) -> ();
                fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue>;
                fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue>;
                fn first_child(&self) -> Item;
                fn set_first_child(&mut self, value: Item) -> ();
                fn send_to_back(&self) -> std::result::Result<(), JsValue>;
                fn clip_mask(&self) -> bool;
                fn set_clip_mask(&mut self, value: bool) -> ();
                fn next_sibling(&self) -> Item;
                fn set_next_sibling(&mut self, value: Item) -> ();
                fn off(
                    &self,
                    object: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue>;
                fn rotate(&self, angle: f64, center: Point) -> std::result::Result<(), JsValue>;
                fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue>;
                fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue>;
                fn scale(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue>;
                fn hit_test_all(
                    &self,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Vec<HitResult>, JsValue>;
                fn insert_children(
                    &self,
                    index: f64,
                    items: Vec<Item>,
                ) -> std::result::Result<Vec<Item>, JsValue>;
                fn style(&self) -> Style;
                fn set_style(&mut self, value: Style) -> ();
                fn position(&self) -> Point;
                fn set_position(&mut self, value: Point) -> ();
                fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue>;
                fn fill_color(&self) -> ItemFillColor;
                fn set_fill_color(&mut self, value: ItemFillColor) -> ();
                fn matrix(&self) -> Matrix;
                fn set_matrix(&mut self, value: Matrix) -> ();
                fn id(&self) -> f64;
                fn set_id(&mut self, value: f64) -> ();
                fn tween(
                    &self,
                    options: ItemTweenParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue>;
                fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue>;
                fn internal_bounds(&self) -> Rectangle;
                fn set_internal_bounds(&mut self, value: Rectangle) -> ();
                fn fill_rule(&self) -> String;
                fn set_fill_rule(&mut self, value: String) -> ();
                fn shadow_color(&self) -> ItemShadowColor;
                fn set_shadow_color(&mut self, value: ItemShadowColor) -> ();
                fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue>;
                fn responds(&self, type_: String) -> std::result::Result<bool, JsValue>;
                fn handle_bounds(&self) -> Rectangle;
                fn set_handle_bounds(&mut self, value: Rectangle) -> ();
                fn skew(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue>;
                fn on_click(&self) -> ItemOnClick;
                fn set_on_click(&mut self, value: ItemOnClick) -> ();
                fn get_items(
                    &self,
                    options: ItemGetItemsParamsOptionsParam,
                ) -> std::result::Result<Vec<Item>, JsValue>;
                fn is_inserted(&self) -> std::result::Result<bool, JsValue>;
                fn get_item(
                    &self,
                    options: ItemGetItemParamsOptionsParam,
                ) -> std::result::Result<Item, JsValue>;
                fn has_fill(&self) -> std::result::Result<bool, JsValue>;
                fn shear(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue>;
                fn visible(&self) -> bool;
                fn set_visible(&mut self, value: bool) -> ();
                fn previous_sibling(&self) -> Item;
                fn set_previous_sibling(&mut self, value: Item) -> ();
                fn hit_test(
                    &self,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<HitResult, JsValue>;
                fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue>;
                fn locked(&self) -> bool;
                fn set_locked(&mut self, value: bool) -> ();
                fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue>;
                fn copy_attributes(
                    &self,
                    source: Item,
                    exclude_matrix: bool,
                ) -> std::result::Result<(), JsValue>;
                fn last_child(&self) -> Item;
                fn set_last_child(&mut self, value: Item) -> ();
                fn stroke_width(&self) -> f64;
                fn set_stroke_width(&mut self, value: f64) -> ();
                fn parent(&self) -> Item;
                fn set_parent(&mut self, value: Item) -> ();
                fn stroke_bounds(&self) -> Rectangle;
                fn set_stroke_bounds(&mut self, value: Rectangle) -> ();
                fn translate(&self, delta: Point) -> std::result::Result<(), JsValue>;
                fn remove(&self) -> std::result::Result<bool, JsValue>;
                fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue>;
                fn bounds(&self) -> Rectangle;
                fn set_bounds(&mut self, value: Rectangle) -> ();
                fn add_children(&self, items: Vec<Item>)
                    -> std::result::Result<Vec<Item>, JsValue>;
                fn dash_array(&self) -> Vec<f64>;
                fn set_dash_array(&mut self, value: Vec<f64>) -> ();
                fn on_mouse_up(&self) -> ItemOnMouseUp;
                fn set_on_mouse_up(&mut self, value: ItemOnMouseUp) -> ();
                fn on(
                    &self,
                    object: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue>;
                fn remove_on(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<(), JsValue>;
                fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue>;
                fn apply_matrix(&self) -> bool;
                fn set_apply_matrix(&mut self, value: bool) -> ();
                fn clone(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue>;
                fn contains(&self, point: Point) -> std::result::Result<bool, JsValue>;
                fn export_json(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<String, JsValue>;
                fn bring_to_front(&self) -> std::result::Result<(), JsValue>;
                fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue>;
                fn remove_on_drag(&self) -> std::result::Result<(), JsValue>;
                fn data(&self) -> JsValue;
                fn set_data(&mut self, value: JsValue) -> ();
                fn import_svg(
                    &self,
                    svg: ItemImportSvgParamsSvgParam,
                    on_load: JsValue,
                ) -> std::result::Result<Item, JsValue>;
                fn has_shadow(&self) -> std::result::Result<bool, JsValue>;
                fn selected_color(&self) -> ItemSelectedColor;
                fn set_selected_color(&mut self, value: ItemSelectedColor) -> ();
                fn class_name(&self) -> String;
                fn set_class_name(&mut self, value: String) -> ();
                fn export_svg(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<ItemExportSvgReturn, JsValue>;
                fn tween_to(
                    &self,
                    to: std::collections::HashMap<String, JsValue>,
                    options: ItemTweenToParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue>;
                fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue>;
                fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue>;
                fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue>;
                fn rasterize(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Raster, JsValue>;
                fn remove_on_move(&self) -> std::result::Result<(), JsValue>;
                fn tween_from(
                    &self,
                    from: std::collections::HashMap<String, JsValue>,
                    options: ItemTweenFromParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue>;
                fn opacity(&self) -> f64;
                fn set_opacity(&mut self, value: f64) -> ();
                fn dash_offset(&self) -> f64;
                fn set_dash_offset(&mut self, value: f64) -> ();
                fn remove_children(
                    &self,
                    start: f64,
                    end: f64,
                ) -> std::result::Result<Vec<Item>, JsValue>;
                fn on_mouse_move(&self) -> ItemOnMouseMove;
                fn set_on_mouse_move(&mut self, value: ItemOnMouseMove) -> ();
                fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue>;
                fn pivot(&self) -> Point;
                fn set_pivot(&mut self, value: Point) -> ();
                fn copy_to(
                    &self,
                    owner: ItemCopyToParamsOwnerParam,
                ) -> std::result::Result<JsValue, JsValue>;
                fn index(&self) -> f64;
                fn set_index(&mut self, value: f64) -> ();
                fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue>;
                fn stroke_color(&self) -> ItemStrokeColor;
                fn set_stroke_color(&mut self, value: ItemStrokeColor) -> ();
                fn layer(&self) -> Layer;
                fn set_layer(&mut self, value: Layer) -> ();
                fn stroke_scaling(&self) -> bool;
                fn set_stroke_scaling(&mut self, value: bool) -> ();
                fn fit_bounds(
                    &self,
                    rectangle: Rectangle,
                    fill: bool,
                ) -> std::result::Result<(), JsValue>;
                fn miter_limit(&self) -> f64;
                fn set_miter_limit(&mut self, value: f64) -> ();
                fn remove_on_down(&self) -> std::result::Result<(), JsValue>;
            }
            impl std::clone::Clone for Item_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for Item_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Item_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum SymbolItemConstructorDefinitionParam {
                ItemCase(Item),
                SymbolDefinitionCase(SymbolDefinition),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum PathInsertParamsSegmentParam {
                PointCase(Point),
                SegmentCase(Segment),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ShapeRadius {
                SizeCase(Size),
                F64Case(f64),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum CurveGetTangentAtParamsLocationParam {
                CurveLocationCase(CurveLocation),
                F64Case(f64),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum RasterOnError {
                TsBindgenRtNullCase,
                JsValueCase(JsValue),
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                # [wasm_bindgen (js_name = "Group" , extends = Item_Class)]
                type Group_Class;
                # [wasm_bindgen (method , structural , getter = clipped , js_class = "Group")]
                fn clipped(this: &Group_Class) -> bool;
                # [wasm_bindgen (method , structural , setter = clipped , js_class = "Group")]
                fn set_clipped(this: &Group_Class, value: bool);
                #[wasm_bindgen(constructor, js_class = "Group")]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Group_Class;
            }
            #[derive(std :: clone :: Clone)]
            struct Group(pub Group_Class);
            impl std::convert::From<&Group> for Item {
                fn from(src: &Group) -> Item {
                    let src: &Item_Class = src.0.as_ref();
                    Item(src.clone())
                }
            }
            impl std::convert::From<&mut Group> for Item {
                fn from(src: &mut Group) -> Item {
                    let src: &Item_Class = src.0.as_ref();
                    Item(src.clone())
                }
            }
            impl Group {
                #[allow(dead_code)]
                pub fn clipped(&self) -> bool {
                    let result = self.0.clipped();
                    result
                }
                #[allow(dead_code)]
                pub fn set_clipped(&self, value: bool) -> () {
                    let result = self.0.set_clipped(value);
                    result
                }
                #[allow(dead_code)]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Group {
                    let result = Group_Class::new(object);
                    let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                    Group(result)
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for Group {
                fn describe() {
                    <Group_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for Group {
                type Abi = <Group_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Group {
                type Abi = <&'a Group_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for Group {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Group {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: Group_Class =
                        <Group_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait Group_Trait: Item_Trait {
                fn clipped(&self) -> bool;
                fn set_clipped(&mut self, value: bool) -> ();
                fn new(object: std::collections::HashMap<String, JsValue>) -> Group;
            }
            impl Item_Trait for Group {
                fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::insert_below(&target, item)
                }
                fn on_double_click(&self) -> ItemOnDoubleClick {
                    let target: Item = self.into();
                    Item::on_double_click(&target)
                }
                fn set_on_double_click(&mut self, value: ItemOnDoubleClick) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_double_click(&mut target, value)
                }
                fn view(&self) -> View {
                    let target: Item = self.into();
                    Item::view(&target)
                }
                fn set_view(&mut self, value: View) -> () {
                    let mut target: Item = self.into();
                    Item::set_view(&mut target, value)
                }
                fn blend_mode(&self) -> String {
                    let target: Item = self.into();
                    Item::blend_mode(&target)
                }
                fn set_blend_mode(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_blend_mode(&mut target, value)
                }
                fn name(&self) -> String {
                    let target: Item = self.into();
                    Item::name(&target)
                }
                fn set_name(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_name(&mut target, value)
                }
                fn project(&self) -> Project {
                    let target: Item = self.into();
                    Item::project(&target)
                }
                fn set_project(&mut self, value: Project) -> () {
                    let mut target: Item = self.into();
                    Item::set_project(&mut target, value)
                }
                fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_child(&target, item)
                }
                fn global_matrix(&self) -> Matrix {
                    let target: Item = self.into();
                    Item::global_matrix(&target)
                }
                fn set_global_matrix(&mut self, value: Matrix) -> () {
                    let mut target: Item = self.into();
                    Item::set_global_matrix(&mut target, value)
                }
                fn on_mouse_leave(&self) -> ItemOnMouseLeave {
                    let target: Item = self.into();
                    Item::on_mouse_leave(&target)
                }
                fn set_on_mouse_leave(&mut self, value: ItemOnMouseLeave) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_leave(&mut target, value)
                }
                fn has_children(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_children(&target)
                }
                fn selected(&self) -> bool {
                    let target: Item = self.into();
                    Item::selected(&target)
                }
                fn set_selected(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_selected(&mut target, value)
                }
                fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::global_to_local(&target, point)
                }
                fn shadow_blur(&self) -> f64 {
                    let target: Item = self.into();
                    Item::shadow_blur(&target)
                }
                fn set_shadow_blur(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_shadow_blur(&mut target, value)
                }
                fn children(&self) -> Vec<Item> {
                    let target: Item = self.into();
                    Item::children(&target)
                }
                fn set_children(&mut self, value: Vec<Item>) -> () {
                    let mut target: Item = self.into();
                    Item::set_children(&mut target, value)
                }
                fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::replace_with(&target, item)
                }
                fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::import_json(&target, json)
                }
                fn insert_child(
                    &self,
                    index: f64,
                    item: Item,
                ) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::insert_child(&target, index, item)
                }
                fn stroke_join(&self) -> String {
                    let target: Item = self.into();
                    Item::stroke_join(&target)
                }
                fn set_stroke_join(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_join(&mut target, value)
                }
                fn rotation(&self) -> f64 {
                    let target: Item = self.into();
                    Item::rotation(&target)
                }
                fn set_rotation(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_rotation(&mut target, value)
                }
                fn scaling(&self) -> Point {
                    let target: Item = self.into();
                    Item::scaling(&target)
                }
                fn set_scaling(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_scaling(&mut target, value)
                }
                fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_ancestor(&target, item)
                }
                fn emit(
                    &self,
                    type_: String,
                    event: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::emit(&target, type_, event)
                }
                fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_up(&target)
                }
                fn add_to(
                    &self,
                    owner: ItemAddToParamsOwnerParam,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::add_to(&target, owner)
                }
                fn stroke_cap(&self) -> String {
                    let target: Item = self.into();
                    Item::stroke_cap(&target)
                }
                fn set_stroke_cap(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_cap(&mut target, value)
                }
                fn on_mouse_drag(&self) -> ItemOnMouseDrag {
                    let target: Item = self.into();
                    Item::on_mouse_drag(&target)
                }
                fn set_on_mouse_drag(&mut self, value: ItemOnMouseDrag) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_drag(&mut target, value)
                }
                fn set(
                    &self,
                    props: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::set(&target, props)
                }
                fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::reverse_children(&target)
                }
                fn matches(
                    &self,
                    name: String,
                    compare: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::matches(&target, name, compare)
                }
                fn on_mouse_enter(&self) -> ItemOnMouseEnter {
                    let target: Item = self.into();
                    Item::on_mouse_enter(&target)
                }
                fn set_on_mouse_enter(&mut self, value: ItemOnMouseEnter) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_enter(&mut target, value)
                }
                fn shadow_offset(&self) -> Point {
                    let target: Item = self.into();
                    Item::shadow_offset(&target)
                }
                fn set_shadow_offset(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_shadow_offset(&mut target, value)
                }
                fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_stroke(&target)
                }
                fn view_matrix(&self) -> Matrix {
                    let target: Item = self.into();
                    Item::view_matrix(&target)
                }
                fn set_view_matrix(&mut self, value: Matrix) -> () {
                    let mut target: Item = self.into();
                    Item::set_view_matrix(&mut target, value)
                }
                fn on_frame(&self) -> ItemOnFrame {
                    let target: Item = self.into();
                    Item::on_frame(&target)
                }
                fn set_on_frame(&mut self, value: ItemOnFrame) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_frame(&mut target, value)
                }
                fn on_mouse_down(&self) -> ItemOnMouseDown {
                    let target: Item = self.into();
                    Item::on_mouse_down(&target)
                }
                fn set_on_mouse_down(&mut self, value: ItemOnMouseDown) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_down(&mut target, value)
                }
                fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_sibling(&target, item)
                }
                fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::local_to_global(&target, point)
                }
                fn first_child(&self) -> Item {
                    let target: Item = self.into();
                    Item::first_child(&target)
                }
                fn set_first_child(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_first_child(&mut target, value)
                }
                fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::send_to_back(&target)
                }
                fn clip_mask(&self) -> bool {
                    let target: Item = self.into();
                    Item::clip_mask(&target)
                }
                fn set_clip_mask(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_clip_mask(&mut target, value)
                }
                fn next_sibling(&self) -> Item {
                    let target: Item = self.into();
                    Item::next_sibling(&target)
                }
                fn set_next_sibling(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_next_sibling(&mut target, value)
                }
                fn off(
                    &self,
                    object: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::off(&target, object)
                }
                fn rotate(&self, angle: f64, center: Point) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::rotate(&target, angle, center)
                }
                fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::add_child(&target, item)
                }
                fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_grouped_with(&target, item)
                }
                fn scale(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::scale(&target, hor, ver, center)
                }
                fn hit_test_all(
                    &self,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Vec<HitResult>, JsValue> {
                    let target: Item = self.into();
                    Item::hit_test_all(&target, point, options)
                }
                fn insert_children(
                    &self,
                    index: f64,
                    items: Vec<Item>,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::insert_children(&target, index, items)
                }
                fn style(&self) -> Style {
                    let target: Item = self.into();
                    Item::style(&target)
                }
                fn set_style(&mut self, value: Style) -> () {
                    let mut target: Item = self.into();
                    Item::set_style(&mut target, value)
                }
                fn position(&self) -> Point {
                    let target: Item = self.into();
                    Item::position(&target)
                }
                fn set_position(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_position(&mut target, value)
                }
                fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::transform(&target, matrix)
                }
                fn fill_color(&self) -> ItemFillColor {
                    let target: Item = self.into();
                    Item::fill_color(&target)
                }
                fn set_fill_color(&mut self, value: ItemFillColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_fill_color(&mut target, value)
                }
                fn matrix(&self) -> Matrix {
                    let target: Item = self.into();
                    Item::matrix(&target)
                }
                fn set_matrix(&mut self, value: Matrix) -> () {
                    let mut target: Item = self.into();
                    Item::set_matrix(&mut target, value)
                }
                fn id(&self) -> f64 {
                    let target: Item = self.into();
                    Item::id(&target)
                }
                fn set_id(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_id(&mut target, value)
                }
                fn tween(
                    &self,
                    options: ItemTweenParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let target: Item = self.into();
                    Item::tween(&target, options)
                }
                fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::reduce(&target, options)
                }
                fn internal_bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::internal_bounds(&target)
                }
                fn set_internal_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_internal_bounds(&mut target, value)
                }
                fn fill_rule(&self) -> String {
                    let target: Item = self.into();
                    Item::fill_rule(&target)
                }
                fn set_fill_rule(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_fill_rule(&mut target, value)
                }
                fn shadow_color(&self) -> ItemShadowColor {
                    let target: Item = self.into();
                    Item::shadow_color(&target)
                }
                fn set_shadow_color(&mut self, value: ItemShadowColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_shadow_color(&mut target, value)
                }
                fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::insert_above(&target, item)
                }
                fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::responds(&target, type_)
                }
                fn handle_bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::handle_bounds(&target)
                }
                fn set_handle_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_handle_bounds(&mut target, value)
                }
                fn skew(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::skew(&target, hor, ver, center)
                }
                fn on_click(&self) -> ItemOnClick {
                    let target: Item = self.into();
                    Item::on_click(&target)
                }
                fn set_on_click(&mut self, value: ItemOnClick) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_click(&mut target, value)
                }
                fn get_items(
                    &self,
                    options: ItemGetItemsParamsOptionsParam,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::get_items(&target, options)
                }
                fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_inserted(&target)
                }
                fn get_item(
                    &self,
                    options: ItemGetItemParamsOptionsParam,
                ) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::get_item(&target, options)
                }
                fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_fill(&target)
                }
                fn shear(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::shear(&target, hor, ver, center)
                }
                fn visible(&self) -> bool {
                    let target: Item = self.into();
                    Item::visible(&target)
                }
                fn set_visible(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_visible(&mut target, value)
                }
                fn previous_sibling(&self) -> Item {
                    let target: Item = self.into();
                    Item::previous_sibling(&target)
                }
                fn set_previous_sibling(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_previous_sibling(&mut target, value)
                }
                fn hit_test(
                    &self,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<HitResult, JsValue> {
                    let target: Item = self.into();
                    Item::hit_test(&target, point, options)
                }
                fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_descendant(&target, item)
                }
                fn locked(&self) -> bool {
                    let target: Item = self.into();
                    Item::locked(&target)
                }
                fn set_locked(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_locked(&mut target, value)
                }
                fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_parent(&target, item)
                }
                fn copy_attributes(
                    &self,
                    source: Item,
                    exclude_matrix: bool,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::copy_attributes(&target, source, exclude_matrix)
                }
                fn last_child(&self) -> Item {
                    let target: Item = self.into();
                    Item::last_child(&target)
                }
                fn set_last_child(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_last_child(&mut target, value)
                }
                fn stroke_width(&self) -> f64 {
                    let target: Item = self.into();
                    Item::stroke_width(&target)
                }
                fn set_stroke_width(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_width(&mut target, value)
                }
                fn parent(&self) -> Item {
                    let target: Item = self.into();
                    Item::parent(&target)
                }
                fn set_parent(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_parent(&mut target, value)
                }
                fn stroke_bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::stroke_bounds(&target)
                }
                fn set_stroke_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_bounds(&mut target, value)
                }
                fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::translate(&target, delta)
                }
                fn remove(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::remove(&target)
                }
                fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::parent_to_local(&target, point)
                }
                fn bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::bounds(&target)
                }
                fn set_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_bounds(&mut target, value)
                }
                fn add_children(
                    &self,
                    items: Vec<Item>,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::add_children(&target, items)
                }
                fn dash_array(&self) -> Vec<f64> {
                    let target: Item = self.into();
                    Item::dash_array(&target)
                }
                fn set_dash_array(&mut self, value: Vec<f64>) -> () {
                    let mut target: Item = self.into();
                    Item::set_dash_array(&mut target, value)
                }
                fn on_mouse_up(&self) -> ItemOnMouseUp {
                    let target: Item = self.into();
                    Item::on_mouse_up(&target)
                }
                fn set_on_mouse_up(&mut self, value: ItemOnMouseUp) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_up(&mut target, value)
                }
                fn on(
                    &self,
                    object: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::on(&target, object)
                }
                fn remove_on(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on(&target, options)
                }
                fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_below(&target, item)
                }
                fn apply_matrix(&self) -> bool {
                    let target: Item = self.into();
                    Item::apply_matrix(&target)
                }
                fn set_apply_matrix(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_apply_matrix(&mut target, value)
                }
                fn clone(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::clone(&target, options)
                }
                fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::contains(&target, point)
                }
                fn export_json(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<String, JsValue> {
                    let target: Item = self.into();
                    Item::export_json(&target, options)
                }
                fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::bring_to_front(&target)
                }
                fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_above(&target, item)
                }
                fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_drag(&target)
                }
                fn data(&self) -> JsValue {
                    let target: Item = self.into();
                    Item::data(&target)
                }
                fn set_data(&mut self, value: JsValue) -> () {
                    let mut target: Item = self.into();
                    Item::set_data(&mut target, value)
                }
                fn import_svg(
                    &self,
                    svg: ItemImportSvgParamsSvgParam,
                    on_load: JsValue,
                ) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::import_svg(&target, svg, on_load)
                }
                fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_shadow(&target)
                }
                fn selected_color(&self) -> ItemSelectedColor {
                    let target: Item = self.into();
                    Item::selected_color(&target)
                }
                fn set_selected_color(&mut self, value: ItemSelectedColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_selected_color(&mut target, value)
                }
                fn class_name(&self) -> String {
                    let target: Item = self.into();
                    Item::class_name(&target)
                }
                fn set_class_name(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_class_name(&mut target, value)
                }
                fn export_svg(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                    let target: Item = self.into();
                    Item::export_svg(&target, options)
                }
                fn tween_to(
                    &self,
                    to: std::collections::HashMap<String, JsValue>,
                    options: ItemTweenToParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let target: Item = self.into();
                    Item::tween_to(&target, to, options)
                }
                fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_inside(&target, rect)
                }
                fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_empty(&target, recursively)
                }
                fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::copy_content(&target, source)
                }
                fn rasterize(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Raster, JsValue> {
                    let target: Item = self.into();
                    Item::rasterize(&target, options)
                }
                fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_move(&target)
                }
                fn tween_from(
                    &self,
                    from: std::collections::HashMap<String, JsValue>,
                    options: ItemTweenFromParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let target: Item = self.into();
                    Item::tween_from(&target, from, options)
                }
                fn opacity(&self) -> f64 {
                    let target: Item = self.into();
                    Item::opacity(&target)
                }
                fn set_opacity(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_opacity(&mut target, value)
                }
                fn dash_offset(&self) -> f64 {
                    let target: Item = self.into();
                    Item::dash_offset(&target)
                }
                fn set_dash_offset(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_dash_offset(&mut target, value)
                }
                fn remove_children(
                    &self,
                    start: f64,
                    end: f64,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::remove_children(&target, start, end)
                }
                fn on_mouse_move(&self) -> ItemOnMouseMove {
                    let target: Item = self.into();
                    Item::on_mouse_move(&target)
                }
                fn set_on_mouse_move(&mut self, value: ItemOnMouseMove) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_move(&mut target, value)
                }
                fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::intersects(&target, item)
                }
                fn pivot(&self) -> Point {
                    let target: Item = self.into();
                    Item::pivot(&target)
                }
                fn set_pivot(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_pivot(&mut target, value)
                }
                fn copy_to(
                    &self,
                    owner: ItemCopyToParamsOwnerParam,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::copy_to(&target, owner)
                }
                fn index(&self) -> f64 {
                    let target: Item = self.into();
                    Item::index(&target)
                }
                fn set_index(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_index(&mut target, value)
                }
                fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::local_to_parent(&target, point)
                }
                fn stroke_color(&self) -> ItemStrokeColor {
                    let target: Item = self.into();
                    Item::stroke_color(&target)
                }
                fn set_stroke_color(&mut self, value: ItemStrokeColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_color(&mut target, value)
                }
                fn layer(&self) -> Layer {
                    let target: Item = self.into();
                    Item::layer(&target)
                }
                fn set_layer(&mut self, value: Layer) -> () {
                    let mut target: Item = self.into();
                    Item::set_layer(&mut target, value)
                }
                fn stroke_scaling(&self) -> bool {
                    let target: Item = self.into();
                    Item::stroke_scaling(&target)
                }
                fn set_stroke_scaling(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_scaling(&mut target, value)
                }
                fn fit_bounds(
                    &self,
                    rectangle: Rectangle,
                    fill: bool,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::fit_bounds(&target, rectangle, fill)
                }
                fn miter_limit(&self) -> f64 {
                    let target: Item = self.into();
                    Item::miter_limit(&target)
                }
                fn set_miter_limit(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_miter_limit(&mut target, value)
                }
                fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_down(&target)
                }
            }
            impl Group_Trait for Group {}
            impl std::clone::Clone for Group_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for Group_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Group_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum RasterOnLoad {
                TsBindgenRtNullCase,
                JsValueCase(JsValue),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ItemFillColor {
                ColorCase(Color),
                TsBindgenRtNullCase,
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ItemExportSvgReturn {
                StringCase(String),
                JsValueCase(JsValue),
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                #[wasm_bindgen(js_name = "PaperScript")]
                type PaperScript_Class;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = execute , method , js_class = "PaperScript" , catch)]
                fn __TSB_execute(
                    this: &PaperScript_Class,
                    code: String,
                    scope: PaperScope,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<std::collections::HashMap<String, JsValue>, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = compile , method , js_class = "PaperScript" , catch)]
                fn __TSB_compile(
                    this: &PaperScript_Class,
                    code: String,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<std::collections::HashMap<String, JsValue>, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = load , method , js_class = "PaperScript" , catch)]
                fn __TSB_load(
                    this: &PaperScript_Class,
                    script: JsValue,
                ) -> std::result::Result<PaperScope, JsValue>;
            }
            #[derive(std :: clone :: Clone)]
            struct PaperScript(pub PaperScript_Class);
            impl PaperScript {
                #[allow(dead_code)]
                pub fn execute(
                    &self,
                    code: String,
                    scope: PaperScope,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<std::collections::HashMap<String, JsValue>, JsValue>
                {
                    let result =
                        std::result::Result::Ok(self.0.__TSB_execute(code, scope, options)?);
                    result
                }
                #[allow(dead_code)]
                pub fn compile(
                    &self,
                    code: String,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<std::collections::HashMap<String, JsValue>, JsValue>
                {
                    let result = std::result::Result::Ok(self.0.__TSB_compile(code, options)?);
                    result
                }
                #[allow(dead_code)]
                pub fn load(&self, script: JsValue) -> std::result::Result<PaperScope, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_load(script)?);
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for PaperScript {
                fn describe() {
                    <PaperScript_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for PaperScript {
                type Abi = <PaperScript_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a PaperScript {
                type Abi = <&'a PaperScript_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for PaperScript {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for PaperScript {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: PaperScript_Class =
                        <PaperScript_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait PaperScript_Trait {
                fn execute(
                    &self,
                    code: String,
                    scope: PaperScope,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<std::collections::HashMap<String, JsValue>, JsValue>;
                fn compile(
                    &self,
                    code: String,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<std::collections::HashMap<String, JsValue>, JsValue>;
                fn load(&self, script: JsValue) -> std::result::Result<PaperScope, JsValue>;
            }
            impl std::clone::Clone for PaperScript_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for PaperScript_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for PaperScript_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                # [wasm_bindgen (js_name = "TextItem" , extends = Item_Class)]
                type TextItem_Class;
                # [wasm_bindgen (method , structural , getter = content , js_class = "TextItem")]
                fn content(this: &TextItem_Class) -> String;
                # [wasm_bindgen (method , structural , setter = content , js_class = "TextItem")]
                fn set_content(this: &TextItem_Class, value: String);
                # [wasm_bindgen (method , structural , getter = justification , js_class = "TextItem")]
                fn justification(this: &TextItem_Class) -> String;
                # [wasm_bindgen (method , structural , setter = justification , js_class = "TextItem")]
                fn set_justification(this: &TextItem_Class, value: String);
                # [wasm_bindgen (method , structural , getter = fontSize , js_class = "TextItem")]
                fn font_size(this: &TextItem_Class) -> TextItemFontSize;
                # [wasm_bindgen (method , structural , setter = fontSize , js_class = "TextItem")]
                fn set_font_size(this: &TextItem_Class, value: TextItemFontSize);
                # [wasm_bindgen (method , structural , getter = fontWeight , js_class = "TextItem")]
                fn font_weight(this: &TextItem_Class) -> TextItemFontWeight;
                # [wasm_bindgen (method , structural , setter = fontWeight , js_class = "TextItem")]
                fn set_font_weight(this: &TextItem_Class, value: TextItemFontWeight);
                # [wasm_bindgen (method , structural , getter = fontFamily , js_class = "TextItem")]
                fn font_family(this: &TextItem_Class) -> String;
                # [wasm_bindgen (method , structural , setter = fontFamily , js_class = "TextItem")]
                fn set_font_family(this: &TextItem_Class, value: String);
                # [wasm_bindgen (method , structural , getter = leading , js_class = "TextItem")]
                fn leading(this: &TextItem_Class) -> TextItemLeading;
                # [wasm_bindgen (method , structural , setter = leading , js_class = "TextItem")]
                fn set_leading(this: &TextItem_Class, value: TextItemLeading);
            }
            #[derive(std :: clone :: Clone)]
            struct TextItem(pub TextItem_Class);
            impl std::convert::From<&TextItem> for Item {
                fn from(src: &TextItem) -> Item {
                    let src: &Item_Class = src.0.as_ref();
                    Item(src.clone())
                }
            }
            impl std::convert::From<&mut TextItem> for Item {
                fn from(src: &mut TextItem) -> Item {
                    let src: &Item_Class = src.0.as_ref();
                    Item(src.clone())
                }
            }
            impl TextItem {
                #[allow(dead_code)]
                pub fn content(&self) -> String {
                    let result = self.0.content();
                    result
                }
                #[allow(dead_code)]
                pub fn set_content(&self, value: String) -> () {
                    let result = self.0.set_content(value);
                    result
                }
                #[allow(dead_code)]
                pub fn justification(&self) -> String {
                    let result = self.0.justification();
                    result
                }
                #[allow(dead_code)]
                pub fn set_justification(&self, value: String) -> () {
                    let result = self.0.set_justification(value);
                    result
                }
                #[allow(dead_code)]
                pub fn font_size(&self) -> TextItemFontSize {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.font_size()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_font_size(&self, value: TextItemFontSize) -> () {
                    let result = self.0.set_font_size(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn font_weight(&self) -> TextItemFontWeight {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.font_weight()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_font_weight(&self, value: TextItemFontWeight) -> () {
                    let result = self.0.set_font_weight(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn font_family(&self) -> String {
                    let result = self.0.font_family();
                    result
                }
                #[allow(dead_code)]
                pub fn set_font_family(&self, value: String) -> () {
                    let result = self.0.set_font_family(value);
                    result
                }
                #[allow(dead_code)]
                pub fn leading(&self) -> TextItemLeading {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.leading()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_leading(&self, value: TextItemLeading) -> () {
                    let result = self.0.set_leading(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for TextItem {
                fn describe() {
                    <TextItem_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for TextItem {
                type Abi = <TextItem_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a TextItem {
                type Abi = <&'a TextItem_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for TextItem {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for TextItem {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: TextItem_Class =
                        <TextItem_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait TextItem_Trait: Item_Trait {
                fn content(&self) -> String;
                fn set_content(&mut self, value: String) -> ();
                fn justification(&self) -> String;
                fn set_justification(&mut self, value: String) -> ();
                fn font_size(&self) -> TextItemFontSize;
                fn set_font_size(&mut self, value: TextItemFontSize) -> ();
                fn font_weight(&self) -> TextItemFontWeight;
                fn set_font_weight(&mut self, value: TextItemFontWeight) -> ();
                fn font_family(&self) -> String;
                fn set_font_family(&mut self, value: String) -> ();
                fn leading(&self) -> TextItemLeading;
                fn set_leading(&mut self, value: TextItemLeading) -> ();
            }
            impl Item_Trait for TextItem {
                fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::insert_below(&target, item)
                }
                fn on_double_click(&self) -> ItemOnDoubleClick {
                    let target: Item = self.into();
                    Item::on_double_click(&target)
                }
                fn set_on_double_click(&mut self, value: ItemOnDoubleClick) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_double_click(&mut target, value)
                }
                fn view(&self) -> View {
                    let target: Item = self.into();
                    Item::view(&target)
                }
                fn set_view(&mut self, value: View) -> () {
                    let mut target: Item = self.into();
                    Item::set_view(&mut target, value)
                }
                fn blend_mode(&self) -> String {
                    let target: Item = self.into();
                    Item::blend_mode(&target)
                }
                fn set_blend_mode(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_blend_mode(&mut target, value)
                }
                fn name(&self) -> String {
                    let target: Item = self.into();
                    Item::name(&target)
                }
                fn set_name(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_name(&mut target, value)
                }
                fn project(&self) -> Project {
                    let target: Item = self.into();
                    Item::project(&target)
                }
                fn set_project(&mut self, value: Project) -> () {
                    let mut target: Item = self.into();
                    Item::set_project(&mut target, value)
                }
                fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_child(&target, item)
                }
                fn global_matrix(&self) -> Matrix {
                    let target: Item = self.into();
                    Item::global_matrix(&target)
                }
                fn set_global_matrix(&mut self, value: Matrix) -> () {
                    let mut target: Item = self.into();
                    Item::set_global_matrix(&mut target, value)
                }
                fn on_mouse_leave(&self) -> ItemOnMouseLeave {
                    let target: Item = self.into();
                    Item::on_mouse_leave(&target)
                }
                fn set_on_mouse_leave(&mut self, value: ItemOnMouseLeave) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_leave(&mut target, value)
                }
                fn has_children(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_children(&target)
                }
                fn selected(&self) -> bool {
                    let target: Item = self.into();
                    Item::selected(&target)
                }
                fn set_selected(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_selected(&mut target, value)
                }
                fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::global_to_local(&target, point)
                }
                fn shadow_blur(&self) -> f64 {
                    let target: Item = self.into();
                    Item::shadow_blur(&target)
                }
                fn set_shadow_blur(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_shadow_blur(&mut target, value)
                }
                fn children(&self) -> Vec<Item> {
                    let target: Item = self.into();
                    Item::children(&target)
                }
                fn set_children(&mut self, value: Vec<Item>) -> () {
                    let mut target: Item = self.into();
                    Item::set_children(&mut target, value)
                }
                fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::replace_with(&target, item)
                }
                fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::import_json(&target, json)
                }
                fn insert_child(
                    &self,
                    index: f64,
                    item: Item,
                ) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::insert_child(&target, index, item)
                }
                fn stroke_join(&self) -> String {
                    let target: Item = self.into();
                    Item::stroke_join(&target)
                }
                fn set_stroke_join(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_join(&mut target, value)
                }
                fn rotation(&self) -> f64 {
                    let target: Item = self.into();
                    Item::rotation(&target)
                }
                fn set_rotation(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_rotation(&mut target, value)
                }
                fn scaling(&self) -> Point {
                    let target: Item = self.into();
                    Item::scaling(&target)
                }
                fn set_scaling(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_scaling(&mut target, value)
                }
                fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_ancestor(&target, item)
                }
                fn emit(
                    &self,
                    type_: String,
                    event: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::emit(&target, type_, event)
                }
                fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_up(&target)
                }
                fn add_to(
                    &self,
                    owner: ItemAddToParamsOwnerParam,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::add_to(&target, owner)
                }
                fn stroke_cap(&self) -> String {
                    let target: Item = self.into();
                    Item::stroke_cap(&target)
                }
                fn set_stroke_cap(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_cap(&mut target, value)
                }
                fn on_mouse_drag(&self) -> ItemOnMouseDrag {
                    let target: Item = self.into();
                    Item::on_mouse_drag(&target)
                }
                fn set_on_mouse_drag(&mut self, value: ItemOnMouseDrag) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_drag(&mut target, value)
                }
                fn set(
                    &self,
                    props: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::set(&target, props)
                }
                fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::reverse_children(&target)
                }
                fn matches(
                    &self,
                    name: String,
                    compare: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::matches(&target, name, compare)
                }
                fn on_mouse_enter(&self) -> ItemOnMouseEnter {
                    let target: Item = self.into();
                    Item::on_mouse_enter(&target)
                }
                fn set_on_mouse_enter(&mut self, value: ItemOnMouseEnter) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_enter(&mut target, value)
                }
                fn shadow_offset(&self) -> Point {
                    let target: Item = self.into();
                    Item::shadow_offset(&target)
                }
                fn set_shadow_offset(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_shadow_offset(&mut target, value)
                }
                fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_stroke(&target)
                }
                fn view_matrix(&self) -> Matrix {
                    let target: Item = self.into();
                    Item::view_matrix(&target)
                }
                fn set_view_matrix(&mut self, value: Matrix) -> () {
                    let mut target: Item = self.into();
                    Item::set_view_matrix(&mut target, value)
                }
                fn on_frame(&self) -> ItemOnFrame {
                    let target: Item = self.into();
                    Item::on_frame(&target)
                }
                fn set_on_frame(&mut self, value: ItemOnFrame) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_frame(&mut target, value)
                }
                fn on_mouse_down(&self) -> ItemOnMouseDown {
                    let target: Item = self.into();
                    Item::on_mouse_down(&target)
                }
                fn set_on_mouse_down(&mut self, value: ItemOnMouseDown) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_down(&mut target, value)
                }
                fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_sibling(&target, item)
                }
                fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::local_to_global(&target, point)
                }
                fn first_child(&self) -> Item {
                    let target: Item = self.into();
                    Item::first_child(&target)
                }
                fn set_first_child(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_first_child(&mut target, value)
                }
                fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::send_to_back(&target)
                }
                fn clip_mask(&self) -> bool {
                    let target: Item = self.into();
                    Item::clip_mask(&target)
                }
                fn set_clip_mask(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_clip_mask(&mut target, value)
                }
                fn next_sibling(&self) -> Item {
                    let target: Item = self.into();
                    Item::next_sibling(&target)
                }
                fn set_next_sibling(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_next_sibling(&mut target, value)
                }
                fn off(
                    &self,
                    object: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::off(&target, object)
                }
                fn rotate(&self, angle: f64, center: Point) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::rotate(&target, angle, center)
                }
                fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::add_child(&target, item)
                }
                fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_grouped_with(&target, item)
                }
                fn scale(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::scale(&target, hor, ver, center)
                }
                fn hit_test_all(
                    &self,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Vec<HitResult>, JsValue> {
                    let target: Item = self.into();
                    Item::hit_test_all(&target, point, options)
                }
                fn insert_children(
                    &self,
                    index: f64,
                    items: Vec<Item>,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::insert_children(&target, index, items)
                }
                fn style(&self) -> Style {
                    let target: Item = self.into();
                    Item::style(&target)
                }
                fn set_style(&mut self, value: Style) -> () {
                    let mut target: Item = self.into();
                    Item::set_style(&mut target, value)
                }
                fn position(&self) -> Point {
                    let target: Item = self.into();
                    Item::position(&target)
                }
                fn set_position(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_position(&mut target, value)
                }
                fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::transform(&target, matrix)
                }
                fn fill_color(&self) -> ItemFillColor {
                    let target: Item = self.into();
                    Item::fill_color(&target)
                }
                fn set_fill_color(&mut self, value: ItemFillColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_fill_color(&mut target, value)
                }
                fn matrix(&self) -> Matrix {
                    let target: Item = self.into();
                    Item::matrix(&target)
                }
                fn set_matrix(&mut self, value: Matrix) -> () {
                    let mut target: Item = self.into();
                    Item::set_matrix(&mut target, value)
                }
                fn id(&self) -> f64 {
                    let target: Item = self.into();
                    Item::id(&target)
                }
                fn set_id(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_id(&mut target, value)
                }
                fn tween(
                    &self,
                    options: ItemTweenParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let target: Item = self.into();
                    Item::tween(&target, options)
                }
                fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::reduce(&target, options)
                }
                fn internal_bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::internal_bounds(&target)
                }
                fn set_internal_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_internal_bounds(&mut target, value)
                }
                fn fill_rule(&self) -> String {
                    let target: Item = self.into();
                    Item::fill_rule(&target)
                }
                fn set_fill_rule(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_fill_rule(&mut target, value)
                }
                fn shadow_color(&self) -> ItemShadowColor {
                    let target: Item = self.into();
                    Item::shadow_color(&target)
                }
                fn set_shadow_color(&mut self, value: ItemShadowColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_shadow_color(&mut target, value)
                }
                fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::insert_above(&target, item)
                }
                fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::responds(&target, type_)
                }
                fn handle_bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::handle_bounds(&target)
                }
                fn set_handle_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_handle_bounds(&mut target, value)
                }
                fn skew(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::skew(&target, hor, ver, center)
                }
                fn on_click(&self) -> ItemOnClick {
                    let target: Item = self.into();
                    Item::on_click(&target)
                }
                fn set_on_click(&mut self, value: ItemOnClick) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_click(&mut target, value)
                }
                fn get_items(
                    &self,
                    options: ItemGetItemsParamsOptionsParam,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::get_items(&target, options)
                }
                fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_inserted(&target)
                }
                fn get_item(
                    &self,
                    options: ItemGetItemParamsOptionsParam,
                ) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::get_item(&target, options)
                }
                fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_fill(&target)
                }
                fn shear(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::shear(&target, hor, ver, center)
                }
                fn visible(&self) -> bool {
                    let target: Item = self.into();
                    Item::visible(&target)
                }
                fn set_visible(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_visible(&mut target, value)
                }
                fn previous_sibling(&self) -> Item {
                    let target: Item = self.into();
                    Item::previous_sibling(&target)
                }
                fn set_previous_sibling(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_previous_sibling(&mut target, value)
                }
                fn hit_test(
                    &self,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<HitResult, JsValue> {
                    let target: Item = self.into();
                    Item::hit_test(&target, point, options)
                }
                fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_descendant(&target, item)
                }
                fn locked(&self) -> bool {
                    let target: Item = self.into();
                    Item::locked(&target)
                }
                fn set_locked(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_locked(&mut target, value)
                }
                fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_parent(&target, item)
                }
                fn copy_attributes(
                    &self,
                    source: Item,
                    exclude_matrix: bool,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::copy_attributes(&target, source, exclude_matrix)
                }
                fn last_child(&self) -> Item {
                    let target: Item = self.into();
                    Item::last_child(&target)
                }
                fn set_last_child(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_last_child(&mut target, value)
                }
                fn stroke_width(&self) -> f64 {
                    let target: Item = self.into();
                    Item::stroke_width(&target)
                }
                fn set_stroke_width(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_width(&mut target, value)
                }
                fn parent(&self) -> Item {
                    let target: Item = self.into();
                    Item::parent(&target)
                }
                fn set_parent(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_parent(&mut target, value)
                }
                fn stroke_bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::stroke_bounds(&target)
                }
                fn set_stroke_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_bounds(&mut target, value)
                }
                fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::translate(&target, delta)
                }
                fn remove(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::remove(&target)
                }
                fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::parent_to_local(&target, point)
                }
                fn bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::bounds(&target)
                }
                fn set_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_bounds(&mut target, value)
                }
                fn add_children(
                    &self,
                    items: Vec<Item>,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::add_children(&target, items)
                }
                fn dash_array(&self) -> Vec<f64> {
                    let target: Item = self.into();
                    Item::dash_array(&target)
                }
                fn set_dash_array(&mut self, value: Vec<f64>) -> () {
                    let mut target: Item = self.into();
                    Item::set_dash_array(&mut target, value)
                }
                fn on_mouse_up(&self) -> ItemOnMouseUp {
                    let target: Item = self.into();
                    Item::on_mouse_up(&target)
                }
                fn set_on_mouse_up(&mut self, value: ItemOnMouseUp) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_up(&mut target, value)
                }
                fn on(
                    &self,
                    object: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::on(&target, object)
                }
                fn remove_on(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on(&target, options)
                }
                fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_below(&target, item)
                }
                fn apply_matrix(&self) -> bool {
                    let target: Item = self.into();
                    Item::apply_matrix(&target)
                }
                fn set_apply_matrix(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_apply_matrix(&mut target, value)
                }
                fn clone(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::clone(&target, options)
                }
                fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::contains(&target, point)
                }
                fn export_json(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<String, JsValue> {
                    let target: Item = self.into();
                    Item::export_json(&target, options)
                }
                fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::bring_to_front(&target)
                }
                fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_above(&target, item)
                }
                fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_drag(&target)
                }
                fn data(&self) -> JsValue {
                    let target: Item = self.into();
                    Item::data(&target)
                }
                fn set_data(&mut self, value: JsValue) -> () {
                    let mut target: Item = self.into();
                    Item::set_data(&mut target, value)
                }
                fn import_svg(
                    &self,
                    svg: ItemImportSvgParamsSvgParam,
                    on_load: JsValue,
                ) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::import_svg(&target, svg, on_load)
                }
                fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_shadow(&target)
                }
                fn selected_color(&self) -> ItemSelectedColor {
                    let target: Item = self.into();
                    Item::selected_color(&target)
                }
                fn set_selected_color(&mut self, value: ItemSelectedColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_selected_color(&mut target, value)
                }
                fn class_name(&self) -> String {
                    let target: Item = self.into();
                    Item::class_name(&target)
                }
                fn set_class_name(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_class_name(&mut target, value)
                }
                fn export_svg(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                    let target: Item = self.into();
                    Item::export_svg(&target, options)
                }
                fn tween_to(
                    &self,
                    to: std::collections::HashMap<String, JsValue>,
                    options: ItemTweenToParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let target: Item = self.into();
                    Item::tween_to(&target, to, options)
                }
                fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_inside(&target, rect)
                }
                fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_empty(&target, recursively)
                }
                fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::copy_content(&target, source)
                }
                fn rasterize(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Raster, JsValue> {
                    let target: Item = self.into();
                    Item::rasterize(&target, options)
                }
                fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_move(&target)
                }
                fn tween_from(
                    &self,
                    from: std::collections::HashMap<String, JsValue>,
                    options: ItemTweenFromParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let target: Item = self.into();
                    Item::tween_from(&target, from, options)
                }
                fn opacity(&self) -> f64 {
                    let target: Item = self.into();
                    Item::opacity(&target)
                }
                fn set_opacity(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_opacity(&mut target, value)
                }
                fn dash_offset(&self) -> f64 {
                    let target: Item = self.into();
                    Item::dash_offset(&target)
                }
                fn set_dash_offset(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_dash_offset(&mut target, value)
                }
                fn remove_children(
                    &self,
                    start: f64,
                    end: f64,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::remove_children(&target, start, end)
                }
                fn on_mouse_move(&self) -> ItemOnMouseMove {
                    let target: Item = self.into();
                    Item::on_mouse_move(&target)
                }
                fn set_on_mouse_move(&mut self, value: ItemOnMouseMove) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_move(&mut target, value)
                }
                fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::intersects(&target, item)
                }
                fn pivot(&self) -> Point {
                    let target: Item = self.into();
                    Item::pivot(&target)
                }
                fn set_pivot(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_pivot(&mut target, value)
                }
                fn copy_to(
                    &self,
                    owner: ItemCopyToParamsOwnerParam,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::copy_to(&target, owner)
                }
                fn index(&self) -> f64 {
                    let target: Item = self.into();
                    Item::index(&target)
                }
                fn set_index(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_index(&mut target, value)
                }
                fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::local_to_parent(&target, point)
                }
                fn stroke_color(&self) -> ItemStrokeColor {
                    let target: Item = self.into();
                    Item::stroke_color(&target)
                }
                fn set_stroke_color(&mut self, value: ItemStrokeColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_color(&mut target, value)
                }
                fn layer(&self) -> Layer {
                    let target: Item = self.into();
                    Item::layer(&target)
                }
                fn set_layer(&mut self, value: Layer) -> () {
                    let mut target: Item = self.into();
                    Item::set_layer(&mut target, value)
                }
                fn stroke_scaling(&self) -> bool {
                    let target: Item = self.into();
                    Item::stroke_scaling(&target)
                }
                fn set_stroke_scaling(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_scaling(&mut target, value)
                }
                fn fit_bounds(
                    &self,
                    rectangle: Rectangle,
                    fill: bool,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::fit_bounds(&target, rectangle, fill)
                }
                fn miter_limit(&self) -> f64 {
                    let target: Item = self.into();
                    Item::miter_limit(&target)
                }
                fn set_miter_limit(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_miter_limit(&mut target, value)
                }
                fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_down(&target)
                }
            }
            impl TextItem_Trait for TextItem {}
            impl std::clone::Clone for TextItem_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for TextItem_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for TextItem_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ItemStrokeColor {
                ColorCase(Color),
                TsBindgenRtNullCase,
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                #[wasm_bindgen(js_name = "Size")]
                type Size_Class;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = subtract , method , js_class = "Size" , catch)]
                fn __TSB_subtract(
                    this: &Size_Class,
                    size: Size,
                ) -> std::result::Result<Size, JsValue>;
                #[wasm_bindgen(constructor, js_class = "Size")]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Size_Class;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = clone , method , js_class = "Size" , catch)]
                fn __TSB_clone(this: &Size_Class) -> std::result::Result<Size, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = min , method , js_class = "Size" , catch)]
                fn __TSB_min(
                    this: &Size_Class,
                    size1: Size,
                    size2: Size,
                ) -> std::result::Result<Size, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = multiply , method , js_class = "Size" , catch)]
                fn __TSB_multiply(
                    this: &Size_Class,
                    size: Size,
                ) -> std::result::Result<Size, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isNaN , method , js_class = "Size" , catch)]
                fn __TSB_is_na_n(this: &Size_Class) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = ceil , method , js_class = "Size" , catch)]
                fn __TSB_ceil(this: &Size_Class) -> std::result::Result<Size, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isZero , method , js_class = "Size" , catch)]
                fn __TSB_is_zero(this: &Size_Class) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = random , method , js_class = "Size" , catch)]
                fn __TSB_random(this: &Size_Class) -> std::result::Result<Size, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = set , method , js_class = "Size" , catch , variadic)]
                fn __TSB_set(
                    this: &Size_Class,
                    values: &[JsValue],
                ) -> std::result::Result<Size, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = round , method , js_class = "Size" , catch)]
                fn __TSB_round(this: &Size_Class) -> std::result::Result<Size, JsValue>;
                # [wasm_bindgen (method , structural , getter = width , js_class = "Size")]
                fn width(this: &Size_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = width , js_class = "Size")]
                fn set_width(this: &Size_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = modulo , method , js_class = "Size" , catch)]
                fn __TSB_modulo(
                    this: &Size_Class,
                    size: Size,
                ) -> std::result::Result<Size, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = add , method , js_class = "Size" , catch)]
                fn __TSB_add(this: &Size_Class, size: Size) -> std::result::Result<Size, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = max , method , js_class = "Size" , catch)]
                fn __TSB_max(
                    this: &Size_Class,
                    size1: Size,
                    size2: Size,
                ) -> std::result::Result<Size, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = floor , method , js_class = "Size" , catch)]
                fn __TSB_floor(this: &Size_Class) -> std::result::Result<Size, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = divide , method , js_class = "Size" , catch)]
                fn __TSB_divide(
                    this: &Size_Class,
                    size: Size,
                ) -> std::result::Result<Size, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = toString , method , js_class = "Size" , catch)]
                fn __TSB_to_string(this: &Size_Class) -> std::result::Result<String, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = abs , method , js_class = "Size" , catch)]
                fn __TSB_abs(this: &Size_Class) -> std::result::Result<Size, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = equals , method , js_class = "Size" , catch)]
                fn __TSB_equals(
                    this: &Size_Class,
                    size: Size,
                ) -> std::result::Result<bool, JsValue>;
                # [wasm_bindgen (method , structural , getter = height , js_class = "Size")]
                fn height(this: &Size_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = height , js_class = "Size")]
                fn set_height(this: &Size_Class, value: f64);
            }
            #[derive(std :: clone :: Clone)]
            struct Size(pub Size_Class);
            impl Size {
                #[allow(dead_code)]
                pub fn subtract(&self, size: Size) -> std::result::Result<Size, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_subtract(size)?);
                    result
                }
                #[allow(dead_code)]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Size {
                    let result = Size_Class::new(object);
                    let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                    Size(result)
                }
                #[allow(dead_code)]
                pub fn clone(&self) -> std::result::Result<Size, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_clone()?);
                    result
                }
                #[allow(dead_code)]
                pub fn min(&self, size1: Size, size2: Size) -> std::result::Result<Size, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_min(size1, size2)?);
                    result
                }
                #[allow(dead_code)]
                pub fn multiply(&self, size: Size) -> std::result::Result<Size, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_multiply(size)?);
                    result
                }
                #[allow(dead_code)]
                pub fn is_na_n(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_na_n()?);
                    result
                }
                #[allow(dead_code)]
                pub fn ceil(&self) -> std::result::Result<Size, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_ceil()?);
                    result
                }
                #[allow(dead_code)]
                pub fn is_zero(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_zero()?);
                    result
                }
                #[allow(dead_code)]
                pub fn random(&self) -> std::result::Result<Size, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_random()?);
                    result
                }
                #[allow(dead_code)]
                pub fn set(&self, values: &[JsValue]) -> std::result::Result<Size, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_set(values)?);
                    result
                }
                #[allow(dead_code)]
                pub fn round(&self) -> std::result::Result<Size, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_round()?);
                    result
                }
                #[allow(dead_code)]
                pub fn width(&self) -> f64 {
                    let result = self.0.width();
                    result
                }
                #[allow(dead_code)]
                pub fn set_width(&self, value: f64) -> () {
                    let result = self.0.set_width(value);
                    result
                }
                #[allow(dead_code)]
                pub fn modulo(&self, size: Size) -> std::result::Result<Size, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_modulo(size)?);
                    result
                }
                #[allow(dead_code)]
                pub fn add(&self, size: Size) -> std::result::Result<Size, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_add(size)?);
                    result
                }
                #[allow(dead_code)]
                pub fn max(&self, size1: Size, size2: Size) -> std::result::Result<Size, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_max(size1, size2)?);
                    result
                }
                #[allow(dead_code)]
                pub fn floor(&self) -> std::result::Result<Size, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_floor()?);
                    result
                }
                #[allow(dead_code)]
                pub fn divide(&self, size: Size) -> std::result::Result<Size, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_divide(size)?);
                    result
                }
                #[allow(dead_code)]
                pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_to_string()?);
                    result
                }
                #[allow(dead_code)]
                pub fn abs(&self) -> std::result::Result<Size, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_abs()?);
                    result
                }
                #[allow(dead_code)]
                pub fn equals(&self, size: Size) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_equals(size)?);
                    result
                }
                #[allow(dead_code)]
                pub fn height(&self) -> f64 {
                    let result = self.0.height();
                    result
                }
                #[allow(dead_code)]
                pub fn set_height(&self, value: f64) -> () {
                    let result = self.0.set_height(value);
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for Size {
                fn describe() {
                    <Size_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for Size {
                type Abi = <Size_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Size {
                type Abi = <&'a Size_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for Size {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Size {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: Size_Class =
                        <Size_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait Size_Trait {
                fn subtract(&self, size: Size) -> std::result::Result<Size, JsValue>;
                fn new(object: std::collections::HashMap<String, JsValue>) -> Size;
                fn clone(&self) -> std::result::Result<Size, JsValue>;
                fn min(&self, size1: Size, size2: Size) -> std::result::Result<Size, JsValue>;
                fn multiply(&self, size: Size) -> std::result::Result<Size, JsValue>;
                fn is_na_n(&self) -> std::result::Result<bool, JsValue>;
                fn ceil(&self) -> std::result::Result<Size, JsValue>;
                fn is_zero(&self) -> std::result::Result<bool, JsValue>;
                fn random(&self) -> std::result::Result<Size, JsValue>;
                fn set(&self, values: &[JsValue]) -> std::result::Result<Size, JsValue>;
                fn round(&self) -> std::result::Result<Size, JsValue>;
                fn width(&self) -> f64;
                fn set_width(&mut self, value: f64) -> ();
                fn modulo(&self, size: Size) -> std::result::Result<Size, JsValue>;
                fn add(&self, size: Size) -> std::result::Result<Size, JsValue>;
                fn max(&self, size1: Size, size2: Size) -> std::result::Result<Size, JsValue>;
                fn floor(&self) -> std::result::Result<Size, JsValue>;
                fn divide(&self, size: Size) -> std::result::Result<Size, JsValue>;
                fn to_string(&self) -> std::result::Result<String, JsValue>;
                fn abs(&self) -> std::result::Result<Size, JsValue>;
                fn equals(&self, size: Size) -> std::result::Result<bool, JsValue>;
                fn height(&self) -> f64;
                fn set_height(&mut self, value: f64) -> ();
            }
            impl std::clone::Clone for Size_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for Size_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Size_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ItemOnMouseDrag {
                TsBindgenRtNullCase,
                JsValueCase(JsValue),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ViewOnMouseEnter {
                TsBindgenRtNullCase,
                JsValueCase(JsValue),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum StyleSelectedColor {
                ColorCase(Color),
                TsBindgenRtNullCase,
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                # [wasm_bindgen (js_name = "Ellipse" , extends = Shape_Class)]
                type Ellipse_Class;
                #[wasm_bindgen(constructor, js_class = "Ellipse")]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Ellipse_Class;
            }
            #[derive(std :: clone :: Clone)]
            struct Ellipse(pub Ellipse_Class);
            impl std::convert::From<&Ellipse> for Shape {
                fn from(src: &Ellipse) -> Shape {
                    let src: &Shape_Class = src.0.as_ref();
                    Shape(src.clone())
                }
            }
            impl std::convert::From<&mut Ellipse> for Shape {
                fn from(src: &mut Ellipse) -> Shape {
                    let src: &Shape_Class = src.0.as_ref();
                    Shape(src.clone())
                }
            }
            impl Ellipse {
                #[allow(dead_code)]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Ellipse {
                    let result = Ellipse_Class::new(object);
                    let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                    Ellipse(result)
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for Ellipse {
                fn describe() {
                    <Ellipse_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for Ellipse {
                type Abi = <Ellipse_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Ellipse {
                type Abi = <&'a Ellipse_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for Ellipse {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Ellipse {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: Ellipse_Class =
                        <Ellipse_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait Ellipse_Trait: Shape_Trait {
                fn new(object: std::collections::HashMap<String, JsValue>) -> Ellipse;
            }
            impl Shape_Trait for Ellipse {}
            impl Ellipse_Trait for Ellipse {}
            impl std::clone::Clone for Ellipse_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for Ellipse_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Ellipse_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                # [wasm_bindgen (js_name = "Arc" , extends = Path_Class)]
                type Arc_Class;
                #[wasm_bindgen(constructor, js_class = "Arc")]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Arc_Class;
            }
            #[derive(std :: clone :: Clone)]
            struct Arc(pub Arc_Class);
            impl std::convert::From<&Arc> for Path {
                fn from(src: &Arc) -> Path {
                    let src: &Path_Class = src.0.as_ref();
                    Path(src.clone())
                }
            }
            impl std::convert::From<&mut Arc> for Path {
                fn from(src: &mut Arc) -> Path {
                    let src: &Path_Class = src.0.as_ref();
                    Path(src.clone())
                }
            }
            impl Arc {
                #[allow(dead_code)]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Arc {
                    let result = Arc_Class::new(object);
                    let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                    Arc(result)
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for Arc {
                fn describe() {
                    <Arc_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for Arc {
                type Abi = <Arc_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Arc {
                type Abi = <&'a Arc_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for Arc {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Arc {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: Arc_Class =
                        <Arc_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait Arc_Trait: Path_Trait {
                fn new(object: std::collections::HashMap<String, JsValue>) -> Arc;
            }
            impl Path_Trait for Arc {}
            impl Arc_Trait for Arc {}
            impl std::clone::Clone for Arc_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for Arc_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Arc_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum StyleFontSize {
                StringCase(String),
                F64Case(f64),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum TextItemFontWeight {
                F64Case(f64),
                StringCase(String),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum TextItemFontSize {
                StringCase(String),
                F64Case(f64),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum TweenOnUpdate {
                TsBindgenRtNullCase,
                JsValueCase(JsValue),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum StyleStrokeColor {
                ColorCase(Color),
                TsBindgenRtNullCase,
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                # [wasm_bindgen (js_name = "PointText" , extends = TextItem_Class)]
                type PointText_Class;
                #[wasm_bindgen(constructor, js_class = "PointText")]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> PointText_Class;
                # [wasm_bindgen (method , structural , getter = point , js_class = "PointText")]
                fn point(this: &PointText_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = point , js_class = "PointText")]
                fn set_point(this: &PointText_Class, value: Point);
            }
            #[derive(std :: clone :: Clone)]
            struct PointText(pub PointText_Class);
            impl std::convert::From<&PointText> for TextItem {
                fn from(src: &PointText) -> TextItem {
                    let src: &TextItem_Class = src.0.as_ref();
                    TextItem(src.clone())
                }
            }
            impl std::convert::From<&mut PointText> for TextItem {
                fn from(src: &mut PointText) -> TextItem {
                    let src: &TextItem_Class = src.0.as_ref();
                    TextItem(src.clone())
                }
            }
            impl PointText {
                #[allow(dead_code)]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> PointText {
                    let result = PointText_Class::new(object);
                    let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                    PointText(result)
                }
                #[allow(dead_code)]
                pub fn point(&self) -> Point {
                    let result = self.0.point();
                    result
                }
                #[allow(dead_code)]
                pub fn set_point(&self, value: Point) -> () {
                    let result = self.0.set_point(value);
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for PointText {
                fn describe() {
                    <PointText_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for PointText {
                type Abi = <PointText_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a PointText {
                type Abi = <&'a PointText_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for PointText {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for PointText {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: PointText_Class =
                        <PointText_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait PointText_Trait: TextItem_Trait {
                fn new(object: std::collections::HashMap<String, JsValue>) -> PointText;
                fn point(&self) -> Point;
                fn set_point(&mut self, value: Point) -> ();
            }
            impl TextItem_Trait for PointText
            where
                PointText: Item_Trait,
            {
                fn content(&self) -> String {
                    let target: TextItem = self.into();
                    TextItem::content(&target)
                }
                fn set_content(&mut self, value: String) -> () {
                    let mut target: TextItem = self.into();
                    TextItem::set_content(&mut target, value)
                }
                fn justification(&self) -> String {
                    let target: TextItem = self.into();
                    TextItem::justification(&target)
                }
                fn set_justification(&mut self, value: String) -> () {
                    let mut target: TextItem = self.into();
                    TextItem::set_justification(&mut target, value)
                }
                fn font_size(&self) -> TextItemFontSize {
                    let target: TextItem = self.into();
                    TextItem::font_size(&target)
                }
                fn set_font_size(&mut self, value: TextItemFontSize) -> () {
                    let mut target: TextItem = self.into();
                    TextItem::set_font_size(&mut target, value)
                }
                fn font_weight(&self) -> TextItemFontWeight {
                    let target: TextItem = self.into();
                    TextItem::font_weight(&target)
                }
                fn set_font_weight(&mut self, value: TextItemFontWeight) -> () {
                    let mut target: TextItem = self.into();
                    TextItem::set_font_weight(&mut target, value)
                }
                fn font_family(&self) -> String {
                    let target: TextItem = self.into();
                    TextItem::font_family(&target)
                }
                fn set_font_family(&mut self, value: String) -> () {
                    let mut target: TextItem = self.into();
                    TextItem::set_font_family(&mut target, value)
                }
                fn leading(&self) -> TextItemLeading {
                    let target: TextItem = self.into();
                    TextItem::leading(&target)
                }
                fn set_leading(&mut self, value: TextItemLeading) -> () {
                    let mut target: TextItem = self.into();
                    TextItem::set_leading(&mut target, value)
                }
            }
            impl Item_Trait for PointText {
                fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::insert_below(&target, item)
                }
                fn on_double_click(&self) -> ItemOnDoubleClick {
                    let target: Item = self.into();
                    Item::on_double_click(&target)
                }
                fn set_on_double_click(&mut self, value: ItemOnDoubleClick) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_double_click(&mut target, value)
                }
                fn view(&self) -> View {
                    let target: Item = self.into();
                    Item::view(&target)
                }
                fn set_view(&mut self, value: View) -> () {
                    let mut target: Item = self.into();
                    Item::set_view(&mut target, value)
                }
                fn blend_mode(&self) -> String {
                    let target: Item = self.into();
                    Item::blend_mode(&target)
                }
                fn set_blend_mode(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_blend_mode(&mut target, value)
                }
                fn name(&self) -> String {
                    let target: Item = self.into();
                    Item::name(&target)
                }
                fn set_name(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_name(&mut target, value)
                }
                fn project(&self) -> Project {
                    let target: Item = self.into();
                    Item::project(&target)
                }
                fn set_project(&mut self, value: Project) -> () {
                    let mut target: Item = self.into();
                    Item::set_project(&mut target, value)
                }
                fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_child(&target, item)
                }
                fn global_matrix(&self) -> Matrix {
                    let target: Item = self.into();
                    Item::global_matrix(&target)
                }
                fn set_global_matrix(&mut self, value: Matrix) -> () {
                    let mut target: Item = self.into();
                    Item::set_global_matrix(&mut target, value)
                }
                fn on_mouse_leave(&self) -> ItemOnMouseLeave {
                    let target: Item = self.into();
                    Item::on_mouse_leave(&target)
                }
                fn set_on_mouse_leave(&mut self, value: ItemOnMouseLeave) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_leave(&mut target, value)
                }
                fn has_children(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_children(&target)
                }
                fn selected(&self) -> bool {
                    let target: Item = self.into();
                    Item::selected(&target)
                }
                fn set_selected(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_selected(&mut target, value)
                }
                fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::global_to_local(&target, point)
                }
                fn shadow_blur(&self) -> f64 {
                    let target: Item = self.into();
                    Item::shadow_blur(&target)
                }
                fn set_shadow_blur(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_shadow_blur(&mut target, value)
                }
                fn children(&self) -> Vec<Item> {
                    let target: Item = self.into();
                    Item::children(&target)
                }
                fn set_children(&mut self, value: Vec<Item>) -> () {
                    let mut target: Item = self.into();
                    Item::set_children(&mut target, value)
                }
                fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::replace_with(&target, item)
                }
                fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::import_json(&target, json)
                }
                fn insert_child(
                    &self,
                    index: f64,
                    item: Item,
                ) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::insert_child(&target, index, item)
                }
                fn stroke_join(&self) -> String {
                    let target: Item = self.into();
                    Item::stroke_join(&target)
                }
                fn set_stroke_join(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_join(&mut target, value)
                }
                fn rotation(&self) -> f64 {
                    let target: Item = self.into();
                    Item::rotation(&target)
                }
                fn set_rotation(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_rotation(&mut target, value)
                }
                fn scaling(&self) -> Point {
                    let target: Item = self.into();
                    Item::scaling(&target)
                }
                fn set_scaling(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_scaling(&mut target, value)
                }
                fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_ancestor(&target, item)
                }
                fn emit(
                    &self,
                    type_: String,
                    event: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::emit(&target, type_, event)
                }
                fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_up(&target)
                }
                fn add_to(
                    &self,
                    owner: ItemAddToParamsOwnerParam,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::add_to(&target, owner)
                }
                fn stroke_cap(&self) -> String {
                    let target: Item = self.into();
                    Item::stroke_cap(&target)
                }
                fn set_stroke_cap(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_cap(&mut target, value)
                }
                fn on_mouse_drag(&self) -> ItemOnMouseDrag {
                    let target: Item = self.into();
                    Item::on_mouse_drag(&target)
                }
                fn set_on_mouse_drag(&mut self, value: ItemOnMouseDrag) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_drag(&mut target, value)
                }
                fn set(
                    &self,
                    props: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::set(&target, props)
                }
                fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::reverse_children(&target)
                }
                fn matches(
                    &self,
                    name: String,
                    compare: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::matches(&target, name, compare)
                }
                fn on_mouse_enter(&self) -> ItemOnMouseEnter {
                    let target: Item = self.into();
                    Item::on_mouse_enter(&target)
                }
                fn set_on_mouse_enter(&mut self, value: ItemOnMouseEnter) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_enter(&mut target, value)
                }
                fn shadow_offset(&self) -> Point {
                    let target: Item = self.into();
                    Item::shadow_offset(&target)
                }
                fn set_shadow_offset(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_shadow_offset(&mut target, value)
                }
                fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_stroke(&target)
                }
                fn view_matrix(&self) -> Matrix {
                    let target: Item = self.into();
                    Item::view_matrix(&target)
                }
                fn set_view_matrix(&mut self, value: Matrix) -> () {
                    let mut target: Item = self.into();
                    Item::set_view_matrix(&mut target, value)
                }
                fn on_frame(&self) -> ItemOnFrame {
                    let target: Item = self.into();
                    Item::on_frame(&target)
                }
                fn set_on_frame(&mut self, value: ItemOnFrame) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_frame(&mut target, value)
                }
                fn on_mouse_down(&self) -> ItemOnMouseDown {
                    let target: Item = self.into();
                    Item::on_mouse_down(&target)
                }
                fn set_on_mouse_down(&mut self, value: ItemOnMouseDown) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_down(&mut target, value)
                }
                fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_sibling(&target, item)
                }
                fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::local_to_global(&target, point)
                }
                fn first_child(&self) -> Item {
                    let target: Item = self.into();
                    Item::first_child(&target)
                }
                fn set_first_child(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_first_child(&mut target, value)
                }
                fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::send_to_back(&target)
                }
                fn clip_mask(&self) -> bool {
                    let target: Item = self.into();
                    Item::clip_mask(&target)
                }
                fn set_clip_mask(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_clip_mask(&mut target, value)
                }
                fn next_sibling(&self) -> Item {
                    let target: Item = self.into();
                    Item::next_sibling(&target)
                }
                fn set_next_sibling(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_next_sibling(&mut target, value)
                }
                fn off(
                    &self,
                    object: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::off(&target, object)
                }
                fn rotate(&self, angle: f64, center: Point) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::rotate(&target, angle, center)
                }
                fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::add_child(&target, item)
                }
                fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_grouped_with(&target, item)
                }
                fn scale(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::scale(&target, hor, ver, center)
                }
                fn hit_test_all(
                    &self,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Vec<HitResult>, JsValue> {
                    let target: Item = self.into();
                    Item::hit_test_all(&target, point, options)
                }
                fn insert_children(
                    &self,
                    index: f64,
                    items: Vec<Item>,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::insert_children(&target, index, items)
                }
                fn style(&self) -> Style {
                    let target: Item = self.into();
                    Item::style(&target)
                }
                fn set_style(&mut self, value: Style) -> () {
                    let mut target: Item = self.into();
                    Item::set_style(&mut target, value)
                }
                fn position(&self) -> Point {
                    let target: Item = self.into();
                    Item::position(&target)
                }
                fn set_position(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_position(&mut target, value)
                }
                fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::transform(&target, matrix)
                }
                fn fill_color(&self) -> ItemFillColor {
                    let target: Item = self.into();
                    Item::fill_color(&target)
                }
                fn set_fill_color(&mut self, value: ItemFillColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_fill_color(&mut target, value)
                }
                fn matrix(&self) -> Matrix {
                    let target: Item = self.into();
                    Item::matrix(&target)
                }
                fn set_matrix(&mut self, value: Matrix) -> () {
                    let mut target: Item = self.into();
                    Item::set_matrix(&mut target, value)
                }
                fn id(&self) -> f64 {
                    let target: Item = self.into();
                    Item::id(&target)
                }
                fn set_id(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_id(&mut target, value)
                }
                fn tween(
                    &self,
                    options: ItemTweenParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let target: Item = self.into();
                    Item::tween(&target, options)
                }
                fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::reduce(&target, options)
                }
                fn internal_bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::internal_bounds(&target)
                }
                fn set_internal_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_internal_bounds(&mut target, value)
                }
                fn fill_rule(&self) -> String {
                    let target: Item = self.into();
                    Item::fill_rule(&target)
                }
                fn set_fill_rule(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_fill_rule(&mut target, value)
                }
                fn shadow_color(&self) -> ItemShadowColor {
                    let target: Item = self.into();
                    Item::shadow_color(&target)
                }
                fn set_shadow_color(&mut self, value: ItemShadowColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_shadow_color(&mut target, value)
                }
                fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::insert_above(&target, item)
                }
                fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::responds(&target, type_)
                }
                fn handle_bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::handle_bounds(&target)
                }
                fn set_handle_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_handle_bounds(&mut target, value)
                }
                fn skew(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::skew(&target, hor, ver, center)
                }
                fn on_click(&self) -> ItemOnClick {
                    let target: Item = self.into();
                    Item::on_click(&target)
                }
                fn set_on_click(&mut self, value: ItemOnClick) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_click(&mut target, value)
                }
                fn get_items(
                    &self,
                    options: ItemGetItemsParamsOptionsParam,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::get_items(&target, options)
                }
                fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_inserted(&target)
                }
                fn get_item(
                    &self,
                    options: ItemGetItemParamsOptionsParam,
                ) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::get_item(&target, options)
                }
                fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_fill(&target)
                }
                fn shear(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::shear(&target, hor, ver, center)
                }
                fn visible(&self) -> bool {
                    let target: Item = self.into();
                    Item::visible(&target)
                }
                fn set_visible(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_visible(&mut target, value)
                }
                fn previous_sibling(&self) -> Item {
                    let target: Item = self.into();
                    Item::previous_sibling(&target)
                }
                fn set_previous_sibling(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_previous_sibling(&mut target, value)
                }
                fn hit_test(
                    &self,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<HitResult, JsValue> {
                    let target: Item = self.into();
                    Item::hit_test(&target, point, options)
                }
                fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_descendant(&target, item)
                }
                fn locked(&self) -> bool {
                    let target: Item = self.into();
                    Item::locked(&target)
                }
                fn set_locked(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_locked(&mut target, value)
                }
                fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_parent(&target, item)
                }
                fn copy_attributes(
                    &self,
                    source: Item,
                    exclude_matrix: bool,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::copy_attributes(&target, source, exclude_matrix)
                }
                fn last_child(&self) -> Item {
                    let target: Item = self.into();
                    Item::last_child(&target)
                }
                fn set_last_child(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_last_child(&mut target, value)
                }
                fn stroke_width(&self) -> f64 {
                    let target: Item = self.into();
                    Item::stroke_width(&target)
                }
                fn set_stroke_width(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_width(&mut target, value)
                }
                fn parent(&self) -> Item {
                    let target: Item = self.into();
                    Item::parent(&target)
                }
                fn set_parent(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_parent(&mut target, value)
                }
                fn stroke_bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::stroke_bounds(&target)
                }
                fn set_stroke_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_bounds(&mut target, value)
                }
                fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::translate(&target, delta)
                }
                fn remove(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::remove(&target)
                }
                fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::parent_to_local(&target, point)
                }
                fn bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::bounds(&target)
                }
                fn set_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_bounds(&mut target, value)
                }
                fn add_children(
                    &self,
                    items: Vec<Item>,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::add_children(&target, items)
                }
                fn dash_array(&self) -> Vec<f64> {
                    let target: Item = self.into();
                    Item::dash_array(&target)
                }
                fn set_dash_array(&mut self, value: Vec<f64>) -> () {
                    let mut target: Item = self.into();
                    Item::set_dash_array(&mut target, value)
                }
                fn on_mouse_up(&self) -> ItemOnMouseUp {
                    let target: Item = self.into();
                    Item::on_mouse_up(&target)
                }
                fn set_on_mouse_up(&mut self, value: ItemOnMouseUp) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_up(&mut target, value)
                }
                fn on(
                    &self,
                    object: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::on(&target, object)
                }
                fn remove_on(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on(&target, options)
                }
                fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_below(&target, item)
                }
                fn apply_matrix(&self) -> bool {
                    let target: Item = self.into();
                    Item::apply_matrix(&target)
                }
                fn set_apply_matrix(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_apply_matrix(&mut target, value)
                }
                fn clone(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::clone(&target, options)
                }
                fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::contains(&target, point)
                }
                fn export_json(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<String, JsValue> {
                    let target: Item = self.into();
                    Item::export_json(&target, options)
                }
                fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::bring_to_front(&target)
                }
                fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_above(&target, item)
                }
                fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_drag(&target)
                }
                fn data(&self) -> JsValue {
                    let target: Item = self.into();
                    Item::data(&target)
                }
                fn set_data(&mut self, value: JsValue) -> () {
                    let mut target: Item = self.into();
                    Item::set_data(&mut target, value)
                }
                fn import_svg(
                    &self,
                    svg: ItemImportSvgParamsSvgParam,
                    on_load: JsValue,
                ) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::import_svg(&target, svg, on_load)
                }
                fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_shadow(&target)
                }
                fn selected_color(&self) -> ItemSelectedColor {
                    let target: Item = self.into();
                    Item::selected_color(&target)
                }
                fn set_selected_color(&mut self, value: ItemSelectedColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_selected_color(&mut target, value)
                }
                fn class_name(&self) -> String {
                    let target: Item = self.into();
                    Item::class_name(&target)
                }
                fn set_class_name(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_class_name(&mut target, value)
                }
                fn export_svg(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                    let target: Item = self.into();
                    Item::export_svg(&target, options)
                }
                fn tween_to(
                    &self,
                    to: std::collections::HashMap<String, JsValue>,
                    options: ItemTweenToParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let target: Item = self.into();
                    Item::tween_to(&target, to, options)
                }
                fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_inside(&target, rect)
                }
                fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_empty(&target, recursively)
                }
                fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::copy_content(&target, source)
                }
                fn rasterize(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Raster, JsValue> {
                    let target: Item = self.into();
                    Item::rasterize(&target, options)
                }
                fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_move(&target)
                }
                fn tween_from(
                    &self,
                    from: std::collections::HashMap<String, JsValue>,
                    options: ItemTweenFromParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let target: Item = self.into();
                    Item::tween_from(&target, from, options)
                }
                fn opacity(&self) -> f64 {
                    let target: Item = self.into();
                    Item::opacity(&target)
                }
                fn set_opacity(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_opacity(&mut target, value)
                }
                fn dash_offset(&self) -> f64 {
                    let target: Item = self.into();
                    Item::dash_offset(&target)
                }
                fn set_dash_offset(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_dash_offset(&mut target, value)
                }
                fn remove_children(
                    &self,
                    start: f64,
                    end: f64,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::remove_children(&target, start, end)
                }
                fn on_mouse_move(&self) -> ItemOnMouseMove {
                    let target: Item = self.into();
                    Item::on_mouse_move(&target)
                }
                fn set_on_mouse_move(&mut self, value: ItemOnMouseMove) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_move(&mut target, value)
                }
                fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::intersects(&target, item)
                }
                fn pivot(&self) -> Point {
                    let target: Item = self.into();
                    Item::pivot(&target)
                }
                fn set_pivot(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_pivot(&mut target, value)
                }
                fn copy_to(
                    &self,
                    owner: ItemCopyToParamsOwnerParam,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::copy_to(&target, owner)
                }
                fn index(&self) -> f64 {
                    let target: Item = self.into();
                    Item::index(&target)
                }
                fn set_index(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_index(&mut target, value)
                }
                fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::local_to_parent(&target, point)
                }
                fn stroke_color(&self) -> ItemStrokeColor {
                    let target: Item = self.into();
                    Item::stroke_color(&target)
                }
                fn set_stroke_color(&mut self, value: ItemStrokeColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_color(&mut target, value)
                }
                fn layer(&self) -> Layer {
                    let target: Item = self.into();
                    Item::layer(&target)
                }
                fn set_layer(&mut self, value: Layer) -> () {
                    let mut target: Item = self.into();
                    Item::set_layer(&mut target, value)
                }
                fn stroke_scaling(&self) -> bool {
                    let target: Item = self.into();
                    Item::stroke_scaling(&target)
                }
                fn set_stroke_scaling(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_scaling(&mut target, value)
                }
                fn fit_bounds(
                    &self,
                    rectangle: Rectangle,
                    fill: bool,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::fit_bounds(&target, rectangle, fill)
                }
                fn miter_limit(&self) -> f64 {
                    let target: Item = self.into();
                    Item::miter_limit(&target)
                }
                fn set_miter_limit(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_miter_limit(&mut target, value)
                }
                fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_down(&target)
                }
            }
            impl PointText_Trait for PointText {}
            impl std::clone::Clone for PointText_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for PointText_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for PointText_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ViewOnMouseLeave {
                TsBindgenRtNullCase,
                JsValueCase(JsValue),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ItemSelectedColor {
                ColorCase(Color),
                TsBindgenRtNullCase,
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                #[wasm_bindgen(js_name = "PaperScope")]
                type PaperScope_Class;
                # [wasm_bindgen (method , structural , getter = Style , js_class = "PaperScope")]
                fn style(this: &PaperScope_Class) -> Style;
                # [wasm_bindgen (method , structural , setter = Style , js_class = "PaperScope")]
                fn set_style(this: &PaperScope_Class, value: Style);
                # [wasm_bindgen (method , structural , getter = PathItem , js_class = "PaperScope")]
                fn path_item(this: &PaperScope_Class) -> PathItem;
                # [wasm_bindgen (method , structural , setter = PathItem , js_class = "PaperScope")]
                fn set_path_item(this: &PaperScope_Class, value: PathItem);
                # [wasm_bindgen (method , structural , getter = Point , js_class = "PaperScope")]
                fn point(this: &PaperScope_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = Point , js_class = "PaperScope")]
                fn set_point(this: &PaperScope_Class, value: Point);
                # [wasm_bindgen (method , structural , getter = Color , js_class = "PaperScope")]
                fn color(this: &PaperScope_Class) -> Color;
                # [wasm_bindgen (method , structural , setter = Color , js_class = "PaperScope")]
                fn set_color(this: &PaperScope_Class, value: Color);
                # [wasm_bindgen (method , structural , getter = Path , js_class = "PaperScope")]
                fn path(this: &PaperScope_Class) -> Path;
                # [wasm_bindgen (method , structural , setter = Path , js_class = "PaperScope")]
                fn set_path(this: &PaperScope_Class, value: Path);
                # [wasm_bindgen (method , structural , getter = PaperScript , js_class = "PaperScope")]
                fn paper_script(this: &PaperScope_Class) -> PaperScript;
                # [wasm_bindgen (method , structural , setter = PaperScript , js_class = "PaperScope")]
                fn set_paper_script(this: &PaperScope_Class, value: PaperScript);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = get , method , js_class = "PaperScope" , catch)]
                fn __TSB_get(
                    this: &PaperScope_Class,
                    id: JsValue,
                ) -> std::result::Result<PaperScope, JsValue>;
                # [wasm_bindgen (method , structural , getter = Curve , js_class = "PaperScope")]
                fn curve(this: &PaperScope_Class) -> Curve;
                # [wasm_bindgen (method , structural , setter = Curve , js_class = "PaperScope")]
                fn set_curve(this: &PaperScope_Class, value: Curve);
                # [wasm_bindgen (method , structural , getter = View , js_class = "PaperScope")]
                fn view(this: &PaperScope_Class) -> View;
                # [wasm_bindgen (method , structural , setter = View , js_class = "PaperScope")]
                fn set_view(this: &PaperScope_Class, value: View);
                # [wasm_bindgen (method , structural , getter = Size , js_class = "PaperScope")]
                fn size(this: &PaperScope_Class) -> Size;
                # [wasm_bindgen (method , structural , setter = Size , js_class = "PaperScope")]
                fn set_size(this: &PaperScope_Class, value: Size);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = setup , method , js_class = "PaperScope" , catch)]
                fn __TSB_setup(
                    this: &PaperScope_Class,
                    element: JsValue,
                ) -> std::result::Result<(), JsValue>;
                # [wasm_bindgen (method , structural , getter = view , js_class = "PaperScope")]
                fn view(this: &PaperScope_Class) -> View;
                # [wasm_bindgen (method , structural , setter = view , js_class = "PaperScope")]
                fn set_view(this: &PaperScope_Class, value: View);
                # [wasm_bindgen (method , structural , getter = Matrix , js_class = "PaperScope")]
                fn matrix(this: &PaperScope_Class) -> Matrix;
                # [wasm_bindgen (method , structural , setter = Matrix , js_class = "PaperScope")]
                fn set_matrix(this: &PaperScope_Class, value: Matrix);
                # [wasm_bindgen (method , structural , getter = tools , js_class = "PaperScope")]
                fn tools(this: &PaperScope_Class) -> Vec<Tool>;
                # [wasm_bindgen (method , structural , setter = tools , js_class = "PaperScope")]
                fn set_tools(this: &PaperScope_Class, value: Vec<Tool>);
                # [wasm_bindgen (method , structural , getter = project , js_class = "PaperScope")]
                fn project(this: &PaperScope_Class) -> Project;
                # [wasm_bindgen (method , structural , setter = project , js_class = "PaperScope")]
                fn set_project(this: &PaperScope_Class, value: Project);
                # [wasm_bindgen (method , structural , getter = Group , js_class = "PaperScope")]
                fn group(this: &PaperScope_Class) -> Group;
                # [wasm_bindgen (method , structural , setter = Group , js_class = "PaperScope")]
                fn set_group(this: &PaperScope_Class, value: Group);
                # [wasm_bindgen (method , structural , getter = Rectangle , js_class = "PaperScope")]
                fn rectangle(this: &PaperScope_Class) -> Rectangle;
                # [wasm_bindgen (method , structural , setter = Rectangle , js_class = "PaperScope")]
                fn set_rectangle(this: &PaperScope_Class, value: Rectangle);
                # [wasm_bindgen (method , structural , getter = tool , js_class = "PaperScope")]
                fn tool(this: &PaperScope_Class) -> Tool;
                # [wasm_bindgen (method , structural , setter = tool , js_class = "PaperScope")]
                fn set_tool(this: &PaperScope_Class, value: Tool);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = execute , method , js_class = "PaperScope" , catch)]
                fn __TSB_execute(
                    this: &PaperScope_Class,
                    code: String,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<(), JsValue>;
                # [wasm_bindgen (method , structural , getter = Item , js_class = "PaperScope")]
                fn item(this: &PaperScope_Class) -> Item;
                # [wasm_bindgen (method , structural , setter = Item , js_class = "PaperScope")]
                fn set_item(this: &PaperScope_Class, value: Item);
                # [wasm_bindgen (method , structural , getter = Key , js_class = "PaperScope")]
                fn key(this: &PaperScope_Class) -> Key;
                # [wasm_bindgen (method , structural , setter = Key , js_class = "PaperScope")]
                fn set_key(this: &PaperScope_Class, value: Key);
                # [wasm_bindgen (method , structural , getter = version , js_class = "PaperScope")]
                fn version(this: &PaperScope_Class) -> String;
                # [wasm_bindgen (method , structural , setter = version , js_class = "PaperScope")]
                fn set_version(this: &PaperScope_Class, value: String);
                # [wasm_bindgen (method , structural , getter = GradientStop , js_class = "PaperScope")]
                fn gradient_stop(this: &PaperScope_Class) -> GradientStop;
                # [wasm_bindgen (method , structural , setter = GradientStop , js_class = "PaperScope")]
                fn set_gradient_stop(this: &PaperScope_Class, value: GradientStop);
                # [wasm_bindgen (method , structural , getter = settings , js_class = "PaperScope")]
                fn settings(this: &PaperScope_Class) -> JsValue;
                # [wasm_bindgen (method , structural , setter = settings , js_class = "PaperScope")]
                fn set_settings(this: &PaperScope_Class, value: JsValue);
                # [wasm_bindgen (method , structural , getter = Event , js_class = "PaperScope")]
                fn event(this: &PaperScope_Class) -> Event;
                # [wasm_bindgen (method , structural , setter = Event , js_class = "PaperScope")]
                fn set_event(this: &PaperScope_Class, value: Event);
                # [wasm_bindgen (method , structural , getter = Tool , js_class = "PaperScope")]
                fn tool(this: &PaperScope_Class) -> Tool;
                # [wasm_bindgen (method , structural , setter = Tool , js_class = "PaperScope")]
                fn set_tool(this: &PaperScope_Class, value: Tool);
                # [wasm_bindgen (method , structural , getter = HitResult , js_class = "PaperScope")]
                fn hit_result(this: &PaperScope_Class) -> HitResult;
                # [wasm_bindgen (method , structural , setter = HitResult , js_class = "PaperScope")]
                fn set_hit_result(this: &PaperScope_Class, value: HitResult);
                # [wasm_bindgen (method , structural , getter = Layer , js_class = "PaperScope")]
                fn layer(this: &PaperScope_Class) -> Layer;
                # [wasm_bindgen (method , structural , setter = Layer , js_class = "PaperScope")]
                fn set_layer(this: &PaperScope_Class, value: Layer);
                # [wasm_bindgen (method , structural , getter = KeyEvent , js_class = "PaperScope")]
                fn key_event(this: &PaperScope_Class) -> KeyEvent;
                # [wasm_bindgen (method , structural , setter = KeyEvent , js_class = "PaperScope")]
                fn set_key_event(this: &PaperScope_Class, value: KeyEvent);
                # [wasm_bindgen (method , structural , getter = projects , js_class = "PaperScope")]
                fn projects(this: &PaperScope_Class) -> Vec<Project>;
                # [wasm_bindgen (method , structural , setter = projects , js_class = "PaperScope")]
                fn set_projects(this: &PaperScope_Class, value: Vec<Project>);
                # [wasm_bindgen (method , structural , getter = PointText , js_class = "PaperScope")]
                fn point_text(this: &PaperScope_Class) -> PointText;
                # [wasm_bindgen (method , structural , setter = PointText , js_class = "PaperScope")]
                fn set_point_text(this: &PaperScope_Class, value: PointText);
                # [wasm_bindgen (method , structural , getter = Raster , js_class = "PaperScope")]
                fn raster(this: &PaperScope_Class) -> Raster;
                # [wasm_bindgen (method , structural , setter = Raster , js_class = "PaperScope")]
                fn set_raster(this: &PaperScope_Class, value: Raster);
                # [wasm_bindgen (method , structural , getter = CurveLocation , js_class = "PaperScope")]
                fn curve_location(this: &PaperScope_Class) -> CurveLocation;
                # [wasm_bindgen (method , structural , setter = CurveLocation , js_class = "PaperScope")]
                fn set_curve_location(this: &PaperScope_Class, value: CurveLocation);
                # [wasm_bindgen (method , structural , getter = Gradient , js_class = "PaperScope")]
                fn gradient(this: &PaperScope_Class) -> Gradient;
                # [wasm_bindgen (method , structural , setter = Gradient , js_class = "PaperScope")]
                fn set_gradient(this: &PaperScope_Class, value: Gradient);
                # [wasm_bindgen (method , structural , getter = TextItem , js_class = "PaperScope")]
                fn text_item(this: &PaperScope_Class) -> TextItem;
                # [wasm_bindgen (method , structural , setter = TextItem , js_class = "PaperScope")]
                fn set_text_item(this: &PaperScope_Class, value: TextItem);
                # [wasm_bindgen (method , structural , getter = SymbolDefinition , js_class = "PaperScope")]
                fn symbol_definition(this: &PaperScope_Class) -> SymbolDefinition;
                # [wasm_bindgen (method , structural , setter = SymbolDefinition , js_class = "PaperScope")]
                fn set_symbol_definition(this: &PaperScope_Class, value: SymbolDefinition);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = install , method , js_class = "PaperScope" , catch)]
                fn __TSB_install(
                    this: &PaperScope_Class,
                    scope: JsValue,
                ) -> std::result::Result<(), JsValue>;
                # [wasm_bindgen (method , structural , getter = Shape , js_class = "PaperScope")]
                fn shape(this: &PaperScope_Class) -> Shape;
                # [wasm_bindgen (method , structural , setter = Shape , js_class = "PaperScope")]
                fn set_shape(this: &PaperScope_Class, value: Shape);
                # [wasm_bindgen (method , structural , getter = MouseEvent , js_class = "PaperScope")]
                fn mouse_event(this: &PaperScope_Class) -> MouseEvent;
                # [wasm_bindgen (method , structural , setter = MouseEvent , js_class = "PaperScope")]
                fn set_mouse_event(this: &PaperScope_Class, value: MouseEvent);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = activate , method , js_class = "PaperScope" , catch)]
                fn __TSB_activate(this: &PaperScope_Class) -> std::result::Result<(), JsValue>;
                # [wasm_bindgen (method , structural , getter = ToolEvent , js_class = "PaperScope")]
                fn tool_event(this: &PaperScope_Class) -> ToolEvent;
                # [wasm_bindgen (method , structural , setter = ToolEvent , js_class = "PaperScope")]
                fn set_tool_event(this: &PaperScope_Class, value: ToolEvent);
                # [wasm_bindgen (method , structural , getter = PaperScope , js_class = "PaperScope")]
                fn paper_scope(this: &PaperScope_Class) -> PaperScope;
                # [wasm_bindgen (method , structural , setter = PaperScope , js_class = "PaperScope")]
                fn set_paper_scope(this: &PaperScope_Class, value: PaperScope);
                # [wasm_bindgen (method , structural , getter = Segment , js_class = "PaperScope")]
                fn segment(this: &PaperScope_Class) -> Segment;
                # [wasm_bindgen (method , structural , setter = Segment , js_class = "PaperScope")]
                fn set_segment(this: &PaperScope_Class, value: Segment);
                #[wasm_bindgen(constructor, js_class = "PaperScope")]
                pub fn new() -> PaperScope_Class;
                # [wasm_bindgen (method , structural , getter = CompoundPath , js_class = "PaperScope")]
                fn compound_path(this: &PaperScope_Class) -> CompoundPath;
                # [wasm_bindgen (method , structural , setter = CompoundPath , js_class = "PaperScope")]
                fn set_compound_path(this: &PaperScope_Class, value: CompoundPath);
                # [wasm_bindgen (method , structural , getter = Project , js_class = "PaperScope")]
                fn project(this: &PaperScope_Class) -> Project;
                # [wasm_bindgen (method , structural , setter = Project , js_class = "PaperScope")]
                fn set_project(this: &PaperScope_Class, value: Project);
                # [wasm_bindgen (method , structural , getter = Tween , js_class = "PaperScope")]
                fn tween(this: &PaperScope_Class) -> Tween;
                # [wasm_bindgen (method , structural , setter = Tween , js_class = "PaperScope")]
                fn set_tween(this: &PaperScope_Class, value: Tween);
                # [wasm_bindgen (method , structural , getter = SymbolItem , js_class = "PaperScope")]
                fn symbol_item(this: &PaperScope_Class) -> SymbolItem;
                # [wasm_bindgen (method , structural , setter = SymbolItem , js_class = "PaperScope")]
                fn set_symbol_item(this: &PaperScope_Class, value: SymbolItem);
            }
            #[derive(std :: clone :: Clone)]
            struct PaperScope(pub PaperScope_Class);
            impl PaperScope {
                #[allow(dead_code)]
                pub fn style(&self) -> Style {
                    let result = self.0.style();
                    result
                }
                #[allow(dead_code)]
                pub fn set_style(&self, value: Style) -> () {
                    let result = self.0.set_style(value);
                    result
                }
                #[allow(dead_code)]
                pub fn path_item(&self) -> PathItem {
                    let result = self.0.path_item();
                    result
                }
                #[allow(dead_code)]
                pub fn set_path_item(&self, value: PathItem) -> () {
                    let result = self.0.set_path_item(value);
                    result
                }
                #[allow(dead_code)]
                pub fn point(&self) -> Point {
                    let result = self.0.point();
                    result
                }
                #[allow(dead_code)]
                pub fn set_point(&self, value: Point) -> () {
                    let result = self.0.set_point(value);
                    result
                }
                #[allow(dead_code)]
                pub fn color(&self) -> Color {
                    let result = self.0.color();
                    result
                }
                #[allow(dead_code)]
                pub fn set_color(&self, value: Color) -> () {
                    let result = self.0.set_color(value);
                    result
                }
                #[allow(dead_code)]
                pub fn path(&self) -> Path {
                    let result = self.0.path();
                    result
                }
                #[allow(dead_code)]
                pub fn set_path(&self, value: Path) -> () {
                    let result = self.0.set_path(value);
                    result
                }
                #[allow(dead_code)]
                pub fn paper_script(&self) -> PaperScript {
                    let result = self.0.paper_script();
                    result
                }
                #[allow(dead_code)]
                pub fn set_paper_script(&self, value: PaperScript) -> () {
                    let result = self.0.set_paper_script(value);
                    result
                }
                #[allow(dead_code)]
                pub fn get(&self, id: JsValue) -> std::result::Result<PaperScope, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get(id)?);
                    result
                }
                #[allow(dead_code)]
                pub fn curve(&self) -> Curve {
                    let result = self.0.curve();
                    result
                }
                #[allow(dead_code)]
                pub fn set_curve(&self, value: Curve) -> () {
                    let result = self.0.set_curve(value);
                    result
                }
                #[allow(dead_code)]
                pub fn view(&self) -> View {
                    let result = self.0.view();
                    result
                }
                #[allow(dead_code)]
                pub fn set_view(&self, value: View) -> () {
                    let result = self.0.set_view(value);
                    result
                }
                #[allow(dead_code)]
                pub fn size(&self) -> Size {
                    let result = self.0.size();
                    result
                }
                #[allow(dead_code)]
                pub fn set_size(&self, value: Size) -> () {
                    let result = self.0.set_size(value);
                    result
                }
                #[allow(dead_code)]
                pub fn setup(
                    &self,
                    element: PaperScopeSetupParamsElementParam,
                ) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_setup(
                        ts_bindgen_rt::to_jsvalue(&element).map_err(ts_bindgen_rt::Error::from)?,
                    )?);
                    result
                }
                #[allow(dead_code)]
                pub fn view(&self) -> View {
                    let result = self.0.view();
                    result
                }
                #[allow(dead_code)]
                pub fn set_view(&self, value: View) -> () {
                    let result = self.0.set_view(value);
                    result
                }
                #[allow(dead_code)]
                pub fn matrix(&self) -> Matrix {
                    let result = self.0.matrix();
                    result
                }
                #[allow(dead_code)]
                pub fn set_matrix(&self, value: Matrix) -> () {
                    let result = self.0.set_matrix(value);
                    result
                }
                #[allow(dead_code)]
                pub fn tools(&self) -> Vec<Tool> {
                    let result = self.0.tools();
                    result
                }
                #[allow(dead_code)]
                pub fn set_tools(&self, value: Vec<Tool>) -> () {
                    let result = self.0.set_tools(value);
                    result
                }
                #[allow(dead_code)]
                pub fn project(&self) -> Project {
                    let result = self.0.project();
                    result
                }
                #[allow(dead_code)]
                pub fn set_project(&self, value: Project) -> () {
                    let result = self.0.set_project(value);
                    result
                }
                #[allow(dead_code)]
                pub fn group(&self) -> Group {
                    let result = self.0.group();
                    result
                }
                #[allow(dead_code)]
                pub fn set_group(&self, value: Group) -> () {
                    let result = self.0.set_group(value);
                    result
                }
                #[allow(dead_code)]
                pub fn rectangle(&self) -> Rectangle {
                    let result = self.0.rectangle();
                    result
                }
                #[allow(dead_code)]
                pub fn set_rectangle(&self, value: Rectangle) -> () {
                    let result = self.0.set_rectangle(value);
                    result
                }
                #[allow(dead_code)]
                pub fn tool(&self) -> Tool {
                    let result = self.0.tool();
                    result
                }
                #[allow(dead_code)]
                pub fn set_tool(&self, value: Tool) -> () {
                    let result = self.0.set_tool(value);
                    result
                }
                #[allow(dead_code)]
                pub fn execute(
                    &self,
                    code: String,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_execute(code, options)?);
                    result
                }
                #[allow(dead_code)]
                pub fn item(&self) -> Item {
                    let result = self.0.item();
                    result
                }
                #[allow(dead_code)]
                pub fn set_item(&self, value: Item) -> () {
                    let result = self.0.set_item(value);
                    result
                }
                #[allow(dead_code)]
                pub fn key(&self) -> Key {
                    let result = self.0.key();
                    result
                }
                #[allow(dead_code)]
                pub fn set_key(&self, value: Key) -> () {
                    let result = self.0.set_key(value);
                    result
                }
                #[allow(dead_code)]
                pub fn version(&self) -> String {
                    let result = self.0.version();
                    result
                }
                #[allow(dead_code)]
                pub fn set_version(&self, value: String) -> () {
                    let result = self.0.set_version(value);
                    result
                }
                #[allow(dead_code)]
                pub fn gradient_stop(&self) -> GradientStop {
                    let result = self.0.gradient_stop();
                    result
                }
                #[allow(dead_code)]
                pub fn set_gradient_stop(&self, value: GradientStop) -> () {
                    let result = self.0.set_gradient_stop(value);
                    result
                }
                #[allow(dead_code)]
                pub fn settings(&self) -> JsValue {
                    let result = self.0.settings();
                    result
                }
                #[allow(dead_code)]
                pub fn set_settings(&self, value: JsValue) -> () {
                    let result = self.0.set_settings(value);
                    result
                }
                #[allow(dead_code)]
                pub fn event(&self) -> Event {
                    let result = self.0.event();
                    result
                }
                #[allow(dead_code)]
                pub fn set_event(&self, value: Event) -> () {
                    let result = self.0.set_event(value);
                    result
                }
                #[allow(dead_code)]
                pub fn tool(&self) -> Tool {
                    let result = self.0.tool();
                    result
                }
                #[allow(dead_code)]
                pub fn set_tool(&self, value: Tool) -> () {
                    let result = self.0.set_tool(value);
                    result
                }
                #[allow(dead_code)]
                pub fn hit_result(&self) -> HitResult {
                    let result = self.0.hit_result();
                    result
                }
                #[allow(dead_code)]
                pub fn set_hit_result(&self, value: HitResult) -> () {
                    let result = self.0.set_hit_result(value);
                    result
                }
                #[allow(dead_code)]
                pub fn layer(&self) -> Layer {
                    let result = self.0.layer();
                    result
                }
                #[allow(dead_code)]
                pub fn set_layer(&self, value: Layer) -> () {
                    let result = self.0.set_layer(value);
                    result
                }
                #[allow(dead_code)]
                pub fn key_event(&self) -> KeyEvent {
                    let result = self.0.key_event();
                    result
                }
                #[allow(dead_code)]
                pub fn set_key_event(&self, value: KeyEvent) -> () {
                    let result = self.0.set_key_event(value);
                    result
                }
                #[allow(dead_code)]
                pub fn projects(&self) -> Vec<Project> {
                    let result = self.0.projects();
                    result
                }
                #[allow(dead_code)]
                pub fn set_projects(&self, value: Vec<Project>) -> () {
                    let result = self.0.set_projects(value);
                    result
                }
                #[allow(dead_code)]
                pub fn point_text(&self) -> PointText {
                    let result = self.0.point_text();
                    result
                }
                #[allow(dead_code)]
                pub fn set_point_text(&self, value: PointText) -> () {
                    let result = self.0.set_point_text(value);
                    result
                }
                #[allow(dead_code)]
                pub fn raster(&self) -> Raster {
                    let result = self.0.raster();
                    result
                }
                #[allow(dead_code)]
                pub fn set_raster(&self, value: Raster) -> () {
                    let result = self.0.set_raster(value);
                    result
                }
                #[allow(dead_code)]
                pub fn curve_location(&self) -> CurveLocation {
                    let result = self.0.curve_location();
                    result
                }
                #[allow(dead_code)]
                pub fn set_curve_location(&self, value: CurveLocation) -> () {
                    let result = self.0.set_curve_location(value);
                    result
                }
                #[allow(dead_code)]
                pub fn gradient(&self) -> Gradient {
                    let result = self.0.gradient();
                    result
                }
                #[allow(dead_code)]
                pub fn set_gradient(&self, value: Gradient) -> () {
                    let result = self.0.set_gradient(value);
                    result
                }
                #[allow(dead_code)]
                pub fn text_item(&self) -> TextItem {
                    let result = self.0.text_item();
                    result
                }
                #[allow(dead_code)]
                pub fn set_text_item(&self, value: TextItem) -> () {
                    let result = self.0.set_text_item(value);
                    result
                }
                #[allow(dead_code)]
                pub fn symbol_definition(&self) -> SymbolDefinition {
                    let result = self.0.symbol_definition();
                    result
                }
                #[allow(dead_code)]
                pub fn set_symbol_definition(&self, value: SymbolDefinition) -> () {
                    let result = self.0.set_symbol_definition(value);
                    result
                }
                #[allow(dead_code)]
                pub fn install(&self, scope: JsValue) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_install(scope)?);
                    result
                }
                #[allow(dead_code)]
                pub fn shape(&self) -> Shape {
                    let result = self.0.shape();
                    result
                }
                #[allow(dead_code)]
                pub fn set_shape(&self, value: Shape) -> () {
                    let result = self.0.set_shape(value);
                    result
                }
                #[allow(dead_code)]
                pub fn mouse_event(&self) -> MouseEvent {
                    let result = self.0.mouse_event();
                    result
                }
                #[allow(dead_code)]
                pub fn set_mouse_event(&self, value: MouseEvent) -> () {
                    let result = self.0.set_mouse_event(value);
                    result
                }
                #[allow(dead_code)]
                pub fn activate(&self) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_activate()?);
                    result
                }
                #[allow(dead_code)]
                pub fn tool_event(&self) -> ToolEvent {
                    let result = self.0.tool_event();
                    result
                }
                #[allow(dead_code)]
                pub fn set_tool_event(&self, value: ToolEvent) -> () {
                    let result = self.0.set_tool_event(value);
                    result
                }
                #[allow(dead_code)]
                pub fn paper_scope(&self) -> PaperScope {
                    let result = self.0.paper_scope();
                    result
                }
                #[allow(dead_code)]
                pub fn set_paper_scope(&self, value: PaperScope) -> () {
                    let result = self.0.set_paper_scope(value);
                    result
                }
                #[allow(dead_code)]
                pub fn segment(&self) -> Segment {
                    let result = self.0.segment();
                    result
                }
                #[allow(dead_code)]
                pub fn set_segment(&self, value: Segment) -> () {
                    let result = self.0.set_segment(value);
                    result
                }
                #[allow(dead_code)]
                pub fn new() -> PaperScope {
                    let result = PaperScope_Class::new();
                    let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                    PaperScope(result)
                }
                #[allow(dead_code)]
                pub fn compound_path(&self) -> CompoundPath {
                    let result = self.0.compound_path();
                    result
                }
                #[allow(dead_code)]
                pub fn set_compound_path(&self, value: CompoundPath) -> () {
                    let result = self.0.set_compound_path(value);
                    result
                }
                #[allow(dead_code)]
                pub fn project(&self) -> Project {
                    let result = self.0.project();
                    result
                }
                #[allow(dead_code)]
                pub fn set_project(&self, value: Project) -> () {
                    let result = self.0.set_project(value);
                    result
                }
                #[allow(dead_code)]
                pub fn tween(&self) -> Tween {
                    let result = self.0.tween();
                    result
                }
                #[allow(dead_code)]
                pub fn set_tween(&self, value: Tween) -> () {
                    let result = self.0.set_tween(value);
                    result
                }
                #[allow(dead_code)]
                pub fn symbol_item(&self) -> SymbolItem {
                    let result = self.0.symbol_item();
                    result
                }
                #[allow(dead_code)]
                pub fn set_symbol_item(&self, value: SymbolItem) -> () {
                    let result = self.0.set_symbol_item(value);
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for PaperScope {
                fn describe() {
                    <PaperScope_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for PaperScope {
                type Abi = <PaperScope_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a PaperScope {
                type Abi = <&'a PaperScope_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for PaperScope {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for PaperScope {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: PaperScope_Class =
                        <PaperScope_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait PaperScope_Trait {
                fn style(&self) -> Style;
                fn set_style(&mut self, value: Style) -> ();
                fn path_item(&self) -> PathItem;
                fn set_path_item(&mut self, value: PathItem) -> ();
                fn point(&self) -> Point;
                fn set_point(&mut self, value: Point) -> ();
                fn color(&self) -> Color;
                fn set_color(&mut self, value: Color) -> ();
                fn path(&self) -> Path;
                fn set_path(&mut self, value: Path) -> ();
                fn paper_script(&self) -> PaperScript;
                fn set_paper_script(&mut self, value: PaperScript) -> ();
                fn get(&self, id: JsValue) -> std::result::Result<PaperScope, JsValue>;
                fn curve(&self) -> Curve;
                fn set_curve(&mut self, value: Curve) -> ();
                fn view(&self) -> View;
                fn set_view(&mut self, value: View) -> ();
                fn size(&self) -> Size;
                fn set_size(&mut self, value: Size) -> ();
                fn setup(
                    &self,
                    element: PaperScopeSetupParamsElementParam,
                ) -> std::result::Result<(), JsValue>;
                fn view(&self) -> View;
                fn set_view(&mut self, value: View) -> ();
                fn matrix(&self) -> Matrix;
                fn set_matrix(&mut self, value: Matrix) -> ();
                fn tools(&self) -> Vec<Tool>;
                fn set_tools(&mut self, value: Vec<Tool>) -> ();
                fn project(&self) -> Project;
                fn set_project(&mut self, value: Project) -> ();
                fn group(&self) -> Group;
                fn set_group(&mut self, value: Group) -> ();
                fn rectangle(&self) -> Rectangle;
                fn set_rectangle(&mut self, value: Rectangle) -> ();
                fn tool(&self) -> Tool;
                fn set_tool(&mut self, value: Tool) -> ();
                fn execute(
                    &self,
                    code: String,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<(), JsValue>;
                fn item(&self) -> Item;
                fn set_item(&mut self, value: Item) -> ();
                fn key(&self) -> Key;
                fn set_key(&mut self, value: Key) -> ();
                fn version(&self) -> String;
                fn set_version(&mut self, value: String) -> ();
                fn gradient_stop(&self) -> GradientStop;
                fn set_gradient_stop(&mut self, value: GradientStop) -> ();
                fn settings(&self) -> JsValue;
                fn set_settings(&mut self, value: JsValue) -> ();
                fn event(&self) -> Event;
                fn set_event(&mut self, value: Event) -> ();
                fn tool(&self) -> Tool;
                fn set_tool(&mut self, value: Tool) -> ();
                fn hit_result(&self) -> HitResult;
                fn set_hit_result(&mut self, value: HitResult) -> ();
                fn layer(&self) -> Layer;
                fn set_layer(&mut self, value: Layer) -> ();
                fn key_event(&self) -> KeyEvent;
                fn set_key_event(&mut self, value: KeyEvent) -> ();
                fn projects(&self) -> Vec<Project>;
                fn set_projects(&mut self, value: Vec<Project>) -> ();
                fn point_text(&self) -> PointText;
                fn set_point_text(&mut self, value: PointText) -> ();
                fn raster(&self) -> Raster;
                fn set_raster(&mut self, value: Raster) -> ();
                fn curve_location(&self) -> CurveLocation;
                fn set_curve_location(&mut self, value: CurveLocation) -> ();
                fn gradient(&self) -> Gradient;
                fn set_gradient(&mut self, value: Gradient) -> ();
                fn text_item(&self) -> TextItem;
                fn set_text_item(&mut self, value: TextItem) -> ();
                fn symbol_definition(&self) -> SymbolDefinition;
                fn set_symbol_definition(&mut self, value: SymbolDefinition) -> ();
                fn install(&self, scope: JsValue) -> std::result::Result<(), JsValue>;
                fn shape(&self) -> Shape;
                fn set_shape(&mut self, value: Shape) -> ();
                fn mouse_event(&self) -> MouseEvent;
                fn set_mouse_event(&mut self, value: MouseEvent) -> ();
                fn activate(&self) -> std::result::Result<(), JsValue>;
                fn tool_event(&self) -> ToolEvent;
                fn set_tool_event(&mut self, value: ToolEvent) -> ();
                fn paper_scope(&self) -> PaperScope;
                fn set_paper_scope(&mut self, value: PaperScope) -> ();
                fn segment(&self) -> Segment;
                fn set_segment(&mut self, value: Segment) -> ();
                fn new() -> PaperScope;
                fn compound_path(&self) -> CompoundPath;
                fn set_compound_path(&mut self, value: CompoundPath) -> ();
                fn project(&self) -> Project;
                fn set_project(&mut self, value: Project) -> ();
                fn tween(&self) -> Tween;
                fn set_tween(&mut self, value: Tween) -> ();
                fn symbol_item(&self) -> SymbolItem;
                fn set_symbol_item(&mut self, value: SymbolItem) -> ();
            }
            impl std::clone::Clone for PaperScope_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for PaperScope_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for PaperScope_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                # [wasm_bindgen (js_name = "Circle" , extends = Shape_Class)]
                type Circle_Class;
                #[wasm_bindgen(constructor, js_class = "Circle")]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Circle_Class;
            }
            #[derive(std :: clone :: Clone)]
            struct Circle(pub Circle_Class);
            impl std::convert::From<&Circle> for Shape {
                fn from(src: &Circle) -> Shape {
                    let src: &Shape_Class = src.0.as_ref();
                    Shape(src.clone())
                }
            }
            impl std::convert::From<&mut Circle> for Shape {
                fn from(src: &mut Circle) -> Shape {
                    let src: &Shape_Class = src.0.as_ref();
                    Shape(src.clone())
                }
            }
            impl Circle {
                #[allow(dead_code)]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Circle {
                    let result = Circle_Class::new(object);
                    let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                    Circle(result)
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for Circle {
                fn describe() {
                    <Circle_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for Circle {
                type Abi = <Circle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Circle {
                type Abi = <&'a Circle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for Circle {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Circle {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: Circle_Class =
                        <Circle_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait Circle_Trait: Shape_Trait {
                fn new(object: std::collections::HashMap<String, JsValue>) -> Circle;
            }
            impl Shape_Trait for Circle {}
            impl Circle_Trait for Circle {}
            impl std::clone::Clone for Circle_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for Circle_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Circle_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ViewOnFrame {
                TsBindgenRtNullCase,
                JsValueCase(JsValue),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum RasterImage {
                JsValueCase(JsValue),
                JsValueCase(JsValue),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ItemOnMouseDown {
                TsBindgenRtNullCase,
                JsValueCase(JsValue),
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                #[wasm_bindgen(js_name = "Tool")]
                type Tool_Class;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = responds , method , js_class = "Tool" , catch)]
                fn __TSB_responds(
                    this: &Tool_Class,
                    type_: String,
                ) -> std::result::Result<bool, JsValue>;
                # [wasm_bindgen (method , structural , getter = fixedDistance , js_class = "Tool")]
                fn fixed_distance(this: &Tool_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = fixedDistance , js_class = "Tool")]
                fn set_fixed_distance(this: &Tool_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = maxDistance , js_class = "Tool")]
                fn max_distance(this: &Tool_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = maxDistance , js_class = "Tool")]
                fn set_max_distance(this: &Tool_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = activate , method , js_class = "Tool" , catch)]
                fn __TSB_activate(this: &Tool_Class) -> std::result::Result<(), JsValue>;
                # [wasm_bindgen (method , structural , getter = onKeyDown , js_class = "Tool")]
                fn on_key_down(this: &Tool_Class) -> ToolOnKeyDown;
                # [wasm_bindgen (method , structural , setter = onKeyDown , js_class = "Tool")]
                fn set_on_key_down(this: &Tool_Class, value: ToolOnKeyDown);
                # [wasm_bindgen (method , structural , getter = minDistance , js_class = "Tool")]
                fn min_distance(this: &Tool_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = minDistance , js_class = "Tool")]
                fn set_min_distance(this: &Tool_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = onMouseDown , js_class = "Tool")]
                fn on_mouse_down(this: &Tool_Class) -> ToolOnMouseDown;
                # [wasm_bindgen (method , structural , setter = onMouseDown , js_class = "Tool")]
                fn set_on_mouse_down(this: &Tool_Class, value: ToolOnMouseDown);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = emit , method , js_class = "Tool" , catch)]
                fn __TSB_emit(
                    this: &Tool_Class,
                    type_: String,
                    event: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = on , method , js_class = "Tool" , catch)]
                fn __TSB_on(
                    this: &Tool_Class,
                    param: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Tool, JsValue>;
                # [wasm_bindgen (method , structural , getter = onMouseDrag , js_class = "Tool")]
                fn on_mouse_drag(this: &Tool_Class) -> ToolOnMouseDrag;
                # [wasm_bindgen (method , structural , setter = onMouseDrag , js_class = "Tool")]
                fn set_on_mouse_drag(this: &Tool_Class, value: ToolOnMouseDrag);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = off , method , js_class = "Tool" , catch)]
                fn __TSB_off(
                    this: &Tool_Class,
                    param: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Tool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = remove , method , js_class = "Tool" , catch)]
                fn __TSB_remove(this: &Tool_Class) -> std::result::Result<(), JsValue>;
                # [wasm_bindgen (method , structural , getter = onKeyUp , js_class = "Tool")]
                fn on_key_up(this: &Tool_Class) -> ToolOnKeyUp;
                # [wasm_bindgen (method , structural , setter = onKeyUp , js_class = "Tool")]
                fn set_on_key_up(this: &Tool_Class, value: ToolOnKeyUp);
                # [wasm_bindgen (method , structural , getter = onMouseUp , js_class = "Tool")]
                fn on_mouse_up(this: &Tool_Class) -> ToolOnMouseUp;
                # [wasm_bindgen (method , structural , setter = onMouseUp , js_class = "Tool")]
                fn set_on_mouse_up(this: &Tool_Class, value: ToolOnMouseUp);
                # [wasm_bindgen (method , structural , getter = onMouseMove , js_class = "Tool")]
                fn on_mouse_move(this: &Tool_Class) -> ToolOnMouseMove;
                # [wasm_bindgen (method , structural , setter = onMouseMove , js_class = "Tool")]
                fn set_on_mouse_move(this: &Tool_Class, value: ToolOnMouseMove);
            }
            #[derive(std :: clone :: Clone)]
            struct Tool(pub Tool_Class);
            impl Tool {
                #[allow(dead_code)]
                pub fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_responds(type_)?);
                    result
                }
                #[allow(dead_code)]
                pub fn fixed_distance(&self) -> f64 {
                    let result = self.0.fixed_distance();
                    result
                }
                #[allow(dead_code)]
                pub fn set_fixed_distance(&self, value: f64) -> () {
                    let result = self.0.set_fixed_distance(value);
                    result
                }
                #[allow(dead_code)]
                pub fn max_distance(&self) -> f64 {
                    let result = self.0.max_distance();
                    result
                }
                #[allow(dead_code)]
                pub fn set_max_distance(&self, value: f64) -> () {
                    let result = self.0.set_max_distance(value);
                    result
                }
                #[allow(dead_code)]
                pub fn activate(&self) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_activate()?);
                    result
                }
                #[allow(dead_code)]
                pub fn on_key_down(&self) -> ToolOnKeyDown {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.on_key_down()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_on_key_down(&self, value: ToolOnKeyDown) -> () {
                    let result = self.0.set_on_key_down(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn min_distance(&self) -> f64 {
                    let result = self.0.min_distance();
                    result
                }
                #[allow(dead_code)]
                pub fn set_min_distance(&self, value: f64) -> () {
                    let result = self.0.set_min_distance(value);
                    result
                }
                #[allow(dead_code)]
                pub fn on_mouse_down(&self) -> ToolOnMouseDown {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_down()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_on_mouse_down(&self, value: ToolOnMouseDown) -> () {
                    let result = self.0.set_on_mouse_down(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn emit(
                    &self,
                    type_: String,
                    event: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_emit(type_, event)?);
                    result
                }
                #[allow(dead_code)]
                pub fn on(
                    &self,
                    param: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Tool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_on(param)?);
                    result
                }
                #[allow(dead_code)]
                pub fn on_mouse_drag(&self) -> ToolOnMouseDrag {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_drag()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_on_mouse_drag(&self, value: ToolOnMouseDrag) -> () {
                    let result = self.0.set_on_mouse_drag(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn off(
                    &self,
                    param: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Tool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_off(param)?);
                    result
                }
                #[allow(dead_code)]
                pub fn remove(&self) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_remove()?);
                    result
                }
                #[allow(dead_code)]
                pub fn on_key_up(&self) -> ToolOnKeyUp {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.on_key_up()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_on_key_up(&self, value: ToolOnKeyUp) -> () {
                    let result = self.0.set_on_key_up(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn on_mouse_up(&self) -> ToolOnMouseUp {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_up()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_on_mouse_up(&self, value: ToolOnMouseUp) -> () {
                    let result = self.0.set_on_mouse_up(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn on_mouse_move(&self) -> ToolOnMouseMove {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_move()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_on_mouse_move(&self, value: ToolOnMouseMove) -> () {
                    let result = self.0.set_on_mouse_move(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for Tool {
                fn describe() {
                    <Tool_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for Tool {
                type Abi = <Tool_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Tool {
                type Abi = <&'a Tool_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for Tool {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Tool {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: Tool_Class =
                        <Tool_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait Tool_Trait {
                fn responds(&self, type_: String) -> std::result::Result<bool, JsValue>;
                fn fixed_distance(&self) -> f64;
                fn set_fixed_distance(&mut self, value: f64) -> ();
                fn max_distance(&self) -> f64;
                fn set_max_distance(&mut self, value: f64) -> ();
                fn activate(&self) -> std::result::Result<(), JsValue>;
                fn on_key_down(&self) -> ToolOnKeyDown;
                fn set_on_key_down(&mut self, value: ToolOnKeyDown) -> ();
                fn min_distance(&self) -> f64;
                fn set_min_distance(&mut self, value: f64) -> ();
                fn on_mouse_down(&self) -> ToolOnMouseDown;
                fn set_on_mouse_down(&mut self, value: ToolOnMouseDown) -> ();
                fn emit(
                    &self,
                    type_: String,
                    event: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue>;
                fn on(
                    &self,
                    param: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Tool, JsValue>;
                fn on_mouse_drag(&self) -> ToolOnMouseDrag;
                fn set_on_mouse_drag(&mut self, value: ToolOnMouseDrag) -> ();
                fn off(
                    &self,
                    param: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Tool, JsValue>;
                fn remove(&self) -> std::result::Result<(), JsValue>;
                fn on_key_up(&self) -> ToolOnKeyUp;
                fn set_on_key_up(&mut self, value: ToolOnKeyUp) -> ();
                fn on_mouse_up(&self) -> ToolOnMouseUp;
                fn set_on_mouse_up(&mut self, value: ToolOnMouseUp) -> ();
                fn on_mouse_move(&self) -> ToolOnMouseMove;
                fn set_on_mouse_move(&mut self, value: ToolOnMouseMove) -> ();
            }
            impl std::clone::Clone for Tool_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for Tool_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Tool_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum CurveGetWeightedTangentAtParamsLocationParam {
                CurveLocationCase(CurveLocation),
                F64Case(f64),
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                # [wasm_bindgen (js_name = "PathItem" , extends = Item_Class)]
                type PathItem_Class;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = cubicCurveBy , method , js_class = "PathItem" , catch)]
                fn __TSB_cubic_curve_by(
                    this: &PathItem_Class,
                    handle1: Point,
                    handle2: Point,
                    to: Point,
                ) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = curveBy , method , js_class = "PathItem" , catch)]
                fn __TSB_curve_by(
                    this: &PathItem_Class,
                    through: Point,
                    to: Point,
                    time: f64,
                ) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = closePath , method , js_class = "PathItem" , catch)]
                fn __TSB_close_path(this: &PathItem_Class) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = simplify , method , js_class = "PathItem" , catch)]
                fn __TSB_simplify(
                    this: &PathItem_Class,
                    tolerance: f64,
                ) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = reverse , method , js_class = "PathItem" , catch)]
                fn __TSB_reverse(this: &PathItem_Class) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = quadraticCurveBy , method , js_class = "PathItem" , catch)]
                fn __TSB_quadratic_curve_by(
                    this: &PathItem_Class,
                    handle: Point,
                    to: Point,
                ) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getIntersections , method , js_class = "PathItem" , catch)]
                fn __TSB_get_intersections(
                    this: &PathItem_Class,
                    path: PathItem,
                    include: JsValue,
                ) -> std::result::Result<Vec<CurveLocation>, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getNearestPoint , method , js_class = "PathItem" , catch)]
                fn __TSB_get_nearest_point(
                    this: &PathItem_Class,
                    point: Point,
                ) -> std::result::Result<Point, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = moveTo , method , js_class = "PathItem" , catch)]
                fn __TSB_move_to(
                    this: &PathItem_Class,
                    point: Point,
                ) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = exclude , method , js_class = "PathItem" , catch)]
                fn __TSB_exclude(
                    this: &PathItem_Class,
                    path: PathItem,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<PathItem, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = interpolate , method , js_class = "PathItem" , catch)]
                fn __TSB_interpolate(
                    this: &PathItem_Class,
                    from: PathItem,
                    to: PathItem,
                    factor: f64,
                ) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = compare , method , js_class = "PathItem" , catch)]
                fn __TSB_compare(
                    this: &PathItem_Class,
                    path: PathItem,
                ) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = arcBy , method , js_class = "PathItem" , catch)]
                fn __TSB_arc_by(
                    this: &PathItem_Class,
                    to: Point,
                    clockwise: bool,
                ) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = lineTo , method , js_class = "PathItem" , catch)]
                fn __TSB_line_to(
                    this: &PathItem_Class,
                    point: Point,
                ) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = lineBy , method , js_class = "PathItem" , catch)]
                fn __TSB_line_by(
                    this: &PathItem_Class,
                    point: Point,
                ) -> std::result::Result<(), JsValue>;
                # [wasm_bindgen (method , structural , getter = pathData , js_class = "PathItem")]
                fn path_data(this: &PathItem_Class) -> String;
                # [wasm_bindgen (method , structural , setter = pathData , js_class = "PathItem")]
                fn set_path_data(this: &PathItem_Class, value: String);
                # [wasm_bindgen (method , structural , getter = interiorPoint , js_class = "PathItem")]
                fn interior_point(this: &PathItem_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = interiorPoint , js_class = "PathItem")]
                fn set_interior_point(this: &PathItem_Class, value: Point);
                # [wasm_bindgen (method , structural , getter = clockwise , js_class = "PathItem")]
                fn clockwise(this: &PathItem_Class) -> bool;
                # [wasm_bindgen (method , structural , setter = clockwise , js_class = "PathItem")]
                fn set_clockwise(this: &PathItem_Class, value: bool);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = smooth , method , js_class = "PathItem" , catch)]
                fn __TSB_smooth(
                    this: &PathItem_Class,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getNearestLocation , method , js_class = "PathItem" , catch)]
                fn __TSB_get_nearest_location(
                    this: &PathItem_Class,
                    point: Point,
                ) -> std::result::Result<CurveLocation, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = divide , method , js_class = "PathItem" , catch)]
                fn __TSB_divide(
                    this: &PathItem_Class,
                    path: PathItem,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<PathItem, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = cubicCurveTo , method , js_class = "PathItem" , catch)]
                fn __TSB_cubic_curve_to(
                    this: &PathItem_Class,
                    handle1: Point,
                    handle2: Point,
                    to: Point,
                ) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = subtract , method , js_class = "PathItem" , catch)]
                fn __TSB_subtract(
                    this: &PathItem_Class,
                    path: PathItem,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<PathItem, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = moveBy , method , js_class = "PathItem" , catch)]
                fn __TSB_move_by(
                    this: &PathItem_Class,
                    to: Point,
                ) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = quadraticCurveTo , method , js_class = "PathItem" , catch)]
                fn __TSB_quadratic_curve_to(
                    this: &PathItem_Class,
                    handle: Point,
                    to: Point,
                ) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getCrossings , method , js_class = "PathItem" , catch)]
                fn __TSB_get_crossings(
                    this: &PathItem_Class,
                    path: PathItem,
                ) -> std::result::Result<Vec<CurveLocation>, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = curveTo , method , js_class = "PathItem" , catch)]
                fn __TSB_curve_to(
                    this: &PathItem_Class,
                    through: Point,
                    to: Point,
                    time: f64,
                ) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = arcTo , method , js_class = "PathItem" , catch)]
                fn __TSB_arc_to(
                    this: &PathItem_Class,
                    to: Point,
                    clockwise: bool,
                ) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = unite , method , js_class = "PathItem" , catch)]
                fn __TSB_unite(
                    this: &PathItem_Class,
                    path: PathItem,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<PathItem, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = flatten , method , js_class = "PathItem" , catch)]
                fn __TSB_flatten(
                    this: &PathItem_Class,
                    flatness: f64,
                ) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = intersect , method , js_class = "PathItem" , catch)]
                fn __TSB_intersect(
                    this: &PathItem_Class,
                    path: PathItem,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<PathItem, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = reorient , method , js_class = "PathItem" , catch)]
                fn __TSB_reorient(
                    this: &PathItem_Class,
                    non_zero: bool,
                    clockwise: bool,
                ) -> std::result::Result<PathItem, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = create , method , js_class = "PathItem" , catch)]
                fn __TSB_create(
                    this: &PathItem_Class,
                    object: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue>;
            }
            #[derive(std :: clone :: Clone)]
            struct PathItem(pub PathItem_Class);
            impl std::convert::From<&PathItem> for Item {
                fn from(src: &PathItem) -> Item {
                    let src: &Item_Class = src.0.as_ref();
                    Item(src.clone())
                }
            }
            impl std::convert::From<&mut PathItem> for Item {
                fn from(src: &mut PathItem) -> Item {
                    let src: &Item_Class = src.0.as_ref();
                    Item(src.clone())
                }
            }
            impl PathItem {
                #[allow(dead_code)]
                pub fn cubic_curve_by(
                    &self,
                    handle1: Point,
                    handle2: Point,
                    to: Point,
                ) -> std::result::Result<(), JsValue> {
                    let result =
                        std::result::Result::Ok(self.0.__TSB_cubic_curve_by(handle1, handle2, to)?);
                    result
                }
                #[allow(dead_code)]
                pub fn curve_by(
                    &self,
                    through: Point,
                    to: Point,
                    time: f64,
                ) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_curve_by(through, to, time)?);
                    result
                }
                #[allow(dead_code)]
                pub fn close_path(&self) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_close_path()?);
                    result
                }
                #[allow(dead_code)]
                pub fn simplify(&self, tolerance: f64) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_simplify(tolerance)?);
                    result
                }
                #[allow(dead_code)]
                pub fn reverse(&self) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_reverse()?);
                    result
                }
                #[allow(dead_code)]
                pub fn quadratic_curve_by(
                    &self,
                    handle: Point,
                    to: Point,
                ) -> std::result::Result<(), JsValue> {
                    let result =
                        std::result::Result::Ok(self.0.__TSB_quadratic_curve_by(handle, to)?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_intersections(
                    &self,
                    path: PathItem,
                    include: JsValue,
                ) -> std::result::Result<Vec<CurveLocation>, JsValue> {
                    let result =
                        std::result::Result::Ok(self.0.__TSB_get_intersections(path, include)?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_nearest_point(
                    &self,
                    point: Point,
                ) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_nearest_point(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn move_to(&self, point: Point) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_move_to(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn exclude(
                    &self,
                    path: PathItem,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<PathItem, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_exclude(path, options)?);
                    result
                }
                #[allow(dead_code)]
                pub fn interpolate(
                    &self,
                    from: PathItem,
                    to: PathItem,
                    factor: f64,
                ) -> std::result::Result<(), JsValue> {
                    let result =
                        std::result::Result::Ok(self.0.__TSB_interpolate(from, to, factor)?);
                    result
                }
                #[allow(dead_code)]
                pub fn compare(&self, path: PathItem) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_compare(path)?);
                    result
                }
                #[allow(dead_code)]
                pub fn arc_by(
                    &self,
                    to: Point,
                    clockwise: bool,
                ) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_arc_by(to, clockwise)?);
                    result
                }
                #[allow(dead_code)]
                pub fn line_to(&self, point: Point) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_line_to(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn line_by(&self, point: Point) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_line_by(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn path_data(&self) -> String {
                    let result = self.0.path_data();
                    result
                }
                #[allow(dead_code)]
                pub fn set_path_data(&self, value: String) -> () {
                    let result = self.0.set_path_data(value);
                    result
                }
                #[allow(dead_code)]
                pub fn interior_point(&self) -> Point {
                    let result = self.0.interior_point();
                    result
                }
                #[allow(dead_code)]
                pub fn set_interior_point(&self, value: Point) -> () {
                    let result = self.0.set_interior_point(value);
                    result
                }
                #[allow(dead_code)]
                pub fn clockwise(&self) -> bool {
                    let result = self.0.clockwise();
                    result
                }
                #[allow(dead_code)]
                pub fn set_clockwise(&self, value: bool) -> () {
                    let result = self.0.set_clockwise(value);
                    result
                }
                #[allow(dead_code)]
                pub fn smooth(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_smooth(options)?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_nearest_location(
                    &self,
                    point: Point,
                ) -> std::result::Result<CurveLocation, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_nearest_location(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn divide(
                    &self,
                    path: PathItem,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<PathItem, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_divide(path, options)?);
                    result
                }
                #[allow(dead_code)]
                pub fn cubic_curve_to(
                    &self,
                    handle1: Point,
                    handle2: Point,
                    to: Point,
                ) -> std::result::Result<(), JsValue> {
                    let result =
                        std::result::Result::Ok(self.0.__TSB_cubic_curve_to(handle1, handle2, to)?);
                    result
                }
                #[allow(dead_code)]
                pub fn subtract(
                    &self,
                    path: PathItem,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<PathItem, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_subtract(path, options)?);
                    result
                }
                #[allow(dead_code)]
                pub fn move_by(&self, to: Point) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_move_by(to)?);
                    result
                }
                #[allow(dead_code)]
                pub fn quadratic_curve_to(
                    &self,
                    handle: Point,
                    to: Point,
                ) -> std::result::Result<(), JsValue> {
                    let result =
                        std::result::Result::Ok(self.0.__TSB_quadratic_curve_to(handle, to)?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_crossings(
                    &self,
                    path: PathItem,
                ) -> std::result::Result<Vec<CurveLocation>, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_crossings(path)?);
                    result
                }
                #[allow(dead_code)]
                pub fn curve_to(
                    &self,
                    through: Point,
                    to: Point,
                    time: f64,
                ) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_curve_to(through, to, time)?);
                    result
                }
                #[allow(dead_code)]
                pub fn arc_to(
                    &self,
                    to: Point,
                    clockwise: bool,
                ) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_arc_to(to, clockwise)?);
                    result
                }
                #[allow(dead_code)]
                pub fn unite(
                    &self,
                    path: PathItem,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<PathItem, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_unite(path, options)?);
                    result
                }
                #[allow(dead_code)]
                pub fn flatten(&self, flatness: f64) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_flatten(flatness)?);
                    result
                }
                #[allow(dead_code)]
                pub fn intersect(
                    &self,
                    path: PathItem,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<PathItem, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_intersect(path, options)?);
                    result
                }
                #[allow(dead_code)]
                pub fn reorient(
                    &self,
                    non_zero: bool,
                    clockwise: bool,
                ) -> std::result::Result<PathItem, JsValue> {
                    let result =
                        std::result::Result::Ok(self.0.__TSB_reorient(non_zero, clockwise)?);
                    result
                }
                #[allow(dead_code)]
                pub fn create(
                    &self,
                    object: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<PathItemCreateReturn, JsValue> {
                    let result = std::result::Result::Ok(
                        ts_bindgen_rt::from_jsvalue(&self.0.__TSB_create(object)?).unwrap(),
                    );
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for PathItem {
                fn describe() {
                    <PathItem_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for PathItem {
                type Abi = <PathItem_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a PathItem {
                type Abi = <&'a PathItem_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for PathItem {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for PathItem {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: PathItem_Class =
                        <PathItem_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait PathItem_Trait: Item_Trait {
                fn cubic_curve_by(
                    &self,
                    handle1: Point,
                    handle2: Point,
                    to: Point,
                ) -> std::result::Result<(), JsValue>;
                fn curve_by(
                    &self,
                    through: Point,
                    to: Point,
                    time: f64,
                ) -> std::result::Result<(), JsValue>;
                fn close_path(&self) -> std::result::Result<(), JsValue>;
                fn simplify(&self, tolerance: f64) -> std::result::Result<bool, JsValue>;
                fn reverse(&self) -> std::result::Result<(), JsValue>;
                fn quadratic_curve_by(
                    &self,
                    handle: Point,
                    to: Point,
                ) -> std::result::Result<(), JsValue>;
                fn get_intersections(
                    &self,
                    path: PathItem,
                    include: JsValue,
                ) -> std::result::Result<Vec<CurveLocation>, JsValue>;
                fn get_nearest_point(&self, point: Point) -> std::result::Result<Point, JsValue>;
                fn move_to(&self, point: Point) -> std::result::Result<(), JsValue>;
                fn exclude(
                    &self,
                    path: PathItem,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<PathItem, JsValue>;
                fn interpolate(
                    &self,
                    from: PathItem,
                    to: PathItem,
                    factor: f64,
                ) -> std::result::Result<(), JsValue>;
                fn compare(&self, path: PathItem) -> std::result::Result<bool, JsValue>;
                fn arc_by(&self, to: Point, clockwise: bool) -> std::result::Result<(), JsValue>;
                fn line_to(&self, point: Point) -> std::result::Result<(), JsValue>;
                fn line_by(&self, point: Point) -> std::result::Result<(), JsValue>;
                fn path_data(&self) -> String;
                fn set_path_data(&mut self, value: String) -> ();
                fn interior_point(&self) -> Point;
                fn set_interior_point(&mut self, value: Point) -> ();
                fn clockwise(&self) -> bool;
                fn set_clockwise(&mut self, value: bool) -> ();
                fn smooth(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<(), JsValue>;
                fn get_nearest_location(
                    &self,
                    point: Point,
                ) -> std::result::Result<CurveLocation, JsValue>;
                fn divide(
                    &self,
                    path: PathItem,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<PathItem, JsValue>;
                fn cubic_curve_to(
                    &self,
                    handle1: Point,
                    handle2: Point,
                    to: Point,
                ) -> std::result::Result<(), JsValue>;
                fn subtract(
                    &self,
                    path: PathItem,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<PathItem, JsValue>;
                fn move_by(&self, to: Point) -> std::result::Result<(), JsValue>;
                fn quadratic_curve_to(
                    &self,
                    handle: Point,
                    to: Point,
                ) -> std::result::Result<(), JsValue>;
                fn get_crossings(
                    &self,
                    path: PathItem,
                ) -> std::result::Result<Vec<CurveLocation>, JsValue>;
                fn curve_to(
                    &self,
                    through: Point,
                    to: Point,
                    time: f64,
                ) -> std::result::Result<(), JsValue>;
                fn arc_to(&self, to: Point, clockwise: bool) -> std::result::Result<(), JsValue>;
                fn unite(
                    &self,
                    path: PathItem,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<PathItem, JsValue>;
                fn flatten(&self, flatness: f64) -> std::result::Result<(), JsValue>;
                fn intersect(
                    &self,
                    path: PathItem,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<PathItem, JsValue>;
                fn reorient(
                    &self,
                    non_zero: bool,
                    clockwise: bool,
                ) -> std::result::Result<PathItem, JsValue>;
                fn create(
                    &self,
                    object: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<PathItemCreateReturn, JsValue>;
            }
            impl Item_Trait for PathItem {
                fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::insert_below(&target, item)
                }
                fn on_double_click(&self) -> ItemOnDoubleClick {
                    let target: Item = self.into();
                    Item::on_double_click(&target)
                }
                fn set_on_double_click(&mut self, value: ItemOnDoubleClick) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_double_click(&mut target, value)
                }
                fn view(&self) -> View {
                    let target: Item = self.into();
                    Item::view(&target)
                }
                fn set_view(&mut self, value: View) -> () {
                    let mut target: Item = self.into();
                    Item::set_view(&mut target, value)
                }
                fn blend_mode(&self) -> String {
                    let target: Item = self.into();
                    Item::blend_mode(&target)
                }
                fn set_blend_mode(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_blend_mode(&mut target, value)
                }
                fn name(&self) -> String {
                    let target: Item = self.into();
                    Item::name(&target)
                }
                fn set_name(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_name(&mut target, value)
                }
                fn project(&self) -> Project {
                    let target: Item = self.into();
                    Item::project(&target)
                }
                fn set_project(&mut self, value: Project) -> () {
                    let mut target: Item = self.into();
                    Item::set_project(&mut target, value)
                }
                fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_child(&target, item)
                }
                fn global_matrix(&self) -> Matrix {
                    let target: Item = self.into();
                    Item::global_matrix(&target)
                }
                fn set_global_matrix(&mut self, value: Matrix) -> () {
                    let mut target: Item = self.into();
                    Item::set_global_matrix(&mut target, value)
                }
                fn on_mouse_leave(&self) -> ItemOnMouseLeave {
                    let target: Item = self.into();
                    Item::on_mouse_leave(&target)
                }
                fn set_on_mouse_leave(&mut self, value: ItemOnMouseLeave) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_leave(&mut target, value)
                }
                fn has_children(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_children(&target)
                }
                fn selected(&self) -> bool {
                    let target: Item = self.into();
                    Item::selected(&target)
                }
                fn set_selected(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_selected(&mut target, value)
                }
                fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::global_to_local(&target, point)
                }
                fn shadow_blur(&self) -> f64 {
                    let target: Item = self.into();
                    Item::shadow_blur(&target)
                }
                fn set_shadow_blur(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_shadow_blur(&mut target, value)
                }
                fn children(&self) -> Vec<Item> {
                    let target: Item = self.into();
                    Item::children(&target)
                }
                fn set_children(&mut self, value: Vec<Item>) -> () {
                    let mut target: Item = self.into();
                    Item::set_children(&mut target, value)
                }
                fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::replace_with(&target, item)
                }
                fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::import_json(&target, json)
                }
                fn insert_child(
                    &self,
                    index: f64,
                    item: Item,
                ) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::insert_child(&target, index, item)
                }
                fn stroke_join(&self) -> String {
                    let target: Item = self.into();
                    Item::stroke_join(&target)
                }
                fn set_stroke_join(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_join(&mut target, value)
                }
                fn rotation(&self) -> f64 {
                    let target: Item = self.into();
                    Item::rotation(&target)
                }
                fn set_rotation(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_rotation(&mut target, value)
                }
                fn scaling(&self) -> Point {
                    let target: Item = self.into();
                    Item::scaling(&target)
                }
                fn set_scaling(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_scaling(&mut target, value)
                }
                fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_ancestor(&target, item)
                }
                fn emit(
                    &self,
                    type_: String,
                    event: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::emit(&target, type_, event)
                }
                fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_up(&target)
                }
                fn add_to(
                    &self,
                    owner: ItemAddToParamsOwnerParam,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::add_to(&target, owner)
                }
                fn stroke_cap(&self) -> String {
                    let target: Item = self.into();
                    Item::stroke_cap(&target)
                }
                fn set_stroke_cap(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_cap(&mut target, value)
                }
                fn on_mouse_drag(&self) -> ItemOnMouseDrag {
                    let target: Item = self.into();
                    Item::on_mouse_drag(&target)
                }
                fn set_on_mouse_drag(&mut self, value: ItemOnMouseDrag) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_drag(&mut target, value)
                }
                fn set(
                    &self,
                    props: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::set(&target, props)
                }
                fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::reverse_children(&target)
                }
                fn matches(
                    &self,
                    name: String,
                    compare: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::matches(&target, name, compare)
                }
                fn on_mouse_enter(&self) -> ItemOnMouseEnter {
                    let target: Item = self.into();
                    Item::on_mouse_enter(&target)
                }
                fn set_on_mouse_enter(&mut self, value: ItemOnMouseEnter) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_enter(&mut target, value)
                }
                fn shadow_offset(&self) -> Point {
                    let target: Item = self.into();
                    Item::shadow_offset(&target)
                }
                fn set_shadow_offset(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_shadow_offset(&mut target, value)
                }
                fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_stroke(&target)
                }
                fn view_matrix(&self) -> Matrix {
                    let target: Item = self.into();
                    Item::view_matrix(&target)
                }
                fn set_view_matrix(&mut self, value: Matrix) -> () {
                    let mut target: Item = self.into();
                    Item::set_view_matrix(&mut target, value)
                }
                fn on_frame(&self) -> ItemOnFrame {
                    let target: Item = self.into();
                    Item::on_frame(&target)
                }
                fn set_on_frame(&mut self, value: ItemOnFrame) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_frame(&mut target, value)
                }
                fn on_mouse_down(&self) -> ItemOnMouseDown {
                    let target: Item = self.into();
                    Item::on_mouse_down(&target)
                }
                fn set_on_mouse_down(&mut self, value: ItemOnMouseDown) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_down(&mut target, value)
                }
                fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_sibling(&target, item)
                }
                fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::local_to_global(&target, point)
                }
                fn first_child(&self) -> Item {
                    let target: Item = self.into();
                    Item::first_child(&target)
                }
                fn set_first_child(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_first_child(&mut target, value)
                }
                fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::send_to_back(&target)
                }
                fn clip_mask(&self) -> bool {
                    let target: Item = self.into();
                    Item::clip_mask(&target)
                }
                fn set_clip_mask(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_clip_mask(&mut target, value)
                }
                fn next_sibling(&self) -> Item {
                    let target: Item = self.into();
                    Item::next_sibling(&target)
                }
                fn set_next_sibling(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_next_sibling(&mut target, value)
                }
                fn off(
                    &self,
                    object: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::off(&target, object)
                }
                fn rotate(&self, angle: f64, center: Point) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::rotate(&target, angle, center)
                }
                fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::add_child(&target, item)
                }
                fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_grouped_with(&target, item)
                }
                fn scale(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::scale(&target, hor, ver, center)
                }
                fn hit_test_all(
                    &self,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Vec<HitResult>, JsValue> {
                    let target: Item = self.into();
                    Item::hit_test_all(&target, point, options)
                }
                fn insert_children(
                    &self,
                    index: f64,
                    items: Vec<Item>,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::insert_children(&target, index, items)
                }
                fn style(&self) -> Style {
                    let target: Item = self.into();
                    Item::style(&target)
                }
                fn set_style(&mut self, value: Style) -> () {
                    let mut target: Item = self.into();
                    Item::set_style(&mut target, value)
                }
                fn position(&self) -> Point {
                    let target: Item = self.into();
                    Item::position(&target)
                }
                fn set_position(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_position(&mut target, value)
                }
                fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::transform(&target, matrix)
                }
                fn fill_color(&self) -> ItemFillColor {
                    let target: Item = self.into();
                    Item::fill_color(&target)
                }
                fn set_fill_color(&mut self, value: ItemFillColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_fill_color(&mut target, value)
                }
                fn matrix(&self) -> Matrix {
                    let target: Item = self.into();
                    Item::matrix(&target)
                }
                fn set_matrix(&mut self, value: Matrix) -> () {
                    let mut target: Item = self.into();
                    Item::set_matrix(&mut target, value)
                }
                fn id(&self) -> f64 {
                    let target: Item = self.into();
                    Item::id(&target)
                }
                fn set_id(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_id(&mut target, value)
                }
                fn tween(
                    &self,
                    options: ItemTweenParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let target: Item = self.into();
                    Item::tween(&target, options)
                }
                fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::reduce(&target, options)
                }
                fn internal_bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::internal_bounds(&target)
                }
                fn set_internal_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_internal_bounds(&mut target, value)
                }
                fn fill_rule(&self) -> String {
                    let target: Item = self.into();
                    Item::fill_rule(&target)
                }
                fn set_fill_rule(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_fill_rule(&mut target, value)
                }
                fn shadow_color(&self) -> ItemShadowColor {
                    let target: Item = self.into();
                    Item::shadow_color(&target)
                }
                fn set_shadow_color(&mut self, value: ItemShadowColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_shadow_color(&mut target, value)
                }
                fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::insert_above(&target, item)
                }
                fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::responds(&target, type_)
                }
                fn handle_bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::handle_bounds(&target)
                }
                fn set_handle_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_handle_bounds(&mut target, value)
                }
                fn skew(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::skew(&target, hor, ver, center)
                }
                fn on_click(&self) -> ItemOnClick {
                    let target: Item = self.into();
                    Item::on_click(&target)
                }
                fn set_on_click(&mut self, value: ItemOnClick) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_click(&mut target, value)
                }
                fn get_items(
                    &self,
                    options: ItemGetItemsParamsOptionsParam,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::get_items(&target, options)
                }
                fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_inserted(&target)
                }
                fn get_item(
                    &self,
                    options: ItemGetItemParamsOptionsParam,
                ) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::get_item(&target, options)
                }
                fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_fill(&target)
                }
                fn shear(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::shear(&target, hor, ver, center)
                }
                fn visible(&self) -> bool {
                    let target: Item = self.into();
                    Item::visible(&target)
                }
                fn set_visible(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_visible(&mut target, value)
                }
                fn previous_sibling(&self) -> Item {
                    let target: Item = self.into();
                    Item::previous_sibling(&target)
                }
                fn set_previous_sibling(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_previous_sibling(&mut target, value)
                }
                fn hit_test(
                    &self,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<HitResult, JsValue> {
                    let target: Item = self.into();
                    Item::hit_test(&target, point, options)
                }
                fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_descendant(&target, item)
                }
                fn locked(&self) -> bool {
                    let target: Item = self.into();
                    Item::locked(&target)
                }
                fn set_locked(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_locked(&mut target, value)
                }
                fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_parent(&target, item)
                }
                fn copy_attributes(
                    &self,
                    source: Item,
                    exclude_matrix: bool,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::copy_attributes(&target, source, exclude_matrix)
                }
                fn last_child(&self) -> Item {
                    let target: Item = self.into();
                    Item::last_child(&target)
                }
                fn set_last_child(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_last_child(&mut target, value)
                }
                fn stroke_width(&self) -> f64 {
                    let target: Item = self.into();
                    Item::stroke_width(&target)
                }
                fn set_stroke_width(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_width(&mut target, value)
                }
                fn parent(&self) -> Item {
                    let target: Item = self.into();
                    Item::parent(&target)
                }
                fn set_parent(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_parent(&mut target, value)
                }
                fn stroke_bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::stroke_bounds(&target)
                }
                fn set_stroke_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_bounds(&mut target, value)
                }
                fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::translate(&target, delta)
                }
                fn remove(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::remove(&target)
                }
                fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::parent_to_local(&target, point)
                }
                fn bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::bounds(&target)
                }
                fn set_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_bounds(&mut target, value)
                }
                fn add_children(
                    &self,
                    items: Vec<Item>,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::add_children(&target, items)
                }
                fn dash_array(&self) -> Vec<f64> {
                    let target: Item = self.into();
                    Item::dash_array(&target)
                }
                fn set_dash_array(&mut self, value: Vec<f64>) -> () {
                    let mut target: Item = self.into();
                    Item::set_dash_array(&mut target, value)
                }
                fn on_mouse_up(&self) -> ItemOnMouseUp {
                    let target: Item = self.into();
                    Item::on_mouse_up(&target)
                }
                fn set_on_mouse_up(&mut self, value: ItemOnMouseUp) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_up(&mut target, value)
                }
                fn on(
                    &self,
                    object: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::on(&target, object)
                }
                fn remove_on(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on(&target, options)
                }
                fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_below(&target, item)
                }
                fn apply_matrix(&self) -> bool {
                    let target: Item = self.into();
                    Item::apply_matrix(&target)
                }
                fn set_apply_matrix(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_apply_matrix(&mut target, value)
                }
                fn clone(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::clone(&target, options)
                }
                fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::contains(&target, point)
                }
                fn export_json(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<String, JsValue> {
                    let target: Item = self.into();
                    Item::export_json(&target, options)
                }
                fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::bring_to_front(&target)
                }
                fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_above(&target, item)
                }
                fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_drag(&target)
                }
                fn data(&self) -> JsValue {
                    let target: Item = self.into();
                    Item::data(&target)
                }
                fn set_data(&mut self, value: JsValue) -> () {
                    let mut target: Item = self.into();
                    Item::set_data(&mut target, value)
                }
                fn import_svg(
                    &self,
                    svg: ItemImportSvgParamsSvgParam,
                    on_load: JsValue,
                ) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::import_svg(&target, svg, on_load)
                }
                fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_shadow(&target)
                }
                fn selected_color(&self) -> ItemSelectedColor {
                    let target: Item = self.into();
                    Item::selected_color(&target)
                }
                fn set_selected_color(&mut self, value: ItemSelectedColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_selected_color(&mut target, value)
                }
                fn class_name(&self) -> String {
                    let target: Item = self.into();
                    Item::class_name(&target)
                }
                fn set_class_name(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_class_name(&mut target, value)
                }
                fn export_svg(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                    let target: Item = self.into();
                    Item::export_svg(&target, options)
                }
                fn tween_to(
                    &self,
                    to: std::collections::HashMap<String, JsValue>,
                    options: ItemTweenToParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let target: Item = self.into();
                    Item::tween_to(&target, to, options)
                }
                fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_inside(&target, rect)
                }
                fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_empty(&target, recursively)
                }
                fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::copy_content(&target, source)
                }
                fn rasterize(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Raster, JsValue> {
                    let target: Item = self.into();
                    Item::rasterize(&target, options)
                }
                fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_move(&target)
                }
                fn tween_from(
                    &self,
                    from: std::collections::HashMap<String, JsValue>,
                    options: ItemTweenFromParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let target: Item = self.into();
                    Item::tween_from(&target, from, options)
                }
                fn opacity(&self) -> f64 {
                    let target: Item = self.into();
                    Item::opacity(&target)
                }
                fn set_opacity(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_opacity(&mut target, value)
                }
                fn dash_offset(&self) -> f64 {
                    let target: Item = self.into();
                    Item::dash_offset(&target)
                }
                fn set_dash_offset(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_dash_offset(&mut target, value)
                }
                fn remove_children(
                    &self,
                    start: f64,
                    end: f64,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::remove_children(&target, start, end)
                }
                fn on_mouse_move(&self) -> ItemOnMouseMove {
                    let target: Item = self.into();
                    Item::on_mouse_move(&target)
                }
                fn set_on_mouse_move(&mut self, value: ItemOnMouseMove) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_move(&mut target, value)
                }
                fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::intersects(&target, item)
                }
                fn pivot(&self) -> Point {
                    let target: Item = self.into();
                    Item::pivot(&target)
                }
                fn set_pivot(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_pivot(&mut target, value)
                }
                fn copy_to(
                    &self,
                    owner: ItemCopyToParamsOwnerParam,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::copy_to(&target, owner)
                }
                fn index(&self) -> f64 {
                    let target: Item = self.into();
                    Item::index(&target)
                }
                fn set_index(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_index(&mut target, value)
                }
                fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::local_to_parent(&target, point)
                }
                fn stroke_color(&self) -> ItemStrokeColor {
                    let target: Item = self.into();
                    Item::stroke_color(&target)
                }
                fn set_stroke_color(&mut self, value: ItemStrokeColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_color(&mut target, value)
                }
                fn layer(&self) -> Layer {
                    let target: Item = self.into();
                    Item::layer(&target)
                }
                fn set_layer(&mut self, value: Layer) -> () {
                    let mut target: Item = self.into();
                    Item::set_layer(&mut target, value)
                }
                fn stroke_scaling(&self) -> bool {
                    let target: Item = self.into();
                    Item::stroke_scaling(&target)
                }
                fn set_stroke_scaling(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_scaling(&mut target, value)
                }
                fn fit_bounds(
                    &self,
                    rectangle: Rectangle,
                    fill: bool,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::fit_bounds(&target, rectangle, fill)
                }
                fn miter_limit(&self) -> f64 {
                    let target: Item = self.into();
                    Item::miter_limit(&target)
                }
                fn set_miter_limit(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_miter_limit(&mut target, value)
                }
                fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_down(&target)
                }
            }
            impl PathItem_Trait for PathItem {}
            impl std::clone::Clone for PathItem_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for PathItem_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for PathItem_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                # [wasm_bindgen (js_name = "Rectangle" , extends = Shape_Class)]
                type Rectangle_Class;
                #[wasm_bindgen(constructor, js_class = "Rectangle")]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Rectangle_Class;
            }
            #[derive(std :: clone :: Clone)]
            struct Rectangle(pub Rectangle_Class);
            impl std::convert::From<&Rectangle> for Shape {
                fn from(src: &Rectangle) -> Shape {
                    let src: &Shape_Class = src.0.as_ref();
                    Shape(src.clone())
                }
            }
            impl std::convert::From<&mut Rectangle> for Shape {
                fn from(src: &mut Rectangle) -> Shape {
                    let src: &Shape_Class = src.0.as_ref();
                    Shape(src.clone())
                }
            }
            impl Rectangle {
                #[allow(dead_code)]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Rectangle {
                    let result = Rectangle_Class::new(object);
                    let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                    Rectangle(result)
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for Rectangle {
                fn describe() {
                    <Rectangle_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for Rectangle {
                type Abi = <Rectangle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Rectangle {
                type Abi = <&'a Rectangle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for Rectangle {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Rectangle {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: Rectangle_Class =
                        <Rectangle_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait Rectangle_Trait: Shape_Trait {
                fn new(object: std::collections::HashMap<String, JsValue>) -> Rectangle;
            }
            impl Shape_Trait for Rectangle {}
            impl Rectangle_Trait for Rectangle {}
            impl std::clone::Clone for Rectangle_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for Rectangle_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Rectangle_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ToolOnKeyDown {
                TsBindgenRtNullCase,
                JsValueCase(JsValue),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum PaperScopeSetupParamsElementParam {
                SizeCase(Size),
                StringCase(String),
                JsValueCase(JsValue),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ToolOnKeyUp {
                TsBindgenRtNullCase,
                JsValueCase(JsValue),
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                # [wasm_bindgen (js_name = "Path" , extends = PathItem_Class)]
                type Path_Class;
                # [wasm_bindgen (method , structural , getter = length , js_class = "Path")]
                fn length(this: &Path_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = length , js_class = "Path")]
                fn set_length(this: &Path_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getNormalAt , method , js_class = "Path" , catch)]
                fn __TSB_get_normal_at(
                    this: &Path_Class,
                    offset: f64,
                ) -> std::result::Result<Point, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getWeightedNormalAt , method , js_class = "Path" , catch)]
                fn __TSB_get_weighted_normal_at(
                    this: &Path_Class,
                    offset: f64,
                ) -> std::result::Result<Point, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = add , method , js_class = "Path" , catch , variadic)]
                fn __TSB_add(
                    this: &Path_Class,
                    segment: &[JsValue],
                ) -> std::result::Result<JsValue, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getOffsetsWithTangent , method , js_class = "Path" , catch)]
                fn __TSB_get_offsets_with_tangent(
                    this: &Path_Class,
                    tangent: Point,
                ) -> std::result::Result<Vec<f64>, JsValue>;
                # [wasm_bindgen (method , structural , getter = firstSegment , js_class = "Path")]
                fn first_segment(this: &Path_Class) -> Segment;
                # [wasm_bindgen (method , structural , setter = firstSegment , js_class = "Path")]
                fn set_first_segment(this: &Path_Class, value: Segment);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = toShape , method , js_class = "Path" , catch)]
                fn __TSB_to_shape(
                    this: &Path_Class,
                    insert: bool,
                ) -> std::result::Result<Shape, JsValue>;
                #[wasm_bindgen(constructor, js_class = "Path")]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Path_Class;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getTangentAt , method , js_class = "Path" , catch)]
                fn __TSB_get_tangent_at(
                    this: &Path_Class,
                    offset: f64,
                ) -> std::result::Result<Point, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = join , method , js_class = "Path" , catch)]
                fn __TSB_join(
                    this: &Path_Class,
                    path: Path,
                    tolerance: f64,
                ) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getWeightedTangentAt , method , js_class = "Path" , catch)]
                fn __TSB_get_weighted_tangent_at(
                    this: &Path_Class,
                    offset: f64,
                ) -> std::result::Result<Point, JsValue>;
                # [wasm_bindgen (method , structural , getter = fullySelected , js_class = "Path")]
                fn fully_selected(this: &Path_Class) -> bool;
                # [wasm_bindgen (method , structural , setter = fullySelected , js_class = "Path")]
                fn set_fully_selected(this: &Path_Class, value: bool);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = reduce , method , js_class = "Path" , catch)]
                fn __TSB_reduce(
                    this: &Path_Class,
                    options: JsValue,
                ) -> std::result::Result<Path, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = addSegments , method , js_class = "Path" , catch)]
                fn __TSB_add_segments(
                    this: &Path_Class,
                    segments: Vec<Segment>,
                ) -> std::result::Result<Vec<Segment>, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = splitAt , method , js_class = "Path" , catch)]
                fn __TSB_split_at(
                    this: &Path_Class,
                    location: JsValue,
                ) -> std::result::Result<Path, JsValue>;
                # [wasm_bindgen (method , structural , getter = lastCurve , js_class = "Path")]
                fn last_curve(this: &Path_Class) -> Curve;
                # [wasm_bindgen (method , structural , setter = lastCurve , js_class = "Path")]
                fn set_last_curve(this: &Path_Class, value: Curve);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = removeSegments , method , js_class = "Path" , catch)]
                fn __TSB_remove_segments(
                    this: &Path_Class,
                    from: f64,
                    to: f64,
                ) -> std::result::Result<Vec<Segment>, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getLocationOf , method , js_class = "Path" , catch)]
                fn __TSB_get_location_of(
                    this: &Path_Class,
                    point: Point,
                ) -> std::result::Result<CurveLocation, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = hasHandles , method , js_class = "Path" , catch)]
                fn __TSB_has_handles(this: &Path_Class) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getOffsetOf , method , js_class = "Path" , catch)]
                fn __TSB_get_offset_of(
                    this: &Path_Class,
                    point: Point,
                ) -> std::result::Result<f64, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getPointAt , method , js_class = "Path" , catch)]
                fn __TSB_get_point_at(
                    this: &Path_Class,
                    offset: f64,
                ) -> std::result::Result<Point, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = insert , method , js_class = "Path" , catch)]
                fn __TSB_insert(
                    this: &Path_Class,
                    index: f64,
                    segment: JsValue,
                ) -> std::result::Result<Segment, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = insertSegments , method , js_class = "Path" , catch)]
                fn __TSB_insert_segments(
                    this: &Path_Class,
                    index: f64,
                    segments: Vec<Segment>,
                ) -> std::result::Result<Vec<Segment>, JsValue>;
                # [wasm_bindgen (method , structural , getter = lastSegment , js_class = "Path")]
                fn last_segment(this: &Path_Class) -> Segment;
                # [wasm_bindgen (method , structural , setter = lastSegment , js_class = "Path")]
                fn set_last_segment(this: &Path_Class, value: Segment);
                # [wasm_bindgen (method , structural , getter = segments , js_class = "Path")]
                fn segments(this: &Path_Class) -> Vec<Segment>;
                # [wasm_bindgen (method , structural , setter = segments , js_class = "Path")]
                fn set_segments(this: &Path_Class, value: Vec<Segment>);
                # [wasm_bindgen (method , structural , getter = closed , js_class = "Path")]
                fn closed(this: &Path_Class) -> bool;
                # [wasm_bindgen (method , structural , setter = closed , js_class = "Path")]
                fn set_closed(this: &Path_Class, value: bool);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getLocationAt , method , js_class = "Path" , catch)]
                fn __TSB_get_location_at(
                    this: &Path_Class,
                    offset: f64,
                ) -> std::result::Result<CurveLocation, JsValue>;
                # [wasm_bindgen (method , structural , getter = curves , js_class = "Path")]
                fn curves(this: &Path_Class) -> Vec<Curve>;
                # [wasm_bindgen (method , structural , setter = curves , js_class = "Path")]
                fn set_curves(this: &Path_Class, value: Vec<Curve>);
                # [wasm_bindgen (method , structural , getter = firstCurve , js_class = "Path")]
                fn first_curve(this: &Path_Class) -> Curve;
                # [wasm_bindgen (method , structural , setter = firstCurve , js_class = "Path")]
                fn set_first_curve(this: &Path_Class, value: Curve);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getCurvatureAt , method , js_class = "Path" , catch)]
                fn __TSB_get_curvature_at(
                    this: &Path_Class,
                    offset: f64,
                ) -> std::result::Result<f64, JsValue>;
                # [wasm_bindgen (method , structural , getter = area , js_class = "Path")]
                fn area(this: &Path_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = area , js_class = "Path")]
                fn set_area(this: &Path_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = clearHandles , method , js_class = "Path" , catch)]
                fn __TSB_clear_handles(this: &Path_Class) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = removeSegment , method , js_class = "Path" , catch)]
                fn __TSB_remove_segment(
                    this: &Path_Class,
                    index: f64,
                ) -> std::result::Result<Segment, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = divideAt , method , js_class = "Path" , catch)]
                fn __TSB_divide_at(
                    this: &Path_Class,
                    location: JsValue,
                ) -> std::result::Result<Segment, JsValue>;
            }
            #[derive(std :: clone :: Clone)]
            struct Path(pub Path_Class);
            impl std::convert::From<&Path> for PathItem {
                fn from(src: &Path) -> PathItem {
                    let src: &PathItem_Class = src.0.as_ref();
                    PathItem(src.clone())
                }
            }
            impl std::convert::From<&mut Path> for PathItem {
                fn from(src: &mut Path) -> PathItem {
                    let src: &PathItem_Class = src.0.as_ref();
                    PathItem(src.clone())
                }
            }
            impl Path {
                #[allow(dead_code)]
                pub fn length(&self) -> f64 {
                    let result = self.0.length();
                    result
                }
                #[allow(dead_code)]
                pub fn set_length(&self, value: f64) -> () {
                    let result = self.0.set_length(value);
                    result
                }
                #[allow(dead_code)]
                pub fn get_normal_at(&self, offset: f64) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_normal_at(offset)?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_weighted_normal_at(
                    &self,
                    offset: f64,
                ) -> std::result::Result<Point, JsValue> {
                    let result =
                        std::result::Result::Ok(self.0.__TSB_get_weighted_normal_at(offset)?);
                    result
                }
                #[allow(dead_code)]
                pub fn add(
                    &self,
                    segment: &[PathAddParamsSegmentParam],
                ) -> std::result::Result<PathAddReturn, JsValue> {
                    let result = std::result::Result::Ok(
                        ts_bindgen_rt::from_jsvalue(
                            &self.0.__TSB_add(
                                ts_bindgen_rt::to_jsvalue(&segment)
                                    .map_err(ts_bindgen_rt::Error::from)?,
                            )?,
                        )
                        .unwrap(),
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn get_offsets_with_tangent(
                    &self,
                    tangent: Point,
                ) -> std::result::Result<Vec<f64>, JsValue> {
                    let result =
                        std::result::Result::Ok(self.0.__TSB_get_offsets_with_tangent(tangent)?);
                    result
                }
                #[allow(dead_code)]
                pub fn first_segment(&self) -> Segment {
                    let result = self.0.first_segment();
                    result
                }
                #[allow(dead_code)]
                pub fn set_first_segment(&self, value: Segment) -> () {
                    let result = self.0.set_first_segment(value);
                    result
                }
                #[allow(dead_code)]
                pub fn to_shape(&self, insert: bool) -> std::result::Result<Shape, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_to_shape(insert)?);
                    result
                }
                #[allow(dead_code)]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Path {
                    let result = Path_Class::new(object);
                    let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                    Path(result)
                }
                #[allow(dead_code)]
                pub fn get_tangent_at(&self, offset: f64) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_tangent_at(offset)?);
                    result
                }
                #[allow(dead_code)]
                pub fn join(&self, path: Path, tolerance: f64) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_join(path, tolerance)?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_weighted_tangent_at(
                    &self,
                    offset: f64,
                ) -> std::result::Result<Point, JsValue> {
                    let result =
                        std::result::Result::Ok(self.0.__TSB_get_weighted_tangent_at(offset)?);
                    result
                }
                #[allow(dead_code)]
                pub fn fully_selected(&self) -> bool {
                    let result = self.0.fully_selected();
                    result
                }
                #[allow(dead_code)]
                pub fn set_fully_selected(&self, value: bool) -> () {
                    let result = self.0.set_fully_selected(value);
                    result
                }
                #[allow(dead_code)]
                pub fn reduce(&self, options: JsValue) -> std::result::Result<Path, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_reduce(options)?);
                    result
                }
                #[allow(dead_code)]
                pub fn add_segments(
                    &self,
                    segments: Vec<Segment>,
                ) -> std::result::Result<Vec<Segment>, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_add_segments(segments)?);
                    result
                }
                #[allow(dead_code)]
                pub fn split_at(
                    &self,
                    location: PathSplitAtParamsLocationParam,
                ) -> std::result::Result<Path, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_split_at(
                        ts_bindgen_rt::to_jsvalue(&location).map_err(ts_bindgen_rt::Error::from)?,
                    )?);
                    result
                }
                #[allow(dead_code)]
                pub fn last_curve(&self) -> Curve {
                    let result = self.0.last_curve();
                    result
                }
                #[allow(dead_code)]
                pub fn set_last_curve(&self, value: Curve) -> () {
                    let result = self.0.set_last_curve(value);
                    result
                }
                #[allow(dead_code)]
                pub fn remove_segments(
                    &self,
                    from: f64,
                    to: f64,
                ) -> std::result::Result<Vec<Segment>, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_remove_segments(from, to)?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_location_of(
                    &self,
                    point: Point,
                ) -> std::result::Result<CurveLocation, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_location_of(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_has_handles()?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_offset_of(&self, point: Point) -> std::result::Result<f64, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_offset_of(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_point_at(&self, offset: f64) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_point_at(offset)?);
                    result
                }
                #[allow(dead_code)]
                pub fn insert(
                    &self,
                    index: f64,
                    segment: PathInsertParamsSegmentParam,
                ) -> std::result::Result<Segment, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_insert(
                        index,
                        ts_bindgen_rt::to_jsvalue(&segment).map_err(ts_bindgen_rt::Error::from)?,
                    )?);
                    result
                }
                #[allow(dead_code)]
                pub fn insert_segments(
                    &self,
                    index: f64,
                    segments: Vec<Segment>,
                ) -> std::result::Result<Vec<Segment>, JsValue> {
                    let result =
                        std::result::Result::Ok(self.0.__TSB_insert_segments(index, segments)?);
                    result
                }
                #[allow(dead_code)]
                pub fn last_segment(&self) -> Segment {
                    let result = self.0.last_segment();
                    result
                }
                #[allow(dead_code)]
                pub fn set_last_segment(&self, value: Segment) -> () {
                    let result = self.0.set_last_segment(value);
                    result
                }
                #[allow(dead_code)]
                pub fn segments(&self) -> Vec<Segment> {
                    let result = self.0.segments();
                    result
                }
                #[allow(dead_code)]
                pub fn set_segments(&self, value: Vec<Segment>) -> () {
                    let result = self.0.set_segments(value);
                    result
                }
                #[allow(dead_code)]
                pub fn closed(&self) -> bool {
                    let result = self.0.closed();
                    result
                }
                #[allow(dead_code)]
                pub fn set_closed(&self, value: bool) -> () {
                    let result = self.0.set_closed(value);
                    result
                }
                #[allow(dead_code)]
                pub fn get_location_at(
                    &self,
                    offset: f64,
                ) -> std::result::Result<CurveLocation, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_location_at(offset)?);
                    result
                }
                #[allow(dead_code)]
                pub fn curves(&self) -> Vec<Curve> {
                    let result = self.0.curves();
                    result
                }
                #[allow(dead_code)]
                pub fn set_curves(&self, value: Vec<Curve>) -> () {
                    let result = self.0.set_curves(value);
                    result
                }
                #[allow(dead_code)]
                pub fn first_curve(&self) -> Curve {
                    let result = self.0.first_curve();
                    result
                }
                #[allow(dead_code)]
                pub fn set_first_curve(&self, value: Curve) -> () {
                    let result = self.0.set_first_curve(value);
                    result
                }
                #[allow(dead_code)]
                pub fn get_curvature_at(&self, offset: f64) -> std::result::Result<f64, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_curvature_at(offset)?);
                    result
                }
                #[allow(dead_code)]
                pub fn area(&self) -> f64 {
                    let result = self.0.area();
                    result
                }
                #[allow(dead_code)]
                pub fn set_area(&self, value: f64) -> () {
                    let result = self.0.set_area(value);
                    result
                }
                #[allow(dead_code)]
                pub fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_clear_handles()?);
                    result
                }
                #[allow(dead_code)]
                pub fn remove_segment(&self, index: f64) -> std::result::Result<Segment, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_remove_segment(index)?);
                    result
                }
                #[allow(dead_code)]
                pub fn divide_at(
                    &self,
                    location: PathDivideAtParamsLocationParam,
                ) -> std::result::Result<Segment, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_divide_at(
                        ts_bindgen_rt::to_jsvalue(&location).map_err(ts_bindgen_rt::Error::from)?,
                    )?);
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for Path {
                fn describe() {
                    <Path_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for Path {
                type Abi = <Path_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Path {
                type Abi = <&'a Path_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for Path {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Path {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: Path_Class =
                        <Path_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait Path_Trait: PathItem_Trait {
                fn length(&self) -> f64;
                fn set_length(&mut self, value: f64) -> ();
                fn get_normal_at(&self, offset: f64) -> std::result::Result<Point, JsValue>;
                fn get_weighted_normal_at(
                    &self,
                    offset: f64,
                ) -> std::result::Result<Point, JsValue>;
                fn add(
                    &self,
                    segment: &[PathAddParamsSegmentParam],
                ) -> std::result::Result<PathAddReturn, JsValue>;
                fn get_offsets_with_tangent(
                    &self,
                    tangent: Point,
                ) -> std::result::Result<Vec<f64>, JsValue>;
                fn first_segment(&self) -> Segment;
                fn set_first_segment(&mut self, value: Segment) -> ();
                fn to_shape(&self, insert: bool) -> std::result::Result<Shape, JsValue>;
                fn new(object: std::collections::HashMap<String, JsValue>) -> Path;
                fn get_tangent_at(&self, offset: f64) -> std::result::Result<Point, JsValue>;
                fn join(&self, path: Path, tolerance: f64) -> std::result::Result<(), JsValue>;
                fn get_weighted_tangent_at(
                    &self,
                    offset: f64,
                ) -> std::result::Result<Point, JsValue>;
                fn fully_selected(&self) -> bool;
                fn set_fully_selected(&mut self, value: bool) -> ();
                fn reduce(&self, options: JsValue) -> std::result::Result<Path, JsValue>;
                fn add_segments(
                    &self,
                    segments: Vec<Segment>,
                ) -> std::result::Result<Vec<Segment>, JsValue>;
                fn split_at(
                    &self,
                    location: PathSplitAtParamsLocationParam,
                ) -> std::result::Result<Path, JsValue>;
                fn last_curve(&self) -> Curve;
                fn set_last_curve(&mut self, value: Curve) -> ();
                fn remove_segments(
                    &self,
                    from: f64,
                    to: f64,
                ) -> std::result::Result<Vec<Segment>, JsValue>;
                fn get_location_of(
                    &self,
                    point: Point,
                ) -> std::result::Result<CurveLocation, JsValue>;
                fn has_handles(&self) -> std::result::Result<bool, JsValue>;
                fn get_offset_of(&self, point: Point) -> std::result::Result<f64, JsValue>;
                fn get_point_at(&self, offset: f64) -> std::result::Result<Point, JsValue>;
                fn insert(
                    &self,
                    index: f64,
                    segment: PathInsertParamsSegmentParam,
                ) -> std::result::Result<Segment, JsValue>;
                fn insert_segments(
                    &self,
                    index: f64,
                    segments: Vec<Segment>,
                ) -> std::result::Result<Vec<Segment>, JsValue>;
                fn last_segment(&self) -> Segment;
                fn set_last_segment(&mut self, value: Segment) -> ();
                fn segments(&self) -> Vec<Segment>;
                fn set_segments(&mut self, value: Vec<Segment>) -> ();
                fn closed(&self) -> bool;
                fn set_closed(&mut self, value: bool) -> ();
                fn get_location_at(
                    &self,
                    offset: f64,
                ) -> std::result::Result<CurveLocation, JsValue>;
                fn curves(&self) -> Vec<Curve>;
                fn set_curves(&mut self, value: Vec<Curve>) -> ();
                fn first_curve(&self) -> Curve;
                fn set_first_curve(&mut self, value: Curve) -> ();
                fn get_curvature_at(&self, offset: f64) -> std::result::Result<f64, JsValue>;
                fn area(&self) -> f64;
                fn set_area(&mut self, value: f64) -> ();
                fn clear_handles(&self) -> std::result::Result<(), JsValue>;
                fn remove_segment(&self, index: f64) -> std::result::Result<Segment, JsValue>;
                fn divide_at(
                    &self,
                    location: PathDivideAtParamsLocationParam,
                ) -> std::result::Result<Segment, JsValue>;
            }
            impl PathItem_Trait for Path
            where
                Path: Item_Trait,
            {
                fn cubic_curve_by(
                    &self,
                    handle1: Point,
                    handle2: Point,
                    to: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::cubic_curve_by(&target, handle1, handle2, to)
                }
                fn curve_by(
                    &self,
                    through: Point,
                    to: Point,
                    time: f64,
                ) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::curve_by(&target, through, to, time)
                }
                fn close_path(&self) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::close_path(&target)
                }
                fn simplify(&self, tolerance: f64) -> std::result::Result<bool, JsValue> {
                    let target: PathItem = self.into();
                    PathItem::simplify(&target, tolerance)
                }
                fn reverse(&self) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::reverse(&target)
                }
                fn quadratic_curve_by(
                    &self,
                    handle: Point,
                    to: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::quadratic_curve_by(&target, handle, to)
                }
                fn get_intersections(
                    &self,
                    path: PathItem,
                    include: JsValue,
                ) -> std::result::Result<Vec<CurveLocation>, JsValue> {
                    let target: PathItem = self.into();
                    PathItem::get_intersections(&target, path, include)
                }
                fn get_nearest_point(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: PathItem = self.into();
                    PathItem::get_nearest_point(&target, point)
                }
                fn move_to(&self, point: Point) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::move_to(&target, point)
                }
                fn exclude(
                    &self,
                    path: PathItem,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<PathItem, JsValue> {
                    let target: PathItem = self.into();
                    PathItem::exclude(&target, path, options)
                }
                fn interpolate(
                    &self,
                    from: PathItem,
                    to: PathItem,
                    factor: f64,
                ) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::interpolate(&target, from, to, factor)
                }
                fn compare(&self, path: PathItem) -> std::result::Result<bool, JsValue> {
                    let target: PathItem = self.into();
                    PathItem::compare(&target, path)
                }
                fn arc_by(&self, to: Point, clockwise: bool) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::arc_by(&target, to, clockwise)
                }
                fn line_to(&self, point: Point) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::line_to(&target, point)
                }
                fn line_by(&self, point: Point) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::line_by(&target, point)
                }
                fn path_data(&self) -> String {
                    let target: PathItem = self.into();
                    PathItem::path_data(&target)
                }
                fn set_path_data(&mut self, value: String) -> () {
                    let mut target: PathItem = self.into();
                    PathItem::set_path_data(&mut target, value)
                }
                fn interior_point(&self) -> Point {
                    let target: PathItem = self.into();
                    PathItem::interior_point(&target)
                }
                fn set_interior_point(&mut self, value: Point) -> () {
                    let mut target: PathItem = self.into();
                    PathItem::set_interior_point(&mut target, value)
                }
                fn clockwise(&self) -> bool {
                    let target: PathItem = self.into();
                    PathItem::clockwise(&target)
                }
                fn set_clockwise(&mut self, value: bool) -> () {
                    let mut target: PathItem = self.into();
                    PathItem::set_clockwise(&mut target, value)
                }
                fn smooth(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::smooth(&target, options)
                }
                fn get_nearest_location(
                    &self,
                    point: Point,
                ) -> std::result::Result<CurveLocation, JsValue> {
                    let target: PathItem = self.into();
                    PathItem::get_nearest_location(&target, point)
                }
                fn divide(
                    &self,
                    path: PathItem,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<PathItem, JsValue> {
                    let target: PathItem = self.into();
                    PathItem::divide(&target, path, options)
                }
                fn cubic_curve_to(
                    &self,
                    handle1: Point,
                    handle2: Point,
                    to: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::cubic_curve_to(&target, handle1, handle2, to)
                }
                fn subtract(
                    &self,
                    path: PathItem,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<PathItem, JsValue> {
                    let target: PathItem = self.into();
                    PathItem::subtract(&target, path, options)
                }
                fn move_by(&self, to: Point) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::move_by(&target, to)
                }
                fn quadratic_curve_to(
                    &self,
                    handle: Point,
                    to: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::quadratic_curve_to(&target, handle, to)
                }
                fn get_crossings(
                    &self,
                    path: PathItem,
                ) -> std::result::Result<Vec<CurveLocation>, JsValue> {
                    let target: PathItem = self.into();
                    PathItem::get_crossings(&target, path)
                }
                fn curve_to(
                    &self,
                    through: Point,
                    to: Point,
                    time: f64,
                ) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::curve_to(&target, through, to, time)
                }
                fn arc_to(&self, to: Point, clockwise: bool) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::arc_to(&target, to, clockwise)
                }
                fn unite(
                    &self,
                    path: PathItem,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<PathItem, JsValue> {
                    let target: PathItem = self.into();
                    PathItem::unite(&target, path, options)
                }
                fn flatten(&self, flatness: f64) -> std::result::Result<(), JsValue> {
                    let target: PathItem = self.into();
                    PathItem::flatten(&target, flatness)
                }
                fn intersect(
                    &self,
                    path: PathItem,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<PathItem, JsValue> {
                    let target: PathItem = self.into();
                    PathItem::intersect(&target, path, options)
                }
                fn reorient(
                    &self,
                    non_zero: bool,
                    clockwise: bool,
                ) -> std::result::Result<PathItem, JsValue> {
                    let target: PathItem = self.into();
                    PathItem::reorient(&target, non_zero, clockwise)
                }
                fn create(
                    &self,
                    object: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<PathItemCreateReturn, JsValue> {
                    let target: PathItem = self.into();
                    PathItem::create(&target, object)
                }
            }
            impl Item_Trait for Path {
                fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::insert_below(&target, item)
                }
                fn on_double_click(&self) -> ItemOnDoubleClick {
                    let target: Item = self.into();
                    Item::on_double_click(&target)
                }
                fn set_on_double_click(&mut self, value: ItemOnDoubleClick) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_double_click(&mut target, value)
                }
                fn view(&self) -> View {
                    let target: Item = self.into();
                    Item::view(&target)
                }
                fn set_view(&mut self, value: View) -> () {
                    let mut target: Item = self.into();
                    Item::set_view(&mut target, value)
                }
                fn blend_mode(&self) -> String {
                    let target: Item = self.into();
                    Item::blend_mode(&target)
                }
                fn set_blend_mode(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_blend_mode(&mut target, value)
                }
                fn name(&self) -> String {
                    let target: Item = self.into();
                    Item::name(&target)
                }
                fn set_name(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_name(&mut target, value)
                }
                fn project(&self) -> Project {
                    let target: Item = self.into();
                    Item::project(&target)
                }
                fn set_project(&mut self, value: Project) -> () {
                    let mut target: Item = self.into();
                    Item::set_project(&mut target, value)
                }
                fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_child(&target, item)
                }
                fn global_matrix(&self) -> Matrix {
                    let target: Item = self.into();
                    Item::global_matrix(&target)
                }
                fn set_global_matrix(&mut self, value: Matrix) -> () {
                    let mut target: Item = self.into();
                    Item::set_global_matrix(&mut target, value)
                }
                fn on_mouse_leave(&self) -> ItemOnMouseLeave {
                    let target: Item = self.into();
                    Item::on_mouse_leave(&target)
                }
                fn set_on_mouse_leave(&mut self, value: ItemOnMouseLeave) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_leave(&mut target, value)
                }
                fn has_children(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_children(&target)
                }
                fn selected(&self) -> bool {
                    let target: Item = self.into();
                    Item::selected(&target)
                }
                fn set_selected(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_selected(&mut target, value)
                }
                fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::global_to_local(&target, point)
                }
                fn shadow_blur(&self) -> f64 {
                    let target: Item = self.into();
                    Item::shadow_blur(&target)
                }
                fn set_shadow_blur(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_shadow_blur(&mut target, value)
                }
                fn children(&self) -> Vec<Item> {
                    let target: Item = self.into();
                    Item::children(&target)
                }
                fn set_children(&mut self, value: Vec<Item>) -> () {
                    let mut target: Item = self.into();
                    Item::set_children(&mut target, value)
                }
                fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::replace_with(&target, item)
                }
                fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::import_json(&target, json)
                }
                fn insert_child(
                    &self,
                    index: f64,
                    item: Item,
                ) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::insert_child(&target, index, item)
                }
                fn stroke_join(&self) -> String {
                    let target: Item = self.into();
                    Item::stroke_join(&target)
                }
                fn set_stroke_join(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_join(&mut target, value)
                }
                fn rotation(&self) -> f64 {
                    let target: Item = self.into();
                    Item::rotation(&target)
                }
                fn set_rotation(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_rotation(&mut target, value)
                }
                fn scaling(&self) -> Point {
                    let target: Item = self.into();
                    Item::scaling(&target)
                }
                fn set_scaling(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_scaling(&mut target, value)
                }
                fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_ancestor(&target, item)
                }
                fn emit(
                    &self,
                    type_: String,
                    event: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::emit(&target, type_, event)
                }
                fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_up(&target)
                }
                fn add_to(
                    &self,
                    owner: ItemAddToParamsOwnerParam,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::add_to(&target, owner)
                }
                fn stroke_cap(&self) -> String {
                    let target: Item = self.into();
                    Item::stroke_cap(&target)
                }
                fn set_stroke_cap(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_cap(&mut target, value)
                }
                fn on_mouse_drag(&self) -> ItemOnMouseDrag {
                    let target: Item = self.into();
                    Item::on_mouse_drag(&target)
                }
                fn set_on_mouse_drag(&mut self, value: ItemOnMouseDrag) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_drag(&mut target, value)
                }
                fn set(
                    &self,
                    props: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::set(&target, props)
                }
                fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::reverse_children(&target)
                }
                fn matches(
                    &self,
                    name: String,
                    compare: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::matches(&target, name, compare)
                }
                fn on_mouse_enter(&self) -> ItemOnMouseEnter {
                    let target: Item = self.into();
                    Item::on_mouse_enter(&target)
                }
                fn set_on_mouse_enter(&mut self, value: ItemOnMouseEnter) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_enter(&mut target, value)
                }
                fn shadow_offset(&self) -> Point {
                    let target: Item = self.into();
                    Item::shadow_offset(&target)
                }
                fn set_shadow_offset(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_shadow_offset(&mut target, value)
                }
                fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_stroke(&target)
                }
                fn view_matrix(&self) -> Matrix {
                    let target: Item = self.into();
                    Item::view_matrix(&target)
                }
                fn set_view_matrix(&mut self, value: Matrix) -> () {
                    let mut target: Item = self.into();
                    Item::set_view_matrix(&mut target, value)
                }
                fn on_frame(&self) -> ItemOnFrame {
                    let target: Item = self.into();
                    Item::on_frame(&target)
                }
                fn set_on_frame(&mut self, value: ItemOnFrame) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_frame(&mut target, value)
                }
                fn on_mouse_down(&self) -> ItemOnMouseDown {
                    let target: Item = self.into();
                    Item::on_mouse_down(&target)
                }
                fn set_on_mouse_down(&mut self, value: ItemOnMouseDown) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_down(&mut target, value)
                }
                fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_sibling(&target, item)
                }
                fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::local_to_global(&target, point)
                }
                fn first_child(&self) -> Item {
                    let target: Item = self.into();
                    Item::first_child(&target)
                }
                fn set_first_child(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_first_child(&mut target, value)
                }
                fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::send_to_back(&target)
                }
                fn clip_mask(&self) -> bool {
                    let target: Item = self.into();
                    Item::clip_mask(&target)
                }
                fn set_clip_mask(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_clip_mask(&mut target, value)
                }
                fn next_sibling(&self) -> Item {
                    let target: Item = self.into();
                    Item::next_sibling(&target)
                }
                fn set_next_sibling(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_next_sibling(&mut target, value)
                }
                fn off(
                    &self,
                    object: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::off(&target, object)
                }
                fn rotate(&self, angle: f64, center: Point) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::rotate(&target, angle, center)
                }
                fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::add_child(&target, item)
                }
                fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_grouped_with(&target, item)
                }
                fn scale(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::scale(&target, hor, ver, center)
                }
                fn hit_test_all(
                    &self,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Vec<HitResult>, JsValue> {
                    let target: Item = self.into();
                    Item::hit_test_all(&target, point, options)
                }
                fn insert_children(
                    &self,
                    index: f64,
                    items: Vec<Item>,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::insert_children(&target, index, items)
                }
                fn style(&self) -> Style {
                    let target: Item = self.into();
                    Item::style(&target)
                }
                fn set_style(&mut self, value: Style) -> () {
                    let mut target: Item = self.into();
                    Item::set_style(&mut target, value)
                }
                fn position(&self) -> Point {
                    let target: Item = self.into();
                    Item::position(&target)
                }
                fn set_position(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_position(&mut target, value)
                }
                fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::transform(&target, matrix)
                }
                fn fill_color(&self) -> ItemFillColor {
                    let target: Item = self.into();
                    Item::fill_color(&target)
                }
                fn set_fill_color(&mut self, value: ItemFillColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_fill_color(&mut target, value)
                }
                fn matrix(&self) -> Matrix {
                    let target: Item = self.into();
                    Item::matrix(&target)
                }
                fn set_matrix(&mut self, value: Matrix) -> () {
                    let mut target: Item = self.into();
                    Item::set_matrix(&mut target, value)
                }
                fn id(&self) -> f64 {
                    let target: Item = self.into();
                    Item::id(&target)
                }
                fn set_id(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_id(&mut target, value)
                }
                fn tween(
                    &self,
                    options: ItemTweenParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let target: Item = self.into();
                    Item::tween(&target, options)
                }
                fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::reduce(&target, options)
                }
                fn internal_bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::internal_bounds(&target)
                }
                fn set_internal_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_internal_bounds(&mut target, value)
                }
                fn fill_rule(&self) -> String {
                    let target: Item = self.into();
                    Item::fill_rule(&target)
                }
                fn set_fill_rule(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_fill_rule(&mut target, value)
                }
                fn shadow_color(&self) -> ItemShadowColor {
                    let target: Item = self.into();
                    Item::shadow_color(&target)
                }
                fn set_shadow_color(&mut self, value: ItemShadowColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_shadow_color(&mut target, value)
                }
                fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::insert_above(&target, item)
                }
                fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::responds(&target, type_)
                }
                fn handle_bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::handle_bounds(&target)
                }
                fn set_handle_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_handle_bounds(&mut target, value)
                }
                fn skew(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::skew(&target, hor, ver, center)
                }
                fn on_click(&self) -> ItemOnClick {
                    let target: Item = self.into();
                    Item::on_click(&target)
                }
                fn set_on_click(&mut self, value: ItemOnClick) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_click(&mut target, value)
                }
                fn get_items(
                    &self,
                    options: ItemGetItemsParamsOptionsParam,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::get_items(&target, options)
                }
                fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_inserted(&target)
                }
                fn get_item(
                    &self,
                    options: ItemGetItemParamsOptionsParam,
                ) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::get_item(&target, options)
                }
                fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_fill(&target)
                }
                fn shear(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::shear(&target, hor, ver, center)
                }
                fn visible(&self) -> bool {
                    let target: Item = self.into();
                    Item::visible(&target)
                }
                fn set_visible(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_visible(&mut target, value)
                }
                fn previous_sibling(&self) -> Item {
                    let target: Item = self.into();
                    Item::previous_sibling(&target)
                }
                fn set_previous_sibling(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_previous_sibling(&mut target, value)
                }
                fn hit_test(
                    &self,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<HitResult, JsValue> {
                    let target: Item = self.into();
                    Item::hit_test(&target, point, options)
                }
                fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_descendant(&target, item)
                }
                fn locked(&self) -> bool {
                    let target: Item = self.into();
                    Item::locked(&target)
                }
                fn set_locked(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_locked(&mut target, value)
                }
                fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_parent(&target, item)
                }
                fn copy_attributes(
                    &self,
                    source: Item,
                    exclude_matrix: bool,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::copy_attributes(&target, source, exclude_matrix)
                }
                fn last_child(&self) -> Item {
                    let target: Item = self.into();
                    Item::last_child(&target)
                }
                fn set_last_child(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_last_child(&mut target, value)
                }
                fn stroke_width(&self) -> f64 {
                    let target: Item = self.into();
                    Item::stroke_width(&target)
                }
                fn set_stroke_width(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_width(&mut target, value)
                }
                fn parent(&self) -> Item {
                    let target: Item = self.into();
                    Item::parent(&target)
                }
                fn set_parent(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_parent(&mut target, value)
                }
                fn stroke_bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::stroke_bounds(&target)
                }
                fn set_stroke_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_bounds(&mut target, value)
                }
                fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::translate(&target, delta)
                }
                fn remove(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::remove(&target)
                }
                fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::parent_to_local(&target, point)
                }
                fn bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::bounds(&target)
                }
                fn set_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_bounds(&mut target, value)
                }
                fn add_children(
                    &self,
                    items: Vec<Item>,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::add_children(&target, items)
                }
                fn dash_array(&self) -> Vec<f64> {
                    let target: Item = self.into();
                    Item::dash_array(&target)
                }
                fn set_dash_array(&mut self, value: Vec<f64>) -> () {
                    let mut target: Item = self.into();
                    Item::set_dash_array(&mut target, value)
                }
                fn on_mouse_up(&self) -> ItemOnMouseUp {
                    let target: Item = self.into();
                    Item::on_mouse_up(&target)
                }
                fn set_on_mouse_up(&mut self, value: ItemOnMouseUp) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_up(&mut target, value)
                }
                fn on(
                    &self,
                    object: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::on(&target, object)
                }
                fn remove_on(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on(&target, options)
                }
                fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_below(&target, item)
                }
                fn apply_matrix(&self) -> bool {
                    let target: Item = self.into();
                    Item::apply_matrix(&target)
                }
                fn set_apply_matrix(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_apply_matrix(&mut target, value)
                }
                fn clone(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::clone(&target, options)
                }
                fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::contains(&target, point)
                }
                fn export_json(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<String, JsValue> {
                    let target: Item = self.into();
                    Item::export_json(&target, options)
                }
                fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::bring_to_front(&target)
                }
                fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_above(&target, item)
                }
                fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_drag(&target)
                }
                fn data(&self) -> JsValue {
                    let target: Item = self.into();
                    Item::data(&target)
                }
                fn set_data(&mut self, value: JsValue) -> () {
                    let mut target: Item = self.into();
                    Item::set_data(&mut target, value)
                }
                fn import_svg(
                    &self,
                    svg: ItemImportSvgParamsSvgParam,
                    on_load: JsValue,
                ) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::import_svg(&target, svg, on_load)
                }
                fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_shadow(&target)
                }
                fn selected_color(&self) -> ItemSelectedColor {
                    let target: Item = self.into();
                    Item::selected_color(&target)
                }
                fn set_selected_color(&mut self, value: ItemSelectedColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_selected_color(&mut target, value)
                }
                fn class_name(&self) -> String {
                    let target: Item = self.into();
                    Item::class_name(&target)
                }
                fn set_class_name(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_class_name(&mut target, value)
                }
                fn export_svg(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                    let target: Item = self.into();
                    Item::export_svg(&target, options)
                }
                fn tween_to(
                    &self,
                    to: std::collections::HashMap<String, JsValue>,
                    options: ItemTweenToParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let target: Item = self.into();
                    Item::tween_to(&target, to, options)
                }
                fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_inside(&target, rect)
                }
                fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_empty(&target, recursively)
                }
                fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::copy_content(&target, source)
                }
                fn rasterize(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Raster, JsValue> {
                    let target: Item = self.into();
                    Item::rasterize(&target, options)
                }
                fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_move(&target)
                }
                fn tween_from(
                    &self,
                    from: std::collections::HashMap<String, JsValue>,
                    options: ItemTweenFromParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let target: Item = self.into();
                    Item::tween_from(&target, from, options)
                }
                fn opacity(&self) -> f64 {
                    let target: Item = self.into();
                    Item::opacity(&target)
                }
                fn set_opacity(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_opacity(&mut target, value)
                }
                fn dash_offset(&self) -> f64 {
                    let target: Item = self.into();
                    Item::dash_offset(&target)
                }
                fn set_dash_offset(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_dash_offset(&mut target, value)
                }
                fn remove_children(
                    &self,
                    start: f64,
                    end: f64,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::remove_children(&target, start, end)
                }
                fn on_mouse_move(&self) -> ItemOnMouseMove {
                    let target: Item = self.into();
                    Item::on_mouse_move(&target)
                }
                fn set_on_mouse_move(&mut self, value: ItemOnMouseMove) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_move(&mut target, value)
                }
                fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::intersects(&target, item)
                }
                fn pivot(&self) -> Point {
                    let target: Item = self.into();
                    Item::pivot(&target)
                }
                fn set_pivot(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_pivot(&mut target, value)
                }
                fn copy_to(
                    &self,
                    owner: ItemCopyToParamsOwnerParam,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::copy_to(&target, owner)
                }
                fn index(&self) -> f64 {
                    let target: Item = self.into();
                    Item::index(&target)
                }
                fn set_index(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_index(&mut target, value)
                }
                fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::local_to_parent(&target, point)
                }
                fn stroke_color(&self) -> ItemStrokeColor {
                    let target: Item = self.into();
                    Item::stroke_color(&target)
                }
                fn set_stroke_color(&mut self, value: ItemStrokeColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_color(&mut target, value)
                }
                fn layer(&self) -> Layer {
                    let target: Item = self.into();
                    Item::layer(&target)
                }
                fn set_layer(&mut self, value: Layer) -> () {
                    let mut target: Item = self.into();
                    Item::set_layer(&mut target, value)
                }
                fn stroke_scaling(&self) -> bool {
                    let target: Item = self.into();
                    Item::stroke_scaling(&target)
                }
                fn set_stroke_scaling(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_scaling(&mut target, value)
                }
                fn fit_bounds(
                    &self,
                    rectangle: Rectangle,
                    fill: bool,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::fit_bounds(&target, rectangle, fill)
                }
                fn miter_limit(&self) -> f64 {
                    let target: Item = self.into();
                    Item::miter_limit(&target)
                }
                fn set_miter_limit(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_miter_limit(&mut target, value)
                }
                fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_down(&target)
                }
            }
            impl Path_Trait for Path {}
            impl std::clone::Clone for Path_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for Path_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Path_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                #[wasm_bindgen(js_name = "Point")]
                type Point_Class;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = subtract , method , js_class = "Point" , catch)]
                fn __TSB_subtract(
                    this: &Point_Class,
                    point: Point,
                ) -> std::result::Result<Point, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isOrthogonal , method , js_class = "Point" , catch)]
                fn __TSB_is_orthogonal(
                    this: &Point_Class,
                    point: Point,
                ) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = toString , method , js_class = "Point" , catch)]
                fn __TSB_to_string(this: &Point_Class) -> std::result::Result<String, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getDistance , method , js_class = "Point" , catch)]
                fn __TSB_get_distance(
                    this: &Point_Class,
                    point: Point,
                    squared: bool,
                ) -> std::result::Result<f64, JsValue>;
                # [wasm_bindgen (method , structural , getter = angle , js_class = "Point")]
                fn angle(this: &Point_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = angle , js_class = "Point")]
                fn set_angle(this: &Point_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isZero , method , js_class = "Point" , catch)]
                fn __TSB_is_zero(this: &Point_Class) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = abs , method , js_class = "Point" , catch)]
                fn __TSB_abs(this: &Point_Class) -> std::result::Result<Point, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = ceil , method , js_class = "Point" , catch)]
                fn __TSB_ceil(this: &Point_Class) -> std::result::Result<Point, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = multiply , method , js_class = "Point" , catch)]
                fn __TSB_multiply(
                    this: &Point_Class,
                    point: Point,
                ) -> std::result::Result<Point, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getDirectedAngle , method , js_class = "Point" , catch)]
                fn __TSB_get_directed_angle(
                    this: &Point_Class,
                    point: Point,
                ) -> std::result::Result<f64, JsValue>;
                # [wasm_bindgen (method , structural , getter = x , js_class = "Point")]
                fn x(this: &Point_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = x , js_class = "Point")]
                fn set_x(this: &Point_Class, value: f64);
                #[wasm_bindgen(constructor, js_class = "Point")]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Point_Class;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = max , method , js_class = "Point" , catch)]
                fn __TSB_max(
                    this: &Point_Class,
                    point1: Point,
                    point2: Point,
                ) -> std::result::Result<Point, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isClose , method , js_class = "Point" , catch)]
                fn __TSB_is_close(
                    this: &Point_Class,
                    point: Point,
                    tolerance: f64,
                ) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = project , method , js_class = "Point" , catch)]
                fn __TSB_project(
                    this: &Point_Class,
                    point: Point,
                ) -> std::result::Result<Point, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = random , method , js_class = "Point" , catch)]
                fn __TSB_random(this: &Point_Class) -> std::result::Result<Point, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = equals , method , js_class = "Point" , catch)]
                fn __TSB_equals(
                    this: &Point_Class,
                    point: Point,
                ) -> std::result::Result<bool, JsValue>;
                # [wasm_bindgen (method , structural , getter = selected , js_class = "Point")]
                fn selected(this: &Point_Class) -> bool;
                # [wasm_bindgen (method , structural , setter = selected , js_class = "Point")]
                fn set_selected(this: &Point_Class, value: bool);
                # [wasm_bindgen (method , structural , getter = quadrant , js_class = "Point")]
                fn quadrant(this: &Point_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = quadrant , js_class = "Point")]
                fn set_quadrant(this: &Point_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = modulo , method , js_class = "Point" , catch)]
                fn __TSB_modulo(
                    this: &Point_Class,
                    point: Point,
                ) -> std::result::Result<Point, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isInQuadrant , method , js_class = "Point" , catch)]
                fn __TSB_is_in_quadrant(
                    this: &Point_Class,
                    quadrant: f64,
                ) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = round , method , js_class = "Point" , catch)]
                fn __TSB_round(this: &Point_Class) -> std::result::Result<Point, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = floor , method , js_class = "Point" , catch)]
                fn __TSB_floor(this: &Point_Class) -> std::result::Result<Point, JsValue>;
                # [wasm_bindgen (method , structural , getter = length , js_class = "Point")]
                fn length(this: &Point_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = length , js_class = "Point")]
                fn set_length(this: &Point_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isInside , method , js_class = "Point" , catch)]
                fn __TSB_is_inside(
                    this: &Point_Class,
                    rect: Rectangle,
                ) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getAngleInRadians , method , js_class = "Point" , catch)]
                fn __TSB_get_angle_in_radians(
                    this: &Point_Class,
                    point: Point,
                ) -> std::result::Result<f64, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = rotate , method , js_class = "Point" , catch)]
                fn __TSB_rotate(
                    this: &Point_Class,
                    angle: f64,
                    center: Point,
                ) -> std::result::Result<Point, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = set , method , js_class = "Point" , catch , variadic)]
                fn __TSB_set(
                    this: &Point_Class,
                    values: &[JsValue],
                ) -> std::result::Result<Point, JsValue>;
                # [wasm_bindgen (method , structural , getter = y , js_class = "Point")]
                fn y(this: &Point_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = y , js_class = "Point")]
                fn set_y(this: &Point_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = clone , method , js_class = "Point" , catch)]
                fn __TSB_clone(this: &Point_Class) -> std::result::Result<Point, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = cross , method , js_class = "Point" , catch)]
                fn __TSB_cross(
                    this: &Point_Class,
                    point: Point,
                ) -> std::result::Result<f64, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isNaN , method , js_class = "Point" , catch)]
                fn __TSB_is_na_n(this: &Point_Class) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getAngle , method , js_class = "Point" , catch)]
                fn __TSB_get_angle(
                    this: &Point_Class,
                    point: Point,
                ) -> std::result::Result<f64, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = add , method , js_class = "Point" , catch)]
                fn __TSB_add(
                    this: &Point_Class,
                    point: Point,
                ) -> std::result::Result<Point, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = min , method , js_class = "Point" , catch)]
                fn __TSB_min(
                    this: &Point_Class,
                    point1: Point,
                    point2: Point,
                ) -> std::result::Result<Point, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = transform , method , js_class = "Point" , catch)]
                fn __TSB_transform(
                    this: &Point_Class,
                    matrix: Matrix,
                ) -> std::result::Result<Point, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isCollinear , method , js_class = "Point" , catch)]
                fn __TSB_is_collinear(
                    this: &Point_Class,
                    point: Point,
                ) -> std::result::Result<bool, JsValue>;
                # [wasm_bindgen (method , structural , getter = angleInRadians , js_class = "Point")]
                fn angle_in_radians(this: &Point_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = angleInRadians , js_class = "Point")]
                fn set_angle_in_radians(this: &Point_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = normalize , method , js_class = "Point" , catch)]
                fn __TSB_normalize(
                    this: &Point_Class,
                    length: f64,
                ) -> std::result::Result<Point, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = dot , method , js_class = "Point" , catch)]
                fn __TSB_dot(this: &Point_Class, point: Point)
                    -> std::result::Result<f64, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = divide , method , js_class = "Point" , catch)]
                fn __TSB_divide(
                    this: &Point_Class,
                    point: Point,
                ) -> std::result::Result<Point, JsValue>;
            }
            #[derive(std :: clone :: Clone)]
            struct Point(pub Point_Class);
            impl Point {
                #[allow(dead_code)]
                pub fn subtract(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_subtract(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn is_orthogonal(&self, point: Point) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_orthogonal(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_to_string()?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_distance(
                    &self,
                    point: Point,
                    squared: bool,
                ) -> std::result::Result<f64, JsValue> {
                    let result =
                        std::result::Result::Ok(self.0.__TSB_get_distance(point, squared)?);
                    result
                }
                #[allow(dead_code)]
                pub fn angle(&self) -> f64 {
                    let result = self.0.angle();
                    result
                }
                #[allow(dead_code)]
                pub fn set_angle(&self, value: f64) -> () {
                    let result = self.0.set_angle(value);
                    result
                }
                #[allow(dead_code)]
                pub fn is_zero(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_zero()?);
                    result
                }
                #[allow(dead_code)]
                pub fn abs(&self) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_abs()?);
                    result
                }
                #[allow(dead_code)]
                pub fn ceil(&self) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_ceil()?);
                    result
                }
                #[allow(dead_code)]
                pub fn multiply(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_multiply(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_directed_angle(
                    &self,
                    point: Point,
                ) -> std::result::Result<f64, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_directed_angle(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn x(&self) -> f64 {
                    let result = self.0.x();
                    result
                }
                #[allow(dead_code)]
                pub fn set_x(&self, value: f64) -> () {
                    let result = self.0.set_x(value);
                    result
                }
                #[allow(dead_code)]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Point {
                    let result = Point_Class::new(object);
                    let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                    Point(result)
                }
                #[allow(dead_code)]
                pub fn max(
                    &self,
                    point1: Point,
                    point2: Point,
                ) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_max(point1, point2)?);
                    result
                }
                #[allow(dead_code)]
                pub fn is_close(
                    &self,
                    point: Point,
                    tolerance: f64,
                ) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_close(point, tolerance)?);
                    result
                }
                #[allow(dead_code)]
                pub fn project(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_project(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn random(&self) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_random()?);
                    result
                }
                #[allow(dead_code)]
                pub fn equals(&self, point: Point) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_equals(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn selected(&self) -> bool {
                    let result = self.0.selected();
                    result
                }
                #[allow(dead_code)]
                pub fn set_selected(&self, value: bool) -> () {
                    let result = self.0.set_selected(value);
                    result
                }
                #[allow(dead_code)]
                pub fn quadrant(&self) -> f64 {
                    let result = self.0.quadrant();
                    result
                }
                #[allow(dead_code)]
                pub fn set_quadrant(&self, value: f64) -> () {
                    let result = self.0.set_quadrant(value);
                    result
                }
                #[allow(dead_code)]
                pub fn modulo(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_modulo(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn is_in_quadrant(&self, quadrant: f64) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_in_quadrant(quadrant)?);
                    result
                }
                #[allow(dead_code)]
                pub fn round(&self) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_round()?);
                    result
                }
                #[allow(dead_code)]
                pub fn floor(&self) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_floor()?);
                    result
                }
                #[allow(dead_code)]
                pub fn length(&self) -> f64 {
                    let result = self.0.length();
                    result
                }
                #[allow(dead_code)]
                pub fn set_length(&self, value: f64) -> () {
                    let result = self.0.set_length(value);
                    result
                }
                #[allow(dead_code)]
                pub fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_inside(rect)?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_angle_in_radians(
                    &self,
                    point: Point,
                ) -> std::result::Result<f64, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_angle_in_radians(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn rotate(
                    &self,
                    angle: f64,
                    center: Point,
                ) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_rotate(angle, center)?);
                    result
                }
                #[allow(dead_code)]
                pub fn set(&self, values: &[JsValue]) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_set(values)?);
                    result
                }
                #[allow(dead_code)]
                pub fn y(&self) -> f64 {
                    let result = self.0.y();
                    result
                }
                #[allow(dead_code)]
                pub fn set_y(&self, value: f64) -> () {
                    let result = self.0.set_y(value);
                    result
                }
                #[allow(dead_code)]
                pub fn clone(&self) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_clone()?);
                    result
                }
                #[allow(dead_code)]
                pub fn cross(&self, point: Point) -> std::result::Result<f64, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_cross(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn is_na_n(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_na_n()?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_angle(&self, point: Point) -> std::result::Result<f64, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_angle(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn add(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_add(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn min(
                    &self,
                    point1: Point,
                    point2: Point,
                ) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_min(point1, point2)?);
                    result
                }
                #[allow(dead_code)]
                pub fn transform(&self, matrix: Matrix) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_transform(matrix)?);
                    result
                }
                #[allow(dead_code)]
                pub fn is_collinear(&self, point: Point) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_collinear(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn angle_in_radians(&self) -> f64 {
                    let result = self.0.angle_in_radians();
                    result
                }
                #[allow(dead_code)]
                pub fn set_angle_in_radians(&self, value: f64) -> () {
                    let result = self.0.set_angle_in_radians(value);
                    result
                }
                #[allow(dead_code)]
                pub fn normalize(&self, length: f64) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_normalize(length)?);
                    result
                }
                #[allow(dead_code)]
                pub fn dot(&self, point: Point) -> std::result::Result<f64, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_dot(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn divide(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_divide(point)?);
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for Point {
                fn describe() {
                    <Point_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for Point {
                type Abi = <Point_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Point {
                type Abi = <&'a Point_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for Point {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Point {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: Point_Class =
                        <Point_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait Point_Trait {
                fn subtract(&self, point: Point) -> std::result::Result<Point, JsValue>;
                fn is_orthogonal(&self, point: Point) -> std::result::Result<bool, JsValue>;
                fn to_string(&self) -> std::result::Result<String, JsValue>;
                fn get_distance(
                    &self,
                    point: Point,
                    squared: bool,
                ) -> std::result::Result<f64, JsValue>;
                fn angle(&self) -> f64;
                fn set_angle(&mut self, value: f64) -> ();
                fn is_zero(&self) -> std::result::Result<bool, JsValue>;
                fn abs(&self) -> std::result::Result<Point, JsValue>;
                fn ceil(&self) -> std::result::Result<Point, JsValue>;
                fn multiply(&self, point: Point) -> std::result::Result<Point, JsValue>;
                fn get_directed_angle(&self, point: Point) -> std::result::Result<f64, JsValue>;
                fn x(&self) -> f64;
                fn set_x(&mut self, value: f64) -> ();
                fn new(object: std::collections::HashMap<String, JsValue>) -> Point;
                fn max(&self, point1: Point, point2: Point) -> std::result::Result<Point, JsValue>;
                fn is_close(
                    &self,
                    point: Point,
                    tolerance: f64,
                ) -> std::result::Result<bool, JsValue>;
                fn project(&self, point: Point) -> std::result::Result<Point, JsValue>;
                fn random(&self) -> std::result::Result<Point, JsValue>;
                fn equals(&self, point: Point) -> std::result::Result<bool, JsValue>;
                fn selected(&self) -> bool;
                fn set_selected(&mut self, value: bool) -> ();
                fn quadrant(&self) -> f64;
                fn set_quadrant(&mut self, value: f64) -> ();
                fn modulo(&self, point: Point) -> std::result::Result<Point, JsValue>;
                fn is_in_quadrant(&self, quadrant: f64) -> std::result::Result<bool, JsValue>;
                fn round(&self) -> std::result::Result<Point, JsValue>;
                fn floor(&self) -> std::result::Result<Point, JsValue>;
                fn length(&self) -> f64;
                fn set_length(&mut self, value: f64) -> ();
                fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue>;
                fn get_angle_in_radians(&self, point: Point) -> std::result::Result<f64, JsValue>;
                fn rotate(&self, angle: f64, center: Point) -> std::result::Result<Point, JsValue>;
                fn set(&self, values: &[JsValue]) -> std::result::Result<Point, JsValue>;
                fn y(&self) -> f64;
                fn set_y(&mut self, value: f64) -> ();
                fn clone(&self) -> std::result::Result<Point, JsValue>;
                fn cross(&self, point: Point) -> std::result::Result<f64, JsValue>;
                fn is_na_n(&self) -> std::result::Result<bool, JsValue>;
                fn get_angle(&self, point: Point) -> std::result::Result<f64, JsValue>;
                fn add(&self, point: Point) -> std::result::Result<Point, JsValue>;
                fn min(&self, point1: Point, point2: Point) -> std::result::Result<Point, JsValue>;
                fn transform(&self, matrix: Matrix) -> std::result::Result<Point, JsValue>;
                fn is_collinear(&self, point: Point) -> std::result::Result<bool, JsValue>;
                fn angle_in_radians(&self) -> f64;
                fn set_angle_in_radians(&mut self, value: f64) -> ();
                fn normalize(&self, length: f64) -> std::result::Result<Point, JsValue>;
                fn dot(&self, point: Point) -> std::result::Result<f64, JsValue>;
                fn divide(&self, point: Point) -> std::result::Result<Point, JsValue>;
            }
            impl std::clone::Clone for Point_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for Point_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Point_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum PathItemCreateReturn {
                PathCase(Path),
                CompoundPathCase(CompoundPath),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ProjectExportSvgReturn {
                StringCase(String),
                JsValueCase(JsValue),
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                # [wasm_bindgen (js_name = "Layer" , extends = Group_Class)]
                type Layer_Class;
                #[wasm_bindgen(constructor, js_class = "Layer")]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Layer_Class;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = activate , method , js_class = "Layer" , catch)]
                fn __TSB_activate(this: &Layer_Class) -> std::result::Result<(), JsValue>;
            }
            #[derive(std :: clone :: Clone)]
            struct Layer(pub Layer_Class);
            impl std::convert::From<&Layer> for Group {
                fn from(src: &Layer) -> Group {
                    let src: &Group_Class = src.0.as_ref();
                    Group(src.clone())
                }
            }
            impl std::convert::From<&mut Layer> for Group {
                fn from(src: &mut Layer) -> Group {
                    let src: &Group_Class = src.0.as_ref();
                    Group(src.clone())
                }
            }
            impl Layer {
                #[allow(dead_code)]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Layer {
                    let result = Layer_Class::new(object);
                    let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                    Layer(result)
                }
                #[allow(dead_code)]
                pub fn activate(&self) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_activate()?);
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for Layer {
                fn describe() {
                    <Layer_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for Layer {
                type Abi = <Layer_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Layer {
                type Abi = <&'a Layer_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for Layer {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Layer {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: Layer_Class =
                        <Layer_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait Layer_Trait: Group_Trait {
                fn new(object: std::collections::HashMap<String, JsValue>) -> Layer;
                fn activate(&self) -> std::result::Result<(), JsValue>;
            }
            impl Group_Trait for Layer
            where
                Layer: Item_Trait,
            {
                fn clipped(&self) -> bool {
                    let target: Group = self.into();
                    Group::clipped(&target)
                }
                fn set_clipped(&mut self, value: bool) -> () {
                    let mut target: Group = self.into();
                    Group::set_clipped(&mut target, value)
                }
                fn new(object: std::collections::HashMap<String, JsValue>) -> Layer {
                    Group::new(object)
                }
            }
            impl Item_Trait for Layer {
                fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::insert_below(&target, item)
                }
                fn on_double_click(&self) -> ItemOnDoubleClick {
                    let target: Item = self.into();
                    Item::on_double_click(&target)
                }
                fn set_on_double_click(&mut self, value: ItemOnDoubleClick) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_double_click(&mut target, value)
                }
                fn view(&self) -> View {
                    let target: Item = self.into();
                    Item::view(&target)
                }
                fn set_view(&mut self, value: View) -> () {
                    let mut target: Item = self.into();
                    Item::set_view(&mut target, value)
                }
                fn blend_mode(&self) -> String {
                    let target: Item = self.into();
                    Item::blend_mode(&target)
                }
                fn set_blend_mode(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_blend_mode(&mut target, value)
                }
                fn name(&self) -> String {
                    let target: Item = self.into();
                    Item::name(&target)
                }
                fn set_name(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_name(&mut target, value)
                }
                fn project(&self) -> Project {
                    let target: Item = self.into();
                    Item::project(&target)
                }
                fn set_project(&mut self, value: Project) -> () {
                    let mut target: Item = self.into();
                    Item::set_project(&mut target, value)
                }
                fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_child(&target, item)
                }
                fn global_matrix(&self) -> Matrix {
                    let target: Item = self.into();
                    Item::global_matrix(&target)
                }
                fn set_global_matrix(&mut self, value: Matrix) -> () {
                    let mut target: Item = self.into();
                    Item::set_global_matrix(&mut target, value)
                }
                fn on_mouse_leave(&self) -> ItemOnMouseLeave {
                    let target: Item = self.into();
                    Item::on_mouse_leave(&target)
                }
                fn set_on_mouse_leave(&mut self, value: ItemOnMouseLeave) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_leave(&mut target, value)
                }
                fn has_children(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_children(&target)
                }
                fn selected(&self) -> bool {
                    let target: Item = self.into();
                    Item::selected(&target)
                }
                fn set_selected(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_selected(&mut target, value)
                }
                fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::global_to_local(&target, point)
                }
                fn shadow_blur(&self) -> f64 {
                    let target: Item = self.into();
                    Item::shadow_blur(&target)
                }
                fn set_shadow_blur(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_shadow_blur(&mut target, value)
                }
                fn children(&self) -> Vec<Item> {
                    let target: Item = self.into();
                    Item::children(&target)
                }
                fn set_children(&mut self, value: Vec<Item>) -> () {
                    let mut target: Item = self.into();
                    Item::set_children(&mut target, value)
                }
                fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::replace_with(&target, item)
                }
                fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::import_json(&target, json)
                }
                fn insert_child(
                    &self,
                    index: f64,
                    item: Item,
                ) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::insert_child(&target, index, item)
                }
                fn stroke_join(&self) -> String {
                    let target: Item = self.into();
                    Item::stroke_join(&target)
                }
                fn set_stroke_join(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_join(&mut target, value)
                }
                fn rotation(&self) -> f64 {
                    let target: Item = self.into();
                    Item::rotation(&target)
                }
                fn set_rotation(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_rotation(&mut target, value)
                }
                fn scaling(&self) -> Point {
                    let target: Item = self.into();
                    Item::scaling(&target)
                }
                fn set_scaling(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_scaling(&mut target, value)
                }
                fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_ancestor(&target, item)
                }
                fn emit(
                    &self,
                    type_: String,
                    event: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::emit(&target, type_, event)
                }
                fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_up(&target)
                }
                fn add_to(
                    &self,
                    owner: ItemAddToParamsOwnerParam,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::add_to(&target, owner)
                }
                fn stroke_cap(&self) -> String {
                    let target: Item = self.into();
                    Item::stroke_cap(&target)
                }
                fn set_stroke_cap(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_cap(&mut target, value)
                }
                fn on_mouse_drag(&self) -> ItemOnMouseDrag {
                    let target: Item = self.into();
                    Item::on_mouse_drag(&target)
                }
                fn set_on_mouse_drag(&mut self, value: ItemOnMouseDrag) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_drag(&mut target, value)
                }
                fn set(
                    &self,
                    props: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::set(&target, props)
                }
                fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::reverse_children(&target)
                }
                fn matches(
                    &self,
                    name: String,
                    compare: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::matches(&target, name, compare)
                }
                fn on_mouse_enter(&self) -> ItemOnMouseEnter {
                    let target: Item = self.into();
                    Item::on_mouse_enter(&target)
                }
                fn set_on_mouse_enter(&mut self, value: ItemOnMouseEnter) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_enter(&mut target, value)
                }
                fn shadow_offset(&self) -> Point {
                    let target: Item = self.into();
                    Item::shadow_offset(&target)
                }
                fn set_shadow_offset(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_shadow_offset(&mut target, value)
                }
                fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_stroke(&target)
                }
                fn view_matrix(&self) -> Matrix {
                    let target: Item = self.into();
                    Item::view_matrix(&target)
                }
                fn set_view_matrix(&mut self, value: Matrix) -> () {
                    let mut target: Item = self.into();
                    Item::set_view_matrix(&mut target, value)
                }
                fn on_frame(&self) -> ItemOnFrame {
                    let target: Item = self.into();
                    Item::on_frame(&target)
                }
                fn set_on_frame(&mut self, value: ItemOnFrame) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_frame(&mut target, value)
                }
                fn on_mouse_down(&self) -> ItemOnMouseDown {
                    let target: Item = self.into();
                    Item::on_mouse_down(&target)
                }
                fn set_on_mouse_down(&mut self, value: ItemOnMouseDown) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_down(&mut target, value)
                }
                fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_sibling(&target, item)
                }
                fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::local_to_global(&target, point)
                }
                fn first_child(&self) -> Item {
                    let target: Item = self.into();
                    Item::first_child(&target)
                }
                fn set_first_child(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_first_child(&mut target, value)
                }
                fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::send_to_back(&target)
                }
                fn clip_mask(&self) -> bool {
                    let target: Item = self.into();
                    Item::clip_mask(&target)
                }
                fn set_clip_mask(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_clip_mask(&mut target, value)
                }
                fn next_sibling(&self) -> Item {
                    let target: Item = self.into();
                    Item::next_sibling(&target)
                }
                fn set_next_sibling(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_next_sibling(&mut target, value)
                }
                fn off(
                    &self,
                    object: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::off(&target, object)
                }
                fn rotate(&self, angle: f64, center: Point) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::rotate(&target, angle, center)
                }
                fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::add_child(&target, item)
                }
                fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_grouped_with(&target, item)
                }
                fn scale(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::scale(&target, hor, ver, center)
                }
                fn hit_test_all(
                    &self,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Vec<HitResult>, JsValue> {
                    let target: Item = self.into();
                    Item::hit_test_all(&target, point, options)
                }
                fn insert_children(
                    &self,
                    index: f64,
                    items: Vec<Item>,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::insert_children(&target, index, items)
                }
                fn style(&self) -> Style {
                    let target: Item = self.into();
                    Item::style(&target)
                }
                fn set_style(&mut self, value: Style) -> () {
                    let mut target: Item = self.into();
                    Item::set_style(&mut target, value)
                }
                fn position(&self) -> Point {
                    let target: Item = self.into();
                    Item::position(&target)
                }
                fn set_position(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_position(&mut target, value)
                }
                fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::transform(&target, matrix)
                }
                fn fill_color(&self) -> ItemFillColor {
                    let target: Item = self.into();
                    Item::fill_color(&target)
                }
                fn set_fill_color(&mut self, value: ItemFillColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_fill_color(&mut target, value)
                }
                fn matrix(&self) -> Matrix {
                    let target: Item = self.into();
                    Item::matrix(&target)
                }
                fn set_matrix(&mut self, value: Matrix) -> () {
                    let mut target: Item = self.into();
                    Item::set_matrix(&mut target, value)
                }
                fn id(&self) -> f64 {
                    let target: Item = self.into();
                    Item::id(&target)
                }
                fn set_id(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_id(&mut target, value)
                }
                fn tween(
                    &self,
                    options: ItemTweenParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let target: Item = self.into();
                    Item::tween(&target, options)
                }
                fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::reduce(&target, options)
                }
                fn internal_bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::internal_bounds(&target)
                }
                fn set_internal_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_internal_bounds(&mut target, value)
                }
                fn fill_rule(&self) -> String {
                    let target: Item = self.into();
                    Item::fill_rule(&target)
                }
                fn set_fill_rule(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_fill_rule(&mut target, value)
                }
                fn shadow_color(&self) -> ItemShadowColor {
                    let target: Item = self.into();
                    Item::shadow_color(&target)
                }
                fn set_shadow_color(&mut self, value: ItemShadowColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_shadow_color(&mut target, value)
                }
                fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::insert_above(&target, item)
                }
                fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::responds(&target, type_)
                }
                fn handle_bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::handle_bounds(&target)
                }
                fn set_handle_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_handle_bounds(&mut target, value)
                }
                fn skew(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::skew(&target, hor, ver, center)
                }
                fn on_click(&self) -> ItemOnClick {
                    let target: Item = self.into();
                    Item::on_click(&target)
                }
                fn set_on_click(&mut self, value: ItemOnClick) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_click(&mut target, value)
                }
                fn get_items(
                    &self,
                    options: ItemGetItemsParamsOptionsParam,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::get_items(&target, options)
                }
                fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_inserted(&target)
                }
                fn get_item(
                    &self,
                    options: ItemGetItemParamsOptionsParam,
                ) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::get_item(&target, options)
                }
                fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_fill(&target)
                }
                fn shear(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::shear(&target, hor, ver, center)
                }
                fn visible(&self) -> bool {
                    let target: Item = self.into();
                    Item::visible(&target)
                }
                fn set_visible(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_visible(&mut target, value)
                }
                fn previous_sibling(&self) -> Item {
                    let target: Item = self.into();
                    Item::previous_sibling(&target)
                }
                fn set_previous_sibling(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_previous_sibling(&mut target, value)
                }
                fn hit_test(
                    &self,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<HitResult, JsValue> {
                    let target: Item = self.into();
                    Item::hit_test(&target, point, options)
                }
                fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_descendant(&target, item)
                }
                fn locked(&self) -> bool {
                    let target: Item = self.into();
                    Item::locked(&target)
                }
                fn set_locked(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_locked(&mut target, value)
                }
                fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_parent(&target, item)
                }
                fn copy_attributes(
                    &self,
                    source: Item,
                    exclude_matrix: bool,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::copy_attributes(&target, source, exclude_matrix)
                }
                fn last_child(&self) -> Item {
                    let target: Item = self.into();
                    Item::last_child(&target)
                }
                fn set_last_child(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_last_child(&mut target, value)
                }
                fn stroke_width(&self) -> f64 {
                    let target: Item = self.into();
                    Item::stroke_width(&target)
                }
                fn set_stroke_width(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_width(&mut target, value)
                }
                fn parent(&self) -> Item {
                    let target: Item = self.into();
                    Item::parent(&target)
                }
                fn set_parent(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_parent(&mut target, value)
                }
                fn stroke_bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::stroke_bounds(&target)
                }
                fn set_stroke_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_bounds(&mut target, value)
                }
                fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::translate(&target, delta)
                }
                fn remove(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::remove(&target)
                }
                fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::parent_to_local(&target, point)
                }
                fn bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::bounds(&target)
                }
                fn set_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_bounds(&mut target, value)
                }
                fn add_children(
                    &self,
                    items: Vec<Item>,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::add_children(&target, items)
                }
                fn dash_array(&self) -> Vec<f64> {
                    let target: Item = self.into();
                    Item::dash_array(&target)
                }
                fn set_dash_array(&mut self, value: Vec<f64>) -> () {
                    let mut target: Item = self.into();
                    Item::set_dash_array(&mut target, value)
                }
                fn on_mouse_up(&self) -> ItemOnMouseUp {
                    let target: Item = self.into();
                    Item::on_mouse_up(&target)
                }
                fn set_on_mouse_up(&mut self, value: ItemOnMouseUp) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_up(&mut target, value)
                }
                fn on(
                    &self,
                    object: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::on(&target, object)
                }
                fn remove_on(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on(&target, options)
                }
                fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_below(&target, item)
                }
                fn apply_matrix(&self) -> bool {
                    let target: Item = self.into();
                    Item::apply_matrix(&target)
                }
                fn set_apply_matrix(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_apply_matrix(&mut target, value)
                }
                fn clone(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::clone(&target, options)
                }
                fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::contains(&target, point)
                }
                fn export_json(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<String, JsValue> {
                    let target: Item = self.into();
                    Item::export_json(&target, options)
                }
                fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::bring_to_front(&target)
                }
                fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_above(&target, item)
                }
                fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_drag(&target)
                }
                fn data(&self) -> JsValue {
                    let target: Item = self.into();
                    Item::data(&target)
                }
                fn set_data(&mut self, value: JsValue) -> () {
                    let mut target: Item = self.into();
                    Item::set_data(&mut target, value)
                }
                fn import_svg(
                    &self,
                    svg: ItemImportSvgParamsSvgParam,
                    on_load: JsValue,
                ) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::import_svg(&target, svg, on_load)
                }
                fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_shadow(&target)
                }
                fn selected_color(&self) -> ItemSelectedColor {
                    let target: Item = self.into();
                    Item::selected_color(&target)
                }
                fn set_selected_color(&mut self, value: ItemSelectedColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_selected_color(&mut target, value)
                }
                fn class_name(&self) -> String {
                    let target: Item = self.into();
                    Item::class_name(&target)
                }
                fn set_class_name(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_class_name(&mut target, value)
                }
                fn export_svg(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                    let target: Item = self.into();
                    Item::export_svg(&target, options)
                }
                fn tween_to(
                    &self,
                    to: std::collections::HashMap<String, JsValue>,
                    options: ItemTweenToParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let target: Item = self.into();
                    Item::tween_to(&target, to, options)
                }
                fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_inside(&target, rect)
                }
                fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_empty(&target, recursively)
                }
                fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::copy_content(&target, source)
                }
                fn rasterize(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Raster, JsValue> {
                    let target: Item = self.into();
                    Item::rasterize(&target, options)
                }
                fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_move(&target)
                }
                fn tween_from(
                    &self,
                    from: std::collections::HashMap<String, JsValue>,
                    options: ItemTweenFromParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let target: Item = self.into();
                    Item::tween_from(&target, from, options)
                }
                fn opacity(&self) -> f64 {
                    let target: Item = self.into();
                    Item::opacity(&target)
                }
                fn set_opacity(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_opacity(&mut target, value)
                }
                fn dash_offset(&self) -> f64 {
                    let target: Item = self.into();
                    Item::dash_offset(&target)
                }
                fn set_dash_offset(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_dash_offset(&mut target, value)
                }
                fn remove_children(
                    &self,
                    start: f64,
                    end: f64,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::remove_children(&target, start, end)
                }
                fn on_mouse_move(&self) -> ItemOnMouseMove {
                    let target: Item = self.into();
                    Item::on_mouse_move(&target)
                }
                fn set_on_mouse_move(&mut self, value: ItemOnMouseMove) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_move(&mut target, value)
                }
                fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::intersects(&target, item)
                }
                fn pivot(&self) -> Point {
                    let target: Item = self.into();
                    Item::pivot(&target)
                }
                fn set_pivot(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_pivot(&mut target, value)
                }
                fn copy_to(
                    &self,
                    owner: ItemCopyToParamsOwnerParam,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::copy_to(&target, owner)
                }
                fn index(&self) -> f64 {
                    let target: Item = self.into();
                    Item::index(&target)
                }
                fn set_index(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_index(&mut target, value)
                }
                fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::local_to_parent(&target, point)
                }
                fn stroke_color(&self) -> ItemStrokeColor {
                    let target: Item = self.into();
                    Item::stroke_color(&target)
                }
                fn set_stroke_color(&mut self, value: ItemStrokeColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_color(&mut target, value)
                }
                fn layer(&self) -> Layer {
                    let target: Item = self.into();
                    Item::layer(&target)
                }
                fn set_layer(&mut self, value: Layer) -> () {
                    let mut target: Item = self.into();
                    Item::set_layer(&mut target, value)
                }
                fn stroke_scaling(&self) -> bool {
                    let target: Item = self.into();
                    Item::stroke_scaling(&target)
                }
                fn set_stroke_scaling(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_scaling(&mut target, value)
                }
                fn fit_bounds(
                    &self,
                    rectangle: Rectangle,
                    fill: bool,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::fit_bounds(&target, rectangle, fill)
                }
                fn miter_limit(&self) -> f64 {
                    let target: Item = self.into();
                    Item::miter_limit(&target)
                }
                fn set_miter_limit(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_miter_limit(&mut target, value)
                }
                fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_down(&target)
                }
            }
            impl Layer_Trait for Layer {}
            impl std::clone::Clone for Layer_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for Layer_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Layer_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                # [wasm_bindgen (js_name = "Line" , extends = Path_Class)]
                type Line_Class;
                #[wasm_bindgen(constructor, js_class = "Line")]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Line_Class;
            }
            #[derive(std :: clone :: Clone)]
            struct Line(pub Line_Class);
            impl std::convert::From<&Line> for Path {
                fn from(src: &Line) -> Path {
                    let src: &Path_Class = src.0.as_ref();
                    Path(src.clone())
                }
            }
            impl std::convert::From<&mut Line> for Path {
                fn from(src: &mut Line) -> Path {
                    let src: &Path_Class = src.0.as_ref();
                    Path(src.clone())
                }
            }
            impl Line {
                #[allow(dead_code)]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Line {
                    let result = Line_Class::new(object);
                    let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                    Line(result)
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for Line {
                fn describe() {
                    <Line_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for Line {
                type Abi = <Line_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Line {
                type Abi = <&'a Line_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for Line {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Line {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: Line_Class =
                        <Line_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait Line_Trait: Path_Trait {
                fn new(object: std::collections::HashMap<String, JsValue>) -> Line;
            }
            impl Path_Trait for Line {}
            impl Line_Trait for Line {}
            impl std::clone::Clone for Line_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for Line_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Line_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ItemTweenFromParamsOptionsParam {
                F64Case(f64),
                StdCollectionsHashMapOfStringJsValueCase(
                    std::collections::HashMap<String, JsValue>,
                ),
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                # [wasm_bindgen (js_name = "Circle" , extends = Path_Class)]
                type Circle_Class;
                #[wasm_bindgen(constructor, js_class = "Circle")]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Circle_Class;
            }
            #[derive(std :: clone :: Clone)]
            struct Circle(pub Circle_Class);
            impl std::convert::From<&Circle> for Path {
                fn from(src: &Circle) -> Path {
                    let src: &Path_Class = src.0.as_ref();
                    Path(src.clone())
                }
            }
            impl std::convert::From<&mut Circle> for Path {
                fn from(src: &mut Circle) -> Path {
                    let src: &Path_Class = src.0.as_ref();
                    Path(src.clone())
                }
            }
            impl Circle {
                #[allow(dead_code)]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Circle {
                    let result = Circle_Class::new(object);
                    let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                    Circle(result)
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for Circle {
                fn describe() {
                    <Circle_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for Circle {
                type Abi = <Circle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Circle {
                type Abi = <&'a Circle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for Circle {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Circle {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: Circle_Class =
                        <Circle_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait Circle_Trait: Path_Trait {
                fn new(object: std::collections::HashMap<String, JsValue>) -> Circle;
            }
            impl Path_Trait for Circle {}
            impl Circle_Trait for Circle {}
            impl std::clone::Clone for Circle_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for Circle_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Circle_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                #[wasm_bindgen(js_name = "View")]
                type View_Class;
                # [wasm_bindgen (method , structural , getter = resolution , js_class = "View")]
                fn resolution(this: &View_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = resolution , js_class = "View")]
                fn set_resolution(this: &View_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = onFrame , js_class = "View")]
                fn on_frame(this: &View_Class) -> ViewOnFrame;
                # [wasm_bindgen (method , structural , setter = onFrame , js_class = "View")]
                fn set_on_frame(this: &View_Class, value: ViewOnFrame);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = update , method , js_class = "View" , catch)]
                fn __TSB_update(this: &View_Class) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = rotate , method , js_class = "View" , catch)]
                fn __TSB_rotate(
                    this: &View_Class,
                    angle: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue>;
                # [wasm_bindgen (method , structural , getter = rotation , js_class = "View")]
                fn rotation(this: &View_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = rotation , js_class = "View")]
                fn set_rotation(this: &View_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = onDoubleClick , js_class = "View")]
                fn on_double_click(this: &View_Class) -> ViewOnDoubleClick;
                # [wasm_bindgen (method , structural , setter = onDoubleClick , js_class = "View")]
                fn set_on_double_click(this: &View_Class, value: ViewOnDoubleClick);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = translate , method , js_class = "View" , catch)]
                fn __TSB_translate(
                    this: &View_Class,
                    delta: Point,
                ) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isInserted , method , js_class = "View" , catch)]
                fn __TSB_is_inserted(this: &View_Class) -> std::result::Result<bool, JsValue>;
                # [wasm_bindgen (method , structural , getter = onMouseDrag , js_class = "View")]
                fn on_mouse_drag(this: &View_Class) -> ViewOnMouseDrag;
                # [wasm_bindgen (method , structural , setter = onMouseDrag , js_class = "View")]
                fn set_on_mouse_drag(this: &View_Class, value: ViewOnMouseDrag);
                # [wasm_bindgen (method , structural , getter = onMouseDown , js_class = "View")]
                fn on_mouse_down(this: &View_Class) -> ViewOnMouseDown;
                # [wasm_bindgen (method , structural , setter = onMouseDown , js_class = "View")]
                fn set_on_mouse_down(this: &View_Class, value: ViewOnMouseDown);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = off , method , js_class = "View" , catch)]
                fn __TSB_off(
                    this: &View_Class,
                    param: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<View, JsValue>;
                # [wasm_bindgen (method , structural , getter = onMouseUp , js_class = "View")]
                fn on_mouse_up(this: &View_Class) -> ViewOnMouseUp;
                # [wasm_bindgen (method , structural , setter = onMouseUp , js_class = "View")]
                fn set_on_mouse_up(this: &View_Class, value: ViewOnMouseUp);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = remove , method , js_class = "View" , catch)]
                fn __TSB_remove(this: &View_Class) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = emit , method , js_class = "View" , catch)]
                fn __TSB_emit(
                    this: &View_Class,
                    type_: String,
                    event: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = scale , method , js_class = "View" , catch)]
                fn __TSB_scale(
                    this: &View_Class,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue>;
                # [wasm_bindgen (method , structural , getter = viewSize , js_class = "View")]
                fn view_size(this: &View_Class) -> Size;
                # [wasm_bindgen (method , structural , setter = viewSize , js_class = "View")]
                fn set_view_size(this: &View_Class, value: Size);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = projectToView , method , js_class = "View" , catch)]
                fn __TSB_project_to_view(
                    this: &View_Class,
                    point: Point,
                ) -> std::result::Result<Point, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = on , method , js_class = "View" , catch)]
                fn __TSB_on(
                    this: &View_Class,
                    param: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<View, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = viewToProject , method , js_class = "View" , catch)]
                fn __TSB_view_to_project(
                    this: &View_Class,
                    point: Point,
                ) -> std::result::Result<Point, JsValue>;
                # [wasm_bindgen (method , structural , getter = onClick , js_class = "View")]
                fn on_click(this: &View_Class) -> ViewOnClick;
                # [wasm_bindgen (method , structural , setter = onClick , js_class = "View")]
                fn set_on_click(this: &View_Class, value: ViewOnClick);
                # [wasm_bindgen (method , structural , getter = center , js_class = "View")]
                fn center(this: &View_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = center , js_class = "View")]
                fn set_center(this: &View_Class, value: Point);
                # [wasm_bindgen (method , structural , getter = autoUpdate , js_class = "View")]
                fn auto_update(this: &View_Class) -> bool;
                # [wasm_bindgen (method , structural , setter = autoUpdate , js_class = "View")]
                fn set_auto_update(this: &View_Class, value: bool);
                # [wasm_bindgen (method , structural , getter = bounds , js_class = "View")]
                fn bounds(this: &View_Class) -> Rectangle;
                # [wasm_bindgen (method , structural , setter = bounds , js_class = "View")]
                fn set_bounds(this: &View_Class, value: Rectangle);
                # [wasm_bindgen (method , structural , getter = pixelRatio , js_class = "View")]
                fn pixel_ratio(this: &View_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = pixelRatio , js_class = "View")]
                fn set_pixel_ratio(this: &View_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = size , js_class = "View")]
                fn size(this: &View_Class) -> Size;
                # [wasm_bindgen (method , structural , setter = size , js_class = "View")]
                fn set_size(this: &View_Class, value: Size);
                # [wasm_bindgen (method , structural , getter = matrix , js_class = "View")]
                fn matrix(this: &View_Class) -> Matrix;
                # [wasm_bindgen (method , structural , setter = matrix , js_class = "View")]
                fn set_matrix(this: &View_Class, value: Matrix);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isVisible , method , js_class = "View" , catch)]
                fn __TSB_is_visible(this: &View_Class) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = transform , method , js_class = "View" , catch)]
                fn __TSB_transform(
                    this: &View_Class,
                    matrix: Matrix,
                ) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = getEventPoint , method , js_class = "View" , catch)]
                fn __TSB_get_event_point(
                    this: &View_Class,
                    event: Event,
                ) -> std::result::Result<Point, JsValue>;
                # [wasm_bindgen (method , structural , getter = zoom , js_class = "View")]
                fn zoom(this: &View_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = zoom , js_class = "View")]
                fn set_zoom(this: &View_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = onMouseLeave , js_class = "View")]
                fn on_mouse_leave(this: &View_Class) -> ViewOnMouseLeave;
                # [wasm_bindgen (method , structural , setter = onMouseLeave , js_class = "View")]
                fn set_on_mouse_leave(this: &View_Class, value: ViewOnMouseLeave);
                # [wasm_bindgen (method , structural , getter = scaling , js_class = "View")]
                fn scaling(this: &View_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = scaling , js_class = "View")]
                fn set_scaling(this: &View_Class, value: Point);
                # [wasm_bindgen (method , structural , getter = onMouseMove , js_class = "View")]
                fn on_mouse_move(this: &View_Class) -> ViewOnMouseMove;
                # [wasm_bindgen (method , structural , setter = onMouseMove , js_class = "View")]
                fn set_on_mouse_move(this: &View_Class, value: ViewOnMouseMove);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = requestUpdate , method , js_class = "View" , catch)]
                fn __TSB_request_update(this: &View_Class) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = skew , method , js_class = "View" , catch)]
                fn __TSB_skew(
                    this: &View_Class,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue>;
                # [wasm_bindgen (method , structural , getter = element , js_class = "View")]
                fn element(this: &View_Class) -> JsValue;
                # [wasm_bindgen (method , structural , setter = element , js_class = "View")]
                fn set_element(this: &View_Class, value: JsValue);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = responds , method , js_class = "View" , catch)]
                fn __TSB_responds(
                    this: &View_Class,
                    type_: String,
                ) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = pause , method , js_class = "View" , catch)]
                fn __TSB_pause(this: &View_Class) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = play , method , js_class = "View" , catch)]
                fn __TSB_play(this: &View_Class) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = shear , method , js_class = "View" , catch)]
                fn __TSB_shear(
                    this: &View_Class,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue>;
                # [wasm_bindgen (method , structural , getter = onMouseEnter , js_class = "View")]
                fn on_mouse_enter(this: &View_Class) -> ViewOnMouseEnter;
                # [wasm_bindgen (method , structural , setter = onMouseEnter , js_class = "View")]
                fn set_on_mouse_enter(this: &View_Class, value: ViewOnMouseEnter);
                # [wasm_bindgen (method , structural , getter = onResize , js_class = "View")]
                fn on_resize(this: &View_Class) -> ViewOnResize;
                # [wasm_bindgen (method , structural , setter = onResize , js_class = "View")]
                fn set_on_resize(this: &View_Class, value: ViewOnResize);
            }
            #[derive(std :: clone :: Clone)]
            struct View(pub View_Class);
            impl View {
                #[allow(dead_code)]
                pub fn resolution(&self) -> f64 {
                    let result = self.0.resolution();
                    result
                }
                #[allow(dead_code)]
                pub fn set_resolution(&self, value: f64) -> () {
                    let result = self.0.set_resolution(value);
                    result
                }
                #[allow(dead_code)]
                pub fn on_frame(&self) -> ViewOnFrame {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.on_frame()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_on_frame(&self, value: ViewOnFrame) -> () {
                    let result = self.0.set_on_frame(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn update(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_update()?);
                    result
                }
                #[allow(dead_code)]
                pub fn rotate(
                    &self,
                    angle: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_rotate(angle, center)?);
                    result
                }
                #[allow(dead_code)]
                pub fn rotation(&self) -> f64 {
                    let result = self.0.rotation();
                    result
                }
                #[allow(dead_code)]
                pub fn set_rotation(&self, value: f64) -> () {
                    let result = self.0.set_rotation(value);
                    result
                }
                #[allow(dead_code)]
                pub fn on_double_click(&self) -> ViewOnDoubleClick {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.on_double_click()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_on_double_click(&self, value: ViewOnDoubleClick) -> () {
                    let result = self.0.set_on_double_click(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_translate(delta)?);
                    result
                }
                #[allow(dead_code)]
                pub fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_inserted()?);
                    result
                }
                #[allow(dead_code)]
                pub fn on_mouse_drag(&self) -> ViewOnMouseDrag {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_drag()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_on_mouse_drag(&self, value: ViewOnMouseDrag) -> () {
                    let result = self.0.set_on_mouse_drag(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn on_mouse_down(&self) -> ViewOnMouseDown {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_down()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_on_mouse_down(&self, value: ViewOnMouseDown) -> () {
                    let result = self.0.set_on_mouse_down(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn off(
                    &self,
                    param: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<View, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_off(param)?);
                    result
                }
                #[allow(dead_code)]
                pub fn on_mouse_up(&self) -> ViewOnMouseUp {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_up()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_on_mouse_up(&self, value: ViewOnMouseUp) -> () {
                    let result = self.0.set_on_mouse_up(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn remove(&self) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_remove()?);
                    result
                }
                #[allow(dead_code)]
                pub fn emit(
                    &self,
                    type_: String,
                    event: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_emit(type_, event)?);
                    result
                }
                #[allow(dead_code)]
                pub fn scale(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_scale(hor, ver, center)?);
                    result
                }
                #[allow(dead_code)]
                pub fn view_size(&self) -> Size {
                    let result = self.0.view_size();
                    result
                }
                #[allow(dead_code)]
                pub fn set_view_size(&self, value: Size) -> () {
                    let result = self.0.set_view_size(value);
                    result
                }
                #[allow(dead_code)]
                pub fn project_to_view(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_project_to_view(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn on(
                    &self,
                    param: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<View, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_on(param)?);
                    result
                }
                #[allow(dead_code)]
                pub fn view_to_project(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_view_to_project(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn on_click(&self) -> ViewOnClick {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.on_click()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_on_click(&self, value: ViewOnClick) -> () {
                    let result = self.0.set_on_click(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn center(&self) -> Point {
                    let result = self.0.center();
                    result
                }
                #[allow(dead_code)]
                pub fn set_center(&self, value: Point) -> () {
                    let result = self.0.set_center(value);
                    result
                }
                #[allow(dead_code)]
                pub fn auto_update(&self) -> bool {
                    let result = self.0.auto_update();
                    result
                }
                #[allow(dead_code)]
                pub fn set_auto_update(&self, value: bool) -> () {
                    let result = self.0.set_auto_update(value);
                    result
                }
                #[allow(dead_code)]
                pub fn bounds(&self) -> Rectangle {
                    let result = self.0.bounds();
                    result
                }
                #[allow(dead_code)]
                pub fn set_bounds(&self, value: Rectangle) -> () {
                    let result = self.0.set_bounds(value);
                    result
                }
                #[allow(dead_code)]
                pub fn pixel_ratio(&self) -> f64 {
                    let result = self.0.pixel_ratio();
                    result
                }
                #[allow(dead_code)]
                pub fn set_pixel_ratio(&self, value: f64) -> () {
                    let result = self.0.set_pixel_ratio(value);
                    result
                }
                #[allow(dead_code)]
                pub fn size(&self) -> Size {
                    let result = self.0.size();
                    result
                }
                #[allow(dead_code)]
                pub fn set_size(&self, value: Size) -> () {
                    let result = self.0.set_size(value);
                    result
                }
                #[allow(dead_code)]
                pub fn matrix(&self) -> Matrix {
                    let result = self.0.matrix();
                    result
                }
                #[allow(dead_code)]
                pub fn set_matrix(&self, value: Matrix) -> () {
                    let result = self.0.set_matrix(value);
                    result
                }
                #[allow(dead_code)]
                pub fn is_visible(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_visible()?);
                    result
                }
                #[allow(dead_code)]
                pub fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_transform(matrix)?);
                    result
                }
                #[allow(dead_code)]
                pub fn get_event_point(&self, event: Event) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_get_event_point(event)?);
                    result
                }
                #[allow(dead_code)]
                pub fn zoom(&self) -> f64 {
                    let result = self.0.zoom();
                    result
                }
                #[allow(dead_code)]
                pub fn set_zoom(&self, value: f64) -> () {
                    let result = self.0.set_zoom(value);
                    result
                }
                #[allow(dead_code)]
                pub fn on_mouse_leave(&self) -> ViewOnMouseLeave {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_leave()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_on_mouse_leave(&self, value: ViewOnMouseLeave) -> () {
                    let result = self.0.set_on_mouse_leave(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn scaling(&self) -> Point {
                    let result = self.0.scaling();
                    result
                }
                #[allow(dead_code)]
                pub fn set_scaling(&self, value: Point) -> () {
                    let result = self.0.set_scaling(value);
                    result
                }
                #[allow(dead_code)]
                pub fn on_mouse_move(&self) -> ViewOnMouseMove {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_move()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_on_mouse_move(&self, value: ViewOnMouseMove) -> () {
                    let result = self.0.set_on_mouse_move(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn request_update(&self) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_request_update()?);
                    result
                }
                #[allow(dead_code)]
                pub fn skew(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_skew(hor, ver, center)?);
                    result
                }
                #[allow(dead_code)]
                pub fn element(&self) -> JsValue {
                    let result = self.0.element();
                    result
                }
                #[allow(dead_code)]
                pub fn set_element(&self, value: JsValue) -> () {
                    let result = self.0.set_element(value);
                    result
                }
                #[allow(dead_code)]
                pub fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_responds(type_)?);
                    result
                }
                #[allow(dead_code)]
                pub fn pause(&self) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_pause()?);
                    result
                }
                #[allow(dead_code)]
                pub fn play(&self) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_play()?);
                    result
                }
                #[allow(dead_code)]
                pub fn shear(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_shear(hor, ver, center)?);
                    result
                }
                #[allow(dead_code)]
                pub fn on_mouse_enter(&self) -> ViewOnMouseEnter {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_enter()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_on_mouse_enter(&self, value: ViewOnMouseEnter) -> () {
                    let result = self.0.set_on_mouse_enter(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn on_resize(&self) -> ViewOnResize {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.on_resize()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_on_resize(&self, value: ViewOnResize) -> () {
                    let result = self.0.set_on_resize(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for View {
                fn describe() {
                    <View_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for View {
                type Abi = <View_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a View {
                type Abi = <&'a View_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for View {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for View {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: View_Class =
                        <View_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait View_Trait {
                fn resolution(&self) -> f64;
                fn set_resolution(&mut self, value: f64) -> ();
                fn on_frame(&self) -> ViewOnFrame;
                fn set_on_frame(&mut self, value: ViewOnFrame) -> ();
                fn update(&self) -> std::result::Result<bool, JsValue>;
                fn rotate(&self, angle: f64, center: Point) -> std::result::Result<(), JsValue>;
                fn rotation(&self) -> f64;
                fn set_rotation(&mut self, value: f64) -> ();
                fn on_double_click(&self) -> ViewOnDoubleClick;
                fn set_on_double_click(&mut self, value: ViewOnDoubleClick) -> ();
                fn translate(&self, delta: Point) -> std::result::Result<(), JsValue>;
                fn is_inserted(&self) -> std::result::Result<bool, JsValue>;
                fn on_mouse_drag(&self) -> ViewOnMouseDrag;
                fn set_on_mouse_drag(&mut self, value: ViewOnMouseDrag) -> ();
                fn on_mouse_down(&self) -> ViewOnMouseDown;
                fn set_on_mouse_down(&mut self, value: ViewOnMouseDown) -> ();
                fn off(
                    &self,
                    param: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<View, JsValue>;
                fn on_mouse_up(&self) -> ViewOnMouseUp;
                fn set_on_mouse_up(&mut self, value: ViewOnMouseUp) -> ();
                fn remove(&self) -> std::result::Result<(), JsValue>;
                fn emit(
                    &self,
                    type_: String,
                    event: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue>;
                fn scale(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue>;
                fn view_size(&self) -> Size;
                fn set_view_size(&mut self, value: Size) -> ();
                fn project_to_view(&self, point: Point) -> std::result::Result<Point, JsValue>;
                fn on(
                    &self,
                    param: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<View, JsValue>;
                fn view_to_project(&self, point: Point) -> std::result::Result<Point, JsValue>;
                fn on_click(&self) -> ViewOnClick;
                fn set_on_click(&mut self, value: ViewOnClick) -> ();
                fn center(&self) -> Point;
                fn set_center(&mut self, value: Point) -> ();
                fn auto_update(&self) -> bool;
                fn set_auto_update(&mut self, value: bool) -> ();
                fn bounds(&self) -> Rectangle;
                fn set_bounds(&mut self, value: Rectangle) -> ();
                fn pixel_ratio(&self) -> f64;
                fn set_pixel_ratio(&mut self, value: f64) -> ();
                fn size(&self) -> Size;
                fn set_size(&mut self, value: Size) -> ();
                fn matrix(&self) -> Matrix;
                fn set_matrix(&mut self, value: Matrix) -> ();
                fn is_visible(&self) -> std::result::Result<bool, JsValue>;
                fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue>;
                fn get_event_point(&self, event: Event) -> std::result::Result<Point, JsValue>;
                fn zoom(&self) -> f64;
                fn set_zoom(&mut self, value: f64) -> ();
                fn on_mouse_leave(&self) -> ViewOnMouseLeave;
                fn set_on_mouse_leave(&mut self, value: ViewOnMouseLeave) -> ();
                fn scaling(&self) -> Point;
                fn set_scaling(&mut self, value: Point) -> ();
                fn on_mouse_move(&self) -> ViewOnMouseMove;
                fn set_on_mouse_move(&mut self, value: ViewOnMouseMove) -> ();
                fn request_update(&self) -> std::result::Result<(), JsValue>;
                fn skew(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue>;
                fn element(&self) -> JsValue;
                fn set_element(&mut self, value: JsValue) -> ();
                fn responds(&self, type_: String) -> std::result::Result<bool, JsValue>;
                fn pause(&self) -> std::result::Result<(), JsValue>;
                fn play(&self) -> std::result::Result<(), JsValue>;
                fn shear(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue>;
                fn on_mouse_enter(&self) -> ViewOnMouseEnter;
                fn set_on_mouse_enter(&mut self, value: ViewOnMouseEnter) -> ();
                fn on_resize(&self) -> ViewOnResize;
                fn set_on_resize(&mut self, value: ViewOnResize) -> ();
            }
            impl std::clone::Clone for View_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for View_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for View_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ItemShadowColor {
                ColorCase(Color),
                TsBindgenRtNullCase,
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                #[wasm_bindgen(js_name = "Rectangle")]
                type Rectangle_Class;
                # [wasm_bindgen (method , structural , getter = width , js_class = "Rectangle")]
                fn width(this: &Rectangle_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = width , js_class = "Rectangle")]
                fn set_width(this: &Rectangle_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = x , js_class = "Rectangle")]
                fn x(this: &Rectangle_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = x , js_class = "Rectangle")]
                fn set_x(this: &Rectangle_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = include , method , js_class = "Rectangle" , catch)]
                fn __TSB_include(
                    this: &Rectangle_Class,
                    point: Point,
                ) -> std::result::Result<Rectangle, JsValue>;
                # [wasm_bindgen (method , structural , getter = leftCenter , js_class = "Rectangle")]
                fn left_center(this: &Rectangle_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = leftCenter , js_class = "Rectangle")]
                fn set_left_center(this: &Rectangle_Class, value: Point);
                # [wasm_bindgen (method , structural , getter = top , js_class = "Rectangle")]
                fn top(this: &Rectangle_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = top , js_class = "Rectangle")]
                fn set_top(this: &Rectangle_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = topLeft , js_class = "Rectangle")]
                fn top_left(this: &Rectangle_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = topLeft , js_class = "Rectangle")]
                fn set_top_left(this: &Rectangle_Class, value: Point);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = clone , method , js_class = "Rectangle" , catch)]
                fn __TSB_clone(this: &Rectangle_Class) -> std::result::Result<Rectangle, JsValue>;
                # [wasm_bindgen (method , structural , getter = bottom , js_class = "Rectangle")]
                fn bottom(this: &Rectangle_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = bottom , js_class = "Rectangle")]
                fn set_bottom(this: &Rectangle_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = topCenter , js_class = "Rectangle")]
                fn top_center(this: &Rectangle_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = topCenter , js_class = "Rectangle")]
                fn set_top_center(this: &Rectangle_Class, value: Point);
                # [wasm_bindgen (method , structural , getter = bottomCenter , js_class = "Rectangle")]
                fn bottom_center(this: &Rectangle_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = bottomCenter , js_class = "Rectangle")]
                fn set_bottom_center(this: &Rectangle_Class, value: Point);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = toString , method , js_class = "Rectangle" , catch)]
                fn __TSB_to_string(this: &Rectangle_Class) -> std::result::Result<String, JsValue>;
                # [wasm_bindgen (method , structural , getter = bottomRight , js_class = "Rectangle")]
                fn bottom_right(this: &Rectangle_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = bottomRight , js_class = "Rectangle")]
                fn set_bottom_right(this: &Rectangle_Class, value: Point);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = set , method , js_class = "Rectangle" , catch , variadic)]
                fn __TSB_set(
                    this: &Rectangle_Class,
                    values: &[JsValue],
                ) -> std::result::Result<Rectangle, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = intersects , method , js_class = "Rectangle" , catch)]
                fn __TSB_intersects(
                    this: &Rectangle_Class,
                    rect: Rectangle,
                    epsilon: f64,
                ) -> std::result::Result<bool, JsValue>;
                # [wasm_bindgen (method , structural , getter = right , js_class = "Rectangle")]
                fn right(this: &Rectangle_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = right , js_class = "Rectangle")]
                fn set_right(this: &Rectangle_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = rightCenter , js_class = "Rectangle")]
                fn right_center(this: &Rectangle_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = rightCenter , js_class = "Rectangle")]
                fn set_right_center(this: &Rectangle_Class, value: Point);
                # [wasm_bindgen (method , structural , getter = point , js_class = "Rectangle")]
                fn point(this: &Rectangle_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = point , js_class = "Rectangle")]
                fn set_point(this: &Rectangle_Class, value: Point);
                # [wasm_bindgen (method , structural , getter = y , js_class = "Rectangle")]
                fn y(this: &Rectangle_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = y , js_class = "Rectangle")]
                fn set_y(this: &Rectangle_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = expand , method , js_class = "Rectangle" , catch)]
                fn __TSB_expand(
                    this: &Rectangle_Class,
                    hor: f64,
                    ver: f64,
                ) -> std::result::Result<Rectangle, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = contains , method , js_class = "Rectangle" , catch)]
                fn __TSB_contains(
                    this: &Rectangle_Class,
                    rect: Rectangle,
                ) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = equals , method , js_class = "Rectangle" , catch)]
                fn __TSB_equals(
                    this: &Rectangle_Class,
                    rect: Rectangle,
                ) -> std::result::Result<bool, JsValue>;
                # [wasm_bindgen (method , structural , getter = center , js_class = "Rectangle")]
                fn center(this: &Rectangle_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = center , js_class = "Rectangle")]
                fn set_center(this: &Rectangle_Class, value: Point);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = intersect , method , js_class = "Rectangle" , catch)]
                fn __TSB_intersect(
                    this: &Rectangle_Class,
                    rect: Rectangle,
                ) -> std::result::Result<Rectangle, JsValue>;
                # [wasm_bindgen (method , structural , getter = topRight , js_class = "Rectangle")]
                fn top_right(this: &Rectangle_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = topRight , js_class = "Rectangle")]
                fn set_top_right(this: &Rectangle_Class, value: Point);
                # [wasm_bindgen (method , structural , getter = selected , js_class = "Rectangle")]
                fn selected(this: &Rectangle_Class) -> bool;
                # [wasm_bindgen (method , structural , setter = selected , js_class = "Rectangle")]
                fn set_selected(this: &Rectangle_Class, value: bool);
                # [wasm_bindgen (method , structural , getter = area , js_class = "Rectangle")]
                fn area(this: &Rectangle_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = area , js_class = "Rectangle")]
                fn set_area(this: &Rectangle_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = height , js_class = "Rectangle")]
                fn height(this: &Rectangle_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = height , js_class = "Rectangle")]
                fn set_height(this: &Rectangle_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = bottomLeft , js_class = "Rectangle")]
                fn bottom_left(this: &Rectangle_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = bottomLeft , js_class = "Rectangle")]
                fn set_bottom_left(this: &Rectangle_Class, value: Point);
                #[wasm_bindgen(constructor, js_class = "Rectangle")]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Rectangle_Class;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isEmpty , method , js_class = "Rectangle" , catch)]
                fn __TSB_is_empty(this: &Rectangle_Class) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = scale , method , js_class = "Rectangle" , catch)]
                fn __TSB_scale(
                    this: &Rectangle_Class,
                    hor: f64,
                    ver: f64,
                ) -> std::result::Result<Rectangle, JsValue>;
                # [wasm_bindgen (method , structural , getter = size , js_class = "Rectangle")]
                fn size(this: &Rectangle_Class) -> Size;
                # [wasm_bindgen (method , structural , setter = size , js_class = "Rectangle")]
                fn set_size(this: &Rectangle_Class, value: Size);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = unite , method , js_class = "Rectangle" , catch)]
                fn __TSB_unite(
                    this: &Rectangle_Class,
                    rect: Rectangle,
                ) -> std::result::Result<Rectangle, JsValue>;
                # [wasm_bindgen (method , structural , getter = left , js_class = "Rectangle")]
                fn left(this: &Rectangle_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = left , js_class = "Rectangle")]
                fn set_left(this: &Rectangle_Class, value: f64);
            }
            #[derive(std :: clone :: Clone)]
            struct Rectangle(pub Rectangle_Class);
            impl Rectangle {
                #[allow(dead_code)]
                pub fn width(&self) -> f64 {
                    let result = self.0.width();
                    result
                }
                #[allow(dead_code)]
                pub fn set_width(&self, value: f64) -> () {
                    let result = self.0.set_width(value);
                    result
                }
                #[allow(dead_code)]
                pub fn x(&self) -> f64 {
                    let result = self.0.x();
                    result
                }
                #[allow(dead_code)]
                pub fn set_x(&self, value: f64) -> () {
                    let result = self.0.set_x(value);
                    result
                }
                #[allow(dead_code)]
                pub fn include(&self, point: Point) -> std::result::Result<Rectangle, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_include(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn left_center(&self) -> Point {
                    let result = self.0.left_center();
                    result
                }
                #[allow(dead_code)]
                pub fn set_left_center(&self, value: Point) -> () {
                    let result = self.0.set_left_center(value);
                    result
                }
                #[allow(dead_code)]
                pub fn top(&self) -> f64 {
                    let result = self.0.top();
                    result
                }
                #[allow(dead_code)]
                pub fn set_top(&self, value: f64) -> () {
                    let result = self.0.set_top(value);
                    result
                }
                #[allow(dead_code)]
                pub fn top_left(&self) -> Point {
                    let result = self.0.top_left();
                    result
                }
                #[allow(dead_code)]
                pub fn set_top_left(&self, value: Point) -> () {
                    let result = self.0.set_top_left(value);
                    result
                }
                #[allow(dead_code)]
                pub fn clone(&self) -> std::result::Result<Rectangle, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_clone()?);
                    result
                }
                #[allow(dead_code)]
                pub fn bottom(&self) -> f64 {
                    let result = self.0.bottom();
                    result
                }
                #[allow(dead_code)]
                pub fn set_bottom(&self, value: f64) -> () {
                    let result = self.0.set_bottom(value);
                    result
                }
                #[allow(dead_code)]
                pub fn top_center(&self) -> Point {
                    let result = self.0.top_center();
                    result
                }
                #[allow(dead_code)]
                pub fn set_top_center(&self, value: Point) -> () {
                    let result = self.0.set_top_center(value);
                    result
                }
                #[allow(dead_code)]
                pub fn bottom_center(&self) -> Point {
                    let result = self.0.bottom_center();
                    result
                }
                #[allow(dead_code)]
                pub fn set_bottom_center(&self, value: Point) -> () {
                    let result = self.0.set_bottom_center(value);
                    result
                }
                #[allow(dead_code)]
                pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_to_string()?);
                    result
                }
                #[allow(dead_code)]
                pub fn bottom_right(&self) -> Point {
                    let result = self.0.bottom_right();
                    result
                }
                #[allow(dead_code)]
                pub fn set_bottom_right(&self, value: Point) -> () {
                    let result = self.0.set_bottom_right(value);
                    result
                }
                #[allow(dead_code)]
                pub fn set(&self, values: &[JsValue]) -> std::result::Result<Rectangle, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_set(values)?);
                    result
                }
                #[allow(dead_code)]
                pub fn intersects(
                    &self,
                    rect: Rectangle,
                    epsilon: f64,
                ) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_intersects(rect, epsilon)?);
                    result
                }
                #[allow(dead_code)]
                pub fn right(&self) -> f64 {
                    let result = self.0.right();
                    result
                }
                #[allow(dead_code)]
                pub fn set_right(&self, value: f64) -> () {
                    let result = self.0.set_right(value);
                    result
                }
                #[allow(dead_code)]
                pub fn right_center(&self) -> Point {
                    let result = self.0.right_center();
                    result
                }
                #[allow(dead_code)]
                pub fn set_right_center(&self, value: Point) -> () {
                    let result = self.0.set_right_center(value);
                    result
                }
                #[allow(dead_code)]
                pub fn point(&self) -> Point {
                    let result = self.0.point();
                    result
                }
                #[allow(dead_code)]
                pub fn set_point(&self, value: Point) -> () {
                    let result = self.0.set_point(value);
                    result
                }
                #[allow(dead_code)]
                pub fn y(&self) -> f64 {
                    let result = self.0.y();
                    result
                }
                #[allow(dead_code)]
                pub fn set_y(&self, value: f64) -> () {
                    let result = self.0.set_y(value);
                    result
                }
                #[allow(dead_code)]
                pub fn expand(
                    &self,
                    hor: f64,
                    ver: f64,
                ) -> std::result::Result<Rectangle, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_expand(hor, ver)?);
                    result
                }
                #[allow(dead_code)]
                pub fn contains(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_contains(rect)?);
                    result
                }
                #[allow(dead_code)]
                pub fn equals(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_equals(rect)?);
                    result
                }
                #[allow(dead_code)]
                pub fn center(&self) -> Point {
                    let result = self.0.center();
                    result
                }
                #[allow(dead_code)]
                pub fn set_center(&self, value: Point) -> () {
                    let result = self.0.set_center(value);
                    result
                }
                #[allow(dead_code)]
                pub fn intersect(
                    &self,
                    rect: Rectangle,
                ) -> std::result::Result<Rectangle, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_intersect(rect)?);
                    result
                }
                #[allow(dead_code)]
                pub fn top_right(&self) -> Point {
                    let result = self.0.top_right();
                    result
                }
                #[allow(dead_code)]
                pub fn set_top_right(&self, value: Point) -> () {
                    let result = self.0.set_top_right(value);
                    result
                }
                #[allow(dead_code)]
                pub fn selected(&self) -> bool {
                    let result = self.0.selected();
                    result
                }
                #[allow(dead_code)]
                pub fn set_selected(&self, value: bool) -> () {
                    let result = self.0.set_selected(value);
                    result
                }
                #[allow(dead_code)]
                pub fn area(&self) -> f64 {
                    let result = self.0.area();
                    result
                }
                #[allow(dead_code)]
                pub fn set_area(&self, value: f64) -> () {
                    let result = self.0.set_area(value);
                    result
                }
                #[allow(dead_code)]
                pub fn height(&self) -> f64 {
                    let result = self.0.height();
                    result
                }
                #[allow(dead_code)]
                pub fn set_height(&self, value: f64) -> () {
                    let result = self.0.set_height(value);
                    result
                }
                #[allow(dead_code)]
                pub fn bottom_left(&self) -> Point {
                    let result = self.0.bottom_left();
                    result
                }
                #[allow(dead_code)]
                pub fn set_bottom_left(&self, value: Point) -> () {
                    let result = self.0.set_bottom_left(value);
                    result
                }
                #[allow(dead_code)]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Rectangle {
                    let result = Rectangle_Class::new(object);
                    let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                    Rectangle(result)
                }
                #[allow(dead_code)]
                pub fn is_empty(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_empty()?);
                    result
                }
                #[allow(dead_code)]
                pub fn scale(&self, hor: f64, ver: f64) -> std::result::Result<Rectangle, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_scale(hor, ver)?);
                    result
                }
                #[allow(dead_code)]
                pub fn size(&self) -> Size {
                    let result = self.0.size();
                    result
                }
                #[allow(dead_code)]
                pub fn set_size(&self, value: Size) -> () {
                    let result = self.0.set_size(value);
                    result
                }
                #[allow(dead_code)]
                pub fn unite(&self, rect: Rectangle) -> std::result::Result<Rectangle, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_unite(rect)?);
                    result
                }
                #[allow(dead_code)]
                pub fn left(&self) -> f64 {
                    let result = self.0.left();
                    result
                }
                #[allow(dead_code)]
                pub fn set_left(&self, value: f64) -> () {
                    let result = self.0.set_left(value);
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for Rectangle {
                fn describe() {
                    <Rectangle_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for Rectangle {
                type Abi = <Rectangle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Rectangle {
                type Abi = <&'a Rectangle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for Rectangle {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Rectangle {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: Rectangle_Class =
                        <Rectangle_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait Rectangle_Trait {
                fn width(&self) -> f64;
                fn set_width(&mut self, value: f64) -> ();
                fn x(&self) -> f64;
                fn set_x(&mut self, value: f64) -> ();
                fn include(&self, point: Point) -> std::result::Result<Rectangle, JsValue>;
                fn left_center(&self) -> Point;
                fn set_left_center(&mut self, value: Point) -> ();
                fn top(&self) -> f64;
                fn set_top(&mut self, value: f64) -> ();
                fn top_left(&self) -> Point;
                fn set_top_left(&mut self, value: Point) -> ();
                fn clone(&self) -> std::result::Result<Rectangle, JsValue>;
                fn bottom(&self) -> f64;
                fn set_bottom(&mut self, value: f64) -> ();
                fn top_center(&self) -> Point;
                fn set_top_center(&mut self, value: Point) -> ();
                fn bottom_center(&self) -> Point;
                fn set_bottom_center(&mut self, value: Point) -> ();
                fn to_string(&self) -> std::result::Result<String, JsValue>;
                fn bottom_right(&self) -> Point;
                fn set_bottom_right(&mut self, value: Point) -> ();
                fn set(&self, values: &[JsValue]) -> std::result::Result<Rectangle, JsValue>;
                fn intersects(
                    &self,
                    rect: Rectangle,
                    epsilon: f64,
                ) -> std::result::Result<bool, JsValue>;
                fn right(&self) -> f64;
                fn set_right(&mut self, value: f64) -> ();
                fn right_center(&self) -> Point;
                fn set_right_center(&mut self, value: Point) -> ();
                fn point(&self) -> Point;
                fn set_point(&mut self, value: Point) -> ();
                fn y(&self) -> f64;
                fn set_y(&mut self, value: f64) -> ();
                fn expand(&self, hor: f64, ver: f64) -> std::result::Result<Rectangle, JsValue>;
                fn contains(&self, rect: Rectangle) -> std::result::Result<bool, JsValue>;
                fn equals(&self, rect: Rectangle) -> std::result::Result<bool, JsValue>;
                fn center(&self) -> Point;
                fn set_center(&mut self, value: Point) -> ();
                fn intersect(&self, rect: Rectangle) -> std::result::Result<Rectangle, JsValue>;
                fn top_right(&self) -> Point;
                fn set_top_right(&mut self, value: Point) -> ();
                fn selected(&self) -> bool;
                fn set_selected(&mut self, value: bool) -> ();
                fn area(&self) -> f64;
                fn set_area(&mut self, value: f64) -> ();
                fn height(&self) -> f64;
                fn set_height(&mut self, value: f64) -> ();
                fn bottom_left(&self) -> Point;
                fn set_bottom_left(&mut self, value: Point) -> ();
                fn new(object: std::collections::HashMap<String, JsValue>) -> Rectangle;
                fn is_empty(&self) -> std::result::Result<bool, JsValue>;
                fn scale(&self, hor: f64, ver: f64) -> std::result::Result<Rectangle, JsValue>;
                fn size(&self) -> Size;
                fn set_size(&mut self, value: Size) -> ();
                fn unite(&self, rect: Rectangle) -> std::result::Result<Rectangle, JsValue>;
                fn left(&self) -> f64;
                fn set_left(&mut self, value: f64) -> ();
            }
            impl std::clone::Clone for Rectangle_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for Rectangle_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Rectangle_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum StyleFillColor {
                ColorCase(Color),
                TsBindgenRtNullCase,
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                # [wasm_bindgen (js_name = "Star" , extends = Path_Class)]
                type Star_Class;
                #[wasm_bindgen(constructor, js_class = "Star")]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Star_Class;
            }
            #[derive(std :: clone :: Clone)]
            struct Star(pub Star_Class);
            impl std::convert::From<&Star> for Path {
                fn from(src: &Star) -> Path {
                    let src: &Path_Class = src.0.as_ref();
                    Path(src.clone())
                }
            }
            impl std::convert::From<&mut Star> for Path {
                fn from(src: &mut Star) -> Path {
                    let src: &Path_Class = src.0.as_ref();
                    Path(src.clone())
                }
            }
            impl Star {
                #[allow(dead_code)]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Star {
                    let result = Star_Class::new(object);
                    let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                    Star(result)
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for Star {
                fn describe() {
                    <Star_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for Star {
                type Abi = <Star_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Star {
                type Abi = <&'a Star_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for Star {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Star {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: Star_Class =
                        <Star_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait Star_Trait: Path_Trait {
                fn new(object: std::collections::HashMap<String, JsValue>) -> Star;
            }
            impl Path_Trait for Star {}
            impl Star_Trait for Star {}
            impl std::clone::Clone for Star_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for Star_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Star_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum StyleFontWeight {
                F64Case(f64),
                StringCase(String),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum CurveGetWeightedNormalAtParamsLocationParam {
                CurveLocationCase(CurveLocation),
                F64Case(f64),
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                #[wasm_bindgen(js_name = "Key")]
                type Key_Class;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isDown , method , js_class = "Key" , catch)]
                fn __TSB_is_down(
                    this: &Key_Class,
                    key: String,
                ) -> std::result::Result<bool, JsValue>;
                # [wasm_bindgen (method , structural , getter = modifiers , js_class = "Key")]
                fn modifiers(this: &Key_Class) -> JsValue;
                # [wasm_bindgen (method , structural , setter = modifiers , js_class = "Key")]
                fn set_modifiers(this: &Key_Class, value: JsValue);
            }
            #[derive(std :: clone :: Clone)]
            struct Key(pub Key_Class);
            impl Key {
                #[allow(dead_code)]
                pub fn is_down(&self, key: String) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_down(key)?);
                    result
                }
                #[allow(dead_code)]
                pub fn modifiers(&self) -> JsValue {
                    let result = self.0.modifiers();
                    result
                }
                #[allow(dead_code)]
                pub fn set_modifiers(&self, value: JsValue) -> () {
                    let result = self.0.set_modifiers(value);
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for Key {
                fn describe() {
                    <Key_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for Key {
                type Abi = <Key_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Key {
                type Abi = <&'a Key_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for Key {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Key {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: Key_Class =
                        <Key_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait Key_Trait {
                fn is_down(&self, key: String) -> std::result::Result<bool, JsValue>;
                fn modifiers(&self) -> JsValue;
                fn set_modifiers(&mut self, value: JsValue) -> ();
            }
            impl std::clone::Clone for Key_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for Key_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Key_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ViewOnMouseUp {
                TsBindgenRtNullCase,
                JsValueCase(JsValue),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum RasterGetAverageColorParamsObjectParam {
                PathCase(Path),
                PointCase(Point),
                RectangleCase(Rectangle),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum CurveGetNormalAtParamsLocationParam {
                CurveLocationCase(CurveLocation),
                F64Case(f64),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum PathSplitAtParamsLocationParam {
                CurveLocationCase(CurveLocation),
                F64Case(f64),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ItemOnFrame {
                TsBindgenRtNullCase,
                JsValueCase(JsValue),
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                # [wasm_bindgen (js_name = "Shape" , extends = Item_Class)]
                type Shape_Class;
                # [wasm_bindgen (method , structural , getter = type , js_class = "Shape")]
                fn type_(this: &Shape_Class) -> String;
                # [wasm_bindgen (method , structural , setter = type , js_class = "Shape")]
                fn set_type_(this: &Shape_Class, value: String);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = toPath , method , js_class = "Shape" , catch)]
                fn __TSB_to_path(
                    this: &Shape_Class,
                    insert: bool,
                ) -> std::result::Result<Path, JsValue>;
                # [wasm_bindgen (method , structural , getter = size , js_class = "Shape")]
                fn size(this: &Shape_Class) -> Size;
                # [wasm_bindgen (method , structural , setter = size , js_class = "Shape")]
                fn set_size(this: &Shape_Class, value: Size);
                # [wasm_bindgen (method , structural , getter = radius , js_class = "Shape")]
                fn radius(this: &Shape_Class) -> ShapeRadius;
                # [wasm_bindgen (method , structural , setter = radius , js_class = "Shape")]
                fn set_radius(this: &Shape_Class, value: ShapeRadius);
            }
            #[derive(std :: clone :: Clone)]
            struct Shape(pub Shape_Class);
            impl std::convert::From<&Shape> for Item {
                fn from(src: &Shape) -> Item {
                    let src: &Item_Class = src.0.as_ref();
                    Item(src.clone())
                }
            }
            impl std::convert::From<&mut Shape> for Item {
                fn from(src: &mut Shape) -> Item {
                    let src: &Item_Class = src.0.as_ref();
                    Item(src.clone())
                }
            }
            impl Shape {
                #[allow(dead_code)]
                pub fn type_(&self) -> String {
                    let result = self.0.type_();
                    result
                }
                #[allow(dead_code)]
                pub fn set_type_(&self, value: String) -> () {
                    let result = self.0.set_type_(value);
                    result
                }
                #[allow(dead_code)]
                pub fn to_path(&self, insert: bool) -> std::result::Result<Path, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_to_path(insert)?);
                    result
                }
                #[allow(dead_code)]
                pub fn size(&self) -> Size {
                    let result = self.0.size();
                    result
                }
                #[allow(dead_code)]
                pub fn set_size(&self, value: Size) -> () {
                    let result = self.0.set_size(value);
                    result
                }
                #[allow(dead_code)]
                pub fn radius(&self) -> ShapeRadius {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.radius()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_radius(&self, value: ShapeRadius) -> () {
                    let result = self.0.set_radius(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for Shape {
                fn describe() {
                    <Shape_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for Shape {
                type Abi = <Shape_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Shape {
                type Abi = <&'a Shape_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for Shape {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Shape {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: Shape_Class =
                        <Shape_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait Shape_Trait: Item_Trait {
                fn type_(&self) -> String;
                fn set_type(&mut self, value: String) -> ();
                fn to_path(&self, insert: bool) -> std::result::Result<Path, JsValue>;
                fn size(&self) -> Size;
                fn set_size(&mut self, value: Size) -> ();
                fn radius(&self) -> ShapeRadius;
                fn set_radius(&mut self, value: ShapeRadius) -> ();
            }
            impl Item_Trait for Shape {
                fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::insert_below(&target, item)
                }
                fn on_double_click(&self) -> ItemOnDoubleClick {
                    let target: Item = self.into();
                    Item::on_double_click(&target)
                }
                fn set_on_double_click(&mut self, value: ItemOnDoubleClick) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_double_click(&mut target, value)
                }
                fn view(&self) -> View {
                    let target: Item = self.into();
                    Item::view(&target)
                }
                fn set_view(&mut self, value: View) -> () {
                    let mut target: Item = self.into();
                    Item::set_view(&mut target, value)
                }
                fn blend_mode(&self) -> String {
                    let target: Item = self.into();
                    Item::blend_mode(&target)
                }
                fn set_blend_mode(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_blend_mode(&mut target, value)
                }
                fn name(&self) -> String {
                    let target: Item = self.into();
                    Item::name(&target)
                }
                fn set_name(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_name(&mut target, value)
                }
                fn project(&self) -> Project {
                    let target: Item = self.into();
                    Item::project(&target)
                }
                fn set_project(&mut self, value: Project) -> () {
                    let mut target: Item = self.into();
                    Item::set_project(&mut target, value)
                }
                fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_child(&target, item)
                }
                fn global_matrix(&self) -> Matrix {
                    let target: Item = self.into();
                    Item::global_matrix(&target)
                }
                fn set_global_matrix(&mut self, value: Matrix) -> () {
                    let mut target: Item = self.into();
                    Item::set_global_matrix(&mut target, value)
                }
                fn on_mouse_leave(&self) -> ItemOnMouseLeave {
                    let target: Item = self.into();
                    Item::on_mouse_leave(&target)
                }
                fn set_on_mouse_leave(&mut self, value: ItemOnMouseLeave) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_leave(&mut target, value)
                }
                fn has_children(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_children(&target)
                }
                fn selected(&self) -> bool {
                    let target: Item = self.into();
                    Item::selected(&target)
                }
                fn set_selected(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_selected(&mut target, value)
                }
                fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::global_to_local(&target, point)
                }
                fn shadow_blur(&self) -> f64 {
                    let target: Item = self.into();
                    Item::shadow_blur(&target)
                }
                fn set_shadow_blur(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_shadow_blur(&mut target, value)
                }
                fn children(&self) -> Vec<Item> {
                    let target: Item = self.into();
                    Item::children(&target)
                }
                fn set_children(&mut self, value: Vec<Item>) -> () {
                    let mut target: Item = self.into();
                    Item::set_children(&mut target, value)
                }
                fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::replace_with(&target, item)
                }
                fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::import_json(&target, json)
                }
                fn insert_child(
                    &self,
                    index: f64,
                    item: Item,
                ) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::insert_child(&target, index, item)
                }
                fn stroke_join(&self) -> String {
                    let target: Item = self.into();
                    Item::stroke_join(&target)
                }
                fn set_stroke_join(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_join(&mut target, value)
                }
                fn rotation(&self) -> f64 {
                    let target: Item = self.into();
                    Item::rotation(&target)
                }
                fn set_rotation(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_rotation(&mut target, value)
                }
                fn scaling(&self) -> Point {
                    let target: Item = self.into();
                    Item::scaling(&target)
                }
                fn set_scaling(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_scaling(&mut target, value)
                }
                fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_ancestor(&target, item)
                }
                fn emit(
                    &self,
                    type_: String,
                    event: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::emit(&target, type_, event)
                }
                fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_up(&target)
                }
                fn add_to(
                    &self,
                    owner: ItemAddToParamsOwnerParam,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::add_to(&target, owner)
                }
                fn stroke_cap(&self) -> String {
                    let target: Item = self.into();
                    Item::stroke_cap(&target)
                }
                fn set_stroke_cap(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_cap(&mut target, value)
                }
                fn on_mouse_drag(&self) -> ItemOnMouseDrag {
                    let target: Item = self.into();
                    Item::on_mouse_drag(&target)
                }
                fn set_on_mouse_drag(&mut self, value: ItemOnMouseDrag) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_drag(&mut target, value)
                }
                fn set(
                    &self,
                    props: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::set(&target, props)
                }
                fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::reverse_children(&target)
                }
                fn matches(
                    &self,
                    name: String,
                    compare: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::matches(&target, name, compare)
                }
                fn on_mouse_enter(&self) -> ItemOnMouseEnter {
                    let target: Item = self.into();
                    Item::on_mouse_enter(&target)
                }
                fn set_on_mouse_enter(&mut self, value: ItemOnMouseEnter) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_enter(&mut target, value)
                }
                fn shadow_offset(&self) -> Point {
                    let target: Item = self.into();
                    Item::shadow_offset(&target)
                }
                fn set_shadow_offset(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_shadow_offset(&mut target, value)
                }
                fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_stroke(&target)
                }
                fn view_matrix(&self) -> Matrix {
                    let target: Item = self.into();
                    Item::view_matrix(&target)
                }
                fn set_view_matrix(&mut self, value: Matrix) -> () {
                    let mut target: Item = self.into();
                    Item::set_view_matrix(&mut target, value)
                }
                fn on_frame(&self) -> ItemOnFrame {
                    let target: Item = self.into();
                    Item::on_frame(&target)
                }
                fn set_on_frame(&mut self, value: ItemOnFrame) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_frame(&mut target, value)
                }
                fn on_mouse_down(&self) -> ItemOnMouseDown {
                    let target: Item = self.into();
                    Item::on_mouse_down(&target)
                }
                fn set_on_mouse_down(&mut self, value: ItemOnMouseDown) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_down(&mut target, value)
                }
                fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_sibling(&target, item)
                }
                fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::local_to_global(&target, point)
                }
                fn first_child(&self) -> Item {
                    let target: Item = self.into();
                    Item::first_child(&target)
                }
                fn set_first_child(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_first_child(&mut target, value)
                }
                fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::send_to_back(&target)
                }
                fn clip_mask(&self) -> bool {
                    let target: Item = self.into();
                    Item::clip_mask(&target)
                }
                fn set_clip_mask(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_clip_mask(&mut target, value)
                }
                fn next_sibling(&self) -> Item {
                    let target: Item = self.into();
                    Item::next_sibling(&target)
                }
                fn set_next_sibling(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_next_sibling(&mut target, value)
                }
                fn off(
                    &self,
                    object: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::off(&target, object)
                }
                fn rotate(&self, angle: f64, center: Point) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::rotate(&target, angle, center)
                }
                fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::add_child(&target, item)
                }
                fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_grouped_with(&target, item)
                }
                fn scale(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::scale(&target, hor, ver, center)
                }
                fn hit_test_all(
                    &self,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Vec<HitResult>, JsValue> {
                    let target: Item = self.into();
                    Item::hit_test_all(&target, point, options)
                }
                fn insert_children(
                    &self,
                    index: f64,
                    items: Vec<Item>,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::insert_children(&target, index, items)
                }
                fn style(&self) -> Style {
                    let target: Item = self.into();
                    Item::style(&target)
                }
                fn set_style(&mut self, value: Style) -> () {
                    let mut target: Item = self.into();
                    Item::set_style(&mut target, value)
                }
                fn position(&self) -> Point {
                    let target: Item = self.into();
                    Item::position(&target)
                }
                fn set_position(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_position(&mut target, value)
                }
                fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::transform(&target, matrix)
                }
                fn fill_color(&self) -> ItemFillColor {
                    let target: Item = self.into();
                    Item::fill_color(&target)
                }
                fn set_fill_color(&mut self, value: ItemFillColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_fill_color(&mut target, value)
                }
                fn matrix(&self) -> Matrix {
                    let target: Item = self.into();
                    Item::matrix(&target)
                }
                fn set_matrix(&mut self, value: Matrix) -> () {
                    let mut target: Item = self.into();
                    Item::set_matrix(&mut target, value)
                }
                fn id(&self) -> f64 {
                    let target: Item = self.into();
                    Item::id(&target)
                }
                fn set_id(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_id(&mut target, value)
                }
                fn tween(
                    &self,
                    options: ItemTweenParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let target: Item = self.into();
                    Item::tween(&target, options)
                }
                fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::reduce(&target, options)
                }
                fn internal_bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::internal_bounds(&target)
                }
                fn set_internal_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_internal_bounds(&mut target, value)
                }
                fn fill_rule(&self) -> String {
                    let target: Item = self.into();
                    Item::fill_rule(&target)
                }
                fn set_fill_rule(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_fill_rule(&mut target, value)
                }
                fn shadow_color(&self) -> ItemShadowColor {
                    let target: Item = self.into();
                    Item::shadow_color(&target)
                }
                fn set_shadow_color(&mut self, value: ItemShadowColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_shadow_color(&mut target, value)
                }
                fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::insert_above(&target, item)
                }
                fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::responds(&target, type_)
                }
                fn handle_bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::handle_bounds(&target)
                }
                fn set_handle_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_handle_bounds(&mut target, value)
                }
                fn skew(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::skew(&target, hor, ver, center)
                }
                fn on_click(&self) -> ItemOnClick {
                    let target: Item = self.into();
                    Item::on_click(&target)
                }
                fn set_on_click(&mut self, value: ItemOnClick) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_click(&mut target, value)
                }
                fn get_items(
                    &self,
                    options: ItemGetItemsParamsOptionsParam,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::get_items(&target, options)
                }
                fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_inserted(&target)
                }
                fn get_item(
                    &self,
                    options: ItemGetItemParamsOptionsParam,
                ) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::get_item(&target, options)
                }
                fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_fill(&target)
                }
                fn shear(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::shear(&target, hor, ver, center)
                }
                fn visible(&self) -> bool {
                    let target: Item = self.into();
                    Item::visible(&target)
                }
                fn set_visible(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_visible(&mut target, value)
                }
                fn previous_sibling(&self) -> Item {
                    let target: Item = self.into();
                    Item::previous_sibling(&target)
                }
                fn set_previous_sibling(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_previous_sibling(&mut target, value)
                }
                fn hit_test(
                    &self,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<HitResult, JsValue> {
                    let target: Item = self.into();
                    Item::hit_test(&target, point, options)
                }
                fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_descendant(&target, item)
                }
                fn locked(&self) -> bool {
                    let target: Item = self.into();
                    Item::locked(&target)
                }
                fn set_locked(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_locked(&mut target, value)
                }
                fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_parent(&target, item)
                }
                fn copy_attributes(
                    &self,
                    source: Item,
                    exclude_matrix: bool,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::copy_attributes(&target, source, exclude_matrix)
                }
                fn last_child(&self) -> Item {
                    let target: Item = self.into();
                    Item::last_child(&target)
                }
                fn set_last_child(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_last_child(&mut target, value)
                }
                fn stroke_width(&self) -> f64 {
                    let target: Item = self.into();
                    Item::stroke_width(&target)
                }
                fn set_stroke_width(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_width(&mut target, value)
                }
                fn parent(&self) -> Item {
                    let target: Item = self.into();
                    Item::parent(&target)
                }
                fn set_parent(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_parent(&mut target, value)
                }
                fn stroke_bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::stroke_bounds(&target)
                }
                fn set_stroke_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_bounds(&mut target, value)
                }
                fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::translate(&target, delta)
                }
                fn remove(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::remove(&target)
                }
                fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::parent_to_local(&target, point)
                }
                fn bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::bounds(&target)
                }
                fn set_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_bounds(&mut target, value)
                }
                fn add_children(
                    &self,
                    items: Vec<Item>,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::add_children(&target, items)
                }
                fn dash_array(&self) -> Vec<f64> {
                    let target: Item = self.into();
                    Item::dash_array(&target)
                }
                fn set_dash_array(&mut self, value: Vec<f64>) -> () {
                    let mut target: Item = self.into();
                    Item::set_dash_array(&mut target, value)
                }
                fn on_mouse_up(&self) -> ItemOnMouseUp {
                    let target: Item = self.into();
                    Item::on_mouse_up(&target)
                }
                fn set_on_mouse_up(&mut self, value: ItemOnMouseUp) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_up(&mut target, value)
                }
                fn on(
                    &self,
                    object: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::on(&target, object)
                }
                fn remove_on(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on(&target, options)
                }
                fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_below(&target, item)
                }
                fn apply_matrix(&self) -> bool {
                    let target: Item = self.into();
                    Item::apply_matrix(&target)
                }
                fn set_apply_matrix(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_apply_matrix(&mut target, value)
                }
                fn clone(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::clone(&target, options)
                }
                fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::contains(&target, point)
                }
                fn export_json(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<String, JsValue> {
                    let target: Item = self.into();
                    Item::export_json(&target, options)
                }
                fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::bring_to_front(&target)
                }
                fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_above(&target, item)
                }
                fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_drag(&target)
                }
                fn data(&self) -> JsValue {
                    let target: Item = self.into();
                    Item::data(&target)
                }
                fn set_data(&mut self, value: JsValue) -> () {
                    let mut target: Item = self.into();
                    Item::set_data(&mut target, value)
                }
                fn import_svg(
                    &self,
                    svg: ItemImportSvgParamsSvgParam,
                    on_load: JsValue,
                ) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::import_svg(&target, svg, on_load)
                }
                fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_shadow(&target)
                }
                fn selected_color(&self) -> ItemSelectedColor {
                    let target: Item = self.into();
                    Item::selected_color(&target)
                }
                fn set_selected_color(&mut self, value: ItemSelectedColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_selected_color(&mut target, value)
                }
                fn class_name(&self) -> String {
                    let target: Item = self.into();
                    Item::class_name(&target)
                }
                fn set_class_name(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_class_name(&mut target, value)
                }
                fn export_svg(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                    let target: Item = self.into();
                    Item::export_svg(&target, options)
                }
                fn tween_to(
                    &self,
                    to: std::collections::HashMap<String, JsValue>,
                    options: ItemTweenToParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let target: Item = self.into();
                    Item::tween_to(&target, to, options)
                }
                fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_inside(&target, rect)
                }
                fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_empty(&target, recursively)
                }
                fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::copy_content(&target, source)
                }
                fn rasterize(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Raster, JsValue> {
                    let target: Item = self.into();
                    Item::rasterize(&target, options)
                }
                fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_move(&target)
                }
                fn tween_from(
                    &self,
                    from: std::collections::HashMap<String, JsValue>,
                    options: ItemTweenFromParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let target: Item = self.into();
                    Item::tween_from(&target, from, options)
                }
                fn opacity(&self) -> f64 {
                    let target: Item = self.into();
                    Item::opacity(&target)
                }
                fn set_opacity(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_opacity(&mut target, value)
                }
                fn dash_offset(&self) -> f64 {
                    let target: Item = self.into();
                    Item::dash_offset(&target)
                }
                fn set_dash_offset(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_dash_offset(&mut target, value)
                }
                fn remove_children(
                    &self,
                    start: f64,
                    end: f64,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::remove_children(&target, start, end)
                }
                fn on_mouse_move(&self) -> ItemOnMouseMove {
                    let target: Item = self.into();
                    Item::on_mouse_move(&target)
                }
                fn set_on_mouse_move(&mut self, value: ItemOnMouseMove) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_move(&mut target, value)
                }
                fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::intersects(&target, item)
                }
                fn pivot(&self) -> Point {
                    let target: Item = self.into();
                    Item::pivot(&target)
                }
                fn set_pivot(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_pivot(&mut target, value)
                }
                fn copy_to(
                    &self,
                    owner: ItemCopyToParamsOwnerParam,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::copy_to(&target, owner)
                }
                fn index(&self) -> f64 {
                    let target: Item = self.into();
                    Item::index(&target)
                }
                fn set_index(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_index(&mut target, value)
                }
                fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::local_to_parent(&target, point)
                }
                fn stroke_color(&self) -> ItemStrokeColor {
                    let target: Item = self.into();
                    Item::stroke_color(&target)
                }
                fn set_stroke_color(&mut self, value: ItemStrokeColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_color(&mut target, value)
                }
                fn layer(&self) -> Layer {
                    let target: Item = self.into();
                    Item::layer(&target)
                }
                fn set_layer(&mut self, value: Layer) -> () {
                    let mut target: Item = self.into();
                    Item::set_layer(&mut target, value)
                }
                fn stroke_scaling(&self) -> bool {
                    let target: Item = self.into();
                    Item::stroke_scaling(&target)
                }
                fn set_stroke_scaling(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_scaling(&mut target, value)
                }
                fn fit_bounds(
                    &self,
                    rectangle: Rectangle,
                    fill: bool,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::fit_bounds(&target, rectangle, fill)
                }
                fn miter_limit(&self) -> f64 {
                    let target: Item = self.into();
                    Item::miter_limit(&target)
                }
                fn set_miter_limit(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_miter_limit(&mut target, value)
                }
                fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_down(&target)
                }
            }
            impl Shape_Trait for Shape {}
            impl std::clone::Clone for Shape_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for Shape_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Shape_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                # [wasm_bindgen (js_name = "SymbolItem" , extends = Item_Class)]
                type SymbolItem_Class;
                # [wasm_bindgen (method , structural , getter = definition , js_class = "SymbolItem")]
                fn definition(this: &SymbolItem_Class) -> SymbolDefinition;
                # [wasm_bindgen (method , structural , setter = definition , js_class = "SymbolItem")]
                fn set_definition(this: &SymbolItem_Class, value: SymbolDefinition);
                #[wasm_bindgen(constructor, js_class = "SymbolItem")]
                pub fn new(
                    definition: SymbolItemConstructorDefinitionParam,
                    point: Point,
                ) -> SymbolItem_Class;
            }
            #[derive(std :: clone :: Clone)]
            struct SymbolItem(pub SymbolItem_Class);
            impl std::convert::From<&SymbolItem> for Item {
                fn from(src: &SymbolItem) -> Item {
                    let src: &Item_Class = src.0.as_ref();
                    Item(src.clone())
                }
            }
            impl std::convert::From<&mut SymbolItem> for Item {
                fn from(src: &mut SymbolItem) -> Item {
                    let src: &Item_Class = src.0.as_ref();
                    Item(src.clone())
                }
            }
            impl SymbolItem {
                #[allow(dead_code)]
                pub fn definition(&self) -> SymbolDefinition {
                    let result = self.0.definition();
                    result
                }
                #[allow(dead_code)]
                pub fn set_definition(&self, value: SymbolDefinition) -> () {
                    let result = self.0.set_definition(value);
                    result
                }
                #[allow(dead_code)]
                pub fn new(
                    definition: SymbolItemConstructorDefinitionParam,
                    point: Point,
                ) -> SymbolItem {
                    let result = SymbolItem_Class::new(
                        ts_bindgen_rt::to_jsvalue(&definition)
                            .map_err(ts_bindgen_rt::Error::from)?,
                        point,
                    );
                    let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                    SymbolItem(result)
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for SymbolItem {
                fn describe() {
                    <SymbolItem_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for SymbolItem {
                type Abi = <SymbolItem_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a SymbolItem {
                type Abi = <&'a SymbolItem_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for SymbolItem {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for SymbolItem {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: SymbolItem_Class =
                        <SymbolItem_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait SymbolItem_Trait: Item_Trait {
                fn definition(&self) -> SymbolDefinition;
                fn set_definition(&mut self, value: SymbolDefinition) -> ();
                fn new(
                    definition: SymbolItemConstructorDefinitionParam,
                    point: Point,
                ) -> SymbolItem;
            }
            impl Item_Trait for SymbolItem {
                fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::insert_below(&target, item)
                }
                fn on_double_click(&self) -> ItemOnDoubleClick {
                    let target: Item = self.into();
                    Item::on_double_click(&target)
                }
                fn set_on_double_click(&mut self, value: ItemOnDoubleClick) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_double_click(&mut target, value)
                }
                fn view(&self) -> View {
                    let target: Item = self.into();
                    Item::view(&target)
                }
                fn set_view(&mut self, value: View) -> () {
                    let mut target: Item = self.into();
                    Item::set_view(&mut target, value)
                }
                fn blend_mode(&self) -> String {
                    let target: Item = self.into();
                    Item::blend_mode(&target)
                }
                fn set_blend_mode(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_blend_mode(&mut target, value)
                }
                fn name(&self) -> String {
                    let target: Item = self.into();
                    Item::name(&target)
                }
                fn set_name(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_name(&mut target, value)
                }
                fn project(&self) -> Project {
                    let target: Item = self.into();
                    Item::project(&target)
                }
                fn set_project(&mut self, value: Project) -> () {
                    let mut target: Item = self.into();
                    Item::set_project(&mut target, value)
                }
                fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_child(&target, item)
                }
                fn global_matrix(&self) -> Matrix {
                    let target: Item = self.into();
                    Item::global_matrix(&target)
                }
                fn set_global_matrix(&mut self, value: Matrix) -> () {
                    let mut target: Item = self.into();
                    Item::set_global_matrix(&mut target, value)
                }
                fn on_mouse_leave(&self) -> ItemOnMouseLeave {
                    let target: Item = self.into();
                    Item::on_mouse_leave(&target)
                }
                fn set_on_mouse_leave(&mut self, value: ItemOnMouseLeave) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_leave(&mut target, value)
                }
                fn has_children(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_children(&target)
                }
                fn selected(&self) -> bool {
                    let target: Item = self.into();
                    Item::selected(&target)
                }
                fn set_selected(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_selected(&mut target, value)
                }
                fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::global_to_local(&target, point)
                }
                fn shadow_blur(&self) -> f64 {
                    let target: Item = self.into();
                    Item::shadow_blur(&target)
                }
                fn set_shadow_blur(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_shadow_blur(&mut target, value)
                }
                fn children(&self) -> Vec<Item> {
                    let target: Item = self.into();
                    Item::children(&target)
                }
                fn set_children(&mut self, value: Vec<Item>) -> () {
                    let mut target: Item = self.into();
                    Item::set_children(&mut target, value)
                }
                fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::replace_with(&target, item)
                }
                fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::import_json(&target, json)
                }
                fn insert_child(
                    &self,
                    index: f64,
                    item: Item,
                ) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::insert_child(&target, index, item)
                }
                fn stroke_join(&self) -> String {
                    let target: Item = self.into();
                    Item::stroke_join(&target)
                }
                fn set_stroke_join(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_join(&mut target, value)
                }
                fn rotation(&self) -> f64 {
                    let target: Item = self.into();
                    Item::rotation(&target)
                }
                fn set_rotation(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_rotation(&mut target, value)
                }
                fn scaling(&self) -> Point {
                    let target: Item = self.into();
                    Item::scaling(&target)
                }
                fn set_scaling(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_scaling(&mut target, value)
                }
                fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_ancestor(&target, item)
                }
                fn emit(
                    &self,
                    type_: String,
                    event: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::emit(&target, type_, event)
                }
                fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_up(&target)
                }
                fn add_to(
                    &self,
                    owner: ItemAddToParamsOwnerParam,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::add_to(&target, owner)
                }
                fn stroke_cap(&self) -> String {
                    let target: Item = self.into();
                    Item::stroke_cap(&target)
                }
                fn set_stroke_cap(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_cap(&mut target, value)
                }
                fn on_mouse_drag(&self) -> ItemOnMouseDrag {
                    let target: Item = self.into();
                    Item::on_mouse_drag(&target)
                }
                fn set_on_mouse_drag(&mut self, value: ItemOnMouseDrag) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_drag(&mut target, value)
                }
                fn set(
                    &self,
                    props: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::set(&target, props)
                }
                fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::reverse_children(&target)
                }
                fn matches(
                    &self,
                    name: String,
                    compare: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::matches(&target, name, compare)
                }
                fn on_mouse_enter(&self) -> ItemOnMouseEnter {
                    let target: Item = self.into();
                    Item::on_mouse_enter(&target)
                }
                fn set_on_mouse_enter(&mut self, value: ItemOnMouseEnter) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_enter(&mut target, value)
                }
                fn shadow_offset(&self) -> Point {
                    let target: Item = self.into();
                    Item::shadow_offset(&target)
                }
                fn set_shadow_offset(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_shadow_offset(&mut target, value)
                }
                fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_stroke(&target)
                }
                fn view_matrix(&self) -> Matrix {
                    let target: Item = self.into();
                    Item::view_matrix(&target)
                }
                fn set_view_matrix(&mut self, value: Matrix) -> () {
                    let mut target: Item = self.into();
                    Item::set_view_matrix(&mut target, value)
                }
                fn on_frame(&self) -> ItemOnFrame {
                    let target: Item = self.into();
                    Item::on_frame(&target)
                }
                fn set_on_frame(&mut self, value: ItemOnFrame) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_frame(&mut target, value)
                }
                fn on_mouse_down(&self) -> ItemOnMouseDown {
                    let target: Item = self.into();
                    Item::on_mouse_down(&target)
                }
                fn set_on_mouse_down(&mut self, value: ItemOnMouseDown) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_down(&mut target, value)
                }
                fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_sibling(&target, item)
                }
                fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::local_to_global(&target, point)
                }
                fn first_child(&self) -> Item {
                    let target: Item = self.into();
                    Item::first_child(&target)
                }
                fn set_first_child(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_first_child(&mut target, value)
                }
                fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::send_to_back(&target)
                }
                fn clip_mask(&self) -> bool {
                    let target: Item = self.into();
                    Item::clip_mask(&target)
                }
                fn set_clip_mask(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_clip_mask(&mut target, value)
                }
                fn next_sibling(&self) -> Item {
                    let target: Item = self.into();
                    Item::next_sibling(&target)
                }
                fn set_next_sibling(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_next_sibling(&mut target, value)
                }
                fn off(
                    &self,
                    object: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::off(&target, object)
                }
                fn rotate(&self, angle: f64, center: Point) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::rotate(&target, angle, center)
                }
                fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::add_child(&target, item)
                }
                fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_grouped_with(&target, item)
                }
                fn scale(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::scale(&target, hor, ver, center)
                }
                fn hit_test_all(
                    &self,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Vec<HitResult>, JsValue> {
                    let target: Item = self.into();
                    Item::hit_test_all(&target, point, options)
                }
                fn insert_children(
                    &self,
                    index: f64,
                    items: Vec<Item>,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::insert_children(&target, index, items)
                }
                fn style(&self) -> Style {
                    let target: Item = self.into();
                    Item::style(&target)
                }
                fn set_style(&mut self, value: Style) -> () {
                    let mut target: Item = self.into();
                    Item::set_style(&mut target, value)
                }
                fn position(&self) -> Point {
                    let target: Item = self.into();
                    Item::position(&target)
                }
                fn set_position(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_position(&mut target, value)
                }
                fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::transform(&target, matrix)
                }
                fn fill_color(&self) -> ItemFillColor {
                    let target: Item = self.into();
                    Item::fill_color(&target)
                }
                fn set_fill_color(&mut self, value: ItemFillColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_fill_color(&mut target, value)
                }
                fn matrix(&self) -> Matrix {
                    let target: Item = self.into();
                    Item::matrix(&target)
                }
                fn set_matrix(&mut self, value: Matrix) -> () {
                    let mut target: Item = self.into();
                    Item::set_matrix(&mut target, value)
                }
                fn id(&self) -> f64 {
                    let target: Item = self.into();
                    Item::id(&target)
                }
                fn set_id(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_id(&mut target, value)
                }
                fn tween(
                    &self,
                    options: ItemTweenParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let target: Item = self.into();
                    Item::tween(&target, options)
                }
                fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::reduce(&target, options)
                }
                fn internal_bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::internal_bounds(&target)
                }
                fn set_internal_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_internal_bounds(&mut target, value)
                }
                fn fill_rule(&self) -> String {
                    let target: Item = self.into();
                    Item::fill_rule(&target)
                }
                fn set_fill_rule(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_fill_rule(&mut target, value)
                }
                fn shadow_color(&self) -> ItemShadowColor {
                    let target: Item = self.into();
                    Item::shadow_color(&target)
                }
                fn set_shadow_color(&mut self, value: ItemShadowColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_shadow_color(&mut target, value)
                }
                fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::insert_above(&target, item)
                }
                fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::responds(&target, type_)
                }
                fn handle_bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::handle_bounds(&target)
                }
                fn set_handle_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_handle_bounds(&mut target, value)
                }
                fn skew(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::skew(&target, hor, ver, center)
                }
                fn on_click(&self) -> ItemOnClick {
                    let target: Item = self.into();
                    Item::on_click(&target)
                }
                fn set_on_click(&mut self, value: ItemOnClick) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_click(&mut target, value)
                }
                fn get_items(
                    &self,
                    options: ItemGetItemsParamsOptionsParam,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::get_items(&target, options)
                }
                fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_inserted(&target)
                }
                fn get_item(
                    &self,
                    options: ItemGetItemParamsOptionsParam,
                ) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::get_item(&target, options)
                }
                fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_fill(&target)
                }
                fn shear(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::shear(&target, hor, ver, center)
                }
                fn visible(&self) -> bool {
                    let target: Item = self.into();
                    Item::visible(&target)
                }
                fn set_visible(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_visible(&mut target, value)
                }
                fn previous_sibling(&self) -> Item {
                    let target: Item = self.into();
                    Item::previous_sibling(&target)
                }
                fn set_previous_sibling(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_previous_sibling(&mut target, value)
                }
                fn hit_test(
                    &self,
                    point: Point,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<HitResult, JsValue> {
                    let target: Item = self.into();
                    Item::hit_test(&target, point, options)
                }
                fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_descendant(&target, item)
                }
                fn locked(&self) -> bool {
                    let target: Item = self.into();
                    Item::locked(&target)
                }
                fn set_locked(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_locked(&mut target, value)
                }
                fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_parent(&target, item)
                }
                fn copy_attributes(
                    &self,
                    source: Item,
                    exclude_matrix: bool,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::copy_attributes(&target, source, exclude_matrix)
                }
                fn last_child(&self) -> Item {
                    let target: Item = self.into();
                    Item::last_child(&target)
                }
                fn set_last_child(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_last_child(&mut target, value)
                }
                fn stroke_width(&self) -> f64 {
                    let target: Item = self.into();
                    Item::stroke_width(&target)
                }
                fn set_stroke_width(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_width(&mut target, value)
                }
                fn parent(&self) -> Item {
                    let target: Item = self.into();
                    Item::parent(&target)
                }
                fn set_parent(&mut self, value: Item) -> () {
                    let mut target: Item = self.into();
                    Item::set_parent(&mut target, value)
                }
                fn stroke_bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::stroke_bounds(&target)
                }
                fn set_stroke_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_bounds(&mut target, value)
                }
                fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::translate(&target, delta)
                }
                fn remove(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::remove(&target)
                }
                fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::parent_to_local(&target, point)
                }
                fn bounds(&self) -> Rectangle {
                    let target: Item = self.into();
                    Item::bounds(&target)
                }
                fn set_bounds(&mut self, value: Rectangle) -> () {
                    let mut target: Item = self.into();
                    Item::set_bounds(&mut target, value)
                }
                fn add_children(
                    &self,
                    items: Vec<Item>,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::add_children(&target, items)
                }
                fn dash_array(&self) -> Vec<f64> {
                    let target: Item = self.into();
                    Item::dash_array(&target)
                }
                fn set_dash_array(&mut self, value: Vec<f64>) -> () {
                    let mut target: Item = self.into();
                    Item::set_dash_array(&mut target, value)
                }
                fn on_mouse_up(&self) -> ItemOnMouseUp {
                    let target: Item = self.into();
                    Item::on_mouse_up(&target)
                }
                fn set_on_mouse_up(&mut self, value: ItemOnMouseUp) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_up(&mut target, value)
                }
                fn on(
                    &self,
                    object: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::on(&target, object)
                }
                fn remove_on(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on(&target, options)
                }
                fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_below(&target, item)
                }
                fn apply_matrix(&self) -> bool {
                    let target: Item = self.into();
                    Item::apply_matrix(&target)
                }
                fn set_apply_matrix(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_apply_matrix(&mut target, value)
                }
                fn clone(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::clone(&target, options)
                }
                fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::contains(&target, point)
                }
                fn export_json(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<String, JsValue> {
                    let target: Item = self.into();
                    Item::export_json(&target, options)
                }
                fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::bring_to_front(&target)
                }
                fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_above(&target, item)
                }
                fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_drag(&target)
                }
                fn data(&self) -> JsValue {
                    let target: Item = self.into();
                    Item::data(&target)
                }
                fn set_data(&mut self, value: JsValue) -> () {
                    let mut target: Item = self.into();
                    Item::set_data(&mut target, value)
                }
                fn import_svg(
                    &self,
                    svg: ItemImportSvgParamsSvgParam,
                    on_load: JsValue,
                ) -> std::result::Result<Item, JsValue> {
                    let target: Item = self.into();
                    Item::import_svg(&target, svg, on_load)
                }
                fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::has_shadow(&target)
                }
                fn selected_color(&self) -> ItemSelectedColor {
                    let target: Item = self.into();
                    Item::selected_color(&target)
                }
                fn set_selected_color(&mut self, value: ItemSelectedColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_selected_color(&mut target, value)
                }
                fn class_name(&self) -> String {
                    let target: Item = self.into();
                    Item::class_name(&target)
                }
                fn set_class_name(&mut self, value: String) -> () {
                    let mut target: Item = self.into();
                    Item::set_class_name(&mut target, value)
                }
                fn export_svg(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                    let target: Item = self.into();
                    Item::export_svg(&target, options)
                }
                fn tween_to(
                    &self,
                    to: std::collections::HashMap<String, JsValue>,
                    options: ItemTweenToParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let target: Item = self.into();
                    Item::tween_to(&target, to, options)
                }
                fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_inside(&target, rect)
                }
                fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::is_empty(&target, recursively)
                }
                fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::copy_content(&target, source)
                }
                fn rasterize(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<Raster, JsValue> {
                    let target: Item = self.into();
                    Item::rasterize(&target, options)
                }
                fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_move(&target)
                }
                fn tween_from(
                    &self,
                    from: std::collections::HashMap<String, JsValue>,
                    options: ItemTweenFromParamsOptionsParam,
                ) -> std::result::Result<Tween, JsValue> {
                    let target: Item = self.into();
                    Item::tween_from(&target, from, options)
                }
                fn opacity(&self) -> f64 {
                    let target: Item = self.into();
                    Item::opacity(&target)
                }
                fn set_opacity(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_opacity(&mut target, value)
                }
                fn dash_offset(&self) -> f64 {
                    let target: Item = self.into();
                    Item::dash_offset(&target)
                }
                fn set_dash_offset(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_dash_offset(&mut target, value)
                }
                fn remove_children(
                    &self,
                    start: f64,
                    end: f64,
                ) -> std::result::Result<Vec<Item>, JsValue> {
                    let target: Item = self.into();
                    Item::remove_children(&target, start, end)
                }
                fn on_mouse_move(&self) -> ItemOnMouseMove {
                    let target: Item = self.into();
                    Item::on_mouse_move(&target)
                }
                fn set_on_mouse_move(&mut self, value: ItemOnMouseMove) -> () {
                    let mut target: Item = self.into();
                    Item::set_on_mouse_move(&mut target, value)
                }
                fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                    let target: Item = self.into();
                    Item::intersects(&target, item)
                }
                fn pivot(&self) -> Point {
                    let target: Item = self.into();
                    Item::pivot(&target)
                }
                fn set_pivot(&mut self, value: Point) -> () {
                    let mut target: Item = self.into();
                    Item::set_pivot(&mut target, value)
                }
                fn copy_to(
                    &self,
                    owner: ItemCopyToParamsOwnerParam,
                ) -> std::result::Result<JsValue, JsValue> {
                    let target: Item = self.into();
                    Item::copy_to(&target, owner)
                }
                fn index(&self) -> f64 {
                    let target: Item = self.into();
                    Item::index(&target)
                }
                fn set_index(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_index(&mut target, value)
                }
                fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                    let target: Item = self.into();
                    Item::local_to_parent(&target, point)
                }
                fn stroke_color(&self) -> ItemStrokeColor {
                    let target: Item = self.into();
                    Item::stroke_color(&target)
                }
                fn set_stroke_color(&mut self, value: ItemStrokeColor) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_color(&mut target, value)
                }
                fn layer(&self) -> Layer {
                    let target: Item = self.into();
                    Item::layer(&target)
                }
                fn set_layer(&mut self, value: Layer) -> () {
                    let mut target: Item = self.into();
                    Item::set_layer(&mut target, value)
                }
                fn stroke_scaling(&self) -> bool {
                    let target: Item = self.into();
                    Item::stroke_scaling(&target)
                }
                fn set_stroke_scaling(&mut self, value: bool) -> () {
                    let mut target: Item = self.into();
                    Item::set_stroke_scaling(&mut target, value)
                }
                fn fit_bounds(
                    &self,
                    rectangle: Rectangle,
                    fill: bool,
                ) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::fit_bounds(&target, rectangle, fill)
                }
                fn miter_limit(&self) -> f64 {
                    let target: Item = self.into();
                    Item::miter_limit(&target)
                }
                fn set_miter_limit(&mut self, value: f64) -> () {
                    let mut target: Item = self.into();
                    Item::set_miter_limit(&mut target, value)
                }
                fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                    let target: Item = self.into();
                    Item::remove_on_down(&target)
                }
            }
            impl SymbolItem_Trait for SymbolItem {}
            impl std::clone::Clone for SymbolItem_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for SymbolItem_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for SymbolItem_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                #[wasm_bindgen(js_name = "Matrix")]
                type Matrix_Class;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = appended , method , js_class = "Matrix" , catch)]
                fn __TSB_appended(
                    this: &Matrix_Class,
                    matrix: Matrix,
                ) -> std::result::Result<Matrix, JsValue>;
                # [wasm_bindgen (method , structural , getter = values , js_class = "Matrix")]
                fn values(this: &Matrix_Class) -> Vec<f64>;
                # [wasm_bindgen (method , structural , setter = values , js_class = "Matrix")]
                fn set_values(this: &Matrix_Class, value: Vec<f64>);
                # [wasm_bindgen (method , structural , getter = translation , js_class = "Matrix")]
                fn translation(this: &Matrix_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = translation , js_class = "Matrix")]
                fn set_translation(this: &Matrix_Class, value: Point);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = decompose , method , js_class = "Matrix" , catch)]
                fn __TSB_decompose(
                    this: &Matrix_Class,
                ) -> std::result::Result<std::collections::HashMap<String, JsValue>, JsValue>;
                # [wasm_bindgen (method , structural , getter = ty , js_class = "Matrix")]
                fn ty(this: &Matrix_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = ty , js_class = "Matrix")]
                fn set_ty(this: &Matrix_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = clone , method , js_class = "Matrix" , catch)]
                fn __TSB_clone(this: &Matrix_Class) -> std::result::Result<Matrix, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isInvertible , method , js_class = "Matrix" , catch)]
                fn __TSB_is_invertible(this: &Matrix_Class) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isSingular , method , js_class = "Matrix" , catch)]
                fn __TSB_is_singular(this: &Matrix_Class) -> std::result::Result<bool, JsValue>;
                # [wasm_bindgen (method , structural , getter = b , js_class = "Matrix")]
                fn b(this: &Matrix_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = b , js_class = "Matrix")]
                fn set_b(this: &Matrix_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = append , method , js_class = "Matrix" , catch)]
                fn __TSB_append(
                    this: &Matrix_Class,
                    matrix: Matrix,
                ) -> std::result::Result<Matrix, JsValue>;
                # [wasm_bindgen (method , structural , getter = c , js_class = "Matrix")]
                fn c(this: &Matrix_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = c , js_class = "Matrix")]
                fn set_c(this: &Matrix_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = transform , method , js_class = "Matrix" , catch)]
                fn __TSB_transform(
                    this: &Matrix_Class,
                    src: Vec<f64>,
                    dst: Vec<f64>,
                    count: f64,
                ) -> std::result::Result<Vec<f64>, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = invert , method , js_class = "Matrix" , catch)]
                fn __TSB_invert(this: &Matrix_Class) -> std::result::Result<Matrix, JsValue>;
                #[wasm_bindgen(constructor, js_class = "Matrix")]
                pub fn new(matrix: Matrix) -> Matrix_Class;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = rotate , method , js_class = "Matrix" , catch)]
                fn __TSB_rotate(
                    this: &Matrix_Class,
                    angle: f64,
                    x: f64,
                    y: f64,
                ) -> std::result::Result<Matrix, JsValue>;
                # [wasm_bindgen (method , structural , getter = d , js_class = "Matrix")]
                fn d(this: &Matrix_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = d , js_class = "Matrix")]
                fn set_d(this: &Matrix_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = translate , method , js_class = "Matrix" , catch)]
                fn __TSB_translate(
                    this: &Matrix_Class,
                    dx: f64,
                    dy: f64,
                ) -> std::result::Result<Matrix, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = inverted , method , js_class = "Matrix" , catch)]
                fn __TSB_inverted(this: &Matrix_Class) -> std::result::Result<Matrix, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = applyToContext , method , js_class = "Matrix" , catch)]
                fn __TSB_apply_to_context(
                    this: &Matrix_Class,
                    ctx: JsValue,
                ) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = scale , method , js_class = "Matrix" , catch)]
                fn __TSB_scale(
                    this: &Matrix_Class,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<Matrix, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = skew , method , js_class = "Matrix" , catch)]
                fn __TSB_skew(
                    this: &Matrix_Class,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<Matrix, JsValue>;
                # [wasm_bindgen (method , structural , getter = scaling , js_class = "Matrix")]
                fn scaling(this: &Matrix_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = scaling , js_class = "Matrix")]
                fn set_scaling(this: &Matrix_Class, value: Point);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = prepend , method , js_class = "Matrix" , catch)]
                fn __TSB_prepend(
                    this: &Matrix_Class,
                    matrix: Matrix,
                ) -> std::result::Result<Matrix, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isIdentity , method , js_class = "Matrix" , catch)]
                fn __TSB_is_identity(this: &Matrix_Class) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = toString , method , js_class = "Matrix" , catch)]
                fn __TSB_to_string(this: &Matrix_Class) -> std::result::Result<String, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = set , method , js_class = "Matrix" , catch , variadic)]
                fn __TSB_set(
                    this: &Matrix_Class,
                    values: &[JsValue],
                ) -> std::result::Result<Point, JsValue>;
                # [wasm_bindgen (method , structural , getter = rotation , js_class = "Matrix")]
                fn rotation(this: &Matrix_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = rotation , js_class = "Matrix")]
                fn set_rotation(this: &Matrix_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = tx , js_class = "Matrix")]
                fn tx(this: &Matrix_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = tx , js_class = "Matrix")]
                fn set_tx(this: &Matrix_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = reset , method , js_class = "Matrix" , catch)]
                fn __TSB_reset(this: &Matrix_Class) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = equals , method , js_class = "Matrix" , catch)]
                fn __TSB_equals(
                    this: &Matrix_Class,
                    matrix: Matrix,
                ) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = inverseTransform , method , js_class = "Matrix" , catch)]
                fn __TSB_inverse_transform(
                    this: &Matrix_Class,
                    point: Point,
                ) -> std::result::Result<Point, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = apply , method , js_class = "Matrix" , catch)]
                fn __TSB_apply(
                    this: &Matrix_Class,
                    recursively: bool,
                ) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = prepended , method , js_class = "Matrix" , catch)]
                fn __TSB_prepended(
                    this: &Matrix_Class,
                    matrix: Matrix,
                ) -> std::result::Result<Matrix, JsValue>;
                # [wasm_bindgen (method , structural , getter = a , js_class = "Matrix")]
                fn a(this: &Matrix_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = a , js_class = "Matrix")]
                fn set_a(this: &Matrix_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = shear , method , js_class = "Matrix" , catch)]
                fn __TSB_shear(
                    this: &Matrix_Class,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<Matrix, JsValue>;
            }
            #[derive(std :: clone :: Clone)]
            struct Matrix(pub Matrix_Class);
            impl Matrix {
                #[allow(dead_code)]
                pub fn appended(&self, matrix: Matrix) -> std::result::Result<Matrix, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_appended(matrix)?);
                    result
                }
                #[allow(dead_code)]
                pub fn values(&self) -> Vec<f64> {
                    let result = self.0.values();
                    result
                }
                #[allow(dead_code)]
                pub fn set_values(&self, value: Vec<f64>) -> () {
                    let result = self.0.set_values(value);
                    result
                }
                #[allow(dead_code)]
                pub fn translation(&self) -> Point {
                    let result = self.0.translation();
                    result
                }
                #[allow(dead_code)]
                pub fn set_translation(&self, value: Point) -> () {
                    let result = self.0.set_translation(value);
                    result
                }
                #[allow(dead_code)]
                pub fn decompose(
                    &self,
                ) -> std::result::Result<std::collections::HashMap<String, JsValue>, JsValue>
                {
                    let result = std::result::Result::Ok(self.0.__TSB_decompose()?);
                    result
                }
                #[allow(dead_code)]
                pub fn ty(&self) -> f64 {
                    let result = self.0.ty();
                    result
                }
                #[allow(dead_code)]
                pub fn set_ty(&self, value: f64) -> () {
                    let result = self.0.set_ty(value);
                    result
                }
                #[allow(dead_code)]
                pub fn clone(&self) -> std::result::Result<Matrix, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_clone()?);
                    result
                }
                #[allow(dead_code)]
                pub fn is_invertible(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_invertible()?);
                    result
                }
                #[allow(dead_code)]
                pub fn is_singular(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_singular()?);
                    result
                }
                #[allow(dead_code)]
                pub fn b(&self) -> f64 {
                    let result = self.0.b();
                    result
                }
                #[allow(dead_code)]
                pub fn set_b(&self, value: f64) -> () {
                    let result = self.0.set_b(value);
                    result
                }
                #[allow(dead_code)]
                pub fn append(&self, matrix: Matrix) -> std::result::Result<Matrix, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_append(matrix)?);
                    result
                }
                #[allow(dead_code)]
                pub fn c(&self) -> f64 {
                    let result = self.0.c();
                    result
                }
                #[allow(dead_code)]
                pub fn set_c(&self, value: f64) -> () {
                    let result = self.0.set_c(value);
                    result
                }
                #[allow(dead_code)]
                pub fn transform(
                    &self,
                    src: Vec<f64>,
                    dst: Vec<f64>,
                    count: f64,
                ) -> std::result::Result<Vec<f64>, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_transform(src, dst, count)?);
                    result
                }
                #[allow(dead_code)]
                pub fn invert(&self) -> std::result::Result<Matrix, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_invert()?);
                    result
                }
                #[allow(dead_code)]
                pub fn new(matrix: Matrix) -> Matrix {
                    let result = Matrix_Class::new(matrix);
                    let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                    Matrix(result)
                }
                #[allow(dead_code)]
                pub fn rotate(
                    &self,
                    angle: f64,
                    x: f64,
                    y: f64,
                ) -> std::result::Result<Matrix, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_rotate(angle, x, y)?);
                    result
                }
                #[allow(dead_code)]
                pub fn d(&self) -> f64 {
                    let result = self.0.d();
                    result
                }
                #[allow(dead_code)]
                pub fn set_d(&self, value: f64) -> () {
                    let result = self.0.set_d(value);
                    result
                }
                #[allow(dead_code)]
                pub fn translate(&self, dx: f64, dy: f64) -> std::result::Result<Matrix, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_translate(dx, dy)?);
                    result
                }
                #[allow(dead_code)]
                pub fn inverted(&self) -> std::result::Result<Matrix, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_inverted()?);
                    result
                }
                #[allow(dead_code)]
                pub fn apply_to_context(&self, ctx: JsValue) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_apply_to_context(ctx)?);
                    result
                }
                #[allow(dead_code)]
                pub fn scale(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<Matrix, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_scale(hor, ver, center)?);
                    result
                }
                #[allow(dead_code)]
                pub fn skew(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<Matrix, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_skew(hor, ver, center)?);
                    result
                }
                #[allow(dead_code)]
                pub fn scaling(&self) -> Point {
                    let result = self.0.scaling();
                    result
                }
                #[allow(dead_code)]
                pub fn set_scaling(&self, value: Point) -> () {
                    let result = self.0.set_scaling(value);
                    result
                }
                #[allow(dead_code)]
                pub fn prepend(&self, matrix: Matrix) -> std::result::Result<Matrix, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_prepend(matrix)?);
                    result
                }
                #[allow(dead_code)]
                pub fn is_identity(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_identity()?);
                    result
                }
                #[allow(dead_code)]
                pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_to_string()?);
                    result
                }
                #[allow(dead_code)]
                pub fn set(&self, values: &[JsValue]) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_set(values)?);
                    result
                }
                #[allow(dead_code)]
                pub fn rotation(&self) -> f64 {
                    let result = self.0.rotation();
                    result
                }
                #[allow(dead_code)]
                pub fn set_rotation(&self, value: f64) -> () {
                    let result = self.0.set_rotation(value);
                    result
                }
                #[allow(dead_code)]
                pub fn tx(&self) -> f64 {
                    let result = self.0.tx();
                    result
                }
                #[allow(dead_code)]
                pub fn set_tx(&self, value: f64) -> () {
                    let result = self.0.set_tx(value);
                    result
                }
                #[allow(dead_code)]
                pub fn reset(&self) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_reset()?);
                    result
                }
                #[allow(dead_code)]
                pub fn equals(&self, matrix: Matrix) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_equals(matrix)?);
                    result
                }
                #[allow(dead_code)]
                pub fn inverse_transform(
                    &self,
                    point: Point,
                ) -> std::result::Result<Point, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_inverse_transform(point)?);
                    result
                }
                #[allow(dead_code)]
                pub fn apply(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_apply(recursively)?);
                    result
                }
                #[allow(dead_code)]
                pub fn prepended(&self, matrix: Matrix) -> std::result::Result<Matrix, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_prepended(matrix)?);
                    result
                }
                #[allow(dead_code)]
                pub fn a(&self) -> f64 {
                    let result = self.0.a();
                    result
                }
                #[allow(dead_code)]
                pub fn set_a(&self, value: f64) -> () {
                    let result = self.0.set_a(value);
                    result
                }
                #[allow(dead_code)]
                pub fn shear(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<Matrix, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_shear(hor, ver, center)?);
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for Matrix {
                fn describe() {
                    <Matrix_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for Matrix {
                type Abi = <Matrix_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Matrix {
                type Abi = <&'a Matrix_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for Matrix {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Matrix {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: Matrix_Class =
                        <Matrix_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait Matrix_Trait {
                fn appended(&self, matrix: Matrix) -> std::result::Result<Matrix, JsValue>;
                fn values(&self) -> Vec<f64>;
                fn set_values(&mut self, value: Vec<f64>) -> ();
                fn translation(&self) -> Point;
                fn set_translation(&mut self, value: Point) -> ();
                fn decompose(
                    &self,
                ) -> std::result::Result<std::collections::HashMap<String, JsValue>, JsValue>;
                fn ty(&self) -> f64;
                fn set_ty(&mut self, value: f64) -> ();
                fn clone(&self) -> std::result::Result<Matrix, JsValue>;
                fn is_invertible(&self) -> std::result::Result<bool, JsValue>;
                fn is_singular(&self) -> std::result::Result<bool, JsValue>;
                fn b(&self) -> f64;
                fn set_b(&mut self, value: f64) -> ();
                fn append(&self, matrix: Matrix) -> std::result::Result<Matrix, JsValue>;
                fn c(&self) -> f64;
                fn set_c(&mut self, value: f64) -> ();
                fn transform(
                    &self,
                    src: Vec<f64>,
                    dst: Vec<f64>,
                    count: f64,
                ) -> std::result::Result<Vec<f64>, JsValue>;
                fn invert(&self) -> std::result::Result<Matrix, JsValue>;
                fn new(matrix: Matrix) -> Matrix;
                fn rotate(
                    &self,
                    angle: f64,
                    x: f64,
                    y: f64,
                ) -> std::result::Result<Matrix, JsValue>;
                fn d(&self) -> f64;
                fn set_d(&mut self, value: f64) -> ();
                fn translate(&self, dx: f64, dy: f64) -> std::result::Result<Matrix, JsValue>;
                fn inverted(&self) -> std::result::Result<Matrix, JsValue>;
                fn apply_to_context(&self, ctx: JsValue) -> std::result::Result<(), JsValue>;
                fn scale(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<Matrix, JsValue>;
                fn skew(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<Matrix, JsValue>;
                fn scaling(&self) -> Point;
                fn set_scaling(&mut self, value: Point) -> ();
                fn prepend(&self, matrix: Matrix) -> std::result::Result<Matrix, JsValue>;
                fn is_identity(&self) -> std::result::Result<bool, JsValue>;
                fn to_string(&self) -> std::result::Result<String, JsValue>;
                fn set(&self, values: &[JsValue]) -> std::result::Result<Point, JsValue>;
                fn rotation(&self) -> f64;
                fn set_rotation(&mut self, value: f64) -> ();
                fn tx(&self) -> f64;
                fn set_tx(&mut self, value: f64) -> ();
                fn reset(&self) -> std::result::Result<(), JsValue>;
                fn equals(&self, matrix: Matrix) -> std::result::Result<bool, JsValue>;
                fn inverse_transform(&self, point: Point) -> std::result::Result<Point, JsValue>;
                fn apply(&self, recursively: bool) -> std::result::Result<bool, JsValue>;
                fn prepended(&self, matrix: Matrix) -> std::result::Result<Matrix, JsValue>;
                fn a(&self) -> f64;
                fn set_a(&mut self, value: f64) -> ();
                fn shear(
                    &self,
                    hor: f64,
                    ver: f64,
                    center: Point,
                ) -> std::result::Result<Matrix, JsValue>;
            }
            impl std::clone::Clone for Matrix_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for Matrix_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Matrix_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                #[wasm_bindgen(js_name = "SymbolDefinition")]
                type SymbolDefinition_Class;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = clone , method , js_class = "SymbolDefinition" , catch)]
                fn __TSB_clone(
                    this: &SymbolDefinition_Class,
                ) -> std::result::Result<SymbolDefinition, JsValue>;
                #[wasm_bindgen(constructor, js_class = "SymbolDefinition")]
                pub fn new(item: Item, dont_center: bool) -> SymbolDefinition_Class;
                # [wasm_bindgen (method , structural , getter = item , js_class = "SymbolDefinition")]
                fn item(this: &SymbolDefinition_Class) -> Item;
                # [wasm_bindgen (method , structural , setter = item , js_class = "SymbolDefinition")]
                fn set_item(this: &SymbolDefinition_Class, value: Item);
                # [wasm_bindgen (method , structural , getter = project , js_class = "SymbolDefinition")]
                fn project(this: &SymbolDefinition_Class) -> Project;
                # [wasm_bindgen (method , structural , setter = project , js_class = "SymbolDefinition")]
                fn set_project(this: &SymbolDefinition_Class, value: Project);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = equals , method , js_class = "SymbolDefinition" , catch)]
                fn __TSB_equals(
                    this: &SymbolDefinition_Class,
                    symbol: SymbolDefinition,
                ) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = place , method , js_class = "SymbolDefinition" , catch)]
                fn __TSB_place(
                    this: &SymbolDefinition_Class,
                    position: Point,
                ) -> std::result::Result<SymbolItem, JsValue>;
            }
            #[derive(std :: clone :: Clone)]
            struct SymbolDefinition(pub SymbolDefinition_Class);
            impl SymbolDefinition {
                #[allow(dead_code)]
                pub fn clone(&self) -> std::result::Result<SymbolDefinition, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_clone()?);
                    result
                }
                #[allow(dead_code)]
                pub fn new(item: Item, dont_center: bool) -> SymbolDefinition {
                    let result = SymbolDefinition_Class::new(item, dont_center);
                    let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                    SymbolDefinition(result)
                }
                #[allow(dead_code)]
                pub fn item(&self) -> Item {
                    let result = self.0.item();
                    result
                }
                #[allow(dead_code)]
                pub fn set_item(&self, value: Item) -> () {
                    let result = self.0.set_item(value);
                    result
                }
                #[allow(dead_code)]
                pub fn project(&self) -> Project {
                    let result = self.0.project();
                    result
                }
                #[allow(dead_code)]
                pub fn set_project(&self, value: Project) -> () {
                    let result = self.0.set_project(value);
                    result
                }
                #[allow(dead_code)]
                pub fn equals(
                    &self,
                    symbol: SymbolDefinition,
                ) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_equals(symbol)?);
                    result
                }
                #[allow(dead_code)]
                pub fn place(&self, position: Point) -> std::result::Result<SymbolItem, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_place(position)?);
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for SymbolDefinition {
                fn describe() {
                    <SymbolDefinition_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for SymbolDefinition {
                type Abi = <SymbolDefinition_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a SymbolDefinition {
                type Abi = <&'a SymbolDefinition_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for SymbolDefinition {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for SymbolDefinition {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: SymbolDefinition_Class =
                        <SymbolDefinition_Class as serde::de::Deserialize>::deserialize(
                            deserializer,
                        )?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait SymbolDefinition_Trait {
                fn clone(&self) -> std::result::Result<SymbolDefinition, JsValue>;
                fn new(item: Item, dont_center: bool) -> SymbolDefinition;
                fn item(&self) -> Item;
                fn set_item(&mut self, value: Item) -> ();
                fn project(&self) -> Project;
                fn set_project(&mut self, value: Project) -> ();
                fn equals(&self, symbol: SymbolDefinition) -> std::result::Result<bool, JsValue>;
                fn place(&self, position: Point) -> std::result::Result<SymbolItem, JsValue>;
            }
            impl std::clone::Clone for SymbolDefinition_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for SymbolDefinition_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for SymbolDefinition_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum CurveSplitAtParamsLocationParam {
                CurveLocationCase(CurveLocation),
                F64Case(f64),
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                #[wasm_bindgen(js_name = "GradientStop")]
                type GradientStop_Class;
                # [wasm_bindgen (method , structural , getter = color , js_class = "GradientStop")]
                fn color(this: &GradientStop_Class) -> Color;
                # [wasm_bindgen (method , structural , setter = color , js_class = "GradientStop")]
                fn set_color(this: &GradientStop_Class, value: Color);
                # [wasm_bindgen (method , structural , getter = offset , js_class = "GradientStop")]
                fn offset(this: &GradientStop_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = offset , js_class = "GradientStop")]
                fn set_offset(this: &GradientStop_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = clone , method , js_class = "GradientStop" , catch)]
                fn __TSB_clone(
                    this: &GradientStop_Class,
                ) -> std::result::Result<GradientStop, JsValue>;
                #[wasm_bindgen(constructor, js_class = "GradientStop")]
                pub fn new(color: Color, offset: f64) -> GradientStop_Class;
            }
            #[derive(std :: clone :: Clone)]
            struct GradientStop(pub GradientStop_Class);
            impl GradientStop {
                #[allow(dead_code)]
                pub fn color(&self) -> Color {
                    let result = self.0.color();
                    result
                }
                #[allow(dead_code)]
                pub fn set_color(&self, value: Color) -> () {
                    let result = self.0.set_color(value);
                    result
                }
                #[allow(dead_code)]
                pub fn offset(&self) -> f64 {
                    let result = self.0.offset();
                    result
                }
                #[allow(dead_code)]
                pub fn set_offset(&self, value: f64) -> () {
                    let result = self.0.set_offset(value);
                    result
                }
                #[allow(dead_code)]
                pub fn clone(&self) -> std::result::Result<GradientStop, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_clone()?);
                    result
                }
                #[allow(dead_code)]
                pub fn new(color: Color, offset: f64) -> GradientStop {
                    let result = GradientStop_Class::new(color, offset);
                    let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                    GradientStop(result)
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for GradientStop {
                fn describe() {
                    <GradientStop_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for GradientStop {
                type Abi = <GradientStop_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a GradientStop {
                type Abi = <&'a GradientStop_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for GradientStop {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for GradientStop {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: GradientStop_Class =
                        <GradientStop_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait GradientStop_Trait {
                fn color(&self) -> Color;
                fn set_color(&mut self, value: Color) -> ();
                fn offset(&self) -> f64;
                fn set_offset(&mut self, value: f64) -> ();
                fn clone(&self) -> std::result::Result<GradientStop, JsValue>;
                fn new(color: Color, offset: f64) -> GradientStop;
            }
            impl std::clone::Clone for GradientStop_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for GradientStop_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for GradientStop_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ViewOnClick {
                TsBindgenRtNullCase,
                JsValueCase(JsValue),
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                #[wasm_bindgen(js_name = "Style")]
                type Style_Class;
                # [wasm_bindgen (method , structural , getter = strokeScaling , js_class = "Style")]
                fn stroke_scaling(this: &Style_Class) -> bool;
                # [wasm_bindgen (method , structural , setter = strokeScaling , js_class = "Style")]
                fn set_stroke_scaling(this: &Style_Class, value: bool);
                # [wasm_bindgen (method , structural , getter = strokeWidth , js_class = "Style")]
                fn stroke_width(this: &Style_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = strokeWidth , js_class = "Style")]
                fn set_stroke_width(this: &Style_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = dashOffset , js_class = "Style")]
                fn dash_offset(this: &Style_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = dashOffset , js_class = "Style")]
                fn set_dash_offset(this: &Style_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = shadowColor , js_class = "Style")]
                fn shadow_color(this: &Style_Class) -> StyleShadowColor;
                # [wasm_bindgen (method , structural , setter = shadowColor , js_class = "Style")]
                fn set_shadow_color(this: &Style_Class, value: StyleShadowColor);
                # [wasm_bindgen (method , structural , getter = fillColor , js_class = "Style")]
                fn fill_color(this: &Style_Class) -> StyleFillColor;
                # [wasm_bindgen (method , structural , setter = fillColor , js_class = "Style")]
                fn set_fill_color(this: &Style_Class, value: StyleFillColor);
                # [wasm_bindgen (method , structural , getter = dashArray , js_class = "Style")]
                fn dash_array(this: &Style_Class) -> Vec<f64>;
                # [wasm_bindgen (method , structural , setter = dashArray , js_class = "Style")]
                fn set_dash_array(this: &Style_Class, value: Vec<f64>);
                # [wasm_bindgen (method , structural , getter = strokeJoin , js_class = "Style")]
                fn stroke_join(this: &Style_Class) -> String;
                # [wasm_bindgen (method , structural , setter = strokeJoin , js_class = "Style")]
                fn set_stroke_join(this: &Style_Class, value: String);
                # [wasm_bindgen (method , structural , getter = leading , js_class = "Style")]
                fn leading(this: &Style_Class) -> StyleLeading;
                # [wasm_bindgen (method , structural , setter = leading , js_class = "Style")]
                fn set_leading(this: &Style_Class, value: StyleLeading);
                # [wasm_bindgen (method , structural , getter = fillRule , js_class = "Style")]
                fn fill_rule(this: &Style_Class) -> String;
                # [wasm_bindgen (method , structural , setter = fillRule , js_class = "Style")]
                fn set_fill_rule(this: &Style_Class, value: String);
                # [wasm_bindgen (method , structural , getter = fontSize , js_class = "Style")]
                fn font_size(this: &Style_Class) -> StyleFontSize;
                # [wasm_bindgen (method , structural , setter = fontSize , js_class = "Style")]
                fn set_font_size(this: &Style_Class, value: StyleFontSize);
                # [wasm_bindgen (method , structural , getter = strokeColor , js_class = "Style")]
                fn stroke_color(this: &Style_Class) -> StyleStrokeColor;
                # [wasm_bindgen (method , structural , setter = strokeColor , js_class = "Style")]
                fn set_stroke_color(this: &Style_Class, value: StyleStrokeColor);
                # [wasm_bindgen (method , structural , getter = shadowBlur , js_class = "Style")]
                fn shadow_blur(this: &Style_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = shadowBlur , js_class = "Style")]
                fn set_shadow_blur(this: &Style_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = justification , js_class = "Style")]
                fn justification(this: &Style_Class) -> String;
                # [wasm_bindgen (method , structural , setter = justification , js_class = "Style")]
                fn set_justification(this: &Style_Class, value: String);
                #[wasm_bindgen(constructor, js_class = "Style")]
                pub fn new(style: std::collections::HashMap<String, JsValue>) -> Style_Class;
                # [wasm_bindgen (method , structural , getter = view , js_class = "Style")]
                fn view(this: &Style_Class) -> View;
                # [wasm_bindgen (method , structural , setter = view , js_class = "Style")]
                fn set_view(this: &Style_Class, value: View);
                # [wasm_bindgen (method , structural , getter = strokeCap , js_class = "Style")]
                fn stroke_cap(this: &Style_Class) -> String;
                # [wasm_bindgen (method , structural , setter = strokeCap , js_class = "Style")]
                fn set_stroke_cap(this: &Style_Class, value: String);
                # [wasm_bindgen (method , structural , getter = shadowOffset , js_class = "Style")]
                fn shadow_offset(this: &Style_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = shadowOffset , js_class = "Style")]
                fn set_shadow_offset(this: &Style_Class, value: Point);
                # [wasm_bindgen (method , structural , getter = selectedColor , js_class = "Style")]
                fn selected_color(this: &Style_Class) -> StyleSelectedColor;
                # [wasm_bindgen (method , structural , setter = selectedColor , js_class = "Style")]
                fn set_selected_color(this: &Style_Class, value: StyleSelectedColor);
                # [wasm_bindgen (method , structural , getter = fontFamily , js_class = "Style")]
                fn font_family(this: &Style_Class) -> String;
                # [wasm_bindgen (method , structural , setter = fontFamily , js_class = "Style")]
                fn set_font_family(this: &Style_Class, value: String);
                # [wasm_bindgen (method , structural , getter = fontWeight , js_class = "Style")]
                fn font_weight(this: &Style_Class) -> StyleFontWeight;
                # [wasm_bindgen (method , structural , setter = fontWeight , js_class = "Style")]
                fn set_font_weight(this: &Style_Class, value: StyleFontWeight);
                # [wasm_bindgen (method , structural , getter = miterLimit , js_class = "Style")]
                fn miter_limit(this: &Style_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = miterLimit , js_class = "Style")]
                fn set_miter_limit(this: &Style_Class, value: f64);
            }
            #[derive(std :: clone :: Clone)]
            struct Style(pub Style_Class);
            impl Style {
                #[allow(dead_code)]
                pub fn stroke_scaling(&self) -> bool {
                    let result = self.0.stroke_scaling();
                    result
                }
                #[allow(dead_code)]
                pub fn set_stroke_scaling(&self, value: bool) -> () {
                    let result = self.0.set_stroke_scaling(value);
                    result
                }
                #[allow(dead_code)]
                pub fn stroke_width(&self) -> f64 {
                    let result = self.0.stroke_width();
                    result
                }
                #[allow(dead_code)]
                pub fn set_stroke_width(&self, value: f64) -> () {
                    let result = self.0.set_stroke_width(value);
                    result
                }
                #[allow(dead_code)]
                pub fn dash_offset(&self) -> f64 {
                    let result = self.0.dash_offset();
                    result
                }
                #[allow(dead_code)]
                pub fn set_dash_offset(&self, value: f64) -> () {
                    let result = self.0.set_dash_offset(value);
                    result
                }
                #[allow(dead_code)]
                pub fn shadow_color(&self) -> StyleShadowColor {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.shadow_color()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_shadow_color(&self, value: StyleShadowColor) -> () {
                    let result = self.0.set_shadow_color(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn fill_color(&self) -> StyleFillColor {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.fill_color()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_fill_color(&self, value: StyleFillColor) -> () {
                    let result = self.0.set_fill_color(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn dash_array(&self) -> Vec<f64> {
                    let result = self.0.dash_array();
                    result
                }
                #[allow(dead_code)]
                pub fn set_dash_array(&self, value: Vec<f64>) -> () {
                    let result = self.0.set_dash_array(value);
                    result
                }
                #[allow(dead_code)]
                pub fn stroke_join(&self) -> String {
                    let result = self.0.stroke_join();
                    result
                }
                #[allow(dead_code)]
                pub fn set_stroke_join(&self, value: String) -> () {
                    let result = self.0.set_stroke_join(value);
                    result
                }
                #[allow(dead_code)]
                pub fn leading(&self) -> StyleLeading {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.leading()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_leading(&self, value: StyleLeading) -> () {
                    let result = self.0.set_leading(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn fill_rule(&self) -> String {
                    let result = self.0.fill_rule();
                    result
                }
                #[allow(dead_code)]
                pub fn set_fill_rule(&self, value: String) -> () {
                    let result = self.0.set_fill_rule(value);
                    result
                }
                #[allow(dead_code)]
                pub fn font_size(&self) -> StyleFontSize {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.font_size()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_font_size(&self, value: StyleFontSize) -> () {
                    let result = self.0.set_font_size(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn stroke_color(&self) -> StyleStrokeColor {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.stroke_color()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_stroke_color(&self, value: StyleStrokeColor) -> () {
                    let result = self.0.set_stroke_color(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn shadow_blur(&self) -> f64 {
                    let result = self.0.shadow_blur();
                    result
                }
                #[allow(dead_code)]
                pub fn set_shadow_blur(&self, value: f64) -> () {
                    let result = self.0.set_shadow_blur(value);
                    result
                }
                #[allow(dead_code)]
                pub fn justification(&self) -> String {
                    let result = self.0.justification();
                    result
                }
                #[allow(dead_code)]
                pub fn set_justification(&self, value: String) -> () {
                    let result = self.0.set_justification(value);
                    result
                }
                #[allow(dead_code)]
                pub fn new(style: std::collections::HashMap<String, JsValue>) -> Style {
                    let result = Style_Class::new(style);
                    let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                    Style(result)
                }
                #[allow(dead_code)]
                pub fn view(&self) -> View {
                    let result = self.0.view();
                    result
                }
                #[allow(dead_code)]
                pub fn set_view(&self, value: View) -> () {
                    let result = self.0.set_view(value);
                    result
                }
                #[allow(dead_code)]
                pub fn stroke_cap(&self) -> String {
                    let result = self.0.stroke_cap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_stroke_cap(&self, value: String) -> () {
                    let result = self.0.set_stroke_cap(value);
                    result
                }
                #[allow(dead_code)]
                pub fn shadow_offset(&self) -> Point {
                    let result = self.0.shadow_offset();
                    result
                }
                #[allow(dead_code)]
                pub fn set_shadow_offset(&self, value: Point) -> () {
                    let result = self.0.set_shadow_offset(value);
                    result
                }
                #[allow(dead_code)]
                pub fn selected_color(&self) -> StyleSelectedColor {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.selected_color()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_selected_color(&self, value: StyleSelectedColor) -> () {
                    let result = self.0.set_selected_color(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn font_family(&self) -> String {
                    let result = self.0.font_family();
                    result
                }
                #[allow(dead_code)]
                pub fn set_font_family(&self, value: String) -> () {
                    let result = self.0.set_font_family(value);
                    result
                }
                #[allow(dead_code)]
                pub fn font_weight(&self) -> StyleFontWeight {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.font_weight()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_font_weight(&self, value: StyleFontWeight) -> () {
                    let result = self.0.set_font_weight(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn miter_limit(&self) -> f64 {
                    let result = self.0.miter_limit();
                    result
                }
                #[allow(dead_code)]
                pub fn set_miter_limit(&self, value: f64) -> () {
                    let result = self.0.set_miter_limit(value);
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for Style {
                fn describe() {
                    <Style_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for Style {
                type Abi = <Style_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Style {
                type Abi = <&'a Style_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for Style {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Style {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: Style_Class =
                        <Style_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait Style_Trait {
                fn stroke_scaling(&self) -> bool;
                fn set_stroke_scaling(&mut self, value: bool) -> ();
                fn stroke_width(&self) -> f64;
                fn set_stroke_width(&mut self, value: f64) -> ();
                fn dash_offset(&self) -> f64;
                fn set_dash_offset(&mut self, value: f64) -> ();
                fn shadow_color(&self) -> StyleShadowColor;
                fn set_shadow_color(&mut self, value: StyleShadowColor) -> ();
                fn fill_color(&self) -> StyleFillColor;
                fn set_fill_color(&mut self, value: StyleFillColor) -> ();
                fn dash_array(&self) -> Vec<f64>;
                fn set_dash_array(&mut self, value: Vec<f64>) -> ();
                fn stroke_join(&self) -> String;
                fn set_stroke_join(&mut self, value: String) -> ();
                fn leading(&self) -> StyleLeading;
                fn set_leading(&mut self, value: StyleLeading) -> ();
                fn fill_rule(&self) -> String;
                fn set_fill_rule(&mut self, value: String) -> ();
                fn font_size(&self) -> StyleFontSize;
                fn set_font_size(&mut self, value: StyleFontSize) -> ();
                fn stroke_color(&self) -> StyleStrokeColor;
                fn set_stroke_color(&mut self, value: StyleStrokeColor) -> ();
                fn shadow_blur(&self) -> f64;
                fn set_shadow_blur(&mut self, value: f64) -> ();
                fn justification(&self) -> String;
                fn set_justification(&mut self, value: String) -> ();
                fn new(style: std::collections::HashMap<String, JsValue>) -> Style;
                fn view(&self) -> View;
                fn set_view(&mut self, value: View) -> ();
                fn stroke_cap(&self) -> String;
                fn set_stroke_cap(&mut self, value: String) -> ();
                fn shadow_offset(&self) -> Point;
                fn set_shadow_offset(&mut self, value: Point) -> ();
                fn selected_color(&self) -> StyleSelectedColor;
                fn set_selected_color(&mut self, value: StyleSelectedColor) -> ();
                fn font_family(&self) -> String;
                fn set_font_family(&mut self, value: String) -> ();
                fn font_weight(&self) -> StyleFontWeight;
                fn set_font_weight(&mut self, value: StyleFontWeight) -> ();
                fn miter_limit(&self) -> f64;
                fn set_miter_limit(&mut self, value: f64) -> ();
            }
            impl std::clone::Clone for Style_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for Style_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Style_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ViewOnResize {
                TsBindgenRtNullCase,
                JsValueCase(JsValue),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ItemTweenToParamsOptionsParam {
                F64Case(f64),
                StdCollectionsHashMapOfStringJsValueCase(
                    std::collections::HashMap<String, JsValue>,
                ),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ItemCopyToParamsOwnerParam {
                CompoundPathCase(CompoundPath),
                LayerCase(Layer),
                GroupCase(Group),
                ProjectCase(Project),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ProjectGetItemParamsOptionsParam {
                JsValueCase(JsValue),
                StdCollectionsHashMapOfStringJsValueCase(
                    std::collections::HashMap<String, JsValue>,
                ),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ItemGetItemsParamsOptionsParam {
                JsValueCase(JsValue),
                StdCollectionsHashMapOfStringJsValueCase(
                    std::collections::HashMap<String, JsValue>,
                ),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ItemOnMouseLeave {
                TsBindgenRtNullCase,
                JsValueCase(JsValue),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ItemOnClick {
                TsBindgenRtNullCase,
                JsValueCase(JsValue),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ToolOnMouseDown {
                TsBindgenRtNullCase,
                JsValueCase(JsValue),
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                #[wasm_bindgen(js_name = "Gradient")]
                type Gradient_Class;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = equals , method , js_class = "Gradient" , catch)]
                fn __TSB_equals(
                    this: &Gradient_Class,
                    gradient: Gradient,
                ) -> std::result::Result<bool, JsValue>;
                # [wasm_bindgen (method , structural , getter = radial , js_class = "Gradient")]
                fn radial(this: &Gradient_Class) -> bool;
                # [wasm_bindgen (method , structural , setter = radial , js_class = "Gradient")]
                fn set_radial(this: &Gradient_Class, value: bool);
                # [wasm_bindgen (method , structural , getter = stops , js_class = "Gradient")]
                fn stops(this: &Gradient_Class) -> Vec<GradientStop>;
                # [wasm_bindgen (method , structural , setter = stops , js_class = "Gradient")]
                fn set_stops(this: &Gradient_Class, value: Vec<GradientStop>);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = clone , method , js_class = "Gradient" , catch)]
                fn __TSB_clone(this: &Gradient_Class) -> std::result::Result<Gradient, JsValue>;
            }
            #[derive(std :: clone :: Clone)]
            struct Gradient(pub Gradient_Class);
            impl Gradient {
                #[allow(dead_code)]
                pub fn equals(&self, gradient: Gradient) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_equals(gradient)?);
                    result
                }
                #[allow(dead_code)]
                pub fn radial(&self) -> bool {
                    let result = self.0.radial();
                    result
                }
                #[allow(dead_code)]
                pub fn set_radial(&self, value: bool) -> () {
                    let result = self.0.set_radial(value);
                    result
                }
                #[allow(dead_code)]
                pub fn stops(&self) -> Vec<GradientStop> {
                    let result = self.0.stops();
                    result
                }
                #[allow(dead_code)]
                pub fn set_stops(&self, value: Vec<GradientStop>) -> () {
                    let result = self.0.set_stops(value);
                    result
                }
                #[allow(dead_code)]
                pub fn clone(&self) -> std::result::Result<Gradient, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_clone()?);
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for Gradient {
                fn describe() {
                    <Gradient_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for Gradient {
                type Abi = <Gradient_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Gradient {
                type Abi = <&'a Gradient_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for Gradient {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Gradient {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: Gradient_Class =
                        <Gradient_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait Gradient_Trait {
                fn equals(&self, gradient: Gradient) -> std::result::Result<bool, JsValue>;
                fn radial(&self) -> bool;
                fn set_radial(&mut self, value: bool) -> ();
                fn stops(&self) -> Vec<GradientStop>;
                fn set_stops(&mut self, value: Vec<GradientStop>) -> ();
                fn clone(&self) -> std::result::Result<Gradient, JsValue>;
            }
            impl std::clone::Clone for Gradient_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for Gradient_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Gradient_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum StyleLeading {
                StringCase(String),
                F64Case(f64),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ProjectGetItemsParamsOptionsParam {
                JsValueCase(JsValue),
                StdCollectionsHashMapOfStringJsValueCase(
                    std::collections::HashMap<String, JsValue>,
                ),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ToolOnMouseDrag {
                TsBindgenRtNullCase,
                JsValueCase(JsValue),
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                # [wasm_bindgen (js_name = "MouseEvent" , extends = Event_Class)]
                type MouseEvent_Class;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = toString , method , js_class = "MouseEvent" , catch)]
                fn __TSB_to_string(this: &MouseEvent_Class)
                    -> std::result::Result<String, JsValue>;
                # [wasm_bindgen (method , structural , getter = delta , js_class = "MouseEvent")]
                fn delta(this: &MouseEvent_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = delta , js_class = "MouseEvent")]
                fn set_delta(this: &MouseEvent_Class, value: Point);
                # [wasm_bindgen (method , structural , getter = target , js_class = "MouseEvent")]
                fn target(this: &MouseEvent_Class) -> Item;
                # [wasm_bindgen (method , structural , setter = target , js_class = "MouseEvent")]
                fn set_target(this: &MouseEvent_Class, value: Item);
                # [wasm_bindgen (method , structural , getter = type , js_class = "MouseEvent")]
                fn type_(this: &MouseEvent_Class) -> String;
                # [wasm_bindgen (method , structural , setter = type , js_class = "MouseEvent")]
                fn set_type_(this: &MouseEvent_Class, value: String);
                # [wasm_bindgen (method , structural , getter = currentTarget , js_class = "MouseEvent")]
                fn current_target(this: &MouseEvent_Class) -> Item;
                # [wasm_bindgen (method , structural , setter = currentTarget , js_class = "MouseEvent")]
                fn set_current_target(this: &MouseEvent_Class, value: Item);
                # [wasm_bindgen (method , structural , getter = point , js_class = "MouseEvent")]
                fn point(this: &MouseEvent_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = point , js_class = "MouseEvent")]
                fn set_point(this: &MouseEvent_Class, value: Point);
            }
            #[derive(std :: clone :: Clone)]
            struct MouseEvent(pub MouseEvent_Class);
            impl std::convert::From<&MouseEvent> for Event {
                fn from(src: &MouseEvent) -> Event {
                    let src: &Event_Class = src.0.as_ref();
                    Event(src.clone())
                }
            }
            impl std::convert::From<&mut MouseEvent> for Event {
                fn from(src: &mut MouseEvent) -> Event {
                    let src: &Event_Class = src.0.as_ref();
                    Event(src.clone())
                }
            }
            impl MouseEvent {
                #[allow(dead_code)]
                pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_to_string()?);
                    result
                }
                #[allow(dead_code)]
                pub fn delta(&self) -> Point {
                    let result = self.0.delta();
                    result
                }
                #[allow(dead_code)]
                pub fn set_delta(&self, value: Point) -> () {
                    let result = self.0.set_delta(value);
                    result
                }
                #[allow(dead_code)]
                pub fn target(&self) -> Item {
                    let result = self.0.target();
                    result
                }
                #[allow(dead_code)]
                pub fn set_target(&self, value: Item) -> () {
                    let result = self.0.set_target(value);
                    result
                }
                #[allow(dead_code)]
                pub fn type_(&self) -> String {
                    let result = self.0.type_();
                    result
                }
                #[allow(dead_code)]
                pub fn set_type_(&self, value: String) -> () {
                    let result = self.0.set_type_(value);
                    result
                }
                #[allow(dead_code)]
                pub fn current_target(&self) -> Item {
                    let result = self.0.current_target();
                    result
                }
                #[allow(dead_code)]
                pub fn set_current_target(&self, value: Item) -> () {
                    let result = self.0.set_current_target(value);
                    result
                }
                #[allow(dead_code)]
                pub fn point(&self) -> Point {
                    let result = self.0.point();
                    result
                }
                #[allow(dead_code)]
                pub fn set_point(&self, value: Point) -> () {
                    let result = self.0.set_point(value);
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for MouseEvent {
                fn describe() {
                    <MouseEvent_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for MouseEvent {
                type Abi = <MouseEvent_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a MouseEvent {
                type Abi = <&'a MouseEvent_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for MouseEvent {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for MouseEvent {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: MouseEvent_Class =
                        <MouseEvent_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait MouseEvent_Trait: Event_Trait {
                fn to_string(&self) -> std::result::Result<String, JsValue>;
                fn delta(&self) -> Point;
                fn set_delta(&mut self, value: Point) -> ();
                fn target(&self) -> Item;
                fn set_target(&mut self, value: Item) -> ();
                fn type_(&self) -> String;
                fn set_type(&mut self, value: String) -> ();
                fn current_target(&self) -> Item;
                fn set_current_target(&mut self, value: Item) -> ();
                fn point(&self) -> Point;
                fn set_point(&mut self, value: Point) -> ();
            }
            impl Event_Trait for MouseEvent {
                fn prevent_default(&self) -> std::result::Result<(), JsValue> {
                    let target: Event = self.into();
                    Event::prevent_default(&target)
                }
                fn time_stamp(&self) -> f64 {
                    let target: Event = self.into();
                    Event::time_stamp(&target)
                }
                fn set_time_stamp(&mut self, value: f64) -> () {
                    let mut target: Event = self.into();
                    Event::set_time_stamp(&mut target, value)
                }
                fn stop(&self) -> std::result::Result<(), JsValue> {
                    let target: Event = self.into();
                    Event::stop(&target)
                }
                fn modifiers(&self) -> JsValue {
                    let target: Event = self.into();
                    Event::modifiers(&target)
                }
                fn set_modifiers(&mut self, value: JsValue) -> () {
                    let mut target: Event = self.into();
                    Event::set_modifiers(&mut target, value)
                }
                fn stop_propagation(&self) -> std::result::Result<(), JsValue> {
                    let target: Event = self.into();
                    Event::stop_propagation(&target)
                }
            }
            impl MouseEvent_Trait for MouseEvent {}
            impl std::clone::Clone for MouseEvent_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for MouseEvent_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for MouseEvent_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                #[wasm_bindgen(js_name = "Segment")]
                type Segment_Class;
                #[wasm_bindgen(constructor, js_class = "Segment")]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Segment_Class;
                # [wasm_bindgen (method , structural , getter = curve , js_class = "Segment")]
                fn curve(this: &Segment_Class) -> Curve;
                # [wasm_bindgen (method , structural , setter = curve , js_class = "Segment")]
                fn set_curve(this: &Segment_Class, value: Curve);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isSmooth , method , js_class = "Segment" , catch)]
                fn __TSB_is_smooth(this: &Segment_Class) -> std::result::Result<bool, JsValue>;
                # [wasm_bindgen (method , structural , getter = location , js_class = "Segment")]
                fn location(this: &Segment_Class) -> CurveLocation;
                # [wasm_bindgen (method , structural , setter = location , js_class = "Segment")]
                fn set_location(this: &Segment_Class, value: CurveLocation);
                # [wasm_bindgen (method , structural , getter = path , js_class = "Segment")]
                fn path(this: &Segment_Class) -> Path;
                # [wasm_bindgen (method , structural , setter = path , js_class = "Segment")]
                fn set_path(this: &Segment_Class, value: Path);
                # [wasm_bindgen (method , structural , getter = handleOut , js_class = "Segment")]
                fn handle_out(this: &Segment_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = handleOut , js_class = "Segment")]
                fn set_handle_out(this: &Segment_Class, value: Point);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = reversed , method , js_class = "Segment" , catch)]
                fn __TSB_reversed(this: &Segment_Class) -> std::result::Result<Segment, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = remove , method , js_class = "Segment" , catch)]
                fn __TSB_remove(this: &Segment_Class) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isLast , method , js_class = "Segment" , catch)]
                fn __TSB_is_last(this: &Segment_Class) -> std::result::Result<bool, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = reverse , method , js_class = "Segment" , catch)]
                fn __TSB_reverse(this: &Segment_Class) -> std::result::Result<Segment, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = transform , method , js_class = "Segment" , catch)]
                fn __TSB_transform(
                    this: &Segment_Class,
                    matrix: Matrix,
                ) -> std::result::Result<(), JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = clone , method , js_class = "Segment" , catch)]
                fn __TSB_clone(this: &Segment_Class) -> std::result::Result<Segment, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = toString , method , js_class = "Segment" , catch)]
                fn __TSB_to_string(this: &Segment_Class) -> std::result::Result<String, JsValue>;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = isFirst , method , js_class = "Segment" , catch)]
                fn __TSB_is_first(this: &Segment_Class) -> std::result::Result<bool, JsValue>;
                # [wasm_bindgen (method , structural , getter = handleIn , js_class = "Segment")]
                fn handle_in(this: &Segment_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = handleIn , js_class = "Segment")]
                fn set_handle_in(this: &Segment_Class, value: Point);
                # [wasm_bindgen (method , structural , getter = previous , js_class = "Segment")]
                fn previous(this: &Segment_Class) -> Segment;
                # [wasm_bindgen (method , structural , setter = previous , js_class = "Segment")]
                fn set_previous(this: &Segment_Class, value: Segment);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = clearHandles , method , js_class = "Segment" , catch)]
                fn __TSB_clear_handles(this: &Segment_Class) -> std::result::Result<(), JsValue>;
                # [wasm_bindgen (method , structural , getter = selected , js_class = "Segment")]
                fn selected(this: &Segment_Class) -> bool;
                # [wasm_bindgen (method , structural , setter = selected , js_class = "Segment")]
                fn set_selected(this: &Segment_Class, value: bool);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = hasHandles , method , js_class = "Segment" , catch)]
                fn __TSB_has_handles(this: &Segment_Class) -> std::result::Result<bool, JsValue>;
                # [wasm_bindgen (method , structural , getter = next , js_class = "Segment")]
                fn next(this: &Segment_Class) -> Segment;
                # [wasm_bindgen (method , structural , setter = next , js_class = "Segment")]
                fn set_next(this: &Segment_Class, value: Segment);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = interpolate , method , js_class = "Segment" , catch)]
                fn __TSB_interpolate(
                    this: &Segment_Class,
                    from: Segment,
                    to: Segment,
                    factor: f64,
                ) -> std::result::Result<(), JsValue>;
                # [wasm_bindgen (method , structural , getter = index , js_class = "Segment")]
                fn index(this: &Segment_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = index , js_class = "Segment")]
                fn set_index(this: &Segment_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = point , js_class = "Segment")]
                fn point(this: &Segment_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = point , js_class = "Segment")]
                fn set_point(this: &Segment_Class, value: Point);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = smooth , method , js_class = "Segment" , catch)]
                fn __TSB_smooth(
                    this: &Segment_Class,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<(), JsValue>;
            }
            #[derive(std :: clone :: Clone)]
            struct Segment(pub Segment_Class);
            impl Segment {
                #[allow(dead_code)]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Segment {
                    let result = Segment_Class::new(object);
                    let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                    Segment(result)
                }
                #[allow(dead_code)]
                pub fn curve(&self) -> Curve {
                    let result = self.0.curve();
                    result
                }
                #[allow(dead_code)]
                pub fn set_curve(&self, value: Curve) -> () {
                    let result = self.0.set_curve(value);
                    result
                }
                #[allow(dead_code)]
                pub fn is_smooth(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_smooth()?);
                    result
                }
                #[allow(dead_code)]
                pub fn location(&self) -> CurveLocation {
                    let result = self.0.location();
                    result
                }
                #[allow(dead_code)]
                pub fn set_location(&self, value: CurveLocation) -> () {
                    let result = self.0.set_location(value);
                    result
                }
                #[allow(dead_code)]
                pub fn path(&self) -> Path {
                    let result = self.0.path();
                    result
                }
                #[allow(dead_code)]
                pub fn set_path(&self, value: Path) -> () {
                    let result = self.0.set_path(value);
                    result
                }
                #[allow(dead_code)]
                pub fn handle_out(&self) -> Point {
                    let result = self.0.handle_out();
                    result
                }
                #[allow(dead_code)]
                pub fn set_handle_out(&self, value: Point) -> () {
                    let result = self.0.set_handle_out(value);
                    result
                }
                #[allow(dead_code)]
                pub fn reversed(&self) -> std::result::Result<Segment, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_reversed()?);
                    result
                }
                #[allow(dead_code)]
                pub fn remove(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_remove()?);
                    result
                }
                #[allow(dead_code)]
                pub fn is_last(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_last()?);
                    result
                }
                #[allow(dead_code)]
                pub fn reverse(&self) -> std::result::Result<Segment, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_reverse()?);
                    result
                }
                #[allow(dead_code)]
                pub fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_transform(matrix)?);
                    result
                }
                #[allow(dead_code)]
                pub fn clone(&self) -> std::result::Result<Segment, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_clone()?);
                    result
                }
                #[allow(dead_code)]
                pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_to_string()?);
                    result
                }
                #[allow(dead_code)]
                pub fn is_first(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_is_first()?);
                    result
                }
                #[allow(dead_code)]
                pub fn handle_in(&self) -> Point {
                    let result = self.0.handle_in();
                    result
                }
                #[allow(dead_code)]
                pub fn set_handle_in(&self, value: Point) -> () {
                    let result = self.0.set_handle_in(value);
                    result
                }
                #[allow(dead_code)]
                pub fn previous(&self) -> Segment {
                    let result = self.0.previous();
                    result
                }
                #[allow(dead_code)]
                pub fn set_previous(&self, value: Segment) -> () {
                    let result = self.0.set_previous(value);
                    result
                }
                #[allow(dead_code)]
                pub fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_clear_handles()?);
                    result
                }
                #[allow(dead_code)]
                pub fn selected(&self) -> bool {
                    let result = self.0.selected();
                    result
                }
                #[allow(dead_code)]
                pub fn set_selected(&self, value: bool) -> () {
                    let result = self.0.set_selected(value);
                    result
                }
                #[allow(dead_code)]
                pub fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_has_handles()?);
                    result
                }
                #[allow(dead_code)]
                pub fn next(&self) -> Segment {
                    let result = self.0.next();
                    result
                }
                #[allow(dead_code)]
                pub fn set_next(&self, value: Segment) -> () {
                    let result = self.0.set_next(value);
                    result
                }
                #[allow(dead_code)]
                pub fn interpolate(
                    &self,
                    from: Segment,
                    to: Segment,
                    factor: f64,
                ) -> std::result::Result<(), JsValue> {
                    let result =
                        std::result::Result::Ok(self.0.__TSB_interpolate(from, to, factor)?);
                    result
                }
                #[allow(dead_code)]
                pub fn index(&self) -> f64 {
                    let result = self.0.index();
                    result
                }
                #[allow(dead_code)]
                pub fn set_index(&self, value: f64) -> () {
                    let result = self.0.set_index(value);
                    result
                }
                #[allow(dead_code)]
                pub fn point(&self) -> Point {
                    let result = self.0.point();
                    result
                }
                #[allow(dead_code)]
                pub fn set_point(&self, value: Point) -> () {
                    let result = self.0.set_point(value);
                    result
                }
                #[allow(dead_code)]
                pub fn smooth(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_smooth(options)?);
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for Segment {
                fn describe() {
                    <Segment_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for Segment {
                type Abi = <Segment_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Segment {
                type Abi = <&'a Segment_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for Segment {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Segment {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: Segment_Class =
                        <Segment_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait Segment_Trait {
                fn new(object: std::collections::HashMap<String, JsValue>) -> Segment;
                fn curve(&self) -> Curve;
                fn set_curve(&mut self, value: Curve) -> ();
                fn is_smooth(&self) -> std::result::Result<bool, JsValue>;
                fn location(&self) -> CurveLocation;
                fn set_location(&mut self, value: CurveLocation) -> ();
                fn path(&self) -> Path;
                fn set_path(&mut self, value: Path) -> ();
                fn handle_out(&self) -> Point;
                fn set_handle_out(&mut self, value: Point) -> ();
                fn reversed(&self) -> std::result::Result<Segment, JsValue>;
                fn remove(&self) -> std::result::Result<bool, JsValue>;
                fn is_last(&self) -> std::result::Result<bool, JsValue>;
                fn reverse(&self) -> std::result::Result<Segment, JsValue>;
                fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue>;
                fn clone(&self) -> std::result::Result<Segment, JsValue>;
                fn to_string(&self) -> std::result::Result<String, JsValue>;
                fn is_first(&self) -> std::result::Result<bool, JsValue>;
                fn handle_in(&self) -> Point;
                fn set_handle_in(&mut self, value: Point) -> ();
                fn previous(&self) -> Segment;
                fn set_previous(&mut self, value: Segment) -> ();
                fn clear_handles(&self) -> std::result::Result<(), JsValue>;
                fn selected(&self) -> bool;
                fn set_selected(&mut self, value: bool) -> ();
                fn has_handles(&self) -> std::result::Result<bool, JsValue>;
                fn next(&self) -> Segment;
                fn set_next(&mut self, value: Segment) -> ();
                fn interpolate(
                    &self,
                    from: Segment,
                    to: Segment,
                    factor: f64,
                ) -> std::result::Result<(), JsValue>;
                fn index(&self) -> f64;
                fn set_index(&mut self, value: f64) -> ();
                fn point(&self) -> Point;
                fn set_point(&mut self, value: Point) -> ();
                fn smooth(
                    &self,
                    options: std::collections::HashMap<String, JsValue>,
                ) -> std::result::Result<(), JsValue>;
            }
            impl std::clone::Clone for Segment_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for Segment_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Segment_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                #[wasm_bindgen(js_name = "Tween")]
                type Tween_Class;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = start , method , js_class = "Tween" , catch)]
                fn __TSB_start(this: &Tween_Class) -> std::result::Result<Tween, JsValue>;
                # [wasm_bindgen (method , structural , getter = onUpdate , js_class = "Tween")]
                fn on_update(this: &Tween_Class) -> TweenOnUpdate;
                # [wasm_bindgen (method , structural , setter = onUpdate , js_class = "Tween")]
                fn set_on_update(this: &Tween_Class, value: TweenOnUpdate);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = then , method , js_class = "Tween" , catch)]
                fn __TSB_then(
                    this: &Tween_Class,
                    callback: JsValue,
                ) -> std::result::Result<Tween, JsValue>;
                #[wasm_bindgen(constructor, js_class = "Tween")]
                pub fn new(
                    object: std::collections::HashMap<String, JsValue>,
                    from: std::collections::HashMap<String, JsValue>,
                    to: std::collections::HashMap<String, JsValue>,
                    duration: f64,
                    easing: TweenConstructorEasingParam,
                    start: bool,
                ) -> Tween_Class;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = stop , method , js_class = "Tween" , catch)]
                fn __TSB_stop(this: &Tween_Class) -> std::result::Result<Tween, JsValue>;
            }
            #[derive(std :: clone :: Clone)]
            struct Tween(pub Tween_Class);
            impl Tween {
                #[allow(dead_code)]
                pub fn start(&self) -> std::result::Result<Tween, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_start()?);
                    result
                }
                #[allow(dead_code)]
                pub fn on_update(&self) -> TweenOnUpdate {
                    let result = ts_bindgen_rt::from_jsvalue(&self.0.on_update()).unwrap();
                    result
                }
                #[allow(dead_code)]
                pub fn set_on_update(&self, value: TweenOnUpdate) -> () {
                    let result = self.0.set_on_update(
                        ts_bindgen_rt::to_jsvalue(&value).map_err(ts_bindgen_rt::Error::from)?,
                    );
                    result
                }
                #[allow(dead_code)]
                pub fn then(&self, callback: JsValue) -> std::result::Result<Tween, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_then(callback)?);
                    result
                }
                #[allow(dead_code)]
                pub fn new(
                    object: std::collections::HashMap<String, JsValue>,
                    from: std::collections::HashMap<String, JsValue>,
                    to: std::collections::HashMap<String, JsValue>,
                    duration: f64,
                    easing: TweenConstructorEasingParam,
                    start: bool,
                ) -> Tween {
                    let result = Tween_Class::new(
                        object,
                        from,
                        to,
                        duration,
                        ts_bindgen_rt::to_jsvalue(&easing).map_err(ts_bindgen_rt::Error::from)?,
                        start,
                    );
                    let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                    Tween(result)
                }
                #[allow(dead_code)]
                pub fn stop(&self) -> std::result::Result<Tween, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_stop()?);
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for Tween {
                fn describe() {
                    <Tween_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for Tween {
                type Abi = <Tween_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Tween {
                type Abi = <&'a Tween_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for Tween {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Tween {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: Tween_Class =
                        <Tween_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait Tween_Trait {
                fn start(&self) -> std::result::Result<Tween, JsValue>;
                fn on_update(&self) -> TweenOnUpdate;
                fn set_on_update(&mut self, value: TweenOnUpdate) -> ();
                fn then(&self, callback: JsValue) -> std::result::Result<Tween, JsValue>;
                fn new(
                    object: std::collections::HashMap<String, JsValue>,
                    from: std::collections::HashMap<String, JsValue>,
                    to: std::collections::HashMap<String, JsValue>,
                    duration: f64,
                    easing: TweenConstructorEasingParam,
                    start: bool,
                ) -> Tween;
                fn stop(&self) -> std::result::Result<Tween, JsValue>;
            }
            impl std::clone::Clone for Tween_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for Tween_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Tween_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                # [wasm_bindgen (js_name = "RegularPolygon" , extends = Path_Class)]
                type RegularPolygon_Class;
                #[wasm_bindgen(constructor, js_class = "RegularPolygon")]
                pub fn new(
                    object: std::collections::HashMap<String, JsValue>,
                ) -> RegularPolygon_Class;
            }
            #[derive(std :: clone :: Clone)]
            struct RegularPolygon(pub RegularPolygon_Class);
            impl std::convert::From<&RegularPolygon> for Path {
                fn from(src: &RegularPolygon) -> Path {
                    let src: &Path_Class = src.0.as_ref();
                    Path(src.clone())
                }
            }
            impl std::convert::From<&mut RegularPolygon> for Path {
                fn from(src: &mut RegularPolygon) -> Path {
                    let src: &Path_Class = src.0.as_ref();
                    Path(src.clone())
                }
            }
            impl RegularPolygon {
                #[allow(dead_code)]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> RegularPolygon {
                    let result = RegularPolygon_Class::new(object);
                    let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                    RegularPolygon(result)
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for RegularPolygon {
                fn describe() {
                    <RegularPolygon_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for RegularPolygon {
                type Abi = <RegularPolygon_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a RegularPolygon {
                type Abi = <&'a RegularPolygon_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for RegularPolygon {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for RegularPolygon {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: RegularPolygon_Class =
                        <RegularPolygon_Class as serde::de::Deserialize>::deserialize(
                            deserializer,
                        )?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait RegularPolygon_Trait: Path_Trait {
                fn new(object: std::collections::HashMap<String, JsValue>) -> RegularPolygon;
            }
            impl Path_Trait for RegularPolygon {}
            impl RegularPolygon_Trait for RegularPolygon {}
            impl std::clone::Clone for RegularPolygon_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for RegularPolygon_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for RegularPolygon_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                #[wasm_bindgen(js_name = "Event")]
                type Event_Class;
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = preventDefault , method , js_class = "Event" , catch)]
                fn __TSB_prevent_default(this: &Event_Class) -> std::result::Result<(), JsValue>;
                # [wasm_bindgen (method , structural , getter = timeStamp , js_class = "Event")]
                fn time_stamp(this: &Event_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = timeStamp , js_class = "Event")]
                fn set_time_stamp(this: &Event_Class, value: f64);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = stop , method , js_class = "Event" , catch)]
                fn __TSB_stop(this: &Event_Class) -> std::result::Result<(), JsValue>;
                # [wasm_bindgen (method , structural , getter = modifiers , js_class = "Event")]
                fn modifiers(this: &Event_Class) -> JsValue;
                # [wasm_bindgen (method , structural , setter = modifiers , js_class = "Event")]
                fn set_modifiers(this: &Event_Class, value: JsValue);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = stopPropagation , method , js_class = "Event" , catch)]
                fn __TSB_stop_propagation(this: &Event_Class) -> std::result::Result<(), JsValue>;
            }
            #[derive(std :: clone :: Clone)]
            struct Event(pub Event_Class);
            impl Event {
                #[allow(dead_code)]
                pub fn prevent_default(&self) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_prevent_default()?);
                    result
                }
                #[allow(dead_code)]
                pub fn time_stamp(&self) -> f64 {
                    let result = self.0.time_stamp();
                    result
                }
                #[allow(dead_code)]
                pub fn set_time_stamp(&self, value: f64) -> () {
                    let result = self.0.set_time_stamp(value);
                    result
                }
                #[allow(dead_code)]
                pub fn stop(&self) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_stop()?);
                    result
                }
                #[allow(dead_code)]
                pub fn modifiers(&self) -> JsValue {
                    let result = self.0.modifiers();
                    result
                }
                #[allow(dead_code)]
                pub fn set_modifiers(&self, value: JsValue) -> () {
                    let result = self.0.set_modifiers(value);
                    result
                }
                #[allow(dead_code)]
                pub fn stop_propagation(&self) -> std::result::Result<(), JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_stop_propagation()?);
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for Event {
                fn describe() {
                    <Event_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for Event {
                type Abi = <Event_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Event {
                type Abi = <&'a Event_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for Event {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Event {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: Event_Class =
                        <Event_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait Event_Trait {
                fn prevent_default(&self) -> std::result::Result<(), JsValue>;
                fn time_stamp(&self) -> f64;
                fn set_time_stamp(&mut self, value: f64) -> ();
                fn stop(&self) -> std::result::Result<(), JsValue>;
                fn modifiers(&self) -> JsValue;
                fn set_modifiers(&mut self, value: JsValue) -> ();
                fn stop_propagation(&self) -> std::result::Result<(), JsValue>;
            }
            impl std::clone::Clone for Event_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for Event_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Event_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ItemGetItemParamsOptionsParam {
                JsValueCase(JsValue),
                StdCollectionsHashMapOfStringJsValueCase(
                    std::collections::HashMap<String, JsValue>,
                ),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ProjectConstructorElementParam {
                SizeCase(Size),
                StringCase(String),
                JsValueCase(JsValue),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ItemOnMouseUp {
                TsBindgenRtNullCase,
                JsValueCase(JsValue),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ViewOnMouseDrag {
                TsBindgenRtNullCase,
                JsValueCase(JsValue),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ToolOnMouseUp {
                TsBindgenRtNullCase,
                JsValueCase(JsValue),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ItemTweenParamsOptionsParam {
                F64Case(f64),
                StdCollectionsHashMapOfStringJsValueCase(
                    std::collections::HashMap<String, JsValue>,
                ),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum RasterSource {
                StringCase(String),
                JsValueCase(JsValue),
                JsValueCase(JsValue),
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                # [wasm_bindgen (js_name = "ToolEvent" , extends = Event_Class)]
                type ToolEvent_Class;
                # [wasm_bindgen (method , structural , getter = middlePoint , js_class = "ToolEvent")]
                fn middle_point(this: &ToolEvent_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = middlePoint , js_class = "ToolEvent")]
                fn set_middle_point(this: &ToolEvent_Class, value: Point);
                # [wasm_bindgen (method , structural , getter = type , js_class = "ToolEvent")]
                fn type_(this: &ToolEvent_Class) -> String;
                # [wasm_bindgen (method , structural , setter = type , js_class = "ToolEvent")]
                fn set_type_(this: &ToolEvent_Class, value: String);
                #[allow(non_snake_case)]
                # [wasm_bindgen (js_name = toString , method , js_class = "ToolEvent" , catch)]
                fn __TSB_to_string(this: &ToolEvent_Class) -> std::result::Result<String, JsValue>;
                # [wasm_bindgen (method , structural , getter = delta , js_class = "ToolEvent")]
                fn delta(this: &ToolEvent_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = delta , js_class = "ToolEvent")]
                fn set_delta(this: &ToolEvent_Class, value: Point);
                # [wasm_bindgen (method , structural , getter = item , js_class = "ToolEvent")]
                fn item(this: &ToolEvent_Class) -> Item;
                # [wasm_bindgen (method , structural , setter = item , js_class = "ToolEvent")]
                fn set_item(this: &ToolEvent_Class, value: Item);
                # [wasm_bindgen (method , structural , getter = downPoint , js_class = "ToolEvent")]
                fn down_point(this: &ToolEvent_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = downPoint , js_class = "ToolEvent")]
                fn set_down_point(this: &ToolEvent_Class, value: Point);
                # [wasm_bindgen (method , structural , getter = lastPoint , js_class = "ToolEvent")]
                fn last_point(this: &ToolEvent_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = lastPoint , js_class = "ToolEvent")]
                fn set_last_point(this: &ToolEvent_Class, value: Point);
                # [wasm_bindgen (method , structural , getter = count , js_class = "ToolEvent")]
                fn count(this: &ToolEvent_Class) -> f64;
                # [wasm_bindgen (method , structural , setter = count , js_class = "ToolEvent")]
                fn set_count(this: &ToolEvent_Class, value: f64);
                # [wasm_bindgen (method , structural , getter = point , js_class = "ToolEvent")]
                fn point(this: &ToolEvent_Class) -> Point;
                # [wasm_bindgen (method , structural , setter = point , js_class = "ToolEvent")]
                fn set_point(this: &ToolEvent_Class, value: Point);
            }
            #[derive(std :: clone :: Clone)]
            struct ToolEvent(pub ToolEvent_Class);
            impl std::convert::From<&ToolEvent> for Event {
                fn from(src: &ToolEvent) -> Event {
                    let src: &Event_Class = src.0.as_ref();
                    Event(src.clone())
                }
            }
            impl std::convert::From<&mut ToolEvent> for Event {
                fn from(src: &mut ToolEvent) -> Event {
                    let src: &Event_Class = src.0.as_ref();
                    Event(src.clone())
                }
            }
            impl ToolEvent {
                #[allow(dead_code)]
                pub fn middle_point(&self) -> Point {
                    let result = self.0.middle_point();
                    result
                }
                #[allow(dead_code)]
                pub fn set_middle_point(&self, value: Point) -> () {
                    let result = self.0.set_middle_point(value);
                    result
                }
                #[allow(dead_code)]
                pub fn type_(&self) -> String {
                    let result = self.0.type_();
                    result
                }
                #[allow(dead_code)]
                pub fn set_type_(&self, value: String) -> () {
                    let result = self.0.set_type_(value);
                    result
                }
                #[allow(dead_code)]
                pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                    let result = std::result::Result::Ok(self.0.__TSB_to_string()?);
                    result
                }
                #[allow(dead_code)]
                pub fn delta(&self) -> Point {
                    let result = self.0.delta();
                    result
                }
                #[allow(dead_code)]
                pub fn set_delta(&self, value: Point) -> () {
                    let result = self.0.set_delta(value);
                    result
                }
                #[allow(dead_code)]
                pub fn item(&self) -> Item {
                    let result = self.0.item();
                    result
                }
                #[allow(dead_code)]
                pub fn set_item(&self, value: Item) -> () {
                    let result = self.0.set_item(value);
                    result
                }
                #[allow(dead_code)]
                pub fn down_point(&self) -> Point {
                    let result = self.0.down_point();
                    result
                }
                #[allow(dead_code)]
                pub fn set_down_point(&self, value: Point) -> () {
                    let result = self.0.set_down_point(value);
                    result
                }
                #[allow(dead_code)]
                pub fn last_point(&self) -> Point {
                    let result = self.0.last_point();
                    result
                }
                #[allow(dead_code)]
                pub fn set_last_point(&self, value: Point) -> () {
                    let result = self.0.set_last_point(value);
                    result
                }
                #[allow(dead_code)]
                pub fn count(&self) -> f64 {
                    let result = self.0.count();
                    result
                }
                #[allow(dead_code)]
                pub fn set_count(&self, value: f64) -> () {
                    let result = self.0.set_count(value);
                    result
                }
                #[allow(dead_code)]
                pub fn point(&self) -> Point {
                    let result = self.0.point();
                    result
                }
                #[allow(dead_code)]
                pub fn set_point(&self, value: Point) -> () {
                    let result = self.0.set_point(value);
                    result
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for ToolEvent {
                fn describe() {
                    <ToolEvent_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for ToolEvent {
                type Abi = <ToolEvent_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a ToolEvent {
                type Abi = <&'a ToolEvent_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for ToolEvent {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for ToolEvent {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: ToolEvent_Class =
                        <ToolEvent_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait ToolEvent_Trait: Event_Trait {
                fn middle_point(&self) -> Point;
                fn set_middle_point(&mut self, value: Point) -> ();
                fn type_(&self) -> String;
                fn set_type(&mut self, value: String) -> ();
                fn to_string(&self) -> std::result::Result<String, JsValue>;
                fn delta(&self) -> Point;
                fn set_delta(&mut self, value: Point) -> ();
                fn item(&self) -> Item;
                fn set_item(&mut self, value: Item) -> ();
                fn down_point(&self) -> Point;
                fn set_down_point(&mut self, value: Point) -> ();
                fn last_point(&self) -> Point;
                fn set_last_point(&mut self, value: Point) -> ();
                fn count(&self) -> f64;
                fn set_count(&mut self, value: f64) -> ();
                fn point(&self) -> Point;
                fn set_point(&mut self, value: Point) -> ();
            }
            impl Event_Trait for ToolEvent {
                fn prevent_default(&self) -> std::result::Result<(), JsValue> {
                    let target: Event = self.into();
                    Event::prevent_default(&target)
                }
                fn time_stamp(&self) -> f64 {
                    let target: Event = self.into();
                    Event::time_stamp(&target)
                }
                fn set_time_stamp(&mut self, value: f64) -> () {
                    let mut target: Event = self.into();
                    Event::set_time_stamp(&mut target, value)
                }
                fn stop(&self) -> std::result::Result<(), JsValue> {
                    let target: Event = self.into();
                    Event::stop(&target)
                }
                fn modifiers(&self) -> JsValue {
                    let target: Event = self.into();
                    Event::modifiers(&target)
                }
                fn set_modifiers(&mut self, value: JsValue) -> () {
                    let mut target: Event = self.into();
                    Event::set_modifiers(&mut target, value)
                }
                fn stop_propagation(&self) -> std::result::Result<(), JsValue> {
                    let target: Event = self.into();
                    Event::stop_propagation(&target)
                }
            }
            impl ToolEvent_Trait for ToolEvent {}
            impl std::clone::Clone for ToolEvent_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for ToolEvent_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for ToolEvent_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
            extern "C" {
                # [wasm_bindgen (js_name = "Rectangle" , extends = Path_Class)]
                type Rectangle_Class;
                #[wasm_bindgen(constructor, js_class = "Rectangle")]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Rectangle_Class;
            }
            #[derive(std :: clone :: Clone)]
            struct Rectangle(pub Rectangle_Class);
            impl std::convert::From<&Rectangle> for Path {
                fn from(src: &Rectangle) -> Path {
                    let src: &Path_Class = src.0.as_ref();
                    Path(src.clone())
                }
            }
            impl std::convert::From<&mut Rectangle> for Path {
                fn from(src: &mut Rectangle) -> Path {
                    let src: &Path_Class = src.0.as_ref();
                    Path(src.clone())
                }
            }
            impl Rectangle {
                #[allow(dead_code)]
                pub fn new(object: std::collections::HashMap<String, JsValue>) -> Rectangle {
                    let result = Rectangle_Class::new(object);
                    let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                    Rectangle(result)
                }
            }
            impl wasm_bindgen::describe::WasmDescribe for Rectangle {
                fn describe() {
                    <Rectangle_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                }
            }
            impl wasm_bindgen::convert::IntoWasmAbi for Rectangle {
                type Abi = <Rectangle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                }
            }
            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Rectangle {
                type Abi = <&'a Rectangle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                fn into_abi(self) -> Self::Abi {
                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                }
            }
            impl serde::ser::Serialize for Rectangle {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde::ser::Serialize::serialize(&self.0, serializer)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Rectangle {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    let internal: Rectangle_Class =
                        <Rectangle_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                    std::result::Result::Ok(Self(internal))
                }
            }
            #[allow(non_camel_case_types)]
            trait Rectangle_Trait: Path_Trait {
                fn new(object: std::collections::HashMap<String, JsValue>) -> Rectangle;
            }
            impl Path_Trait for Rectangle {}
            impl Rectangle_Trait for Rectangle {}
            impl std::clone::Clone for Rectangle_Class {
                fn clone(&self) -> Self {
                    Self {
                        obj: std::clone::Clone::clone(&self.obj),
                    }
                }
            }
            impl serde::ser::Serialize for Rectangle_Class {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                }
            }
            impl<'de> serde::de::Deserialize<'de> for Rectangle_Class {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::de::Deserializer<'de>,
                {
                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                }
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum ProjectImportSvgParamsSvgParam {
                StringCase(String),
                JsValueCase(JsValue),
            }
            #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
            #[serde(untagged)]
            pub enum PathAddParamsSegmentParam {
                PointCase(Point),
                SegmentCase(Segment),
                VecOfF64Case(Vec<f64>),
            }
            #[cfg(target_family = "wasm")]
            pub mod paper {
                #[cfg(target_family = "wasm")]
                pub mod dist {
                    #[cfg(target_family = "wasm")]
                    pub mod paper {
                        #[cfg(target_family = "wasm")]
                        pub mod paper {
                            #[allow(unused)]
                            use wasm_bindgen::prelude::*;
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                # [wasm_bindgen (js_name = "Raster" , extends = Item_Class)]
                                type Raster_Class;
                                # [wasm_bindgen (method , structural , getter = resolution , js_class = "Raster")]
                                fn resolution(this: &Raster_Class) -> Size;
                                # [wasm_bindgen (method , structural , setter = resolution , js_class = "Raster")]
                                fn set_resolution(this: &Raster_Class, value: Size);
                                # [wasm_bindgen (method , structural , getter = smoothing , js_class = "Raster")]
                                fn smoothing(this: &Raster_Class) -> String;
                                # [wasm_bindgen (method , structural , setter = smoothing , js_class = "Raster")]
                                fn set_smoothing(this: &Raster_Class, value: String);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getSubRaster , method , js_class = "Raster" , catch)]
                                fn __TSB_get_sub_raster(
                                    this: &Raster_Class,
                                    rect: Rectangle,
                                ) -> std::result::Result<Raster, JsValue>;
                                # [wasm_bindgen (method , structural , getter = size , js_class = "Raster")]
                                fn size(this: &Raster_Class) -> Size;
                                # [wasm_bindgen (method , structural , setter = size , js_class = "Raster")]
                                fn set_size(this: &Raster_Class, value: Size);
                                # [wasm_bindgen (method , structural , getter = width , js_class = "Raster")]
                                fn width(this: &Raster_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = width , js_class = "Raster")]
                                fn set_width(this: &Raster_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getSubCanvas , method , js_class = "Raster" , catch)]
                                fn __TSB_get_sub_canvas(
                                    this: &Raster_Class,
                                    rect: Rectangle,
                                ) -> std::result::Result<JsValue, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = drawImage , method , js_class = "Raster" , catch)]
                                fn __TSB_draw_image(
                                    this: &Raster_Class,
                                    image: JsValue,
                                    point: Point,
                                ) -> std::result::Result<(), JsValue>;
                                # [wasm_bindgen (method , structural , getter = source , js_class = "Raster")]
                                fn source(this: &Raster_Class) -> RasterSource;
                                # [wasm_bindgen (method , structural , setter = source , js_class = "Raster")]
                                fn set_source(this: &Raster_Class, value: RasterSource);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getAverageColor , method , js_class = "Raster" , catch)]
                                fn __TSB_get_average_color(
                                    this: &Raster_Class,
                                    object: JsValue,
                                ) -> std::result::Result<Color, JsValue>;
                                # [wasm_bindgen (method , structural , getter = onError , js_class = "Raster")]
                                fn on_error(this: &Raster_Class) -> RasterOnError;
                                # [wasm_bindgen (method , structural , setter = onError , js_class = "Raster")]
                                fn set_on_error(this: &Raster_Class, value: RasterOnError);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = setImageData , method , js_class = "Raster" , catch)]
                                fn __TSB_set_image_data(
                                    this: &Raster_Class,
                                    data: JsValue,
                                    point: Point,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getPixel , method , js_class = "Raster" , catch)]
                                fn __TSB_get_pixel(
                                    this: &Raster_Class,
                                    point: Point,
                                ) -> std::result::Result<Color, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getImageData , method , js_class = "Raster" , catch)]
                                fn __TSB_get_image_data(
                                    this: &Raster_Class,
                                    rect: Rectangle,
                                ) -> std::result::Result<JsValue, JsValue>;
                                #[wasm_bindgen(constructor, js_class = "Raster")]
                                pub fn new(
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> Raster_Class;
                                # [wasm_bindgen (method , structural , getter = image , js_class = "Raster")]
                                fn image(this: &Raster_Class) -> RasterImage;
                                # [wasm_bindgen (method , structural , setter = image , js_class = "Raster")]
                                fn set_image(this: &Raster_Class, value: RasterImage);
                                # [wasm_bindgen (method , structural , getter = context , js_class = "Raster")]
                                fn context(this: &Raster_Class) -> JsValue;
                                # [wasm_bindgen (method , structural , setter = context , js_class = "Raster")]
                                fn set_context(this: &Raster_Class, value: JsValue);
                                # [wasm_bindgen (method , structural , getter = canvas , js_class = "Raster")]
                                fn canvas(this: &Raster_Class) -> JsValue;
                                # [wasm_bindgen (method , structural , setter = canvas , js_class = "Raster")]
                                fn set_canvas(this: &Raster_Class, value: JsValue);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = setPixel , method , js_class = "Raster" , catch)]
                                fn __TSB_set_pixel(
                                    this: &Raster_Class,
                                    point: Point,
                                    color: Color,
                                ) -> std::result::Result<(), JsValue>;
                                # [wasm_bindgen (method , structural , getter = loaded , js_class = "Raster")]
                                fn loaded(this: &Raster_Class) -> bool;
                                # [wasm_bindgen (method , structural , setter = loaded , js_class = "Raster")]
                                fn set_loaded(this: &Raster_Class, value: bool);
                                # [wasm_bindgen (method , structural , getter = crossOrigin , js_class = "Raster")]
                                fn cross_origin(this: &Raster_Class) -> String;
                                # [wasm_bindgen (method , structural , setter = crossOrigin , js_class = "Raster")]
                                fn set_cross_origin(this: &Raster_Class, value: String);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = clear , method , js_class = "Raster" , catch)]
                                fn __TSB_clear(
                                    this: &Raster_Class,
                                ) -> std::result::Result<(), JsValue>;
                                # [wasm_bindgen (method , structural , getter = onLoad , js_class = "Raster")]
                                fn on_load(this: &Raster_Class) -> RasterOnLoad;
                                # [wasm_bindgen (method , structural , setter = onLoad , js_class = "Raster")]
                                fn set_on_load(this: &Raster_Class, value: RasterOnLoad);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = createImageData , method , js_class = "Raster" , catch)]
                                fn __TSB_create_image_data(
                                    this: &Raster_Class,
                                    size: Size,
                                ) -> std::result::Result<JsValue, JsValue>;
                                # [wasm_bindgen (method , structural , getter = height , js_class = "Raster")]
                                fn height(this: &Raster_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = height , js_class = "Raster")]
                                fn set_height(this: &Raster_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = toDataURL , method , js_class = "Raster" , catch)]
                                fn __TSB_to_data_url(
                                    this: &Raster_Class,
                                ) -> std::result::Result<String, JsValue>;
                            }
                            #[derive(std :: clone :: Clone)]
                            struct Raster(pub Raster_Class);
                            impl std::convert::From<&Raster> for Item {
                                fn from(src: &Raster) -> Item {
                                    let src: &Item_Class = src.0.as_ref();
                                    Item(src.clone())
                                }
                            }
                            impl std::convert::From<&mut Raster> for Item {
                                fn from(src: &mut Raster) -> Item {
                                    let src: &Item_Class = src.0.as_ref();
                                    Item(src.clone())
                                }
                            }
                            impl Raster {
                                #[allow(dead_code)]
                                pub fn resolution(&self) -> Size {
                                    let result = self.0.resolution();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_resolution(&self, value: Size) -> () {
                                    let result = self.0.set_resolution(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn smoothing(&self) -> String {
                                    let result = self.0.smoothing();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_smoothing(&self, value: String) -> () {
                                    let result = self.0.set_smoothing(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_sub_raster(
                                    &self,
                                    rect: Rectangle,
                                ) -> std::result::Result<Raster, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_get_sub_raster(rect)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn size(&self) -> Size {
                                    let result = self.0.size();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_size(&self, value: Size) -> () {
                                    let result = self.0.set_size(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn width(&self) -> f64 {
                                    let result = self.0.width();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_width(&self, value: f64) -> () {
                                    let result = self.0.set_width(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_sub_canvas(
                                    &self,
                                    rect: Rectangle,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_get_sub_canvas(rect)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn draw_image(
                                    &self,
                                    image: JsValue,
                                    point: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_draw_image(image, point)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn source(&self) -> RasterSource {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.source()).unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_source(&self, value: RasterSource) -> () {
                                    let result = self.0.set_source(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_average_color(
                                    &self,
                                    object: RasterGetAverageColorParamsObjectParam,
                                ) -> std::result::Result<Color, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_average_color(
                                            ts_bindgen_rt::to_jsvalue(&object)
                                                .map_err(ts_bindgen_rt::Error::from)?,
                                        )?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn on_error(&self) -> RasterOnError {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.on_error()).unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_on_error(&self, value: RasterOnError) -> () {
                                    let result = self.0.set_on_error(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_image_data(
                                    &self,
                                    data: JsValue,
                                    point: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_set_image_data(data, point)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_pixel(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Color, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_get_pixel(point)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_image_data(
                                    &self,
                                    rect: Rectangle,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_get_image_data(rect)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn new(
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> Raster {
                                    let result = Raster_Class::new(object);
                                    let result =
                                        ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result)
                                            .unwrap();
                                    Raster(result)
                                }
                                #[allow(dead_code)]
                                pub fn image(&self) -> RasterImage {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.image()).unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_image(&self, value: RasterImage) -> () {
                                    let result = self.0.set_image(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn context(&self) -> JsValue {
                                    let result = self.0.context();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_context(&self, value: JsValue) -> () {
                                    let result = self.0.set_context(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn canvas(&self) -> JsValue {
                                    let result = self.0.canvas();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_canvas(&self, value: JsValue) -> () {
                                    let result = self.0.set_canvas(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_pixel(
                                    &self,
                                    point: Point,
                                    color: Color,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_set_pixel(point, color)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn loaded(&self) -> bool {
                                    let result = self.0.loaded();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_loaded(&self, value: bool) -> () {
                                    let result = self.0.set_loaded(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn cross_origin(&self) -> String {
                                    let result = self.0.cross_origin();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_cross_origin(&self, value: String) -> () {
                                    let result = self.0.set_cross_origin(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn clear(&self) -> std::result::Result<(), JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_clear()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn on_load(&self) -> RasterOnLoad {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.on_load()).unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_on_load(&self, value: RasterOnLoad) -> () {
                                    let result = self.0.set_on_load(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn create_image_data(
                                    &self,
                                    size: Size,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_create_image_data(size)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn height(&self) -> f64 {
                                    let result = self.0.height();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_height(&self, value: f64) -> () {
                                    let result = self.0.set_height(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn to_data_url(&self) -> std::result::Result<String, JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_to_data_url()?);
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for Raster {
                                fn describe() {
                                    <Raster_Class as wasm_bindgen::describe::WasmDescribe>::describe(
                                    )
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for Raster {
                                type Abi =
                                    <Raster_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Raster {
                                type Abi =
                                    <&'a Raster_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for Raster {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Raster {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal: Raster_Class =
                                        <Raster_Class as serde::de::Deserialize>::deserialize(
                                            deserializer,
                                        )?;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait Raster_Trait: Item_Trait {
                                fn resolution(&self) -> Size;
                                fn set_resolution(&mut self, value: Size) -> ();
                                fn smoothing(&self) -> String;
                                fn set_smoothing(&mut self, value: String) -> ();
                                fn get_sub_raster(
                                    &self,
                                    rect: Rectangle,
                                ) -> std::result::Result<Raster, JsValue>;
                                fn size(&self) -> Size;
                                fn set_size(&mut self, value: Size) -> ();
                                fn width(&self) -> f64;
                                fn set_width(&mut self, value: f64) -> ();
                                fn get_sub_canvas(
                                    &self,
                                    rect: Rectangle,
                                ) -> std::result::Result<JsValue, JsValue>;
                                fn draw_image(
                                    &self,
                                    image: JsValue,
                                    point: Point,
                                ) -> std::result::Result<(), JsValue>;
                                fn source(&self) -> RasterSource;
                                fn set_source(&mut self, value: RasterSource) -> ();
                                fn get_average_color(
                                    &self,
                                    object: RasterGetAverageColorParamsObjectParam,
                                ) -> std::result::Result<Color, JsValue>;
                                fn on_error(&self) -> RasterOnError;
                                fn set_on_error(&mut self, value: RasterOnError) -> ();
                                fn set_image_data(
                                    &self,
                                    data: JsValue,
                                    point: Point,
                                ) -> std::result::Result<(), JsValue>;
                                fn get_pixel(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Color, JsValue>;
                                fn get_image_data(
                                    &self,
                                    rect: Rectangle,
                                ) -> std::result::Result<JsValue, JsValue>;
                                fn new(
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> Raster;
                                fn image(&self) -> RasterImage;
                                fn set_image(&mut self, value: RasterImage) -> ();
                                fn context(&self) -> JsValue;
                                fn set_context(&mut self, value: JsValue) -> ();
                                fn canvas(&self) -> JsValue;
                                fn set_canvas(&mut self, value: JsValue) -> ();
                                fn set_pixel(
                                    &self,
                                    point: Point,
                                    color: Color,
                                ) -> std::result::Result<(), JsValue>;
                                fn loaded(&self) -> bool;
                                fn set_loaded(&mut self, value: bool) -> ();
                                fn cross_origin(&self) -> String;
                                fn set_cross_origin(&mut self, value: String) -> ();
                                fn clear(&self) -> std::result::Result<(), JsValue>;
                                fn on_load(&self) -> RasterOnLoad;
                                fn set_on_load(&mut self, value: RasterOnLoad) -> ();
                                fn create_image_data(
                                    &self,
                                    size: Size,
                                ) -> std::result::Result<JsValue, JsValue>;
                                fn height(&self) -> f64;
                                fn set_height(&mut self, value: f64) -> ();
                                fn to_data_url(&self) -> std::result::Result<String, JsValue>;
                            }
                            impl Item_Trait for Raster {
                                fn insert_below(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_below(&target, item)
                                }
                                fn on_double_click(&self) -> ItemOnDoubleClick {
                                    let target: Item = self.into();
                                    Item::on_double_click(&target)
                                }
                                fn set_on_double_click(&mut self, value: ItemOnDoubleClick) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_double_click(&mut target, value)
                                }
                                fn view(&self) -> View {
                                    let target: Item = self.into();
                                    Item::view(&target)
                                }
                                fn set_view(&mut self, value: View) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_view(&mut target, value)
                                }
                                fn blend_mode(&self) -> String {
                                    let target: Item = self.into();
                                    Item::blend_mode(&target)
                                }
                                fn set_blend_mode(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_blend_mode(&mut target, value)
                                }
                                fn name(&self) -> String {
                                    let target: Item = self.into();
                                    Item::name(&target)
                                }
                                fn set_name(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_name(&mut target, value)
                                }
                                fn project(&self) -> Project {
                                    let target: Item = self.into();
                                    Item::project(&target)
                                }
                                fn set_project(&mut self, value: Project) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_project(&mut target, value)
                                }
                                fn is_child(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_child(&target, item)
                                }
                                fn global_matrix(&self) -> Matrix {
                                    let target: Item = self.into();
                                    Item::global_matrix(&target)
                                }
                                fn set_global_matrix(&mut self, value: Matrix) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_global_matrix(&mut target, value)
                                }
                                fn on_mouse_leave(&self) -> ItemOnMouseLeave {
                                    let target: Item = self.into();
                                    Item::on_mouse_leave(&target)
                                }
                                fn set_on_mouse_leave(&mut self, value: ItemOnMouseLeave) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_leave(&mut target, value)
                                }
                                fn has_children(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_children(&target)
                                }
                                fn selected(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::selected(&target)
                                }
                                fn set_selected(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_selected(&mut target, value)
                                }
                                fn global_to_local(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::global_to_local(&target, point)
                                }
                                fn shadow_blur(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::shadow_blur(&target)
                                }
                                fn set_shadow_blur(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_shadow_blur(&mut target, value)
                                }
                                fn children(&self) -> Vec<Item> {
                                    let target: Item = self.into();
                                    Item::children(&target)
                                }
                                fn set_children(&mut self, value: Vec<Item>) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_children(&mut target, value)
                                }
                                fn replace_with(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::replace_with(&target, item)
                                }
                                fn import_json(
                                    &self,
                                    json: String,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::import_json(&target, json)
                                }
                                fn insert_child(
                                    &self,
                                    index: f64,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_child(&target, index, item)
                                }
                                fn stroke_join(&self) -> String {
                                    let target: Item = self.into();
                                    Item::stroke_join(&target)
                                }
                                fn set_stroke_join(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_join(&mut target, value)
                                }
                                fn rotation(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::rotation(&target)
                                }
                                fn set_rotation(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_rotation(&mut target, value)
                                }
                                fn scaling(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::scaling(&target)
                                }
                                fn set_scaling(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_scaling(&mut target, value)
                                }
                                fn is_ancestor(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_ancestor(&target, item)
                                }
                                fn emit(
                                    &self,
                                    type_: String,
                                    event: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::emit(&target, type_, event)
                                }
                                fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_up(&target)
                                }
                                fn add_to(
                                    &self,
                                    owner: ItemAddToParamsOwnerParam,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::add_to(&target, owner)
                                }
                                fn stroke_cap(&self) -> String {
                                    let target: Item = self.into();
                                    Item::stroke_cap(&target)
                                }
                                fn set_stroke_cap(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_cap(&mut target, value)
                                }
                                fn on_mouse_drag(&self) -> ItemOnMouseDrag {
                                    let target: Item = self.into();
                                    Item::on_mouse_drag(&target)
                                }
                                fn set_on_mouse_drag(&mut self, value: ItemOnMouseDrag) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_drag(&mut target, value)
                                }
                                fn set(
                                    &self,
                                    props: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::set(&target, props)
                                }
                                fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::reverse_children(&target)
                                }
                                fn matches(
                                    &self,
                                    name: String,
                                    compare: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::matches(&target, name, compare)
                                }
                                fn on_mouse_enter(&self) -> ItemOnMouseEnter {
                                    let target: Item = self.into();
                                    Item::on_mouse_enter(&target)
                                }
                                fn set_on_mouse_enter(&mut self, value: ItemOnMouseEnter) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_enter(&mut target, value)
                                }
                                fn shadow_offset(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::shadow_offset(&target)
                                }
                                fn set_shadow_offset(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_shadow_offset(&mut target, value)
                                }
                                fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_stroke(&target)
                                }
                                fn view_matrix(&self) -> Matrix {
                                    let target: Item = self.into();
                                    Item::view_matrix(&target)
                                }
                                fn set_view_matrix(&mut self, value: Matrix) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_view_matrix(&mut target, value)
                                }
                                fn on_frame(&self) -> ItemOnFrame {
                                    let target: Item = self.into();
                                    Item::on_frame(&target)
                                }
                                fn set_on_frame(&mut self, value: ItemOnFrame) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_frame(&mut target, value)
                                }
                                fn on_mouse_down(&self) -> ItemOnMouseDown {
                                    let target: Item = self.into();
                                    Item::on_mouse_down(&target)
                                }
                                fn set_on_mouse_down(&mut self, value: ItemOnMouseDown) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_down(&mut target, value)
                                }
                                fn is_sibling(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_sibling(&target, item)
                                }
                                fn local_to_global(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::local_to_global(&target, point)
                                }
                                fn first_child(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::first_child(&target)
                                }
                                fn set_first_child(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_first_child(&mut target, value)
                                }
                                fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::send_to_back(&target)
                                }
                                fn clip_mask(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::clip_mask(&target)
                                }
                                fn set_clip_mask(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_clip_mask(&mut target, value)
                                }
                                fn next_sibling(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::next_sibling(&target)
                                }
                                fn set_next_sibling(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_next_sibling(&mut target, value)
                                }
                                fn off(
                                    &self,
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::off(&target, object)
                                }
                                fn rotate(
                                    &self,
                                    angle: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::rotate(&target, angle, center)
                                }
                                fn add_child(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::add_child(&target, item)
                                }
                                fn is_grouped_with(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_grouped_with(&target, item)
                                }
                                fn scale(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::scale(&target, hor, ver, center)
                                }
                                fn hit_test_all(
                                    &self,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Vec<HitResult>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::hit_test_all(&target, point, options)
                                }
                                fn insert_children(
                                    &self,
                                    index: f64,
                                    items: Vec<Item>,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_children(&target, index, items)
                                }
                                fn style(&self) -> Style {
                                    let target: Item = self.into();
                                    Item::style(&target)
                                }
                                fn set_style(&mut self, value: Style) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_style(&mut target, value)
                                }
                                fn position(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::position(&target)
                                }
                                fn set_position(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_position(&mut target, value)
                                }
                                fn transform(
                                    &self,
                                    matrix: Matrix,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::transform(&target, matrix)
                                }
                                fn fill_color(&self) -> ItemFillColor {
                                    let target: Item = self.into();
                                    Item::fill_color(&target)
                                }
                                fn set_fill_color(&mut self, value: ItemFillColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_fill_color(&mut target, value)
                                }
                                fn matrix(&self) -> Matrix {
                                    let target: Item = self.into();
                                    Item::matrix(&target)
                                }
                                fn set_matrix(&mut self, value: Matrix) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_matrix(&mut target, value)
                                }
                                fn id(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::id(&target)
                                }
                                fn set_id(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_id(&mut target, value)
                                }
                                fn tween(
                                    &self,
                                    options: ItemTweenParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::tween(&target, options)
                                }
                                fn reduce(
                                    &self,
                                    options: JsValue,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::reduce(&target, options)
                                }
                                fn internal_bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::internal_bounds(&target)
                                }
                                fn set_internal_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_internal_bounds(&mut target, value)
                                }
                                fn fill_rule(&self) -> String {
                                    let target: Item = self.into();
                                    Item::fill_rule(&target)
                                }
                                fn set_fill_rule(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_fill_rule(&mut target, value)
                                }
                                fn shadow_color(&self) -> ItemShadowColor {
                                    let target: Item = self.into();
                                    Item::shadow_color(&target)
                                }
                                fn set_shadow_color(&mut self, value: ItemShadowColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_shadow_color(&mut target, value)
                                }
                                fn insert_above(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_above(&target, item)
                                }
                                fn responds(
                                    &self,
                                    type_: String,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::responds(&target, type_)
                                }
                                fn handle_bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::handle_bounds(&target)
                                }
                                fn set_handle_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_handle_bounds(&mut target, value)
                                }
                                fn skew(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::skew(&target, hor, ver, center)
                                }
                                fn on_click(&self) -> ItemOnClick {
                                    let target: Item = self.into();
                                    Item::on_click(&target)
                                }
                                fn set_on_click(&mut self, value: ItemOnClick) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_click(&mut target, value)
                                }
                                fn get_items(
                                    &self,
                                    options: ItemGetItemsParamsOptionsParam,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::get_items(&target, options)
                                }
                                fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::is_inserted(&target)
                                }
                                fn get_item(
                                    &self,
                                    options: ItemGetItemParamsOptionsParam,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::get_item(&target, options)
                                }
                                fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_fill(&target)
                                }
                                fn shear(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::shear(&target, hor, ver, center)
                                }
                                fn visible(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::visible(&target)
                                }
                                fn set_visible(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_visible(&mut target, value)
                                }
                                fn previous_sibling(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::previous_sibling(&target)
                                }
                                fn set_previous_sibling(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_previous_sibling(&mut target, value)
                                }
                                fn hit_test(
                                    &self,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<HitResult, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::hit_test(&target, point, options)
                                }
                                fn is_descendant(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_descendant(&target, item)
                                }
                                fn locked(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::locked(&target)
                                }
                                fn set_locked(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_locked(&mut target, value)
                                }
                                fn is_parent(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_parent(&target, item)
                                }
                                fn copy_attributes(
                                    &self,
                                    source: Item,
                                    exclude_matrix: bool,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::copy_attributes(&target, source, exclude_matrix)
                                }
                                fn last_child(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::last_child(&target)
                                }
                                fn set_last_child(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_last_child(&mut target, value)
                                }
                                fn stroke_width(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::stroke_width(&target)
                                }
                                fn set_stroke_width(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_width(&mut target, value)
                                }
                                fn parent(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::parent(&target)
                                }
                                fn set_parent(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_parent(&mut target, value)
                                }
                                fn stroke_bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::stroke_bounds(&target)
                                }
                                fn set_stroke_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_bounds(&mut target, value)
                                }
                                fn translate(
                                    &self,
                                    delta: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::translate(&target, delta)
                                }
                                fn remove(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::remove(&target)
                                }
                                fn parent_to_local(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::parent_to_local(&target, point)
                                }
                                fn bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::bounds(&target)
                                }
                                fn set_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_bounds(&mut target, value)
                                }
                                fn add_children(
                                    &self,
                                    items: Vec<Item>,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::add_children(&target, items)
                                }
                                fn dash_array(&self) -> Vec<f64> {
                                    let target: Item = self.into();
                                    Item::dash_array(&target)
                                }
                                fn set_dash_array(&mut self, value: Vec<f64>) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_dash_array(&mut target, value)
                                }
                                fn on_mouse_up(&self) -> ItemOnMouseUp {
                                    let target: Item = self.into();
                                    Item::on_mouse_up(&target)
                                }
                                fn set_on_mouse_up(&mut self, value: ItemOnMouseUp) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_up(&mut target, value)
                                }
                                fn on(
                                    &self,
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::on(&target, object)
                                }
                                fn remove_on(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::remove_on(&target, options)
                                }
                                fn is_below(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_below(&target, item)
                                }
                                fn apply_matrix(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::apply_matrix(&target)
                                }
                                fn set_apply_matrix(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_apply_matrix(&mut target, value)
                                }
                                fn clone(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::clone(&target, options)
                                }
                                fn contains(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::contains(&target, point)
                                }
                                fn export_json(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<String, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::export_json(&target, options)
                                }
                                fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::bring_to_front(&target)
                                }
                                fn is_above(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_above(&target, item)
                                }
                                fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_drag(&target)
                                }
                                fn data(&self) -> JsValue {
                                    let target: Item = self.into();
                                    Item::data(&target)
                                }
                                fn set_data(&mut self, value: JsValue) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_data(&mut target, value)
                                }
                                fn import_svg(
                                    &self,
                                    svg: ItemImportSvgParamsSvgParam,
                                    on_load: JsValue,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::import_svg(&target, svg, on_load)
                                }
                                fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_shadow(&target)
                                }
                                fn selected_color(&self) -> ItemSelectedColor {
                                    let target: Item = self.into();
                                    Item::selected_color(&target)
                                }
                                fn set_selected_color(&mut self, value: ItemSelectedColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_selected_color(&mut target, value)
                                }
                                fn class_name(&self) -> String {
                                    let target: Item = self.into();
                                    Item::class_name(&target)
                                }
                                fn set_class_name(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_class_name(&mut target, value)
                                }
                                fn export_svg(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<ItemExportSvgReturn, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::export_svg(&target, options)
                                }
                                fn tween_to(
                                    &self,
                                    to: std::collections::HashMap<String, JsValue>,
                                    options: ItemTweenToParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::tween_to(&target, to, options)
                                }
                                fn is_inside(
                                    &self,
                                    rect: Rectangle,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_inside(&target, rect)
                                }
                                fn is_empty(
                                    &self,
                                    recursively: bool,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_empty(&target, recursively)
                                }
                                fn copy_content(
                                    &self,
                                    source: Item,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::copy_content(&target, source)
                                }
                                fn rasterize(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Raster, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::rasterize(&target, options)
                                }
                                fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_move(&target)
                                }
                                fn tween_from(
                                    &self,
                                    from: std::collections::HashMap<String, JsValue>,
                                    options: ItemTweenFromParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::tween_from(&target, from, options)
                                }
                                fn opacity(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::opacity(&target)
                                }
                                fn set_opacity(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_opacity(&mut target, value)
                                }
                                fn dash_offset(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::dash_offset(&target)
                                }
                                fn set_dash_offset(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_dash_offset(&mut target, value)
                                }
                                fn remove_children(
                                    &self,
                                    start: f64,
                                    end: f64,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::remove_children(&target, start, end)
                                }
                                fn on_mouse_move(&self) -> ItemOnMouseMove {
                                    let target: Item = self.into();
                                    Item::on_mouse_move(&target)
                                }
                                fn set_on_mouse_move(&mut self, value: ItemOnMouseMove) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_move(&mut target, value)
                                }
                                fn intersects(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::intersects(&target, item)
                                }
                                fn pivot(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::pivot(&target)
                                }
                                fn set_pivot(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_pivot(&mut target, value)
                                }
                                fn copy_to(
                                    &self,
                                    owner: ItemCopyToParamsOwnerParam,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::copy_to(&target, owner)
                                }
                                fn index(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::index(&target)
                                }
                                fn set_index(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_index(&mut target, value)
                                }
                                fn local_to_parent(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::local_to_parent(&target, point)
                                }
                                fn stroke_color(&self) -> ItemStrokeColor {
                                    let target: Item = self.into();
                                    Item::stroke_color(&target)
                                }
                                fn set_stroke_color(&mut self, value: ItemStrokeColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_color(&mut target, value)
                                }
                                fn layer(&self) -> Layer {
                                    let target: Item = self.into();
                                    Item::layer(&target)
                                }
                                fn set_layer(&mut self, value: Layer) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_layer(&mut target, value)
                                }
                                fn stroke_scaling(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::stroke_scaling(&target)
                                }
                                fn set_stroke_scaling(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_scaling(&mut target, value)
                                }
                                fn fit_bounds(
                                    &self,
                                    rectangle: Rectangle,
                                    fill: bool,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::fit_bounds(&target, rectangle, fill)
                                }
                                fn miter_limit(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::miter_limit(&target)
                                }
                                fn set_miter_limit(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_miter_limit(&mut target, value)
                                }
                                fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_down(&target)
                                }
                            }
                            impl Raster_Trait for Raster {}
                            impl std::clone::Clone for Raster_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for Raster_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Raster_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                #[wasm_bindgen(js_name = "Curve")]
                                type Curve_Class;
                                # [wasm_bindgen (method , structural , getter = path , js_class = "Curve")]
                                fn path(this: &Curve_Class) -> Path;
                                # [wasm_bindgen (method , structural , setter = path , js_class = "Curve")]
                                fn set_path(this: &Curve_Class, value: Path);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = divideAtTime , method , js_class = "Curve" , catch)]
                                fn __TSB_divide_at_time(
                                    this: &Curve_Class,
                                    time: f64,
                                ) -> std::result::Result<Curve, JsValue>;
                                # [wasm_bindgen (method , structural , getter = selected , js_class = "Curve")]
                                fn selected(this: &Curve_Class) -> bool;
                                # [wasm_bindgen (method , structural , setter = selected , js_class = "Curve")]
                                fn set_selected(this: &Curve_Class, value: bool);
                                # [wasm_bindgen (method , structural , getter = area , js_class = "Curve")]
                                fn area(this: &Curve_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = area , js_class = "Curve")]
                                fn set_area(this: &Curve_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getIntersections , method , js_class = "Curve" , catch)]
                                fn __TSB_get_intersections(
                                    this: &Curve_Class,
                                    curve: Curve,
                                ) -> std::result::Result<Vec<CurveLocation>, JsValue>;
                                # [wasm_bindgen (method , structural , getter = next , js_class = "Curve")]
                                fn next(this: &Curve_Class) -> Curve;
                                # [wasm_bindgen (method , structural , setter = next , js_class = "Curve")]
                                fn set_next(this: &Curve_Class, value: Curve);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getWeightedTangentAtTime , method , js_class = "Curve" , catch)]
                                fn __TSB_get_weighted_tangent_at_time(
                                    this: &Curve_Class,
                                    time: f64,
                                ) -> std::result::Result<Point, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = splitAtTime , method , js_class = "Curve" , catch)]
                                fn __TSB_split_at_time(
                                    this: &Curve_Class,
                                    time: f64,
                                ) -> std::result::Result<Path, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isStraight , method , js_class = "Curve" , catch)]
                                fn __TSB_is_straight(
                                    this: &Curve_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getNearestLocation , method , js_class = "Curve" , catch)]
                                fn __TSB_get_nearest_location(
                                    this: &Curve_Class,
                                    point: Point,
                                ) -> std::result::Result<CurveLocation, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getTimeOf , method , js_class = "Curve" , catch)]
                                fn __TSB_get_time_of(
                                    this: &Curve_Class,
                                    point: Point,
                                ) -> std::result::Result<f64, JsValue>;
                                # [wasm_bindgen (method , structural , getter = bounds , js_class = "Curve")]
                                fn bounds(this: &Curve_Class) -> Rectangle;
                                # [wasm_bindgen (method , structural , setter = bounds , js_class = "Curve")]
                                fn set_bounds(this: &Curve_Class, value: Rectangle);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getTimeAt , method , js_class = "Curve" , catch)]
                                fn __TSB_get_time_at(
                                    this: &Curve_Class,
                                    offset: f64,
                                    start: f64,
                                ) -> std::result::Result<f64, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getWeightedNormalAt , method , js_class = "Curve" , catch)]
                                fn __TSB_get_weighted_normal_at(
                                    this: &Curve_Class,
                                    location: JsValue,
                                ) -> std::result::Result<Point, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getNormalAtTime , method , js_class = "Curve" , catch)]
                                fn __TSB_get_normal_at_time(
                                    this: &Curve_Class,
                                    time: f64,
                                ) -> std::result::Result<Point, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = hasLength , method , js_class = "Curve" , catch)]
                                fn __TSB_has_length(
                                    this: &Curve_Class,
                                    epsilon: f64,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getTimesWithTangent , method , js_class = "Curve" , catch)]
                                fn __TSB_get_times_with_tangent(
                                    this: &Curve_Class,
                                    tangent: Point,
                                ) -> std::result::Result<Vec<f64>, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getPointAtTime , method , js_class = "Curve" , catch)]
                                fn __TSB_get_point_at_time(
                                    this: &Curve_Class,
                                    time: f64,
                                ) -> std::result::Result<Point, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = splitAt , method , js_class = "Curve" , catch)]
                                fn __TSB_split_at(
                                    this: &Curve_Class,
                                    location: JsValue,
                                ) -> std::result::Result<Path, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getLocationAtTime , method , js_class = "Curve" , catch)]
                                fn __TSB_get_location_at_time(
                                    this: &Curve_Class,
                                    time: f64,
                                ) -> std::result::Result<CurveLocation, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getNormalAt , method , js_class = "Curve" , catch)]
                                fn __TSB_get_normal_at(
                                    this: &Curve_Class,
                                    location: JsValue,
                                ) -> std::result::Result<Point, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isLinear , method , js_class = "Curve" , catch)]
                                fn __TSB_is_linear(
                                    this: &Curve_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                # [wasm_bindgen (method , structural , getter = point2 , js_class = "Curve")]
                                fn point2(this: &Curve_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = point2 , js_class = "Curve")]
                                fn set_point2(this: &Curve_Class, value: Point);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = reversed , method , js_class = "Curve" , catch)]
                                fn __TSB_reversed(
                                    this: &Curve_Class,
                                ) -> std::result::Result<Curve, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getOffsetOf , method , js_class = "Curve" , catch)]
                                fn __TSB_get_offset_of(
                                    this: &Curve_Class,
                                    point: Point,
                                ) -> std::result::Result<f64, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getOffsetAtTime , method , js_class = "Curve" , catch)]
                                fn __TSB_get_offset_at_time(
                                    this: &Curve_Class,
                                    time: f64,
                                ) -> std::result::Result<f64, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getLocationOf , method , js_class = "Curve" , catch)]
                                fn __TSB_get_location_of(
                                    this: &Curve_Class,
                                    point: Point,
                                ) -> std::result::Result<CurveLocation, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getNearestPoint , method , js_class = "Curve" , catch)]
                                fn __TSB_get_nearest_point(
                                    this: &Curve_Class,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                # [wasm_bindgen (method , structural , getter = strokeBounds , js_class = "Curve")]
                                fn stroke_bounds(this: &Curve_Class) -> Rectangle;
                                # [wasm_bindgen (method , structural , setter = strokeBounds , js_class = "Curve")]
                                fn set_stroke_bounds(this: &Curve_Class, value: Rectangle);
                                # [wasm_bindgen (method , structural , getter = handle1 , js_class = "Curve")]
                                fn handle1(this: &Curve_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = handle1 , js_class = "Curve")]
                                fn set_handle1(this: &Curve_Class, value: Point);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getPart , method , js_class = "Curve" , catch)]
                                fn __TSB_get_part(
                                    this: &Curve_Class,
                                    from: f64,
                                    to: f64,
                                ) -> std::result::Result<Curve, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isFirst , method , js_class = "Curve" , catch)]
                                fn __TSB_is_first(
                                    this: &Curve_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                # [wasm_bindgen (method , structural , getter = index , js_class = "Curve")]
                                fn index(this: &Curve_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = index , js_class = "Curve")]
                                fn set_index(this: &Curve_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = previous , js_class = "Curve")]
                                fn previous(this: &Curve_Class) -> Curve;
                                # [wasm_bindgen (method , structural , setter = previous , js_class = "Curve")]
                                fn set_previous(this: &Curve_Class, value: Curve);
                                # [wasm_bindgen (method , structural , getter = segment2 , js_class = "Curve")]
                                fn segment2(this: &Curve_Class) -> Segment;
                                # [wasm_bindgen (method , structural , setter = segment2 , js_class = "Curve")]
                                fn set_segment2(this: &Curve_Class, value: Segment);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = hasHandles , method , js_class = "Curve" , catch)]
                                fn __TSB_has_handles(
                                    this: &Curve_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                # [wasm_bindgen (method , structural , getter = handleBounds , js_class = "Curve")]
                                fn handle_bounds(this: &Curve_Class) -> Rectangle;
                                # [wasm_bindgen (method , structural , setter = handleBounds , js_class = "Curve")]
                                fn set_handle_bounds(this: &Curve_Class, value: Rectangle);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isCollinear , method , js_class = "Curve" , catch)]
                                fn __TSB_is_collinear(
                                    this: &Curve_Class,
                                    curve: Curve,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getPointAt , method , js_class = "Curve" , catch)]
                                fn __TSB_get_point_at(
                                    this: &Curve_Class,
                                    location: JsValue,
                                ) -> std::result::Result<Point, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getWeightedNormalAtTime , method , js_class = "Curve" , catch)]
                                fn __TSB_get_weighted_normal_at_time(
                                    this: &Curve_Class,
                                    time: f64,
                                ) -> std::result::Result<Point, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = classify , method , js_class = "Curve" , catch)]
                                fn __TSB_classify(
                                    this: &Curve_Class,
                                ) -> std::result::Result<
                                    std::collections::HashMap<String, JsValue>,
                                    JsValue,
                                >;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getCurvatureAtTime , method , js_class = "Curve" , catch)]
                                fn __TSB_get_curvature_at_time(
                                    this: &Curve_Class,
                                    time: f64,
                                ) -> std::result::Result<f64, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isLast , method , js_class = "Curve" , catch)]
                                fn __TSB_is_last(
                                    this: &Curve_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getCurvatureAt , method , js_class = "Curve" , catch)]
                                fn __TSB_get_curvature_at(
                                    this: &Curve_Class,
                                    location: JsValue,
                                ) -> std::result::Result<f64, JsValue>;
                                # [wasm_bindgen (method , structural , getter = segment1 , js_class = "Curve")]
                                fn segment1(this: &Curve_Class) -> Segment;
                                # [wasm_bindgen (method , structural , setter = segment1 , js_class = "Curve")]
                                fn set_segment1(this: &Curve_Class, value: Segment);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isHorizontal , method , js_class = "Curve" , catch)]
                                fn __TSB_is_horizontal(
                                    this: &Curve_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = toString , method , js_class = "Curve" , catch)]
                                fn __TSB_to_string(
                                    this: &Curve_Class,
                                ) -> std::result::Result<String, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = clearHandles , method , js_class = "Curve" , catch)]
                                fn __TSB_clear_handles(
                                    this: &Curve_Class,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getLocationAt , method , js_class = "Curve" , catch)]
                                fn __TSB_get_location_at(
                                    this: &Curve_Class,
                                    offset: f64,
                                ) -> std::result::Result<CurveLocation, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getTangentAtTime , method , js_class = "Curve" , catch)]
                                fn __TSB_get_tangent_at_time(
                                    this: &Curve_Class,
                                    time: f64,
                                ) -> std::result::Result<Point, JsValue>;
                                # [wasm_bindgen (method , structural , getter = length , js_class = "Curve")]
                                fn length(this: &Curve_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = length , js_class = "Curve")]
                                fn set_length(this: &Curve_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = divideAt , method , js_class = "Curve" , catch)]
                                fn __TSB_divide_at(
                                    this: &Curve_Class,
                                    location: JsValue,
                                ) -> std::result::Result<Curve, JsValue>;
                                # [wasm_bindgen (method , structural , getter = handle2 , js_class = "Curve")]
                                fn handle2(this: &Curve_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = handle2 , js_class = "Curve")]
                                fn set_handle2(this: &Curve_Class, value: Point);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = clone , method , js_class = "Curve" , catch)]
                                fn __TSB_clone(
                                    this: &Curve_Class,
                                ) -> std::result::Result<Curve, JsValue>;
                                # [wasm_bindgen (method , structural , getter = values , js_class = "Curve")]
                                fn values(this: &Curve_Class) -> Vec<f64>;
                                # [wasm_bindgen (method , structural , setter = values , js_class = "Curve")]
                                fn set_values(this: &Curve_Class, value: Vec<f64>);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getWeightedTangentAt , method , js_class = "Curve" , catch)]
                                fn __TSB_get_weighted_tangent_at(
                                    this: &Curve_Class,
                                    location: JsValue,
                                ) -> std::result::Result<Point, JsValue>;
                                #[wasm_bindgen(constructor, js_class = "Curve")]
                                pub fn new(
                                    point1: Point,
                                    handle1: Point,
                                    handle2: Point,
                                    point2: Point,
                                ) -> Curve_Class;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = remove , method , js_class = "Curve" , catch)]
                                fn __TSB_remove(
                                    this: &Curve_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isVertical , method , js_class = "Curve" , catch)]
                                fn __TSB_is_vertical(
                                    this: &Curve_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                # [wasm_bindgen (method , structural , getter = point1 , js_class = "Curve")]
                                fn point1(this: &Curve_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = point1 , js_class = "Curve")]
                                fn set_point1(this: &Curve_Class, value: Point);
                                # [wasm_bindgen (method , structural , getter = points , js_class = "Curve")]
                                fn points(this: &Curve_Class) -> Vec<Point>;
                                # [wasm_bindgen (method , structural , setter = points , js_class = "Curve")]
                                fn set_points(this: &Curve_Class, value: Vec<Point>);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getTangentAt , method , js_class = "Curve" , catch)]
                                fn __TSB_get_tangent_at(
                                    this: &Curve_Class,
                                    location: JsValue,
                                ) -> std::result::Result<Point, JsValue>;
                            }
                            #[derive(std :: clone :: Clone)]
                            struct Curve(pub Curve_Class);
                            impl Curve {
                                #[allow(dead_code)]
                                pub fn path(&self) -> Path {
                                    let result = self.0.path();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_path(&self, value: Path) -> () {
                                    let result = self.0.set_path(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn divide_at_time(
                                    &self,
                                    time: f64,
                                ) -> std::result::Result<Curve, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_divide_at_time(time)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn selected(&self) -> bool {
                                    let result = self.0.selected();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_selected(&self, value: bool) -> () {
                                    let result = self.0.set_selected(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn area(&self) -> f64 {
                                    let result = self.0.area();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_area(&self, value: f64) -> () {
                                    let result = self.0.set_area(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_intersections(
                                    &self,
                                    curve: Curve,
                                ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_intersections(curve)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn next(&self) -> Curve {
                                    let result = self.0.next();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_next(&self, value: Curve) -> () {
                                    let result = self.0.set_next(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_weighted_tangent_at_time(
                                    &self,
                                    time: f64,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_weighted_tangent_at_time(time)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn split_at_time(
                                    &self,
                                    time: f64,
                                ) -> std::result::Result<Path, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_split_at_time(time)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_straight(&self) -> std::result::Result<bool, JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_is_straight()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_nearest_location(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<CurveLocation, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_nearest_location(point)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_time_of(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<f64, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_get_time_of(point)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn bounds(&self) -> Rectangle {
                                    let result = self.0.bounds();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_bounds(&self, value: Rectangle) -> () {
                                    let result = self.0.set_bounds(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_time_at(
                                    &self,
                                    offset: f64,
                                    start: f64,
                                ) -> std::result::Result<f64, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_time_at(offset, start)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_weighted_normal_at(
                                    &self,
                                    location: CurveGetWeightedNormalAtParamsLocationParam,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_weighted_normal_at(
                                            ts_bindgen_rt::to_jsvalue(&location)
                                                .map_err(ts_bindgen_rt::Error::from)?,
                                        )?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_normal_at_time(
                                    &self,
                                    time: f64,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_normal_at_time(time)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn has_length(
                                    &self,
                                    epsilon: f64,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_has_length(epsilon)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_times_with_tangent(
                                    &self,
                                    tangent: Point,
                                ) -> std::result::Result<Vec<f64>, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_times_with_tangent(tangent)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_point_at_time(
                                    &self,
                                    time: f64,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_point_at_time(time)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn split_at(
                                    &self,
                                    location: CurveSplitAtParamsLocationParam,
                                ) -> std::result::Result<Path, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_split_at(
                                            ts_bindgen_rt::to_jsvalue(&location)
                                                .map_err(ts_bindgen_rt::Error::from)?,
                                        )?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_location_at_time(
                                    &self,
                                    time: f64,
                                ) -> std::result::Result<CurveLocation, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_location_at_time(time)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_normal_at(
                                    &self,
                                    location: CurveGetNormalAtParamsLocationParam,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_normal_at(
                                            ts_bindgen_rt::to_jsvalue(&location)
                                                .map_err(ts_bindgen_rt::Error::from)?,
                                        )?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_linear(&self) -> std::result::Result<bool, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_is_linear()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn point2(&self) -> Point {
                                    let result = self.0.point2();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_point2(&self, value: Point) -> () {
                                    let result = self.0.set_point2(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn reversed(&self) -> std::result::Result<Curve, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_reversed()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_offset_of(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<f64, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_get_offset_of(point)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_offset_at_time(
                                    &self,
                                    time: f64,
                                ) -> std::result::Result<f64, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_offset_at_time(time)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_location_of(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<CurveLocation, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_location_of(point)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_nearest_point(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_nearest_point(point)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn stroke_bounds(&self) -> Rectangle {
                                    let result = self.0.stroke_bounds();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_stroke_bounds(&self, value: Rectangle) -> () {
                                    let result = self.0.set_stroke_bounds(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn handle1(&self) -> Point {
                                    let result = self.0.handle1();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_handle1(&self, value: Point) -> () {
                                    let result = self.0.set_handle1(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_part(
                                    &self,
                                    from: f64,
                                    to: f64,
                                ) -> std::result::Result<Curve, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_get_part(from, to)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_first(&self) -> std::result::Result<bool, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_is_first()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn index(&self) -> f64 {
                                    let result = self.0.index();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_index(&self, value: f64) -> () {
                                    let result = self.0.set_index(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn previous(&self) -> Curve {
                                    let result = self.0.previous();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_previous(&self, value: Curve) -> () {
                                    let result = self.0.set_previous(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn segment2(&self) -> Segment {
                                    let result = self.0.segment2();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_segment2(&self, value: Segment) -> () {
                                    let result = self.0.set_segment2(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_has_handles()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn handle_bounds(&self) -> Rectangle {
                                    let result = self.0.handle_bounds();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_handle_bounds(&self, value: Rectangle) -> () {
                                    let result = self.0.set_handle_bounds(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_collinear(
                                    &self,
                                    curve: Curve,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_is_collinear(curve)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_point_at(
                                    &self,
                                    location: CurveGetPointAtParamsLocationParam,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_point_at(
                                            ts_bindgen_rt::to_jsvalue(&location)
                                                .map_err(ts_bindgen_rt::Error::from)?,
                                        )?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_weighted_normal_at_time(
                                    &self,
                                    time: f64,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_weighted_normal_at_time(time)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn classify(
                                    &self,
                                ) -> std::result::Result<
                                    std::collections::HashMap<String, JsValue>,
                                    JsValue,
                                > {
                                    let result = std::result::Result::Ok(self.0.__TSB_classify()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_curvature_at_time(
                                    &self,
                                    time: f64,
                                ) -> std::result::Result<f64, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_curvature_at_time(time)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_last(&self) -> std::result::Result<bool, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_is_last()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_curvature_at(
                                    &self,
                                    location: CurveGetCurvatureAtParamsLocationParam,
                                ) -> std::result::Result<f64, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_curvature_at(
                                            ts_bindgen_rt::to_jsvalue(&location)
                                                .map_err(ts_bindgen_rt::Error::from)?,
                                        )?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn segment1(&self) -> Segment {
                                    let result = self.0.segment1();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_segment1(&self, value: Segment) -> () {
                                    let result = self.0.set_segment1(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_horizontal(&self) -> std::result::Result<bool, JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_is_horizontal()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_to_string()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_clear_handles()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_location_at(
                                    &self,
                                    offset: f64,
                                ) -> std::result::Result<CurveLocation, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_location_at(offset)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_tangent_at_time(
                                    &self,
                                    time: f64,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_tangent_at_time(time)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn length(&self) -> f64 {
                                    let result = self.0.length();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_length(&self, value: f64) -> () {
                                    let result = self.0.set_length(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn divide_at(
                                    &self,
                                    location: CurveDivideAtParamsLocationParam,
                                ) -> std::result::Result<Curve, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_divide_at(
                                            ts_bindgen_rt::to_jsvalue(&location)
                                                .map_err(ts_bindgen_rt::Error::from)?,
                                        )?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn handle2(&self) -> Point {
                                    let result = self.0.handle2();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_handle2(&self, value: Point) -> () {
                                    let result = self.0.set_handle2(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn clone(&self) -> std::result::Result<Curve, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_clone()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn values(&self) -> Vec<f64> {
                                    let result = self.0.values();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_values(&self, value: Vec<f64>) -> () {
                                    let result = self.0.set_values(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_weighted_tangent_at(
                                    &self,
                                    location: CurveGetWeightedTangentAtParamsLocationParam,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_weighted_tangent_at(
                                            ts_bindgen_rt::to_jsvalue(&location)
                                                .map_err(ts_bindgen_rt::Error::from)?,
                                        )?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn new(
                                    point1: Point,
                                    handle1: Point,
                                    handle2: Point,
                                    point2: Point,
                                ) -> Curve {
                                    let result = Curve_Class::new(point1, handle1, handle2, point2);
                                    let result =
                                        ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result)
                                            .unwrap();
                                    Curve(result)
                                }
                                #[allow(dead_code)]
                                pub fn remove(&self) -> std::result::Result<bool, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_remove()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_vertical(&self) -> std::result::Result<bool, JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_is_vertical()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn point1(&self) -> Point {
                                    let result = self.0.point1();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_point1(&self, value: Point) -> () {
                                    let result = self.0.set_point1(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn points(&self) -> Vec<Point> {
                                    let result = self.0.points();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_points(&self, value: Vec<Point>) -> () {
                                    let result = self.0.set_points(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_tangent_at(
                                    &self,
                                    location: CurveGetTangentAtParamsLocationParam,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_tangent_at(
                                            ts_bindgen_rt::to_jsvalue(&location)
                                                .map_err(ts_bindgen_rt::Error::from)?,
                                        )?,
                                    );
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for Curve {
                                fn describe() {
                                    <Curve_Class as wasm_bindgen::describe::WasmDescribe>::describe(
                                    )
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for Curve {
                                type Abi = <Curve_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Curve {
                                type Abi =
                                    <&'a Curve_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for Curve {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Curve {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal: Curve_Class =
                                        <Curve_Class as serde::de::Deserialize>::deserialize(
                                            deserializer,
                                        )?;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait Curve_Trait {
                                fn path(&self) -> Path;
                                fn set_path(&mut self, value: Path) -> ();
                                fn divide_at_time(
                                    &self,
                                    time: f64,
                                ) -> std::result::Result<Curve, JsValue>;
                                fn selected(&self) -> bool;
                                fn set_selected(&mut self, value: bool) -> ();
                                fn area(&self) -> f64;
                                fn set_area(&mut self, value: f64) -> ();
                                fn get_intersections(
                                    &self,
                                    curve: Curve,
                                ) -> std::result::Result<Vec<CurveLocation>, JsValue>;
                                fn next(&self) -> Curve;
                                fn set_next(&mut self, value: Curve) -> ();
                                fn get_weighted_tangent_at_time(
                                    &self,
                                    time: f64,
                                ) -> std::result::Result<Point, JsValue>;
                                fn split_at_time(
                                    &self,
                                    time: f64,
                                ) -> std::result::Result<Path, JsValue>;
                                fn is_straight(&self) -> std::result::Result<bool, JsValue>;
                                fn get_nearest_location(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<CurveLocation, JsValue>;
                                fn get_time_of(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<f64, JsValue>;
                                fn bounds(&self) -> Rectangle;
                                fn set_bounds(&mut self, value: Rectangle) -> ();
                                fn get_time_at(
                                    &self,
                                    offset: f64,
                                    start: f64,
                                ) -> std::result::Result<f64, JsValue>;
                                fn get_weighted_normal_at(
                                    &self,
                                    location: CurveGetWeightedNormalAtParamsLocationParam,
                                ) -> std::result::Result<Point, JsValue>;
                                fn get_normal_at_time(
                                    &self,
                                    time: f64,
                                ) -> std::result::Result<Point, JsValue>;
                                fn has_length(
                                    &self,
                                    epsilon: f64,
                                ) -> std::result::Result<bool, JsValue>;
                                fn get_times_with_tangent(
                                    &self,
                                    tangent: Point,
                                ) -> std::result::Result<Vec<f64>, JsValue>;
                                fn get_point_at_time(
                                    &self,
                                    time: f64,
                                ) -> std::result::Result<Point, JsValue>;
                                fn split_at(
                                    &self,
                                    location: CurveSplitAtParamsLocationParam,
                                ) -> std::result::Result<Path, JsValue>;
                                fn get_location_at_time(
                                    &self,
                                    time: f64,
                                ) -> std::result::Result<CurveLocation, JsValue>;
                                fn get_normal_at(
                                    &self,
                                    location: CurveGetNormalAtParamsLocationParam,
                                ) -> std::result::Result<Point, JsValue>;
                                fn is_linear(&self) -> std::result::Result<bool, JsValue>;
                                fn point2(&self) -> Point;
                                fn set_point2(&mut self, value: Point) -> ();
                                fn reversed(&self) -> std::result::Result<Curve, JsValue>;
                                fn get_offset_of(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<f64, JsValue>;
                                fn get_offset_at_time(
                                    &self,
                                    time: f64,
                                ) -> std::result::Result<f64, JsValue>;
                                fn get_location_of(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<CurveLocation, JsValue>;
                                fn get_nearest_point(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                fn stroke_bounds(&self) -> Rectangle;
                                fn set_stroke_bounds(&mut self, value: Rectangle) -> ();
                                fn handle1(&self) -> Point;
                                fn set_handle1(&mut self, value: Point) -> ();
                                fn get_part(
                                    &self,
                                    from: f64,
                                    to: f64,
                                ) -> std::result::Result<Curve, JsValue>;
                                fn is_first(&self) -> std::result::Result<bool, JsValue>;
                                fn index(&self) -> f64;
                                fn set_index(&mut self, value: f64) -> ();
                                fn previous(&self) -> Curve;
                                fn set_previous(&mut self, value: Curve) -> ();
                                fn segment2(&self) -> Segment;
                                fn set_segment2(&mut self, value: Segment) -> ();
                                fn has_handles(&self) -> std::result::Result<bool, JsValue>;
                                fn handle_bounds(&self) -> Rectangle;
                                fn set_handle_bounds(&mut self, value: Rectangle) -> ();
                                fn is_collinear(
                                    &self,
                                    curve: Curve,
                                ) -> std::result::Result<bool, JsValue>;
                                fn get_point_at(
                                    &self,
                                    location: CurveGetPointAtParamsLocationParam,
                                ) -> std::result::Result<Point, JsValue>;
                                fn get_weighted_normal_at_time(
                                    &self,
                                    time: f64,
                                ) -> std::result::Result<Point, JsValue>;
                                fn classify(
                                    &self,
                                ) -> std::result::Result<
                                    std::collections::HashMap<String, JsValue>,
                                    JsValue,
                                >;
                                fn get_curvature_at_time(
                                    &self,
                                    time: f64,
                                ) -> std::result::Result<f64, JsValue>;
                                fn is_last(&self) -> std::result::Result<bool, JsValue>;
                                fn get_curvature_at(
                                    &self,
                                    location: CurveGetCurvatureAtParamsLocationParam,
                                ) -> std::result::Result<f64, JsValue>;
                                fn segment1(&self) -> Segment;
                                fn set_segment1(&mut self, value: Segment) -> ();
                                fn is_horizontal(&self) -> std::result::Result<bool, JsValue>;
                                fn to_string(&self) -> std::result::Result<String, JsValue>;
                                fn clear_handles(&self) -> std::result::Result<(), JsValue>;
                                fn get_location_at(
                                    &self,
                                    offset: f64,
                                ) -> std::result::Result<CurveLocation, JsValue>;
                                fn get_tangent_at_time(
                                    &self,
                                    time: f64,
                                ) -> std::result::Result<Point, JsValue>;
                                fn length(&self) -> f64;
                                fn set_length(&mut self, value: f64) -> ();
                                fn divide_at(
                                    &self,
                                    location: CurveDivideAtParamsLocationParam,
                                ) -> std::result::Result<Curve, JsValue>;
                                fn handle2(&self) -> Point;
                                fn set_handle2(&mut self, value: Point) -> ();
                                fn clone(&self) -> std::result::Result<Curve, JsValue>;
                                fn values(&self) -> Vec<f64>;
                                fn set_values(&mut self, value: Vec<f64>) -> ();
                                fn get_weighted_tangent_at(
                                    &self,
                                    location: CurveGetWeightedTangentAtParamsLocationParam,
                                ) -> std::result::Result<Point, JsValue>;
                                fn new(
                                    point1: Point,
                                    handle1: Point,
                                    handle2: Point,
                                    point2: Point,
                                ) -> Curve;
                                fn remove(&self) -> std::result::Result<bool, JsValue>;
                                fn is_vertical(&self) -> std::result::Result<bool, JsValue>;
                                fn point1(&self) -> Point;
                                fn set_point1(&mut self, value: Point) -> ();
                                fn points(&self) -> Vec<Point>;
                                fn set_points(&mut self, value: Vec<Point>) -> ();
                                fn get_tangent_at(
                                    &self,
                                    location: CurveGetTangentAtParamsLocationParam,
                                ) -> std::result::Result<Point, JsValue>;
                            }
                            impl std::clone::Clone for Curve_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for Curve_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Curve_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                #[wasm_bindgen(js_name = "HitResult")]
                                type HitResult_Class;
                                # [wasm_bindgen (method , structural , getter = color , js_class = "HitResult")]
                                fn color(this: &HitResult_Class) -> HitResultColor;
                                # [wasm_bindgen (method , structural , setter = color , js_class = "HitResult")]
                                fn set_color(this: &HitResult_Class, value: HitResultColor);
                                # [wasm_bindgen (method , structural , getter = name , js_class = "HitResult")]
                                fn name(this: &HitResult_Class) -> String;
                                # [wasm_bindgen (method , structural , setter = name , js_class = "HitResult")]
                                fn set_name(this: &HitResult_Class, value: String);
                                # [wasm_bindgen (method , structural , getter = segment , js_class = "HitResult")]
                                fn segment(this: &HitResult_Class) -> Segment;
                                # [wasm_bindgen (method , structural , setter = segment , js_class = "HitResult")]
                                fn set_segment(this: &HitResult_Class, value: Segment);
                                # [wasm_bindgen (method , structural , getter = item , js_class = "HitResult")]
                                fn item(this: &HitResult_Class) -> Item;
                                # [wasm_bindgen (method , structural , setter = item , js_class = "HitResult")]
                                fn set_item(this: &HitResult_Class, value: Item);
                                # [wasm_bindgen (method , structural , getter = location , js_class = "HitResult")]
                                fn location(this: &HitResult_Class) -> CurveLocation;
                                # [wasm_bindgen (method , structural , setter = location , js_class = "HitResult")]
                                fn set_location(this: &HitResult_Class, value: CurveLocation);
                                # [wasm_bindgen (method , structural , getter = type , js_class = "HitResult")]
                                fn type_(this: &HitResult_Class) -> String;
                                # [wasm_bindgen (method , structural , setter = type , js_class = "HitResult")]
                                fn set_type_(this: &HitResult_Class, value: String);
                                # [wasm_bindgen (method , structural , getter = point , js_class = "HitResult")]
                                fn point(this: &HitResult_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = point , js_class = "HitResult")]
                                fn set_point(this: &HitResult_Class, value: Point);
                            }
                            #[derive(std :: clone :: Clone)]
                            struct HitResult(pub HitResult_Class);
                            impl HitResult {
                                #[allow(dead_code)]
                                pub fn color(&self) -> HitResultColor {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.color()).unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_color(&self, value: HitResultColor) -> () {
                                    let result = self.0.set_color(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn name(&self) -> String {
                                    let result = self.0.name();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_name(&self, value: String) -> () {
                                    let result = self.0.set_name(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn segment(&self) -> Segment {
                                    let result = self.0.segment();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_segment(&self, value: Segment) -> () {
                                    let result = self.0.set_segment(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn item(&self) -> Item {
                                    let result = self.0.item();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_item(&self, value: Item) -> () {
                                    let result = self.0.set_item(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn location(&self) -> CurveLocation {
                                    let result = self.0.location();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_location(&self, value: CurveLocation) -> () {
                                    let result = self.0.set_location(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn type_(&self) -> String {
                                    let result = self.0.type_();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_type_(&self, value: String) -> () {
                                    let result = self.0.set_type_(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn point(&self) -> Point {
                                    let result = self.0.point();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_point(&self, value: Point) -> () {
                                    let result = self.0.set_point(value);
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for HitResult {
                                fn describe() {
                                    < HitResult_Class as wasm_bindgen :: describe :: WasmDescribe > :: describe ()
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for HitResult {
                                type Abi =
                                    <HitResult_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a HitResult {
                                type Abi = < & 'a HitResult_Class as wasm_bindgen :: convert :: IntoWasmAbi > :: Abi ;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for HitResult {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for HitResult {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal: HitResult_Class =
                                        <HitResult_Class as serde::de::Deserialize>::deserialize(
                                            deserializer,
                                        )?;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait HitResult_Trait {
                                fn color(&self) -> HitResultColor;
                                fn set_color(&mut self, value: HitResultColor) -> ();
                                fn name(&self) -> String;
                                fn set_name(&mut self, value: String) -> ();
                                fn segment(&self) -> Segment;
                                fn set_segment(&mut self, value: Segment) -> ();
                                fn item(&self) -> Item;
                                fn set_item(&mut self, value: Item) -> ();
                                fn location(&self) -> CurveLocation;
                                fn set_location(&mut self, value: CurveLocation) -> ();
                                fn type_(&self) -> String;
                                fn set_type(&mut self, value: String) -> ();
                                fn point(&self) -> Point;
                                fn set_point(&mut self, value: Point) -> ();
                            }
                            impl std::clone::Clone for HitResult_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for HitResult_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for HitResult_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                #[wasm_bindgen(js_name = "Project")]
                                type Project_Class;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = remove , method , js_class = "Project" , catch)]
                                fn __TSB_remove(
                                    this: &Project_Class,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = exportJSON , method , js_class = "Project" , catch)]
                                fn __TSB_export_json(
                                    this: &Project_Class,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<String, JsValue>;
                                # [wasm_bindgen (method , structural , getter = currentStyle , js_class = "Project")]
                                fn current_style(this: &Project_Class) -> Style;
                                # [wasm_bindgen (method , structural , setter = currentStyle , js_class = "Project")]
                                fn set_current_style(this: &Project_Class, value: Style);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = hitTest , method , js_class = "Project" , catch)]
                                fn __TSB_hit_test(
                                    this: &Project_Class,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<HitResult, JsValue>;
                                # [wasm_bindgen (method , structural , getter = activeLayer , js_class = "Project")]
                                fn active_layer(this: &Project_Class) -> Layer;
                                # [wasm_bindgen (method , structural , setter = activeLayer , js_class = "Project")]
                                fn set_active_layer(this: &Project_Class, value: Layer);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getItems , method , js_class = "Project" , catch)]
                                fn __TSB_get_items(
                                    this: &Project_Class,
                                    options: JsValue,
                                ) -> std::result::Result<Vec<Item>, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = addLayer , method , js_class = "Project" , catch)]
                                fn __TSB_add_layer(
                                    this: &Project_Class,
                                    layer: Layer,
                                ) -> std::result::Result<Layer, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = importJSON , method , js_class = "Project" , catch)]
                                fn __TSB_import_json(
                                    this: &Project_Class,
                                    json: String,
                                ) -> std::result::Result<Item, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = activate , method , js_class = "Project" , catch)]
                                fn __TSB_activate(
                                    this: &Project_Class,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = selectAll , method , js_class = "Project" , catch)]
                                fn __TSB_select_all(
                                    this: &Project_Class,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isEmpty , method , js_class = "Project" , catch)]
                                fn __TSB_is_empty(
                                    this: &Project_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = exportSVG , method , js_class = "Project" , catch)]
                                fn __TSB_export_svg(
                                    this: &Project_Class,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = clear , method , js_class = "Project" , catch)]
                                fn __TSB_clear(
                                    this: &Project_Class,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getItem , method , js_class = "Project" , catch)]
                                fn __TSB_get_item(
                                    this: &Project_Class,
                                    options: JsValue,
                                ) -> std::result::Result<Item, JsValue>;
                                # [wasm_bindgen (method , structural , getter = index , js_class = "Project")]
                                fn index(this: &Project_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = index , js_class = "Project")]
                                fn set_index(this: &Project_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = insertLayer , method , js_class = "Project" , catch)]
                                fn __TSB_insert_layer(
                                    this: &Project_Class,
                                    index: f64,
                                    layer: Layer,
                                ) -> std::result::Result<Layer, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = hitTestAll , method , js_class = "Project" , catch)]
                                fn __TSB_hit_test_all(
                                    this: &Project_Class,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Vec<HitResult>, JsValue>;
                                # [wasm_bindgen (method , structural , getter = view , js_class = "Project")]
                                fn view(this: &Project_Class) -> View;
                                # [wasm_bindgen (method , structural , setter = view , js_class = "Project")]
                                fn set_view(this: &Project_Class, value: View);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = importSVG , method , js_class = "Project" , catch)]
                                fn __TSB_import_svg(
                                    this: &Project_Class,
                                    svg: JsValue,
                                    on_load: JsValue,
                                ) -> std::result::Result<Item, JsValue>;
                                # [wasm_bindgen (method , structural , getter = selectedItems , js_class = "Project")]
                                fn selected_items(this: &Project_Class) -> Vec<Item>;
                                # [wasm_bindgen (method , structural , setter = selectedItems , js_class = "Project")]
                                fn set_selected_items(this: &Project_Class, value: Vec<Item>);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = deselectAll , method , js_class = "Project" , catch)]
                                fn __TSB_deselect_all(
                                    this: &Project_Class,
                                ) -> std::result::Result<(), JsValue>;
                                # [wasm_bindgen (method , structural , getter = symbolDefinitions , js_class = "Project")]
                                fn symbol_definitions(
                                    this: &Project_Class,
                                ) -> Vec<SymbolDefinition>;
                                # [wasm_bindgen (method , structural , setter = symbolDefinitions , js_class = "Project")]
                                fn set_symbol_definitions(
                                    this: &Project_Class,
                                    value: Vec<SymbolDefinition>,
                                );
                                #[wasm_bindgen(constructor, js_class = "Project")]
                                pub fn new(
                                    element: ProjectConstructorElementParam,
                                ) -> Project_Class;
                                # [wasm_bindgen (method , structural , getter = layers , js_class = "Project")]
                                fn layers(this: &Project_Class) -> Vec<Layer>;
                                # [wasm_bindgen (method , structural , setter = layers , js_class = "Project")]
                                fn set_layers(this: &Project_Class, value: Vec<Layer>);
                            }
                            #[derive(std :: clone :: Clone)]
                            struct Project(pub Project_Class);
                            impl Project {
                                #[allow(dead_code)]
                                pub fn remove(&self) -> std::result::Result<(), JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_remove()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn export_json(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<String, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_export_json(options)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn current_style(&self) -> Style {
                                    let result = self.0.current_style();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_current_style(&self, value: Style) -> () {
                                    let result = self.0.set_current_style(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn hit_test(
                                    &self,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<HitResult, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_hit_test(point, options)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn active_layer(&self) -> Layer {
                                    let result = self.0.active_layer();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_active_layer(&self, value: Layer) -> () {
                                    let result = self.0.set_active_layer(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_items(
                                    &self,
                                    options: ProjectGetItemsParamsOptionsParam,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_items(
                                            ts_bindgen_rt::to_jsvalue(&options)
                                                .map_err(ts_bindgen_rt::Error::from)?,
                                        )?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn add_layer(
                                    &self,
                                    layer: Layer,
                                ) -> std::result::Result<Layer, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_add_layer(layer)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn import_json(
                                    &self,
                                    json: String,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_import_json(json)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn activate(&self) -> std::result::Result<(), JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_activate()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn select_all(&self) -> std::result::Result<(), JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_select_all()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_empty(&self) -> std::result::Result<bool, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_is_empty()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn export_svg(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<ProjectExportSvgReturn, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        ts_bindgen_rt::from_jsvalue(
                                            &self.0.__TSB_export_svg(options)?,
                                        )
                                        .unwrap(),
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn clear(&self) -> std::result::Result<(), JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_clear()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_item(
                                    &self,
                                    options: ProjectGetItemParamsOptionsParam,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_item(
                                            ts_bindgen_rt::to_jsvalue(&options)
                                                .map_err(ts_bindgen_rt::Error::from)?,
                                        )?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn index(&self) -> f64 {
                                    let result = self.0.index();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_index(&self, value: f64) -> () {
                                    let result = self.0.set_index(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn insert_layer(
                                    &self,
                                    index: f64,
                                    layer: Layer,
                                ) -> std::result::Result<Layer, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_insert_layer(index, layer)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn hit_test_all(
                                    &self,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Vec<HitResult>, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_hit_test_all(point, options)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn view(&self) -> View {
                                    let result = self.0.view();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_view(&self, value: View) -> () {
                                    let result = self.0.set_view(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn import_svg(
                                    &self,
                                    svg: ProjectImportSvgParamsSvgParam,
                                    on_load: JsValue,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_import_svg(
                                            ts_bindgen_rt::to_jsvalue(&svg)
                                                .map_err(ts_bindgen_rt::Error::from)?,
                                            on_load,
                                        )?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn selected_items(&self) -> Vec<Item> {
                                    let result = self.0.selected_items();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_selected_items(&self, value: Vec<Item>) -> () {
                                    let result = self.0.set_selected_items(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn deselect_all(&self) -> std::result::Result<(), JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_deselect_all()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn symbol_definitions(&self) -> Vec<SymbolDefinition> {
                                    let result = self.0.symbol_definitions();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_symbol_definitions(
                                    &self,
                                    value: Vec<SymbolDefinition>,
                                ) -> () {
                                    let result = self.0.set_symbol_definitions(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn new(element: ProjectConstructorElementParam) -> Project {
                                    let result = Project_Class::new(
                                        ts_bindgen_rt::to_jsvalue(&element)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    let result =
                                        ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result)
                                            .unwrap();
                                    Project(result)
                                }
                                #[allow(dead_code)]
                                pub fn layers(&self) -> Vec<Layer> {
                                    let result = self.0.layers();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_layers(&self, value: Vec<Layer>) -> () {
                                    let result = self.0.set_layers(value);
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for Project {
                                fn describe() {
                                    < Project_Class as wasm_bindgen :: describe :: WasmDescribe > :: describe ()
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for Project {
                                type Abi =
                                    <Project_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Project {
                                type Abi =
                                    <&'a Project_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for Project {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Project {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal: Project_Class =
                                        <Project_Class as serde::de::Deserialize>::deserialize(
                                            deserializer,
                                        )?;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait Project_Trait {
                                fn remove(&self) -> std::result::Result<(), JsValue>;
                                fn export_json(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<String, JsValue>;
                                fn current_style(&self) -> Style;
                                fn set_current_style(&mut self, value: Style) -> ();
                                fn hit_test(
                                    &self,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<HitResult, JsValue>;
                                fn active_layer(&self) -> Layer;
                                fn set_active_layer(&mut self, value: Layer) -> ();
                                fn get_items(
                                    &self,
                                    options: ProjectGetItemsParamsOptionsParam,
                                ) -> std::result::Result<Vec<Item>, JsValue>;
                                fn add_layer(
                                    &self,
                                    layer: Layer,
                                ) -> std::result::Result<Layer, JsValue>;
                                fn import_json(
                                    &self,
                                    json: String,
                                ) -> std::result::Result<Item, JsValue>;
                                fn activate(&self) -> std::result::Result<(), JsValue>;
                                fn select_all(&self) -> std::result::Result<(), JsValue>;
                                fn is_empty(&self) -> std::result::Result<bool, JsValue>;
                                fn export_svg(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<ProjectExportSvgReturn, JsValue>;
                                fn clear(&self) -> std::result::Result<(), JsValue>;
                                fn get_item(
                                    &self,
                                    options: ProjectGetItemParamsOptionsParam,
                                ) -> std::result::Result<Item, JsValue>;
                                fn index(&self) -> f64;
                                fn set_index(&mut self, value: f64) -> ();
                                fn insert_layer(
                                    &self,
                                    index: f64,
                                    layer: Layer,
                                ) -> std::result::Result<Layer, JsValue>;
                                fn hit_test_all(
                                    &self,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Vec<HitResult>, JsValue>;
                                fn view(&self) -> View;
                                fn set_view(&mut self, value: View) -> ();
                                fn import_svg(
                                    &self,
                                    svg: ProjectImportSvgParamsSvgParam,
                                    on_load: JsValue,
                                ) -> std::result::Result<Item, JsValue>;
                                fn selected_items(&self) -> Vec<Item>;
                                fn set_selected_items(&mut self, value: Vec<Item>) -> ();
                                fn deselect_all(&self) -> std::result::Result<(), JsValue>;
                                fn symbol_definitions(&self) -> Vec<SymbolDefinition>;
                                fn set_symbol_definitions(
                                    &mut self,
                                    value: Vec<SymbolDefinition>,
                                ) -> ();
                                fn new(element: ProjectConstructorElementParam) -> Project;
                                fn layers(&self) -> Vec<Layer>;
                                fn set_layers(&mut self, value: Vec<Layer>) -> ();
                            }
                            impl std::clone::Clone for Project_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for Project_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Project_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                #[wasm_bindgen(js_name = "Color")]
                                type Color_Class;
                                # [wasm_bindgen (method , structural , getter = blue , js_class = "Color")]
                                fn blue(this: &Color_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = blue , js_class = "Color")]
                                fn set_blue(this: &Color_Class, value: f64);
                                #[wasm_bindgen(constructor, js_class = "Color")]
                                pub fn new(
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> Color_Class;
                                # [wasm_bindgen (method , structural , getter = red , js_class = "Color")]
                                fn red(this: &Color_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = red , js_class = "Color")]
                                fn set_red(this: &Color_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = lightness , js_class = "Color")]
                                fn lightness(this: &Color_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = lightness , js_class = "Color")]
                                fn set_lightness(this: &Color_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = gradient , js_class = "Color")]
                                fn gradient(this: &Color_Class) -> Gradient;
                                # [wasm_bindgen (method , structural , setter = gradient , js_class = "Color")]
                                fn set_gradient(this: &Color_Class, value: Gradient);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = clone , method , js_class = "Color" , catch)]
                                fn __TSB_clone(
                                    this: &Color_Class,
                                ) -> std::result::Result<Color, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = transform , method , js_class = "Color" , catch)]
                                fn __TSB_transform(
                                    this: &Color_Class,
                                    matrix: Matrix,
                                ) -> std::result::Result<(), JsValue>;
                                # [wasm_bindgen (method , structural , getter = green , js_class = "Color")]
                                fn green(this: &Color_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = green , js_class = "Color")]
                                fn set_green(this: &Color_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = hasAlpha , method , js_class = "Color" , catch)]
                                fn __TSB_has_alpha(
                                    this: &Color_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = subtract , method , js_class = "Color" , catch)]
                                fn __TSB_subtract(
                                    this: &Color_Class,
                                    color: Color,
                                ) -> std::result::Result<Color, JsValue>;
                                # [wasm_bindgen (method , structural , getter = highlight , js_class = "Color")]
                                fn highlight(this: &Color_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = highlight , js_class = "Color")]
                                fn set_highlight(this: &Color_Class, value: Point);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = toCSS , method , js_class = "Color" , catch)]
                                fn __TSB_to_css(
                                    this: &Color_Class,
                                    hex: bool,
                                ) -> std::result::Result<String, JsValue>;
                                # [wasm_bindgen (method , structural , getter = hue , js_class = "Color")]
                                fn hue(this: &Color_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = hue , js_class = "Color")]
                                fn set_hue(this: &Color_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = multiply , method , js_class = "Color" , catch)]
                                fn __TSB_multiply(
                                    this: &Color_Class,
                                    color: Color,
                                ) -> std::result::Result<Color, JsValue>;
                                # [wasm_bindgen (method , structural , getter = type , js_class = "Color")]
                                fn type_(this: &Color_Class) -> String;
                                # [wasm_bindgen (method , structural , setter = type , js_class = "Color")]
                                fn set_type_(this: &Color_Class, value: String);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = convert , method , js_class = "Color" , catch)]
                                fn __TSB_convert(
                                    this: &Color_Class,
                                    type_: String,
                                ) -> std::result::Result<Color, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = add , method , js_class = "Color" , catch)]
                                fn __TSB_add(
                                    this: &Color_Class,
                                    color: Color,
                                ) -> std::result::Result<Color, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = equals , method , js_class = "Color" , catch)]
                                fn __TSB_equals(
                                    this: &Color_Class,
                                    color: Color,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = set , method , js_class = "Color" , catch , variadic)]
                                fn __TSB_set(
                                    this: &Color_Class,
                                    values: &[JsValue],
                                ) -> std::result::Result<Color, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = divide , method , js_class = "Color" , catch)]
                                fn __TSB_divide(
                                    this: &Color_Class,
                                    color: Color,
                                ) -> std::result::Result<Color, JsValue>;
                                # [wasm_bindgen (method , structural , getter = components , js_class = "Color")]
                                fn components(this: &Color_Class) -> Vec<f64>;
                                # [wasm_bindgen (method , structural , setter = components , js_class = "Color")]
                                fn set_components(this: &Color_Class, value: Vec<f64>);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = toString , method , js_class = "Color" , catch)]
                                fn __TSB_to_string(
                                    this: &Color_Class,
                                ) -> std::result::Result<String, JsValue>;
                                # [wasm_bindgen (method , structural , getter = brightness , js_class = "Color")]
                                fn brightness(this: &Color_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = brightness , js_class = "Color")]
                                fn set_brightness(this: &Color_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = alpha , js_class = "Color")]
                                fn alpha(this: &Color_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = alpha , js_class = "Color")]
                                fn set_alpha(this: &Color_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = random , method , js_class = "Color" , catch)]
                                fn __TSB_random(
                                    this: &Color_Class,
                                ) -> std::result::Result<Color, JsValue>;
                                # [wasm_bindgen (method , structural , getter = gray , js_class = "Color")]
                                fn gray(this: &Color_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = gray , js_class = "Color")]
                                fn set_gray(this: &Color_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = saturation , js_class = "Color")]
                                fn saturation(this: &Color_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = saturation , js_class = "Color")]
                                fn set_saturation(this: &Color_Class, value: f64);
                            }
                            #[derive(std :: clone :: Clone)]
                            struct Color(pub Color_Class);
                            impl Color {
                                #[allow(dead_code)]
                                pub fn blue(&self) -> f64 {
                                    let result = self.0.blue();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_blue(&self, value: f64) -> () {
                                    let result = self.0.set_blue(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn new(
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> Color {
                                    let result = Color_Class::new(object);
                                    let result =
                                        ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result)
                                            .unwrap();
                                    Color(result)
                                }
                                #[allow(dead_code)]
                                pub fn red(&self) -> f64 {
                                    let result = self.0.red();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_red(&self, value: f64) -> () {
                                    let result = self.0.set_red(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn lightness(&self) -> f64 {
                                    let result = self.0.lightness();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_lightness(&self, value: f64) -> () {
                                    let result = self.0.set_lightness(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn gradient(&self) -> Gradient {
                                    let result = self.0.gradient();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_gradient(&self, value: Gradient) -> () {
                                    let result = self.0.set_gradient(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn clone(&self) -> std::result::Result<Color, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_clone()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn transform(
                                    &self,
                                    matrix: Matrix,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_transform(matrix)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn green(&self) -> f64 {
                                    let result = self.0.green();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_green(&self, value: f64) -> () {
                                    let result = self.0.set_green(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn has_alpha(&self) -> std::result::Result<bool, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_has_alpha()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn subtract(
                                    &self,
                                    color: Color,
                                ) -> std::result::Result<Color, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_subtract(color)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn highlight(&self) -> Point {
                                    let result = self.0.highlight();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_highlight(&self, value: Point) -> () {
                                    let result = self.0.set_highlight(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn to_css(
                                    &self,
                                    hex: bool,
                                ) -> std::result::Result<String, JsValue>
                                {
                                    let result = std::result::Result::Ok(self.0.__TSB_to_css(hex)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn hue(&self) -> f64 {
                                    let result = self.0.hue();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_hue(&self, value: f64) -> () {
                                    let result = self.0.set_hue(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn multiply(
                                    &self,
                                    color: Color,
                                ) -> std::result::Result<Color, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_multiply(color)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn type_(&self) -> String {
                                    let result = self.0.type_();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_type_(&self, value: String) -> () {
                                    let result = self.0.set_type_(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn convert(
                                    &self,
                                    type_: String,
                                ) -> std::result::Result<Color, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_convert(type_)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn add(
                                    &self,
                                    color: Color,
                                ) -> std::result::Result<Color, JsValue>
                                {
                                    let result = std::result::Result::Ok(self.0.__TSB_add(color)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn equals(
                                    &self,
                                    color: Color,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_equals(color)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set(
                                    &self,
                                    values: &[JsValue],
                                ) -> std::result::Result<Color, JsValue>
                                {
                                    let result = std::result::Result::Ok(self.0.__TSB_set(values)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn divide(
                                    &self,
                                    color: Color,
                                ) -> std::result::Result<Color, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_divide(color)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn components(&self) -> Vec<f64> {
                                    let result = self.0.components();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_components(&self, value: Vec<f64>) -> () {
                                    let result = self.0.set_components(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_to_string()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn brightness(&self) -> f64 {
                                    let result = self.0.brightness();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_brightness(&self, value: f64) -> () {
                                    let result = self.0.set_brightness(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn alpha(&self) -> f64 {
                                    let result = self.0.alpha();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_alpha(&self, value: f64) -> () {
                                    let result = self.0.set_alpha(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn random(&self) -> std::result::Result<Color, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_random()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn gray(&self) -> f64 {
                                    let result = self.0.gray();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_gray(&self, value: f64) -> () {
                                    let result = self.0.set_gray(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn saturation(&self) -> f64 {
                                    let result = self.0.saturation();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_saturation(&self, value: f64) -> () {
                                    let result = self.0.set_saturation(value);
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for Color {
                                fn describe() {
                                    <Color_Class as wasm_bindgen::describe::WasmDescribe>::describe(
                                    )
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for Color {
                                type Abi = <Color_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Color {
                                type Abi =
                                    <&'a Color_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for Color {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Color {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal: Color_Class =
                                        <Color_Class as serde::de::Deserialize>::deserialize(
                                            deserializer,
                                        )?;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait Color_Trait {
                                fn blue(&self) -> f64;
                                fn set_blue(&mut self, value: f64) -> ();
                                fn new(object: std::collections::HashMap<String, JsValue>)
                                    -> Color;
                                fn red(&self) -> f64;
                                fn set_red(&mut self, value: f64) -> ();
                                fn lightness(&self) -> f64;
                                fn set_lightness(&mut self, value: f64) -> ();
                                fn gradient(&self) -> Gradient;
                                fn set_gradient(&mut self, value: Gradient) -> ();
                                fn clone(&self) -> std::result::Result<Color, JsValue>;
                                fn transform(
                                    &self,
                                    matrix: Matrix,
                                ) -> std::result::Result<(), JsValue>;
                                fn green(&self) -> f64;
                                fn set_green(&mut self, value: f64) -> ();
                                fn has_alpha(&self) -> std::result::Result<bool, JsValue>;
                                fn subtract(
                                    &self,
                                    color: Color,
                                ) -> std::result::Result<Color, JsValue>;
                                fn highlight(&self) -> Point;
                                fn set_highlight(&mut self, value: Point) -> ();
                                fn to_css(&self, hex: bool)
                                    -> std::result::Result<String, JsValue>;
                                fn hue(&self) -> f64;
                                fn set_hue(&mut self, value: f64) -> ();
                                fn multiply(
                                    &self,
                                    color: Color,
                                ) -> std::result::Result<Color, JsValue>;
                                fn type_(&self) -> String;
                                fn set_type(&mut self, value: String) -> ();
                                fn convert(
                                    &self,
                                    type_: String,
                                ) -> std::result::Result<Color, JsValue>;
                                fn add(&self, color: Color) -> std::result::Result<Color, JsValue>;
                                fn equals(
                                    &self,
                                    color: Color,
                                ) -> std::result::Result<bool, JsValue>;
                                fn set(
                                    &self,
                                    values: &[JsValue],
                                ) -> std::result::Result<Color, JsValue>;
                                fn divide(
                                    &self,
                                    color: Color,
                                ) -> std::result::Result<Color, JsValue>;
                                fn components(&self) -> Vec<f64>;
                                fn set_components(&mut self, value: Vec<f64>) -> ();
                                fn to_string(&self) -> std::result::Result<String, JsValue>;
                                fn brightness(&self) -> f64;
                                fn set_brightness(&mut self, value: f64) -> ();
                                fn alpha(&self) -> f64;
                                fn set_alpha(&mut self, value: f64) -> ();
                                fn random(&self) -> std::result::Result<Color, JsValue>;
                                fn gray(&self) -> f64;
                                fn set_gray(&mut self, value: f64) -> ();
                                fn saturation(&self) -> f64;
                                fn set_saturation(&mut self, value: f64) -> ();
                            }
                            impl std::clone::Clone for Color_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for Color_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Color_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                #[wasm_bindgen(js_name = "CurveLocation")]
                                type CurveLocation_Class;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isTouching , method , js_class = "CurveLocation" , catch)]
                                fn __TSB_is_touching(
                                    this: &CurveLocation_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                # [wasm_bindgen (method , structural , getter = curvature , js_class = "CurveLocation")]
                                fn curvature(this: &CurveLocation_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = curvature , js_class = "CurveLocation")]
                                fn set_curvature(this: &CurveLocation_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = time , js_class = "CurveLocation")]
                                fn time(this: &CurveLocation_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = time , js_class = "CurveLocation")]
                                fn set_time(this: &CurveLocation_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isCrossing , method , js_class = "CurveLocation" , catch)]
                                fn __TSB_is_crossing(
                                    this: &CurveLocation_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                # [wasm_bindgen (method , structural , getter = offset , js_class = "CurveLocation")]
                                fn offset(this: &CurveLocation_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = offset , js_class = "CurveLocation")]
                                fn set_offset(this: &CurveLocation_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = normal , js_class = "CurveLocation")]
                                fn normal(this: &CurveLocation_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = normal , js_class = "CurveLocation")]
                                fn set_normal(this: &CurveLocation_Class, value: Point);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = toString , method , js_class = "CurveLocation" , catch)]
                                fn __TSB_to_string(
                                    this: &CurveLocation_Class,
                                ) -> std::result::Result<String, JsValue>;
                                # [wasm_bindgen (method , structural , getter = point , js_class = "CurveLocation")]
                                fn point(this: &CurveLocation_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = point , js_class = "CurveLocation")]
                                fn set_point(this: &CurveLocation_Class, value: Point);
                                # [wasm_bindgen (method , structural , getter = curveOffset , js_class = "CurveLocation")]
                                fn curve_offset(this: &CurveLocation_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = curveOffset , js_class = "CurveLocation")]
                                fn set_curve_offset(this: &CurveLocation_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = hasOverlap , method , js_class = "CurveLocation" , catch)]
                                fn __TSB_has_overlap(
                                    this: &CurveLocation_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                # [wasm_bindgen (method , structural , getter = intersection , js_class = "CurveLocation")]
                                fn intersection(this: &CurveLocation_Class) -> CurveLocation;
                                # [wasm_bindgen (method , structural , setter = intersection , js_class = "CurveLocation")]
                                fn set_intersection(
                                    this: &CurveLocation_Class,
                                    value: CurveLocation,
                                );
                                # [wasm_bindgen (method , structural , getter = distance , js_class = "CurveLocation")]
                                fn distance(this: &CurveLocation_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = distance , js_class = "CurveLocation")]
                                fn set_distance(this: &CurveLocation_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = curve , js_class = "CurveLocation")]
                                fn curve(this: &CurveLocation_Class) -> Curve;
                                # [wasm_bindgen (method , structural , setter = curve , js_class = "CurveLocation")]
                                fn set_curve(this: &CurveLocation_Class, value: Curve);
                                # [wasm_bindgen (method , structural , getter = path , js_class = "CurveLocation")]
                                fn path(this: &CurveLocation_Class) -> Path;
                                # [wasm_bindgen (method , structural , setter = path , js_class = "CurveLocation")]
                                fn set_path(this: &CurveLocation_Class, value: Path);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = equals , method , js_class = "CurveLocation" , catch)]
                                fn __TSB_equals(
                                    this: &CurveLocation_Class,
                                    location: CurveLocation,
                                ) -> std::result::Result<bool, JsValue>;
                                #[wasm_bindgen(constructor, js_class = "CurveLocation")]
                                pub fn new(
                                    curve: Curve,
                                    time: f64,
                                    point: Point,
                                ) -> CurveLocation_Class;
                                # [wasm_bindgen (method , structural , getter = tangent , js_class = "CurveLocation")]
                                fn tangent(this: &CurveLocation_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = tangent , js_class = "CurveLocation")]
                                fn set_tangent(this: &CurveLocation_Class, value: Point);
                                # [wasm_bindgen (method , structural , getter = index , js_class = "CurveLocation")]
                                fn index(this: &CurveLocation_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = index , js_class = "CurveLocation")]
                                fn set_index(this: &CurveLocation_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = segment , js_class = "CurveLocation")]
                                fn segment(this: &CurveLocation_Class) -> Segment;
                                # [wasm_bindgen (method , structural , setter = segment , js_class = "CurveLocation")]
                                fn set_segment(this: &CurveLocation_Class, value: Segment);
                            }
                            #[derive(std :: clone :: Clone)]
                            struct CurveLocation(pub CurveLocation_Class);
                            impl CurveLocation {
                                #[allow(dead_code)]
                                pub fn is_touching(&self) -> std::result::Result<bool, JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_is_touching()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn curvature(&self) -> f64 {
                                    let result = self.0.curvature();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_curvature(&self, value: f64) -> () {
                                    let result = self.0.set_curvature(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn time(&self) -> f64 {
                                    let result = self.0.time();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_time(&self, value: f64) -> () {
                                    let result = self.0.set_time(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_crossing(&self) -> std::result::Result<bool, JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_is_crossing()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn offset(&self) -> f64 {
                                    let result = self.0.offset();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_offset(&self, value: f64) -> () {
                                    let result = self.0.set_offset(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn normal(&self) -> Point {
                                    let result = self.0.normal();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_normal(&self, value: Point) -> () {
                                    let result = self.0.set_normal(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_to_string()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn point(&self) -> Point {
                                    let result = self.0.point();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_point(&self, value: Point) -> () {
                                    let result = self.0.set_point(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn curve_offset(&self) -> f64 {
                                    let result = self.0.curve_offset();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_curve_offset(&self, value: f64) -> () {
                                    let result = self.0.set_curve_offset(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn has_overlap(&self) -> std::result::Result<bool, JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_has_overlap()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn intersection(&self) -> CurveLocation {
                                    let result = self.0.intersection();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_intersection(&self, value: CurveLocation) -> () {
                                    let result = self.0.set_intersection(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn distance(&self) -> f64 {
                                    let result = self.0.distance();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_distance(&self, value: f64) -> () {
                                    let result = self.0.set_distance(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn curve(&self) -> Curve {
                                    let result = self.0.curve();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_curve(&self, value: Curve) -> () {
                                    let result = self.0.set_curve(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn path(&self) -> Path {
                                    let result = self.0.path();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_path(&self, value: Path) -> () {
                                    let result = self.0.set_path(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn equals(
                                    &self,
                                    location: CurveLocation,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_equals(location)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn new(curve: Curve, time: f64, point: Point) -> CurveLocation {
                                    let result = CurveLocation_Class::new(curve, time, point);
                                    let result =
                                        ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result)
                                            .unwrap();
                                    CurveLocation(result)
                                }
                                #[allow(dead_code)]
                                pub fn tangent(&self) -> Point {
                                    let result = self.0.tangent();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_tangent(&self, value: Point) -> () {
                                    let result = self.0.set_tangent(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn index(&self) -> f64 {
                                    let result = self.0.index();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_index(&self, value: f64) -> () {
                                    let result = self.0.set_index(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn segment(&self) -> Segment {
                                    let result = self.0.segment();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_segment(&self, value: Segment) -> () {
                                    let result = self.0.set_segment(value);
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for CurveLocation {
                                fn describe() {
                                    < CurveLocation_Class as wasm_bindgen :: describe :: WasmDescribe > :: describe ()
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for CurveLocation {
                                type Abi = < CurveLocation_Class as wasm_bindgen :: convert :: IntoWasmAbi > :: Abi ;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a CurveLocation {
                                type Abi = < & 'a CurveLocation_Class as wasm_bindgen :: convert :: IntoWasmAbi > :: Abi ;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for CurveLocation {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for CurveLocation {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal : CurveLocation_Class = < CurveLocation_Class as serde :: de :: Deserialize > :: deserialize (deserializer) ? ;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait CurveLocation_Trait {
                                fn is_touching(&self) -> std::result::Result<bool, JsValue>;
                                fn curvature(&self) -> f64;
                                fn set_curvature(&mut self, value: f64) -> ();
                                fn time(&self) -> f64;
                                fn set_time(&mut self, value: f64) -> ();
                                fn is_crossing(&self) -> std::result::Result<bool, JsValue>;
                                fn offset(&self) -> f64;
                                fn set_offset(&mut self, value: f64) -> ();
                                fn normal(&self) -> Point;
                                fn set_normal(&mut self, value: Point) -> ();
                                fn to_string(&self) -> std::result::Result<String, JsValue>;
                                fn point(&self) -> Point;
                                fn set_point(&mut self, value: Point) -> ();
                                fn curve_offset(&self) -> f64;
                                fn set_curve_offset(&mut self, value: f64) -> ();
                                fn has_overlap(&self) -> std::result::Result<bool, JsValue>;
                                fn intersection(&self) -> CurveLocation;
                                fn set_intersection(&mut self, value: CurveLocation) -> ();
                                fn distance(&self) -> f64;
                                fn set_distance(&mut self, value: f64) -> ();
                                fn curve(&self) -> Curve;
                                fn set_curve(&mut self, value: Curve) -> ();
                                fn path(&self) -> Path;
                                fn set_path(&mut self, value: Path) -> ();
                                fn equals(
                                    &self,
                                    location: CurveLocation,
                                ) -> std::result::Result<bool, JsValue>;
                                fn new(curve: Curve, time: f64, point: Point) -> CurveLocation;
                                fn tangent(&self) -> Point;
                                fn set_tangent(&mut self, value: Point) -> ();
                                fn index(&self) -> f64;
                                fn set_index(&mut self, value: f64) -> ();
                                fn segment(&self) -> Segment;
                                fn set_segment(&mut self, value: Segment) -> ();
                            }
                            impl std::clone::Clone for CurveLocation_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for CurveLocation_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for CurveLocation_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                # [wasm_bindgen (js_name = "CompoundPath" , extends = PathItem_Class)]
                                type CompoundPath_Class;
                                # [wasm_bindgen (method , structural , getter = lastCurve , js_class = "CompoundPath")]
                                fn last_curve(this: &CompoundPath_Class) -> Curve;
                                # [wasm_bindgen (method , structural , setter = lastCurve , js_class = "CompoundPath")]
                                fn set_last_curve(this: &CompoundPath_Class, value: Curve);
                                # [wasm_bindgen (method , structural , getter = area , js_class = "CompoundPath")]
                                fn area(this: &CompoundPath_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = area , js_class = "CompoundPath")]
                                fn set_area(this: &CompoundPath_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = curves , js_class = "CompoundPath")]
                                fn curves(this: &CompoundPath_Class) -> Vec<Curve>;
                                # [wasm_bindgen (method , structural , setter = curves , js_class = "CompoundPath")]
                                fn set_curves(this: &CompoundPath_Class, value: Vec<Curve>);
                                # [wasm_bindgen (method , structural , getter = firstCurve , js_class = "CompoundPath")]
                                fn first_curve(this: &CompoundPath_Class) -> Curve;
                                # [wasm_bindgen (method , structural , setter = firstCurve , js_class = "CompoundPath")]
                                fn set_first_curve(this: &CompoundPath_Class, value: Curve);
                                # [wasm_bindgen (method , structural , getter = lastSegment , js_class = "CompoundPath")]
                                fn last_segment(this: &CompoundPath_Class) -> Segment;
                                # [wasm_bindgen (method , structural , setter = lastSegment , js_class = "CompoundPath")]
                                fn set_last_segment(this: &CompoundPath_Class, value: Segment);
                                #[wasm_bindgen(constructor, js_class = "CompoundPath")]
                                pub fn new(
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> CompoundPath_Class;
                                # [wasm_bindgen (method , structural , getter = firstSegment , js_class = "CompoundPath")]
                                fn first_segment(this: &CompoundPath_Class) -> Segment;
                                # [wasm_bindgen (method , structural , setter = firstSegment , js_class = "CompoundPath")]
                                fn set_first_segment(this: &CompoundPath_Class, value: Segment);
                                # [wasm_bindgen (method , structural , getter = length , js_class = "CompoundPath")]
                                fn length(this: &CompoundPath_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = length , js_class = "CompoundPath")]
                                fn set_length(this: &CompoundPath_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = closed , js_class = "CompoundPath")]
                                fn closed(this: &CompoundPath_Class) -> bool;
                                # [wasm_bindgen (method , structural , setter = closed , js_class = "CompoundPath")]
                                fn set_closed(this: &CompoundPath_Class, value: bool);
                            }
                            #[derive(std :: clone :: Clone)]
                            struct CompoundPath(pub CompoundPath_Class);
                            impl std::convert::From<&CompoundPath> for PathItem {
                                fn from(src: &CompoundPath) -> PathItem {
                                    let src: &PathItem_Class = src.0.as_ref();
                                    PathItem(src.clone())
                                }
                            }
                            impl std::convert::From<&mut CompoundPath> for PathItem {
                                fn from(src: &mut CompoundPath) -> PathItem {
                                    let src: &PathItem_Class = src.0.as_ref();
                                    PathItem(src.clone())
                                }
                            }
                            impl CompoundPath {
                                #[allow(dead_code)]
                                pub fn last_curve(&self) -> Curve {
                                    let result = self.0.last_curve();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_last_curve(&self, value: Curve) -> () {
                                    let result = self.0.set_last_curve(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn area(&self) -> f64 {
                                    let result = self.0.area();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_area(&self, value: f64) -> () {
                                    let result = self.0.set_area(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn curves(&self) -> Vec<Curve> {
                                    let result = self.0.curves();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_curves(&self, value: Vec<Curve>) -> () {
                                    let result = self.0.set_curves(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn first_curve(&self) -> Curve {
                                    let result = self.0.first_curve();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_first_curve(&self, value: Curve) -> () {
                                    let result = self.0.set_first_curve(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn last_segment(&self) -> Segment {
                                    let result = self.0.last_segment();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_last_segment(&self, value: Segment) -> () {
                                    let result = self.0.set_last_segment(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn new(
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> CompoundPath {
                                    let result = CompoundPath_Class::new(object);
                                    let result =
                                        ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result)
                                            .unwrap();
                                    CompoundPath(result)
                                }
                                #[allow(dead_code)]
                                pub fn first_segment(&self) -> Segment {
                                    let result = self.0.first_segment();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_first_segment(&self, value: Segment) -> () {
                                    let result = self.0.set_first_segment(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn length(&self) -> f64 {
                                    let result = self.0.length();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_length(&self, value: f64) -> () {
                                    let result = self.0.set_length(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn closed(&self) -> bool {
                                    let result = self.0.closed();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_closed(&self, value: bool) -> () {
                                    let result = self.0.set_closed(value);
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for CompoundPath {
                                fn describe() {
                                    < CompoundPath_Class as wasm_bindgen :: describe :: WasmDescribe > :: describe ()
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for CompoundPath {
                                type Abi =
                                    <CompoundPath_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a CompoundPath {
                                type Abi = < & 'a CompoundPath_Class as wasm_bindgen :: convert :: IntoWasmAbi > :: Abi ;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for CompoundPath {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for CompoundPath {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal : CompoundPath_Class = < CompoundPath_Class as serde :: de :: Deserialize > :: deserialize (deserializer) ? ;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait CompoundPath_Trait: PathItem_Trait {
                                fn last_curve(&self) -> Curve;
                                fn set_last_curve(&mut self, value: Curve) -> ();
                                fn area(&self) -> f64;
                                fn set_area(&mut self, value: f64) -> ();
                                fn curves(&self) -> Vec<Curve>;
                                fn set_curves(&mut self, value: Vec<Curve>) -> ();
                                fn first_curve(&self) -> Curve;
                                fn set_first_curve(&mut self, value: Curve) -> ();
                                fn last_segment(&self) -> Segment;
                                fn set_last_segment(&mut self, value: Segment) -> ();
                                fn new(
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> CompoundPath;
                                fn first_segment(&self) -> Segment;
                                fn set_first_segment(&mut self, value: Segment) -> ();
                                fn length(&self) -> f64;
                                fn set_length(&mut self, value: f64) -> ();
                                fn closed(&self) -> bool;
                                fn set_closed(&mut self, value: bool) -> ();
                            }
                            impl PathItem_Trait for CompoundPath
                            where
                                CompoundPath: Item_Trait,
                            {
                                fn cubic_curve_by(
                                    &self,
                                    handle1: Point,
                                    handle2: Point,
                                    to: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::cubic_curve_by(&target, handle1, handle2, to)
                                }
                                fn curve_by(
                                    &self,
                                    through: Point,
                                    to: Point,
                                    time: f64,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::curve_by(&target, through, to, time)
                                }
                                fn close_path(&self) -> std::result::Result<(), JsValue> {
                                    let target: PathItem = self.into();
                                    PathItem::close_path(&target)
                                }
                                fn simplify(
                                    &self,
                                    tolerance: f64,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::simplify(&target, tolerance)
                                }
                                fn reverse(&self) -> std::result::Result<(), JsValue> {
                                    let target: PathItem = self.into();
                                    PathItem::reverse(&target)
                                }
                                fn quadratic_curve_by(
                                    &self,
                                    handle: Point,
                                    to: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::quadratic_curve_by(&target, handle, to)
                                }
                                fn get_intersections(
                                    &self,
                                    path: PathItem,
                                    include: JsValue,
                                ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::get_intersections(&target, path, include)
                                }
                                fn get_nearest_point(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::get_nearest_point(&target, point)
                                }
                                fn move_to(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::move_to(&target, point)
                                }
                                fn exclude(
                                    &self,
                                    path: PathItem,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<PathItem, JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::exclude(&target, path, options)
                                }
                                fn interpolate(
                                    &self,
                                    from: PathItem,
                                    to: PathItem,
                                    factor: f64,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::interpolate(&target, from, to, factor)
                                }
                                fn compare(
                                    &self,
                                    path: PathItem,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::compare(&target, path)
                                }
                                fn arc_by(
                                    &self,
                                    to: Point,
                                    clockwise: bool,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::arc_by(&target, to, clockwise)
                                }
                                fn line_to(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::line_to(&target, point)
                                }
                                fn line_by(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::line_by(&target, point)
                                }
                                fn path_data(&self) -> String {
                                    let target: PathItem = self.into();
                                    PathItem::path_data(&target)
                                }
                                fn set_path_data(&mut self, value: String) -> () {
                                    let mut target: PathItem = self.into();
                                    PathItem::set_path_data(&mut target, value)
                                }
                                fn interior_point(&self) -> Point {
                                    let target: PathItem = self.into();
                                    PathItem::interior_point(&target)
                                }
                                fn set_interior_point(&mut self, value: Point) -> () {
                                    let mut target: PathItem = self.into();
                                    PathItem::set_interior_point(&mut target, value)
                                }
                                fn clockwise(&self) -> bool {
                                    let target: PathItem = self.into();
                                    PathItem::clockwise(&target)
                                }
                                fn set_clockwise(&mut self, value: bool) -> () {
                                    let mut target: PathItem = self.into();
                                    PathItem::set_clockwise(&mut target, value)
                                }
                                fn smooth(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::smooth(&target, options)
                                }
                                fn get_nearest_location(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<CurveLocation, JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::get_nearest_location(&target, point)
                                }
                                fn divide(
                                    &self,
                                    path: PathItem,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<PathItem, JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::divide(&target, path, options)
                                }
                                fn cubic_curve_to(
                                    &self,
                                    handle1: Point,
                                    handle2: Point,
                                    to: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::cubic_curve_to(&target, handle1, handle2, to)
                                }
                                fn subtract(
                                    &self,
                                    path: PathItem,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<PathItem, JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::subtract(&target, path, options)
                                }
                                fn move_by(&self, to: Point) -> std::result::Result<(), JsValue> {
                                    let target: PathItem = self.into();
                                    PathItem::move_by(&target, to)
                                }
                                fn quadratic_curve_to(
                                    &self,
                                    handle: Point,
                                    to: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::quadratic_curve_to(&target, handle, to)
                                }
                                fn get_crossings(
                                    &self,
                                    path: PathItem,
                                ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::get_crossings(&target, path)
                                }
                                fn curve_to(
                                    &self,
                                    through: Point,
                                    to: Point,
                                    time: f64,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::curve_to(&target, through, to, time)
                                }
                                fn arc_to(
                                    &self,
                                    to: Point,
                                    clockwise: bool,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::arc_to(&target, to, clockwise)
                                }
                                fn unite(
                                    &self,
                                    path: PathItem,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<PathItem, JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::unite(&target, path, options)
                                }
                                fn flatten(
                                    &self,
                                    flatness: f64,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::flatten(&target, flatness)
                                }
                                fn intersect(
                                    &self,
                                    path: PathItem,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<PathItem, JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::intersect(&target, path, options)
                                }
                                fn reorient(
                                    &self,
                                    non_zero: bool,
                                    clockwise: bool,
                                ) -> std::result::Result<PathItem, JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::reorient(&target, non_zero, clockwise)
                                }
                                fn create(
                                    &self,
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<PathItemCreateReturn, JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::create(&target, object)
                                }
                            }
                            impl Item_Trait for CompoundPath {
                                fn insert_below(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_below(&target, item)
                                }
                                fn on_double_click(&self) -> ItemOnDoubleClick {
                                    let target: Item = self.into();
                                    Item::on_double_click(&target)
                                }
                                fn set_on_double_click(&mut self, value: ItemOnDoubleClick) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_double_click(&mut target, value)
                                }
                                fn view(&self) -> View {
                                    let target: Item = self.into();
                                    Item::view(&target)
                                }
                                fn set_view(&mut self, value: View) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_view(&mut target, value)
                                }
                                fn blend_mode(&self) -> String {
                                    let target: Item = self.into();
                                    Item::blend_mode(&target)
                                }
                                fn set_blend_mode(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_blend_mode(&mut target, value)
                                }
                                fn name(&self) -> String {
                                    let target: Item = self.into();
                                    Item::name(&target)
                                }
                                fn set_name(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_name(&mut target, value)
                                }
                                fn project(&self) -> Project {
                                    let target: Item = self.into();
                                    Item::project(&target)
                                }
                                fn set_project(&mut self, value: Project) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_project(&mut target, value)
                                }
                                fn is_child(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_child(&target, item)
                                }
                                fn global_matrix(&self) -> Matrix {
                                    let target: Item = self.into();
                                    Item::global_matrix(&target)
                                }
                                fn set_global_matrix(&mut self, value: Matrix) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_global_matrix(&mut target, value)
                                }
                                fn on_mouse_leave(&self) -> ItemOnMouseLeave {
                                    let target: Item = self.into();
                                    Item::on_mouse_leave(&target)
                                }
                                fn set_on_mouse_leave(&mut self, value: ItemOnMouseLeave) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_leave(&mut target, value)
                                }
                                fn has_children(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_children(&target)
                                }
                                fn selected(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::selected(&target)
                                }
                                fn set_selected(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_selected(&mut target, value)
                                }
                                fn global_to_local(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::global_to_local(&target, point)
                                }
                                fn shadow_blur(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::shadow_blur(&target)
                                }
                                fn set_shadow_blur(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_shadow_blur(&mut target, value)
                                }
                                fn children(&self) -> Vec<Item> {
                                    let target: Item = self.into();
                                    Item::children(&target)
                                }
                                fn set_children(&mut self, value: Vec<Item>) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_children(&mut target, value)
                                }
                                fn replace_with(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::replace_with(&target, item)
                                }
                                fn import_json(
                                    &self,
                                    json: String,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::import_json(&target, json)
                                }
                                fn insert_child(
                                    &self,
                                    index: f64,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_child(&target, index, item)
                                }
                                fn stroke_join(&self) -> String {
                                    let target: Item = self.into();
                                    Item::stroke_join(&target)
                                }
                                fn set_stroke_join(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_join(&mut target, value)
                                }
                                fn rotation(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::rotation(&target)
                                }
                                fn set_rotation(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_rotation(&mut target, value)
                                }
                                fn scaling(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::scaling(&target)
                                }
                                fn set_scaling(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_scaling(&mut target, value)
                                }
                                fn is_ancestor(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_ancestor(&target, item)
                                }
                                fn emit(
                                    &self,
                                    type_: String,
                                    event: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::emit(&target, type_, event)
                                }
                                fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_up(&target)
                                }
                                fn add_to(
                                    &self,
                                    owner: ItemAddToParamsOwnerParam,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::add_to(&target, owner)
                                }
                                fn stroke_cap(&self) -> String {
                                    let target: Item = self.into();
                                    Item::stroke_cap(&target)
                                }
                                fn set_stroke_cap(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_cap(&mut target, value)
                                }
                                fn on_mouse_drag(&self) -> ItemOnMouseDrag {
                                    let target: Item = self.into();
                                    Item::on_mouse_drag(&target)
                                }
                                fn set_on_mouse_drag(&mut self, value: ItemOnMouseDrag) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_drag(&mut target, value)
                                }
                                fn set(
                                    &self,
                                    props: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::set(&target, props)
                                }
                                fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::reverse_children(&target)
                                }
                                fn matches(
                                    &self,
                                    name: String,
                                    compare: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::matches(&target, name, compare)
                                }
                                fn on_mouse_enter(&self) -> ItemOnMouseEnter {
                                    let target: Item = self.into();
                                    Item::on_mouse_enter(&target)
                                }
                                fn set_on_mouse_enter(&mut self, value: ItemOnMouseEnter) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_enter(&mut target, value)
                                }
                                fn shadow_offset(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::shadow_offset(&target)
                                }
                                fn set_shadow_offset(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_shadow_offset(&mut target, value)
                                }
                                fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_stroke(&target)
                                }
                                fn view_matrix(&self) -> Matrix {
                                    let target: Item = self.into();
                                    Item::view_matrix(&target)
                                }
                                fn set_view_matrix(&mut self, value: Matrix) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_view_matrix(&mut target, value)
                                }
                                fn on_frame(&self) -> ItemOnFrame {
                                    let target: Item = self.into();
                                    Item::on_frame(&target)
                                }
                                fn set_on_frame(&mut self, value: ItemOnFrame) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_frame(&mut target, value)
                                }
                                fn on_mouse_down(&self) -> ItemOnMouseDown {
                                    let target: Item = self.into();
                                    Item::on_mouse_down(&target)
                                }
                                fn set_on_mouse_down(&mut self, value: ItemOnMouseDown) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_down(&mut target, value)
                                }
                                fn is_sibling(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_sibling(&target, item)
                                }
                                fn local_to_global(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::local_to_global(&target, point)
                                }
                                fn first_child(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::first_child(&target)
                                }
                                fn set_first_child(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_first_child(&mut target, value)
                                }
                                fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::send_to_back(&target)
                                }
                                fn clip_mask(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::clip_mask(&target)
                                }
                                fn set_clip_mask(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_clip_mask(&mut target, value)
                                }
                                fn next_sibling(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::next_sibling(&target)
                                }
                                fn set_next_sibling(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_next_sibling(&mut target, value)
                                }
                                fn off(
                                    &self,
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::off(&target, object)
                                }
                                fn rotate(
                                    &self,
                                    angle: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::rotate(&target, angle, center)
                                }
                                fn add_child(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::add_child(&target, item)
                                }
                                fn is_grouped_with(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_grouped_with(&target, item)
                                }
                                fn scale(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::scale(&target, hor, ver, center)
                                }
                                fn hit_test_all(
                                    &self,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Vec<HitResult>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::hit_test_all(&target, point, options)
                                }
                                fn insert_children(
                                    &self,
                                    index: f64,
                                    items: Vec<Item>,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_children(&target, index, items)
                                }
                                fn style(&self) -> Style {
                                    let target: Item = self.into();
                                    Item::style(&target)
                                }
                                fn set_style(&mut self, value: Style) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_style(&mut target, value)
                                }
                                fn position(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::position(&target)
                                }
                                fn set_position(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_position(&mut target, value)
                                }
                                fn transform(
                                    &self,
                                    matrix: Matrix,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::transform(&target, matrix)
                                }
                                fn fill_color(&self) -> ItemFillColor {
                                    let target: Item = self.into();
                                    Item::fill_color(&target)
                                }
                                fn set_fill_color(&mut self, value: ItemFillColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_fill_color(&mut target, value)
                                }
                                fn matrix(&self) -> Matrix {
                                    let target: Item = self.into();
                                    Item::matrix(&target)
                                }
                                fn set_matrix(&mut self, value: Matrix) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_matrix(&mut target, value)
                                }
                                fn id(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::id(&target)
                                }
                                fn set_id(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_id(&mut target, value)
                                }
                                fn tween(
                                    &self,
                                    options: ItemTweenParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::tween(&target, options)
                                }
                                fn reduce(
                                    &self,
                                    options: JsValue,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::reduce(&target, options)
                                }
                                fn internal_bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::internal_bounds(&target)
                                }
                                fn set_internal_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_internal_bounds(&mut target, value)
                                }
                                fn fill_rule(&self) -> String {
                                    let target: Item = self.into();
                                    Item::fill_rule(&target)
                                }
                                fn set_fill_rule(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_fill_rule(&mut target, value)
                                }
                                fn shadow_color(&self) -> ItemShadowColor {
                                    let target: Item = self.into();
                                    Item::shadow_color(&target)
                                }
                                fn set_shadow_color(&mut self, value: ItemShadowColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_shadow_color(&mut target, value)
                                }
                                fn insert_above(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_above(&target, item)
                                }
                                fn responds(
                                    &self,
                                    type_: String,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::responds(&target, type_)
                                }
                                fn handle_bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::handle_bounds(&target)
                                }
                                fn set_handle_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_handle_bounds(&mut target, value)
                                }
                                fn skew(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::skew(&target, hor, ver, center)
                                }
                                fn on_click(&self) -> ItemOnClick {
                                    let target: Item = self.into();
                                    Item::on_click(&target)
                                }
                                fn set_on_click(&mut self, value: ItemOnClick) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_click(&mut target, value)
                                }
                                fn get_items(
                                    &self,
                                    options: ItemGetItemsParamsOptionsParam,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::get_items(&target, options)
                                }
                                fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::is_inserted(&target)
                                }
                                fn get_item(
                                    &self,
                                    options: ItemGetItemParamsOptionsParam,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::get_item(&target, options)
                                }
                                fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_fill(&target)
                                }
                                fn shear(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::shear(&target, hor, ver, center)
                                }
                                fn visible(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::visible(&target)
                                }
                                fn set_visible(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_visible(&mut target, value)
                                }
                                fn previous_sibling(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::previous_sibling(&target)
                                }
                                fn set_previous_sibling(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_previous_sibling(&mut target, value)
                                }
                                fn hit_test(
                                    &self,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<HitResult, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::hit_test(&target, point, options)
                                }
                                fn is_descendant(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_descendant(&target, item)
                                }
                                fn locked(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::locked(&target)
                                }
                                fn set_locked(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_locked(&mut target, value)
                                }
                                fn is_parent(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_parent(&target, item)
                                }
                                fn copy_attributes(
                                    &self,
                                    source: Item,
                                    exclude_matrix: bool,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::copy_attributes(&target, source, exclude_matrix)
                                }
                                fn last_child(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::last_child(&target)
                                }
                                fn set_last_child(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_last_child(&mut target, value)
                                }
                                fn stroke_width(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::stroke_width(&target)
                                }
                                fn set_stroke_width(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_width(&mut target, value)
                                }
                                fn parent(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::parent(&target)
                                }
                                fn set_parent(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_parent(&mut target, value)
                                }
                                fn stroke_bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::stroke_bounds(&target)
                                }
                                fn set_stroke_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_bounds(&mut target, value)
                                }
                                fn translate(
                                    &self,
                                    delta: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::translate(&target, delta)
                                }
                                fn remove(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::remove(&target)
                                }
                                fn parent_to_local(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::parent_to_local(&target, point)
                                }
                                fn bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::bounds(&target)
                                }
                                fn set_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_bounds(&mut target, value)
                                }
                                fn add_children(
                                    &self,
                                    items: Vec<Item>,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::add_children(&target, items)
                                }
                                fn dash_array(&self) -> Vec<f64> {
                                    let target: Item = self.into();
                                    Item::dash_array(&target)
                                }
                                fn set_dash_array(&mut self, value: Vec<f64>) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_dash_array(&mut target, value)
                                }
                                fn on_mouse_up(&self) -> ItemOnMouseUp {
                                    let target: Item = self.into();
                                    Item::on_mouse_up(&target)
                                }
                                fn set_on_mouse_up(&mut self, value: ItemOnMouseUp) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_up(&mut target, value)
                                }
                                fn on(
                                    &self,
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::on(&target, object)
                                }
                                fn remove_on(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::remove_on(&target, options)
                                }
                                fn is_below(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_below(&target, item)
                                }
                                fn apply_matrix(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::apply_matrix(&target)
                                }
                                fn set_apply_matrix(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_apply_matrix(&mut target, value)
                                }
                                fn clone(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::clone(&target, options)
                                }
                                fn contains(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::contains(&target, point)
                                }
                                fn export_json(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<String, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::export_json(&target, options)
                                }
                                fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::bring_to_front(&target)
                                }
                                fn is_above(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_above(&target, item)
                                }
                                fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_drag(&target)
                                }
                                fn data(&self) -> JsValue {
                                    let target: Item = self.into();
                                    Item::data(&target)
                                }
                                fn set_data(&mut self, value: JsValue) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_data(&mut target, value)
                                }
                                fn import_svg(
                                    &self,
                                    svg: ItemImportSvgParamsSvgParam,
                                    on_load: JsValue,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::import_svg(&target, svg, on_load)
                                }
                                fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_shadow(&target)
                                }
                                fn selected_color(&self) -> ItemSelectedColor {
                                    let target: Item = self.into();
                                    Item::selected_color(&target)
                                }
                                fn set_selected_color(&mut self, value: ItemSelectedColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_selected_color(&mut target, value)
                                }
                                fn class_name(&self) -> String {
                                    let target: Item = self.into();
                                    Item::class_name(&target)
                                }
                                fn set_class_name(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_class_name(&mut target, value)
                                }
                                fn export_svg(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<ItemExportSvgReturn, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::export_svg(&target, options)
                                }
                                fn tween_to(
                                    &self,
                                    to: std::collections::HashMap<String, JsValue>,
                                    options: ItemTweenToParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::tween_to(&target, to, options)
                                }
                                fn is_inside(
                                    &self,
                                    rect: Rectangle,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_inside(&target, rect)
                                }
                                fn is_empty(
                                    &self,
                                    recursively: bool,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_empty(&target, recursively)
                                }
                                fn copy_content(
                                    &self,
                                    source: Item,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::copy_content(&target, source)
                                }
                                fn rasterize(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Raster, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::rasterize(&target, options)
                                }
                                fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_move(&target)
                                }
                                fn tween_from(
                                    &self,
                                    from: std::collections::HashMap<String, JsValue>,
                                    options: ItemTweenFromParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::tween_from(&target, from, options)
                                }
                                fn opacity(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::opacity(&target)
                                }
                                fn set_opacity(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_opacity(&mut target, value)
                                }
                                fn dash_offset(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::dash_offset(&target)
                                }
                                fn set_dash_offset(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_dash_offset(&mut target, value)
                                }
                                fn remove_children(
                                    &self,
                                    start: f64,
                                    end: f64,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::remove_children(&target, start, end)
                                }
                                fn on_mouse_move(&self) -> ItemOnMouseMove {
                                    let target: Item = self.into();
                                    Item::on_mouse_move(&target)
                                }
                                fn set_on_mouse_move(&mut self, value: ItemOnMouseMove) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_move(&mut target, value)
                                }
                                fn intersects(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::intersects(&target, item)
                                }
                                fn pivot(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::pivot(&target)
                                }
                                fn set_pivot(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_pivot(&mut target, value)
                                }
                                fn copy_to(
                                    &self,
                                    owner: ItemCopyToParamsOwnerParam,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::copy_to(&target, owner)
                                }
                                fn index(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::index(&target)
                                }
                                fn set_index(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_index(&mut target, value)
                                }
                                fn local_to_parent(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::local_to_parent(&target, point)
                                }
                                fn stroke_color(&self) -> ItemStrokeColor {
                                    let target: Item = self.into();
                                    Item::stroke_color(&target)
                                }
                                fn set_stroke_color(&mut self, value: ItemStrokeColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_color(&mut target, value)
                                }
                                fn layer(&self) -> Layer {
                                    let target: Item = self.into();
                                    Item::layer(&target)
                                }
                                fn set_layer(&mut self, value: Layer) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_layer(&mut target, value)
                                }
                                fn stroke_scaling(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::stroke_scaling(&target)
                                }
                                fn set_stroke_scaling(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_scaling(&mut target, value)
                                }
                                fn fit_bounds(
                                    &self,
                                    rectangle: Rectangle,
                                    fill: bool,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::fit_bounds(&target, rectangle, fill)
                                }
                                fn miter_limit(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::miter_limit(&target)
                                }
                                fn set_miter_limit(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_miter_limit(&mut target, value)
                                }
                                fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_down(&target)
                                }
                            }
                            impl CompoundPath_Trait for CompoundPath {}
                            impl std::clone::Clone for CompoundPath_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for CompoundPath_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for CompoundPath_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                # [wasm_bindgen (js_name = "KeyEvent" , extends = Event_Class)]
                                type KeyEvent_Class;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = toString , method , js_class = "KeyEvent" , catch)]
                                fn __TSB_to_string(
                                    this: &KeyEvent_Class,
                                ) -> std::result::Result<String, JsValue>;
                                # [wasm_bindgen (method , structural , getter = type , js_class = "KeyEvent")]
                                fn type_(this: &KeyEvent_Class) -> String;
                                # [wasm_bindgen (method , structural , setter = type , js_class = "KeyEvent")]
                                fn set_type_(this: &KeyEvent_Class, value: String);
                                # [wasm_bindgen (method , structural , getter = character , js_class = "KeyEvent")]
                                fn character(this: &KeyEvent_Class) -> String;
                                # [wasm_bindgen (method , structural , setter = character , js_class = "KeyEvent")]
                                fn set_character(this: &KeyEvent_Class, value: String);
                                # [wasm_bindgen (method , structural , getter = key , js_class = "KeyEvent")]
                                fn key(this: &KeyEvent_Class) -> String;
                                # [wasm_bindgen (method , structural , setter = key , js_class = "KeyEvent")]
                                fn set_key(this: &KeyEvent_Class, value: String);
                            }
                            #[derive(std :: clone :: Clone)]
                            struct KeyEvent(pub KeyEvent_Class);
                            impl std::convert::From<&KeyEvent> for Event {
                                fn from(src: &KeyEvent) -> Event {
                                    let src: &Event_Class = src.0.as_ref();
                                    Event(src.clone())
                                }
                            }
                            impl std::convert::From<&mut KeyEvent> for Event {
                                fn from(src: &mut KeyEvent) -> Event {
                                    let src: &Event_Class = src.0.as_ref();
                                    Event(src.clone())
                                }
                            }
                            impl KeyEvent {
                                #[allow(dead_code)]
                                pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_to_string()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn type_(&self) -> String {
                                    let result = self.0.type_();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_type_(&self, value: String) -> () {
                                    let result = self.0.set_type_(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn character(&self) -> String {
                                    let result = self.0.character();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_character(&self, value: String) -> () {
                                    let result = self.0.set_character(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn key(&self) -> String {
                                    let result = self.0.key();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_key(&self, value: String) -> () {
                                    let result = self.0.set_key(value);
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for KeyEvent {
                                fn describe() {
                                    < KeyEvent_Class as wasm_bindgen :: describe :: WasmDescribe > :: describe ()
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for KeyEvent {
                                type Abi =
                                    <KeyEvent_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a KeyEvent {
                                type Abi =
                                    <&'a KeyEvent_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for KeyEvent {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for KeyEvent {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal: KeyEvent_Class =
                                        <KeyEvent_Class as serde::de::Deserialize>::deserialize(
                                            deserializer,
                                        )?;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait KeyEvent_Trait: Event_Trait {
                                fn to_string(&self) -> std::result::Result<String, JsValue>;
                                fn type_(&self) -> String;
                                fn set_type(&mut self, value: String) -> ();
                                fn character(&self) -> String;
                                fn set_character(&mut self, value: String) -> ();
                                fn key(&self) -> String;
                                fn set_key(&mut self, value: String) -> ();
                            }
                            impl Event_Trait for KeyEvent {
                                fn prevent_default(&self) -> std::result::Result<(), JsValue> {
                                    let target: Event = self.into();
                                    Event::prevent_default(&target)
                                }
                                fn time_stamp(&self) -> f64 {
                                    let target: Event = self.into();
                                    Event::time_stamp(&target)
                                }
                                fn set_time_stamp(&mut self, value: f64) -> () {
                                    let mut target: Event = self.into();
                                    Event::set_time_stamp(&mut target, value)
                                }
                                fn stop(&self) -> std::result::Result<(), JsValue> {
                                    let target: Event = self.into();
                                    Event::stop(&target)
                                }
                                fn modifiers(&self) -> JsValue {
                                    let target: Event = self.into();
                                    Event::modifiers(&target)
                                }
                                fn set_modifiers(&mut self, value: JsValue) -> () {
                                    let mut target: Event = self.into();
                                    Event::set_modifiers(&mut target, value)
                                }
                                fn stop_propagation(&self) -> std::result::Result<(), JsValue> {
                                    let target: Event = self.into();
                                    Event::stop_propagation(&target)
                                }
                            }
                            impl KeyEvent_Trait for KeyEvent {}
                            impl std::clone::Clone for KeyEvent_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for KeyEvent_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for KeyEvent_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                #[wasm_bindgen(js_name = "Item")]
                                type Item_Class;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = insertBelow , method , js_class = "Item" , catch)]
                                fn __TSB_insert_below(
                                    this: &Item_Class,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>;
                                # [wasm_bindgen (method , structural , getter = onDoubleClick , js_class = "Item")]
                                fn on_double_click(this: &Item_Class) -> ItemOnDoubleClick;
                                # [wasm_bindgen (method , structural , setter = onDoubleClick , js_class = "Item")]
                                fn set_on_double_click(this: &Item_Class, value: ItemOnDoubleClick);
                                # [wasm_bindgen (method , structural , getter = view , js_class = "Item")]
                                fn view(this: &Item_Class) -> View;
                                # [wasm_bindgen (method , structural , setter = view , js_class = "Item")]
                                fn set_view(this: &Item_Class, value: View);
                                # [wasm_bindgen (method , structural , getter = blendMode , js_class = "Item")]
                                fn blend_mode(this: &Item_Class) -> String;
                                # [wasm_bindgen (method , structural , setter = blendMode , js_class = "Item")]
                                fn set_blend_mode(this: &Item_Class, value: String);
                                # [wasm_bindgen (method , structural , getter = name , js_class = "Item")]
                                fn name(this: &Item_Class) -> String;
                                # [wasm_bindgen (method , structural , setter = name , js_class = "Item")]
                                fn set_name(this: &Item_Class, value: String);
                                # [wasm_bindgen (method , structural , getter = project , js_class = "Item")]
                                fn project(this: &Item_Class) -> Project;
                                # [wasm_bindgen (method , structural , setter = project , js_class = "Item")]
                                fn set_project(this: &Item_Class, value: Project);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isChild , method , js_class = "Item" , catch)]
                                fn __TSB_is_child(
                                    this: &Item_Class,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>;
                                # [wasm_bindgen (method , structural , getter = globalMatrix , js_class = "Item")]
                                fn global_matrix(this: &Item_Class) -> Matrix;
                                # [wasm_bindgen (method , structural , setter = globalMatrix , js_class = "Item")]
                                fn set_global_matrix(this: &Item_Class, value: Matrix);
                                # [wasm_bindgen (method , structural , getter = onMouseLeave , js_class = "Item")]
                                fn on_mouse_leave(this: &Item_Class) -> ItemOnMouseLeave;
                                # [wasm_bindgen (method , structural , setter = onMouseLeave , js_class = "Item")]
                                fn set_on_mouse_leave(this: &Item_Class, value: ItemOnMouseLeave);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = hasChildren , method , js_class = "Item" , catch)]
                                fn __TSB_has_children(
                                    this: &Item_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                # [wasm_bindgen (method , structural , getter = selected , js_class = "Item")]
                                fn selected(this: &Item_Class) -> bool;
                                # [wasm_bindgen (method , structural , setter = selected , js_class = "Item")]
                                fn set_selected(this: &Item_Class, value: bool);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = globalToLocal , method , js_class = "Item" , catch)]
                                fn __TSB_global_to_local(
                                    this: &Item_Class,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                # [wasm_bindgen (method , structural , getter = shadowBlur , js_class = "Item")]
                                fn shadow_blur(this: &Item_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = shadowBlur , js_class = "Item")]
                                fn set_shadow_blur(this: &Item_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = children , js_class = "Item")]
                                fn children(this: &Item_Class) -> Vec<Item>;
                                # [wasm_bindgen (method , structural , setter = children , js_class = "Item")]
                                fn set_children(this: &Item_Class, value: Vec<Item>);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = replaceWith , method , js_class = "Item" , catch)]
                                fn __TSB_replace_with(
                                    this: &Item_Class,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = importJSON , method , js_class = "Item" , catch)]
                                fn __TSB_import_json(
                                    this: &Item_Class,
                                    json: String,
                                ) -> std::result::Result<Item, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = insertChild , method , js_class = "Item" , catch)]
                                fn __TSB_insert_child(
                                    this: &Item_Class,
                                    index: f64,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>;
                                # [wasm_bindgen (method , structural , getter = strokeJoin , js_class = "Item")]
                                fn stroke_join(this: &Item_Class) -> String;
                                # [wasm_bindgen (method , structural , setter = strokeJoin , js_class = "Item")]
                                fn set_stroke_join(this: &Item_Class, value: String);
                                # [wasm_bindgen (method , structural , getter = rotation , js_class = "Item")]
                                fn rotation(this: &Item_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = rotation , js_class = "Item")]
                                fn set_rotation(this: &Item_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = scaling , js_class = "Item")]
                                fn scaling(this: &Item_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = scaling , js_class = "Item")]
                                fn set_scaling(this: &Item_Class, value: Point);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isAncestor , method , js_class = "Item" , catch)]
                                fn __TSB_is_ancestor(
                                    this: &Item_Class,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = emit , method , js_class = "Item" , catch)]
                                fn __TSB_emit(
                                    this: &Item_Class,
                                    type_: String,
                                    event: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = removeOnUp , method , js_class = "Item" , catch)]
                                fn __TSB_remove_on_up(
                                    this: &Item_Class,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = addTo , method , js_class = "Item" , catch)]
                                fn __TSB_add_to(
                                    this: &Item_Class,
                                    owner: JsValue,
                                ) -> std::result::Result<JsValue, JsValue>;
                                # [wasm_bindgen (method , structural , getter = strokeCap , js_class = "Item")]
                                fn stroke_cap(this: &Item_Class) -> String;
                                # [wasm_bindgen (method , structural , setter = strokeCap , js_class = "Item")]
                                fn set_stroke_cap(this: &Item_Class, value: String);
                                # [wasm_bindgen (method , structural , getter = onMouseDrag , js_class = "Item")]
                                fn on_mouse_drag(this: &Item_Class) -> ItemOnMouseDrag;
                                # [wasm_bindgen (method , structural , setter = onMouseDrag , js_class = "Item")]
                                fn set_on_mouse_drag(this: &Item_Class, value: ItemOnMouseDrag);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = set , method , js_class = "Item" , catch)]
                                fn __TSB_set(
                                    this: &Item_Class,
                                    props: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = reverseChildren , method , js_class = "Item" , catch)]
                                fn __TSB_reverse_children(
                                    this: &Item_Class,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = matches , method , js_class = "Item" , catch)]
                                fn __TSB_matches(
                                    this: &Item_Class,
                                    name: String,
                                    compare: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>;
                                # [wasm_bindgen (method , structural , getter = onMouseEnter , js_class = "Item")]
                                fn on_mouse_enter(this: &Item_Class) -> ItemOnMouseEnter;
                                # [wasm_bindgen (method , structural , setter = onMouseEnter , js_class = "Item")]
                                fn set_on_mouse_enter(this: &Item_Class, value: ItemOnMouseEnter);
                                # [wasm_bindgen (method , structural , getter = shadowOffset , js_class = "Item")]
                                fn shadow_offset(this: &Item_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = shadowOffset , js_class = "Item")]
                                fn set_shadow_offset(this: &Item_Class, value: Point);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = hasStroke , method , js_class = "Item" , catch)]
                                fn __TSB_has_stroke(
                                    this: &Item_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                # [wasm_bindgen (method , structural , getter = viewMatrix , js_class = "Item")]
                                fn view_matrix(this: &Item_Class) -> Matrix;
                                # [wasm_bindgen (method , structural , setter = viewMatrix , js_class = "Item")]
                                fn set_view_matrix(this: &Item_Class, value: Matrix);
                                # [wasm_bindgen (method , structural , getter = onFrame , js_class = "Item")]
                                fn on_frame(this: &Item_Class) -> ItemOnFrame;
                                # [wasm_bindgen (method , structural , setter = onFrame , js_class = "Item")]
                                fn set_on_frame(this: &Item_Class, value: ItemOnFrame);
                                # [wasm_bindgen (method , structural , getter = onMouseDown , js_class = "Item")]
                                fn on_mouse_down(this: &Item_Class) -> ItemOnMouseDown;
                                # [wasm_bindgen (method , structural , setter = onMouseDown , js_class = "Item")]
                                fn set_on_mouse_down(this: &Item_Class, value: ItemOnMouseDown);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isSibling , method , js_class = "Item" , catch)]
                                fn __TSB_is_sibling(
                                    this: &Item_Class,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = localToGlobal , method , js_class = "Item" , catch)]
                                fn __TSB_local_to_global(
                                    this: &Item_Class,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                # [wasm_bindgen (method , structural , getter = firstChild , js_class = "Item")]
                                fn first_child(this: &Item_Class) -> Item;
                                # [wasm_bindgen (method , structural , setter = firstChild , js_class = "Item")]
                                fn set_first_child(this: &Item_Class, value: Item);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = sendToBack , method , js_class = "Item" , catch)]
                                fn __TSB_send_to_back(
                                    this: &Item_Class,
                                ) -> std::result::Result<(), JsValue>;
                                # [wasm_bindgen (method , structural , getter = clipMask , js_class = "Item")]
                                fn clip_mask(this: &Item_Class) -> bool;
                                # [wasm_bindgen (method , structural , setter = clipMask , js_class = "Item")]
                                fn set_clip_mask(this: &Item_Class, value: bool);
                                # [wasm_bindgen (method , structural , getter = nextSibling , js_class = "Item")]
                                fn next_sibling(this: &Item_Class) -> Item;
                                # [wasm_bindgen (method , structural , setter = nextSibling , js_class = "Item")]
                                fn set_next_sibling(this: &Item_Class, value: Item);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = off , method , js_class = "Item" , catch)]
                                fn __TSB_off(
                                    this: &Item_Class,
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = rotate , method , js_class = "Item" , catch)]
                                fn __TSB_rotate(
                                    this: &Item_Class,
                                    angle: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = addChild , method , js_class = "Item" , catch)]
                                fn __TSB_add_child(
                                    this: &Item_Class,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isGroupedWith , method , js_class = "Item" , catch)]
                                fn __TSB_is_grouped_with(
                                    this: &Item_Class,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = scale , method , js_class = "Item" , catch)]
                                fn __TSB_scale(
                                    this: &Item_Class,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = hitTestAll , method , js_class = "Item" , catch)]
                                fn __TSB_hit_test_all(
                                    this: &Item_Class,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Vec<HitResult>, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = insertChildren , method , js_class = "Item" , catch)]
                                fn __TSB_insert_children(
                                    this: &Item_Class,
                                    index: f64,
                                    items: Vec<Item>,
                                ) -> std::result::Result<Vec<Item>, JsValue>;
                                # [wasm_bindgen (method , structural , getter = style , js_class = "Item")]
                                fn style(this: &Item_Class) -> Style;
                                # [wasm_bindgen (method , structural , setter = style , js_class = "Item")]
                                fn set_style(this: &Item_Class, value: Style);
                                # [wasm_bindgen (method , structural , getter = position , js_class = "Item")]
                                fn position(this: &Item_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = position , js_class = "Item")]
                                fn set_position(this: &Item_Class, value: Point);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = transform , method , js_class = "Item" , catch)]
                                fn __TSB_transform(
                                    this: &Item_Class,
                                    matrix: Matrix,
                                ) -> std::result::Result<(), JsValue>;
                                # [wasm_bindgen (method , structural , getter = fillColor , js_class = "Item")]
                                fn fill_color(this: &Item_Class) -> ItemFillColor;
                                # [wasm_bindgen (method , structural , setter = fillColor , js_class = "Item")]
                                fn set_fill_color(this: &Item_Class, value: ItemFillColor);
                                # [wasm_bindgen (method , structural , getter = matrix , js_class = "Item")]
                                fn matrix(this: &Item_Class) -> Matrix;
                                # [wasm_bindgen (method , structural , setter = matrix , js_class = "Item")]
                                fn set_matrix(this: &Item_Class, value: Matrix);
                                # [wasm_bindgen (method , structural , getter = id , js_class = "Item")]
                                fn id(this: &Item_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = id , js_class = "Item")]
                                fn set_id(this: &Item_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = tween , method , js_class = "Item" , catch)]
                                fn __TSB_tween(
                                    this: &Item_Class,
                                    options: JsValue,
                                ) -> std::result::Result<Tween, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = reduce , method , js_class = "Item" , catch)]
                                fn __TSB_reduce(
                                    this: &Item_Class,
                                    options: JsValue,
                                ) -> std::result::Result<Item, JsValue>;
                                # [wasm_bindgen (method , structural , getter = internalBounds , js_class = "Item")]
                                fn internal_bounds(this: &Item_Class) -> Rectangle;
                                # [wasm_bindgen (method , structural , setter = internalBounds , js_class = "Item")]
                                fn set_internal_bounds(this: &Item_Class, value: Rectangle);
                                # [wasm_bindgen (method , structural , getter = fillRule , js_class = "Item")]
                                fn fill_rule(this: &Item_Class) -> String;
                                # [wasm_bindgen (method , structural , setter = fillRule , js_class = "Item")]
                                fn set_fill_rule(this: &Item_Class, value: String);
                                # [wasm_bindgen (method , structural , getter = shadowColor , js_class = "Item")]
                                fn shadow_color(this: &Item_Class) -> ItemShadowColor;
                                # [wasm_bindgen (method , structural , setter = shadowColor , js_class = "Item")]
                                fn set_shadow_color(this: &Item_Class, value: ItemShadowColor);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = insertAbove , method , js_class = "Item" , catch)]
                                fn __TSB_insert_above(
                                    this: &Item_Class,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = responds , method , js_class = "Item" , catch)]
                                fn __TSB_responds(
                                    this: &Item_Class,
                                    type_: String,
                                ) -> std::result::Result<bool, JsValue>;
                                # [wasm_bindgen (method , structural , getter = handleBounds , js_class = "Item")]
                                fn handle_bounds(this: &Item_Class) -> Rectangle;
                                # [wasm_bindgen (method , structural , setter = handleBounds , js_class = "Item")]
                                fn set_handle_bounds(this: &Item_Class, value: Rectangle);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = skew , method , js_class = "Item" , catch)]
                                fn __TSB_skew(
                                    this: &Item_Class,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>;
                                # [wasm_bindgen (method , structural , getter = onClick , js_class = "Item")]
                                fn on_click(this: &Item_Class) -> ItemOnClick;
                                # [wasm_bindgen (method , structural , setter = onClick , js_class = "Item")]
                                fn set_on_click(this: &Item_Class, value: ItemOnClick);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getItems , method , js_class = "Item" , catch)]
                                fn __TSB_get_items(
                                    this: &Item_Class,
                                    options: JsValue,
                                ) -> std::result::Result<Vec<Item>, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isInserted , method , js_class = "Item" , catch)]
                                fn __TSB_is_inserted(
                                    this: &Item_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getItem , method , js_class = "Item" , catch)]
                                fn __TSB_get_item(
                                    this: &Item_Class,
                                    options: JsValue,
                                ) -> std::result::Result<Item, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = hasFill , method , js_class = "Item" , catch)]
                                fn __TSB_has_fill(
                                    this: &Item_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = shear , method , js_class = "Item" , catch)]
                                fn __TSB_shear(
                                    this: &Item_Class,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>;
                                # [wasm_bindgen (method , structural , getter = visible , js_class = "Item")]
                                fn visible(this: &Item_Class) -> bool;
                                # [wasm_bindgen (method , structural , setter = visible , js_class = "Item")]
                                fn set_visible(this: &Item_Class, value: bool);
                                # [wasm_bindgen (method , structural , getter = previousSibling , js_class = "Item")]
                                fn previous_sibling(this: &Item_Class) -> Item;
                                # [wasm_bindgen (method , structural , setter = previousSibling , js_class = "Item")]
                                fn set_previous_sibling(this: &Item_Class, value: Item);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = hitTest , method , js_class = "Item" , catch)]
                                fn __TSB_hit_test(
                                    this: &Item_Class,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<HitResult, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isDescendant , method , js_class = "Item" , catch)]
                                fn __TSB_is_descendant(
                                    this: &Item_Class,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>;
                                # [wasm_bindgen (method , structural , getter = locked , js_class = "Item")]
                                fn locked(this: &Item_Class) -> bool;
                                # [wasm_bindgen (method , structural , setter = locked , js_class = "Item")]
                                fn set_locked(this: &Item_Class, value: bool);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isParent , method , js_class = "Item" , catch)]
                                fn __TSB_is_parent(
                                    this: &Item_Class,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = copyAttributes , method , js_class = "Item" , catch)]
                                fn __TSB_copy_attributes(
                                    this: &Item_Class,
                                    source: Item,
                                    exclude_matrix: bool,
                                ) -> std::result::Result<(), JsValue>;
                                # [wasm_bindgen (method , structural , getter = lastChild , js_class = "Item")]
                                fn last_child(this: &Item_Class) -> Item;
                                # [wasm_bindgen (method , structural , setter = lastChild , js_class = "Item")]
                                fn set_last_child(this: &Item_Class, value: Item);
                                # [wasm_bindgen (method , structural , getter = strokeWidth , js_class = "Item")]
                                fn stroke_width(this: &Item_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = strokeWidth , js_class = "Item")]
                                fn set_stroke_width(this: &Item_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = parent , js_class = "Item")]
                                fn parent(this: &Item_Class) -> Item;
                                # [wasm_bindgen (method , structural , setter = parent , js_class = "Item")]
                                fn set_parent(this: &Item_Class, value: Item);
                                # [wasm_bindgen (method , structural , getter = strokeBounds , js_class = "Item")]
                                fn stroke_bounds(this: &Item_Class) -> Rectangle;
                                # [wasm_bindgen (method , structural , setter = strokeBounds , js_class = "Item")]
                                fn set_stroke_bounds(this: &Item_Class, value: Rectangle);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = translate , method , js_class = "Item" , catch)]
                                fn __TSB_translate(
                                    this: &Item_Class,
                                    delta: Point,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = remove , method , js_class = "Item" , catch)]
                                fn __TSB_remove(
                                    this: &Item_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = parentToLocal , method , js_class = "Item" , catch)]
                                fn __TSB_parent_to_local(
                                    this: &Item_Class,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                # [wasm_bindgen (method , structural , getter = bounds , js_class = "Item")]
                                fn bounds(this: &Item_Class) -> Rectangle;
                                # [wasm_bindgen (method , structural , setter = bounds , js_class = "Item")]
                                fn set_bounds(this: &Item_Class, value: Rectangle);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = addChildren , method , js_class = "Item" , catch)]
                                fn __TSB_add_children(
                                    this: &Item_Class,
                                    items: Vec<Item>,
                                ) -> std::result::Result<Vec<Item>, JsValue>;
                                # [wasm_bindgen (method , structural , getter = dashArray , js_class = "Item")]
                                fn dash_array(this: &Item_Class) -> Vec<f64>;
                                # [wasm_bindgen (method , structural , setter = dashArray , js_class = "Item")]
                                fn set_dash_array(this: &Item_Class, value: Vec<f64>);
                                # [wasm_bindgen (method , structural , getter = onMouseUp , js_class = "Item")]
                                fn on_mouse_up(this: &Item_Class) -> ItemOnMouseUp;
                                # [wasm_bindgen (method , structural , setter = onMouseUp , js_class = "Item")]
                                fn set_on_mouse_up(this: &Item_Class, value: ItemOnMouseUp);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = on , method , js_class = "Item" , catch)]
                                fn __TSB_on(
                                    this: &Item_Class,
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = removeOn , method , js_class = "Item" , catch)]
                                fn __TSB_remove_on(
                                    this: &Item_Class,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isBelow , method , js_class = "Item" , catch)]
                                fn __TSB_is_below(
                                    this: &Item_Class,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>;
                                # [wasm_bindgen (method , structural , getter = applyMatrix , js_class = "Item")]
                                fn apply_matrix(this: &Item_Class) -> bool;
                                # [wasm_bindgen (method , structural , setter = applyMatrix , js_class = "Item")]
                                fn set_apply_matrix(this: &Item_Class, value: bool);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = clone , method , js_class = "Item" , catch)]
                                fn __TSB_clone(
                                    this: &Item_Class,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = contains , method , js_class = "Item" , catch)]
                                fn __TSB_contains(
                                    this: &Item_Class,
                                    point: Point,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = exportJSON , method , js_class = "Item" , catch)]
                                fn __TSB_export_json(
                                    this: &Item_Class,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<String, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = bringToFront , method , js_class = "Item" , catch)]
                                fn __TSB_bring_to_front(
                                    this: &Item_Class,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isAbove , method , js_class = "Item" , catch)]
                                fn __TSB_is_above(
                                    this: &Item_Class,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = removeOnDrag , method , js_class = "Item" , catch)]
                                fn __TSB_remove_on_drag(
                                    this: &Item_Class,
                                ) -> std::result::Result<(), JsValue>;
                                # [wasm_bindgen (method , structural , getter = data , js_class = "Item")]
                                fn data(this: &Item_Class) -> JsValue;
                                # [wasm_bindgen (method , structural , setter = data , js_class = "Item")]
                                fn set_data(this: &Item_Class, value: JsValue);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = importSVG , method , js_class = "Item" , catch)]
                                fn __TSB_import_svg(
                                    this: &Item_Class,
                                    svg: JsValue,
                                    on_load: JsValue,
                                ) -> std::result::Result<Item, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = hasShadow , method , js_class = "Item" , catch)]
                                fn __TSB_has_shadow(
                                    this: &Item_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                # [wasm_bindgen (method , structural , getter = selectedColor , js_class = "Item")]
                                fn selected_color(this: &Item_Class) -> ItemSelectedColor;
                                # [wasm_bindgen (method , structural , setter = selectedColor , js_class = "Item")]
                                fn set_selected_color(this: &Item_Class, value: ItemSelectedColor);
                                # [wasm_bindgen (method , structural , getter = className , js_class = "Item")]
                                fn class_name(this: &Item_Class) -> String;
                                # [wasm_bindgen (method , structural , setter = className , js_class = "Item")]
                                fn set_class_name(this: &Item_Class, value: String);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = exportSVG , method , js_class = "Item" , catch)]
                                fn __TSB_export_svg(
                                    this: &Item_Class,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = tweenTo , method , js_class = "Item" , catch)]
                                fn __TSB_tween_to(
                                    this: &Item_Class,
                                    to: std::collections::HashMap<String, JsValue>,
                                    options: JsValue,
                                ) -> std::result::Result<Tween, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isInside , method , js_class = "Item" , catch)]
                                fn __TSB_is_inside(
                                    this: &Item_Class,
                                    rect: Rectangle,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isEmpty , method , js_class = "Item" , catch)]
                                fn __TSB_is_empty(
                                    this: &Item_Class,
                                    recursively: bool,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = copyContent , method , js_class = "Item" , catch)]
                                fn __TSB_copy_content(
                                    this: &Item_Class,
                                    source: Item,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = rasterize , method , js_class = "Item" , catch)]
                                fn __TSB_rasterize(
                                    this: &Item_Class,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Raster, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = removeOnMove , method , js_class = "Item" , catch)]
                                fn __TSB_remove_on_move(
                                    this: &Item_Class,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = tweenFrom , method , js_class = "Item" , catch)]
                                fn __TSB_tween_from(
                                    this: &Item_Class,
                                    from: std::collections::HashMap<String, JsValue>,
                                    options: JsValue,
                                ) -> std::result::Result<Tween, JsValue>;
                                # [wasm_bindgen (method , structural , getter = opacity , js_class = "Item")]
                                fn opacity(this: &Item_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = opacity , js_class = "Item")]
                                fn set_opacity(this: &Item_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = dashOffset , js_class = "Item")]
                                fn dash_offset(this: &Item_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = dashOffset , js_class = "Item")]
                                fn set_dash_offset(this: &Item_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = removeChildren , method , js_class = "Item" , catch)]
                                fn __TSB_remove_children(
                                    this: &Item_Class,
                                    start: f64,
                                    end: f64,
                                ) -> std::result::Result<Vec<Item>, JsValue>;
                                # [wasm_bindgen (method , structural , getter = onMouseMove , js_class = "Item")]
                                fn on_mouse_move(this: &Item_Class) -> ItemOnMouseMove;
                                # [wasm_bindgen (method , structural , setter = onMouseMove , js_class = "Item")]
                                fn set_on_mouse_move(this: &Item_Class, value: ItemOnMouseMove);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = intersects , method , js_class = "Item" , catch)]
                                fn __TSB_intersects(
                                    this: &Item_Class,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>;
                                # [wasm_bindgen (method , structural , getter = pivot , js_class = "Item")]
                                fn pivot(this: &Item_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = pivot , js_class = "Item")]
                                fn set_pivot(this: &Item_Class, value: Point);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = copyTo , method , js_class = "Item" , catch)]
                                fn __TSB_copy_to(
                                    this: &Item_Class,
                                    owner: JsValue,
                                ) -> std::result::Result<JsValue, JsValue>;
                                # [wasm_bindgen (method , structural , getter = index , js_class = "Item")]
                                fn index(this: &Item_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = index , js_class = "Item")]
                                fn set_index(this: &Item_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = localToParent , method , js_class = "Item" , catch)]
                                fn __TSB_local_to_parent(
                                    this: &Item_Class,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                # [wasm_bindgen (method , structural , getter = strokeColor , js_class = "Item")]
                                fn stroke_color(this: &Item_Class) -> ItemStrokeColor;
                                # [wasm_bindgen (method , structural , setter = strokeColor , js_class = "Item")]
                                fn set_stroke_color(this: &Item_Class, value: ItemStrokeColor);
                                # [wasm_bindgen (method , structural , getter = layer , js_class = "Item")]
                                fn layer(this: &Item_Class) -> Layer;
                                # [wasm_bindgen (method , structural , setter = layer , js_class = "Item")]
                                fn set_layer(this: &Item_Class, value: Layer);
                                # [wasm_bindgen (method , structural , getter = strokeScaling , js_class = "Item")]
                                fn stroke_scaling(this: &Item_Class) -> bool;
                                # [wasm_bindgen (method , structural , setter = strokeScaling , js_class = "Item")]
                                fn set_stroke_scaling(this: &Item_Class, value: bool);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = fitBounds , method , js_class = "Item" , catch)]
                                fn __TSB_fit_bounds(
                                    this: &Item_Class,
                                    rectangle: Rectangle,
                                    fill: bool,
                                ) -> std::result::Result<(), JsValue>;
                                # [wasm_bindgen (method , structural , getter = miterLimit , js_class = "Item")]
                                fn miter_limit(this: &Item_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = miterLimit , js_class = "Item")]
                                fn set_miter_limit(this: &Item_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = removeOnDown , method , js_class = "Item" , catch)]
                                fn __TSB_remove_on_down(
                                    this: &Item_Class,
                                ) -> std::result::Result<(), JsValue>;
                            }
                            #[derive(std :: clone :: Clone)]
                            struct Item(pub Item_Class);
                            impl Item {
                                #[allow(dead_code)]
                                pub fn insert_below(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_insert_below(item)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn on_double_click(&self) -> ItemOnDoubleClick {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.on_double_click())
                                            .unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_on_double_click(&self, value: ItemOnDoubleClick) -> () {
                                    let result = self.0.set_on_double_click(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn view(&self) -> View {
                                    let result = self.0.view();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_view(&self, value: View) -> () {
                                    let result = self.0.set_view(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn blend_mode(&self) -> String {
                                    let result = self.0.blend_mode();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_blend_mode(&self, value: String) -> () {
                                    let result = self.0.set_blend_mode(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn name(&self) -> String {
                                    let result = self.0.name();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_name(&self, value: String) -> () {
                                    let result = self.0.set_name(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn project(&self) -> Project {
                                    let result = self.0.project();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_project(&self, value: Project) -> () {
                                    let result = self.0.set_project(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_child(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_is_child(item)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn global_matrix(&self) -> Matrix {
                                    let result = self.0.global_matrix();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_global_matrix(&self, value: Matrix) -> () {
                                    let result = self.0.set_global_matrix(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn on_mouse_leave(&self) -> ItemOnMouseLeave {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_leave())
                                            .unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_on_mouse_leave(&self, value: ItemOnMouseLeave) -> () {
                                    let result = self.0.set_on_mouse_leave(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn has_children(&self) -> std::result::Result<bool, JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_has_children()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn selected(&self) -> bool {
                                    let result = self.0.selected();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_selected(&self, value: bool) -> () {
                                    let result = self.0.set_selected(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn global_to_local(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_global_to_local(point)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn shadow_blur(&self) -> f64 {
                                    let result = self.0.shadow_blur();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_shadow_blur(&self, value: f64) -> () {
                                    let result = self.0.set_shadow_blur(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn children(&self) -> Vec<Item> {
                                    let result = self.0.children();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_children(&self, value: Vec<Item>) -> () {
                                    let result = self.0.set_children(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn replace_with(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_replace_with(item)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn import_json(
                                    &self,
                                    json: String,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_import_json(json)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn insert_child(
                                    &self,
                                    index: f64,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_insert_child(index, item)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn stroke_join(&self) -> String {
                                    let result = self.0.stroke_join();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_stroke_join(&self, value: String) -> () {
                                    let result = self.0.set_stroke_join(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn rotation(&self) -> f64 {
                                    let result = self.0.rotation();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_rotation(&self, value: f64) -> () {
                                    let result = self.0.set_rotation(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn scaling(&self) -> Point {
                                    let result = self.0.scaling();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_scaling(&self, value: Point) -> () {
                                    let result = self.0.set_scaling(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_ancestor(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_is_ancestor(item)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn emit(
                                    &self,
                                    type_: String,
                                    event: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_emit(type_, event)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_remove_on_up()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn add_to(
                                    &self,
                                    owner: ItemAddToParamsOwnerParam,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_add_to(
                                            ts_bindgen_rt::to_jsvalue(&owner)
                                                .map_err(ts_bindgen_rt::Error::from)?,
                                        )?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn stroke_cap(&self) -> String {
                                    let result = self.0.stroke_cap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_stroke_cap(&self, value: String) -> () {
                                    let result = self.0.set_stroke_cap(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn on_mouse_drag(&self) -> ItemOnMouseDrag {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_drag())
                                            .unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_on_mouse_drag(&self, value: ItemOnMouseDrag) -> () {
                                    let result = self.0.set_on_mouse_drag(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set(
                                    &self,
                                    props: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let result = std::result::Result::Ok(self.0.__TSB_set(props)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_reverse_children()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn matches(
                                    &self,
                                    name: String,
                                    compare: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_matches(name, compare)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn on_mouse_enter(&self) -> ItemOnMouseEnter {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_enter())
                                            .unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_on_mouse_enter(&self, value: ItemOnMouseEnter) -> () {
                                    let result = self.0.set_on_mouse_enter(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn shadow_offset(&self) -> Point {
                                    let result = self.0.shadow_offset();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_shadow_offset(&self, value: Point) -> () {
                                    let result = self.0.set_shadow_offset(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_has_stroke()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn view_matrix(&self) -> Matrix {
                                    let result = self.0.view_matrix();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_view_matrix(&self, value: Matrix) -> () {
                                    let result = self.0.set_view_matrix(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn on_frame(&self) -> ItemOnFrame {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.on_frame()).unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_on_frame(&self, value: ItemOnFrame) -> () {
                                    let result = self.0.set_on_frame(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn on_mouse_down(&self) -> ItemOnMouseDown {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_down())
                                            .unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_on_mouse_down(&self, value: ItemOnMouseDown) -> () {
                                    let result = self.0.set_on_mouse_down(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_sibling(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_is_sibling(item)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn local_to_global(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_local_to_global(point)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn first_child(&self) -> Item {
                                    let result = self.0.first_child();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_first_child(&self, value: Item) -> () {
                                    let result = self.0.set_first_child(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_send_to_back()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn clip_mask(&self) -> bool {
                                    let result = self.0.clip_mask();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_clip_mask(&self, value: bool) -> () {
                                    let result = self.0.set_clip_mask(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn next_sibling(&self) -> Item {
                                    let result = self.0.next_sibling();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_next_sibling(&self, value: Item) -> () {
                                    let result = self.0.set_next_sibling(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn off(
                                    &self,
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let result = std::result::Result::Ok(self.0.__TSB_off(object)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn rotate(
                                    &self,
                                    angle: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_rotate(angle, center)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn add_child(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_add_child(item)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_grouped_with(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_is_grouped_with(item)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn scale(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_scale(hor, ver, center)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn hit_test_all(
                                    &self,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Vec<HitResult>, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_hit_test_all(point, options)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn insert_children(
                                    &self,
                                    index: f64,
                                    items: Vec<Item>,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_insert_children(index, items)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn style(&self) -> Style {
                                    let result = self.0.style();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_style(&self, value: Style) -> () {
                                    let result = self.0.set_style(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn position(&self) -> Point {
                                    let result = self.0.position();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_position(&self, value: Point) -> () {
                                    let result = self.0.set_position(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn transform(
                                    &self,
                                    matrix: Matrix,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_transform(matrix)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn fill_color(&self) -> ItemFillColor {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.fill_color()).unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_fill_color(&self, value: ItemFillColor) -> () {
                                    let result = self.0.set_fill_color(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn matrix(&self) -> Matrix {
                                    let result = self.0.matrix();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_matrix(&self, value: Matrix) -> () {
                                    let result = self.0.set_matrix(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn id(&self) -> f64 {
                                    let result = self.0.id();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_id(&self, value: f64) -> () {
                                    let result = self.0.set_id(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn tween(
                                    &self,
                                    options: ItemTweenParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_tween(
                                            ts_bindgen_rt::to_jsvalue(&options)
                                                .map_err(ts_bindgen_rt::Error::from)?,
                                        )?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn reduce(
                                    &self,
                                    options: JsValue,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_reduce(options)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn internal_bounds(&self) -> Rectangle {
                                    let result = self.0.internal_bounds();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_internal_bounds(&self, value: Rectangle) -> () {
                                    let result = self.0.set_internal_bounds(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn fill_rule(&self) -> String {
                                    let result = self.0.fill_rule();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_fill_rule(&self, value: String) -> () {
                                    let result = self.0.set_fill_rule(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn shadow_color(&self) -> ItemShadowColor {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.shadow_color())
                                            .unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_shadow_color(&self, value: ItemShadowColor) -> () {
                                    let result = self.0.set_shadow_color(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn insert_above(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_insert_above(item)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn responds(
                                    &self,
                                    type_: String,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_responds(type_)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn handle_bounds(&self) -> Rectangle {
                                    let result = self.0.handle_bounds();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_handle_bounds(&self, value: Rectangle) -> () {
                                    let result = self.0.set_handle_bounds(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn skew(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_skew(hor, ver, center)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn on_click(&self) -> ItemOnClick {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.on_click()).unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_on_click(&self, value: ItemOnClick) -> () {
                                    let result = self.0.set_on_click(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_items(
                                    &self,
                                    options: ItemGetItemsParamsOptionsParam,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_items(
                                            ts_bindgen_rt::to_jsvalue(&options)
                                                .map_err(ts_bindgen_rt::Error::from)?,
                                        )?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_is_inserted()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_item(
                                    &self,
                                    options: ItemGetItemParamsOptionsParam,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_item(
                                            ts_bindgen_rt::to_jsvalue(&options)
                                                .map_err(ts_bindgen_rt::Error::from)?,
                                        )?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_has_fill()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn shear(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_shear(hor, ver, center)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn visible(&self) -> bool {
                                    let result = self.0.visible();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_visible(&self, value: bool) -> () {
                                    let result = self.0.set_visible(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn previous_sibling(&self) -> Item {
                                    let result = self.0.previous_sibling();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_previous_sibling(&self, value: Item) -> () {
                                    let result = self.0.set_previous_sibling(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn hit_test(
                                    &self,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<HitResult, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_hit_test(point, options)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_descendant(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_is_descendant(item)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn locked(&self) -> bool {
                                    let result = self.0.locked();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_locked(&self, value: bool) -> () {
                                    let result = self.0.set_locked(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_parent(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_is_parent(item)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn copy_attributes(
                                    &self,
                                    source: Item,
                                    exclude_matrix: bool,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_copy_attributes(source, exclude_matrix)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn last_child(&self) -> Item {
                                    let result = self.0.last_child();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_last_child(&self, value: Item) -> () {
                                    let result = self.0.set_last_child(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn stroke_width(&self) -> f64 {
                                    let result = self.0.stroke_width();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_stroke_width(&self, value: f64) -> () {
                                    let result = self.0.set_stroke_width(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn parent(&self) -> Item {
                                    let result = self.0.parent();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_parent(&self, value: Item) -> () {
                                    let result = self.0.set_parent(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn stroke_bounds(&self) -> Rectangle {
                                    let result = self.0.stroke_bounds();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_stroke_bounds(&self, value: Rectangle) -> () {
                                    let result = self.0.set_stroke_bounds(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn translate(
                                    &self,
                                    delta: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_translate(delta)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn remove(&self) -> std::result::Result<bool, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_remove()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn parent_to_local(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_parent_to_local(point)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn bounds(&self) -> Rectangle {
                                    let result = self.0.bounds();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_bounds(&self, value: Rectangle) -> () {
                                    let result = self.0.set_bounds(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn add_children(
                                    &self,
                                    items: Vec<Item>,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_add_children(items)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn dash_array(&self) -> Vec<f64> {
                                    let result = self.0.dash_array();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_dash_array(&self, value: Vec<f64>) -> () {
                                    let result = self.0.set_dash_array(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn on_mouse_up(&self) -> ItemOnMouseUp {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_up()).unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_on_mouse_up(&self, value: ItemOnMouseUp) -> () {
                                    let result = self.0.set_on_mouse_up(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn on(
                                    &self,
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let result = std::result::Result::Ok(self.0.__TSB_on(object)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn remove_on(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_remove_on(options)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_below(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_is_below(item)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn apply_matrix(&self) -> bool {
                                    let result = self.0.apply_matrix();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_apply_matrix(&self, value: bool) -> () {
                                    let result = self.0.set_apply_matrix(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn clone(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_clone(options)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn contains(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_contains(point)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn export_json(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<String, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_export_json(options)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_bring_to_front()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_above(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_is_above(item)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_remove_on_drag()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn data(&self) -> JsValue {
                                    let result = self.0.data();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_data(&self, value: JsValue) -> () {
                                    let result = self.0.set_data(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn import_svg(
                                    &self,
                                    svg: ItemImportSvgParamsSvgParam,
                                    on_load: JsValue,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_import_svg(
                                            ts_bindgen_rt::to_jsvalue(&svg)
                                                .map_err(ts_bindgen_rt::Error::from)?,
                                            on_load,
                                        )?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_has_shadow()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn selected_color(&self) -> ItemSelectedColor {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.selected_color())
                                            .unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_selected_color(&self, value: ItemSelectedColor) -> () {
                                    let result = self.0.set_selected_color(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn class_name(&self) -> String {
                                    let result = self.0.class_name();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_class_name(&self, value: String) -> () {
                                    let result = self.0.set_class_name(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn export_svg(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<ItemExportSvgReturn, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        ts_bindgen_rt::from_jsvalue(
                                            &self.0.__TSB_export_svg(options)?,
                                        )
                                        .unwrap(),
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn tween_to(
                                    &self,
                                    to: std::collections::HashMap<String, JsValue>,
                                    options: ItemTweenToParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_tween_to(
                                            to,
                                            ts_bindgen_rt::to_jsvalue(&options)
                                                .map_err(ts_bindgen_rt::Error::from)?,
                                        )?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_inside(
                                    &self,
                                    rect: Rectangle,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_is_inside(rect)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_empty(
                                    &self,
                                    recursively: bool,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_is_empty(recursively)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn copy_content(
                                    &self,
                                    source: Item,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_copy_content(source)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn rasterize(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Raster, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_rasterize(options)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_remove_on_move()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn tween_from(
                                    &self,
                                    from: std::collections::HashMap<String, JsValue>,
                                    options: ItemTweenFromParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_tween_from(
                                            from,
                                            ts_bindgen_rt::to_jsvalue(&options)
                                                .map_err(ts_bindgen_rt::Error::from)?,
                                        )?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn opacity(&self) -> f64 {
                                    let result = self.0.opacity();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_opacity(&self, value: f64) -> () {
                                    let result = self.0.set_opacity(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn dash_offset(&self) -> f64 {
                                    let result = self.0.dash_offset();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_dash_offset(&self, value: f64) -> () {
                                    let result = self.0.set_dash_offset(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn remove_children(
                                    &self,
                                    start: f64,
                                    end: f64,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_remove_children(start, end)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn on_mouse_move(&self) -> ItemOnMouseMove {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_move())
                                            .unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_on_mouse_move(&self, value: ItemOnMouseMove) -> () {
                                    let result = self.0.set_on_mouse_move(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn intersects(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_intersects(item)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn pivot(&self) -> Point {
                                    let result = self.0.pivot();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_pivot(&self, value: Point) -> () {
                                    let result = self.0.set_pivot(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn copy_to(
                                    &self,
                                    owner: ItemCopyToParamsOwnerParam,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_copy_to(
                                            ts_bindgen_rt::to_jsvalue(&owner)
                                                .map_err(ts_bindgen_rt::Error::from)?,
                                        )?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn index(&self) -> f64 {
                                    let result = self.0.index();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_index(&self, value: f64) -> () {
                                    let result = self.0.set_index(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn local_to_parent(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_local_to_parent(point)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn stroke_color(&self) -> ItemStrokeColor {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.stroke_color())
                                            .unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_stroke_color(&self, value: ItemStrokeColor) -> () {
                                    let result = self.0.set_stroke_color(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn layer(&self) -> Layer {
                                    let result = self.0.layer();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_layer(&self, value: Layer) -> () {
                                    let result = self.0.set_layer(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn stroke_scaling(&self) -> bool {
                                    let result = self.0.stroke_scaling();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_stroke_scaling(&self, value: bool) -> () {
                                    let result = self.0.set_stroke_scaling(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn fit_bounds(
                                    &self,
                                    rectangle: Rectangle,
                                    fill: bool,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_fit_bounds(rectangle, fill)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn miter_limit(&self) -> f64 {
                                    let result = self.0.miter_limit();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_miter_limit(&self, value: f64) -> () {
                                    let result = self.0.set_miter_limit(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_remove_on_down()?);
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for Item {
                                fn describe() {
                                    <Item_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for Item {
                                type Abi = <Item_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Item {
                                type Abi =
                                    <&'a Item_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for Item {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Item {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal: Item_Class =
                                        <Item_Class as serde::de::Deserialize>::deserialize(
                                            deserializer,
                                        )?;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait Item_Trait {
                                fn insert_below(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>;
                                fn on_double_click(&self) -> ItemOnDoubleClick;
                                fn set_on_double_click(&mut self, value: ItemOnDoubleClick) -> ();
                                fn view(&self) -> View;
                                fn set_view(&mut self, value: View) -> ();
                                fn blend_mode(&self) -> String;
                                fn set_blend_mode(&mut self, value: String) -> ();
                                fn name(&self) -> String;
                                fn set_name(&mut self, value: String) -> ();
                                fn project(&self) -> Project;
                                fn set_project(&mut self, value: Project) -> ();
                                fn is_child(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>;
                                fn global_matrix(&self) -> Matrix;
                                fn set_global_matrix(&mut self, value: Matrix) -> ();
                                fn on_mouse_leave(&self) -> ItemOnMouseLeave;
                                fn set_on_mouse_leave(&mut self, value: ItemOnMouseLeave) -> ();
                                fn has_children(&self) -> std::result::Result<bool, JsValue>;
                                fn selected(&self) -> bool;
                                fn set_selected(&mut self, value: bool) -> ();
                                fn global_to_local(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                fn shadow_blur(&self) -> f64;
                                fn set_shadow_blur(&mut self, value: f64) -> ();
                                fn children(&self) -> Vec<Item>;
                                fn set_children(&mut self, value: Vec<Item>) -> ();
                                fn replace_with(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>;
                                fn import_json(
                                    &self,
                                    json: String,
                                ) -> std::result::Result<Item, JsValue>;
                                fn insert_child(
                                    &self,
                                    index: f64,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>;
                                fn stroke_join(&self) -> String;
                                fn set_stroke_join(&mut self, value: String) -> ();
                                fn rotation(&self) -> f64;
                                fn set_rotation(&mut self, value: f64) -> ();
                                fn scaling(&self) -> Point;
                                fn set_scaling(&mut self, value: Point) -> ();
                                fn is_ancestor(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>;
                                fn emit(
                                    &self,
                                    type_: String,
                                    event: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>;
                                fn remove_on_up(&self) -> std::result::Result<(), JsValue>;
                                fn add_to(
                                    &self,
                                    owner: ItemAddToParamsOwnerParam,
                                ) -> std::result::Result<JsValue, JsValue>;
                                fn stroke_cap(&self) -> String;
                                fn set_stroke_cap(&mut self, value: String) -> ();
                                fn on_mouse_drag(&self) -> ItemOnMouseDrag;
                                fn set_on_mouse_drag(&mut self, value: ItemOnMouseDrag) -> ();
                                fn set(
                                    &self,
                                    props: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>;
                                fn reverse_children(&self) -> std::result::Result<(), JsValue>;
                                fn matches(
                                    &self,
                                    name: String,
                                    compare: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>;
                                fn on_mouse_enter(&self) -> ItemOnMouseEnter;
                                fn set_on_mouse_enter(&mut self, value: ItemOnMouseEnter) -> ();
                                fn shadow_offset(&self) -> Point;
                                fn set_shadow_offset(&mut self, value: Point) -> ();
                                fn has_stroke(&self) -> std::result::Result<bool, JsValue>;
                                fn view_matrix(&self) -> Matrix;
                                fn set_view_matrix(&mut self, value: Matrix) -> ();
                                fn on_frame(&self) -> ItemOnFrame;
                                fn set_on_frame(&mut self, value: ItemOnFrame) -> ();
                                fn on_mouse_down(&self) -> ItemOnMouseDown;
                                fn set_on_mouse_down(&mut self, value: ItemOnMouseDown) -> ();
                                fn is_sibling(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>;
                                fn local_to_global(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                fn first_child(&self) -> Item;
                                fn set_first_child(&mut self, value: Item) -> ();
                                fn send_to_back(&self) -> std::result::Result<(), JsValue>;
                                fn clip_mask(&self) -> bool;
                                fn set_clip_mask(&mut self, value: bool) -> ();
                                fn next_sibling(&self) -> Item;
                                fn set_next_sibling(&mut self, value: Item) -> ();
                                fn off(
                                    &self,
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>;
                                fn rotate(
                                    &self,
                                    angle: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>;
                                fn add_child(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>;
                                fn is_grouped_with(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>;
                                fn scale(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>;
                                fn hit_test_all(
                                    &self,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Vec<HitResult>, JsValue>;
                                fn insert_children(
                                    &self,
                                    index: f64,
                                    items: Vec<Item>,
                                ) -> std::result::Result<Vec<Item>, JsValue>;
                                fn style(&self) -> Style;
                                fn set_style(&mut self, value: Style) -> ();
                                fn position(&self) -> Point;
                                fn set_position(&mut self, value: Point) -> ();
                                fn transform(
                                    &self,
                                    matrix: Matrix,
                                ) -> std::result::Result<(), JsValue>;
                                fn fill_color(&self) -> ItemFillColor;
                                fn set_fill_color(&mut self, value: ItemFillColor) -> ();
                                fn matrix(&self) -> Matrix;
                                fn set_matrix(&mut self, value: Matrix) -> ();
                                fn id(&self) -> f64;
                                fn set_id(&mut self, value: f64) -> ();
                                fn tween(
                                    &self,
                                    options: ItemTweenParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>;
                                fn reduce(
                                    &self,
                                    options: JsValue,
                                ) -> std::result::Result<Item, JsValue>;
                                fn internal_bounds(&self) -> Rectangle;
                                fn set_internal_bounds(&mut self, value: Rectangle) -> ();
                                fn fill_rule(&self) -> String;
                                fn set_fill_rule(&mut self, value: String) -> ();
                                fn shadow_color(&self) -> ItemShadowColor;
                                fn set_shadow_color(&mut self, value: ItemShadowColor) -> ();
                                fn insert_above(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>;
                                fn responds(
                                    &self,
                                    type_: String,
                                ) -> std::result::Result<bool, JsValue>;
                                fn handle_bounds(&self) -> Rectangle;
                                fn set_handle_bounds(&mut self, value: Rectangle) -> ();
                                fn skew(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>;
                                fn on_click(&self) -> ItemOnClick;
                                fn set_on_click(&mut self, value: ItemOnClick) -> ();
                                fn get_items(
                                    &self,
                                    options: ItemGetItemsParamsOptionsParam,
                                ) -> std::result::Result<Vec<Item>, JsValue>;
                                fn is_inserted(&self) -> std::result::Result<bool, JsValue>;
                                fn get_item(
                                    &self,
                                    options: ItemGetItemParamsOptionsParam,
                                ) -> std::result::Result<Item, JsValue>;
                                fn has_fill(&self) -> std::result::Result<bool, JsValue>;
                                fn shear(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>;
                                fn visible(&self) -> bool;
                                fn set_visible(&mut self, value: bool) -> ();
                                fn previous_sibling(&self) -> Item;
                                fn set_previous_sibling(&mut self, value: Item) -> ();
                                fn hit_test(
                                    &self,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<HitResult, JsValue>;
                                fn is_descendant(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>;
                                fn locked(&self) -> bool;
                                fn set_locked(&mut self, value: bool) -> ();
                                fn is_parent(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>;
                                fn copy_attributes(
                                    &self,
                                    source: Item,
                                    exclude_matrix: bool,
                                ) -> std::result::Result<(), JsValue>;
                                fn last_child(&self) -> Item;
                                fn set_last_child(&mut self, value: Item) -> ();
                                fn stroke_width(&self) -> f64;
                                fn set_stroke_width(&mut self, value: f64) -> ();
                                fn parent(&self) -> Item;
                                fn set_parent(&mut self, value: Item) -> ();
                                fn stroke_bounds(&self) -> Rectangle;
                                fn set_stroke_bounds(&mut self, value: Rectangle) -> ();
                                fn translate(
                                    &self,
                                    delta: Point,
                                ) -> std::result::Result<(), JsValue>;
                                fn remove(&self) -> std::result::Result<bool, JsValue>;
                                fn parent_to_local(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                fn bounds(&self) -> Rectangle;
                                fn set_bounds(&mut self, value: Rectangle) -> ();
                                fn add_children(
                                    &self,
                                    items: Vec<Item>,
                                ) -> std::result::Result<Vec<Item>, JsValue>;
                                fn dash_array(&self) -> Vec<f64>;
                                fn set_dash_array(&mut self, value: Vec<f64>) -> ();
                                fn on_mouse_up(&self) -> ItemOnMouseUp;
                                fn set_on_mouse_up(&mut self, value: ItemOnMouseUp) -> ();
                                fn on(
                                    &self,
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>;
                                fn remove_on(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<(), JsValue>;
                                fn is_below(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>;
                                fn apply_matrix(&self) -> bool;
                                fn set_apply_matrix(&mut self, value: bool) -> ();
                                fn clone(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>;
                                fn contains(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<bool, JsValue>;
                                fn export_json(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<String, JsValue>;
                                fn bring_to_front(&self) -> std::result::Result<(), JsValue>;
                                fn is_above(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>;
                                fn remove_on_drag(&self) -> std::result::Result<(), JsValue>;
                                fn data(&self) -> JsValue;
                                fn set_data(&mut self, value: JsValue) -> ();
                                fn import_svg(
                                    &self,
                                    svg: ItemImportSvgParamsSvgParam,
                                    on_load: JsValue,
                                ) -> std::result::Result<Item, JsValue>;
                                fn has_shadow(&self) -> std::result::Result<bool, JsValue>;
                                fn selected_color(&self) -> ItemSelectedColor;
                                fn set_selected_color(&mut self, value: ItemSelectedColor) -> ();
                                fn class_name(&self) -> String;
                                fn set_class_name(&mut self, value: String) -> ();
                                fn export_svg(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<ItemExportSvgReturn, JsValue>;
                                fn tween_to(
                                    &self,
                                    to: std::collections::HashMap<String, JsValue>,
                                    options: ItemTweenToParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>;
                                fn is_inside(
                                    &self,
                                    rect: Rectangle,
                                ) -> std::result::Result<bool, JsValue>;
                                fn is_empty(
                                    &self,
                                    recursively: bool,
                                ) -> std::result::Result<bool, JsValue>;
                                fn copy_content(
                                    &self,
                                    source: Item,
                                ) -> std::result::Result<(), JsValue>;
                                fn rasterize(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Raster, JsValue>;
                                fn remove_on_move(&self) -> std::result::Result<(), JsValue>;
                                fn tween_from(
                                    &self,
                                    from: std::collections::HashMap<String, JsValue>,
                                    options: ItemTweenFromParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>;
                                fn opacity(&self) -> f64;
                                fn set_opacity(&mut self, value: f64) -> ();
                                fn dash_offset(&self) -> f64;
                                fn set_dash_offset(&mut self, value: f64) -> ();
                                fn remove_children(
                                    &self,
                                    start: f64,
                                    end: f64,
                                ) -> std::result::Result<Vec<Item>, JsValue>;
                                fn on_mouse_move(&self) -> ItemOnMouseMove;
                                fn set_on_mouse_move(&mut self, value: ItemOnMouseMove) -> ();
                                fn intersects(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>;
                                fn pivot(&self) -> Point;
                                fn set_pivot(&mut self, value: Point) -> ();
                                fn copy_to(
                                    &self,
                                    owner: ItemCopyToParamsOwnerParam,
                                ) -> std::result::Result<JsValue, JsValue>;
                                fn index(&self) -> f64;
                                fn set_index(&mut self, value: f64) -> ();
                                fn local_to_parent(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                fn stroke_color(&self) -> ItemStrokeColor;
                                fn set_stroke_color(&mut self, value: ItemStrokeColor) -> ();
                                fn layer(&self) -> Layer;
                                fn set_layer(&mut self, value: Layer) -> ();
                                fn stroke_scaling(&self) -> bool;
                                fn set_stroke_scaling(&mut self, value: bool) -> ();
                                fn fit_bounds(
                                    &self,
                                    rectangle: Rectangle,
                                    fill: bool,
                                ) -> std::result::Result<(), JsValue>;
                                fn miter_limit(&self) -> f64;
                                fn set_miter_limit(&mut self, value: f64) -> ();
                                fn remove_on_down(&self) -> std::result::Result<(), JsValue>;
                            }
                            impl std::clone::Clone for Item_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for Item_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Item_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                # [wasm_bindgen (js_name = "Group" , extends = Item_Class)]
                                type Group_Class;
                                # [wasm_bindgen (method , structural , getter = clipped , js_class = "Group")]
                                fn clipped(this: &Group_Class) -> bool;
                                # [wasm_bindgen (method , structural , setter = clipped , js_class = "Group")]
                                fn set_clipped(this: &Group_Class, value: bool);
                                #[wasm_bindgen(constructor, js_class = "Group")]
                                pub fn new(
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> Group_Class;
                            }
                            #[derive(std :: clone :: Clone)]
                            struct Group(pub Group_Class);
                            impl std::convert::From<&Group> for Item {
                                fn from(src: &Group) -> Item {
                                    let src: &Item_Class = src.0.as_ref();
                                    Item(src.clone())
                                }
                            }
                            impl std::convert::From<&mut Group> for Item {
                                fn from(src: &mut Group) -> Item {
                                    let src: &Item_Class = src.0.as_ref();
                                    Item(src.clone())
                                }
                            }
                            impl Group {
                                #[allow(dead_code)]
                                pub fn clipped(&self) -> bool {
                                    let result = self.0.clipped();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_clipped(&self, value: bool) -> () {
                                    let result = self.0.set_clipped(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn new(
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> Group {
                                    let result = Group_Class::new(object);
                                    let result =
                                        ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result)
                                            .unwrap();
                                    Group(result)
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for Group {
                                fn describe() {
                                    <Group_Class as wasm_bindgen::describe::WasmDescribe>::describe(
                                    )
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for Group {
                                type Abi = <Group_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Group {
                                type Abi =
                                    <&'a Group_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for Group {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Group {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal: Group_Class =
                                        <Group_Class as serde::de::Deserialize>::deserialize(
                                            deserializer,
                                        )?;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait Group_Trait: Item_Trait {
                                fn clipped(&self) -> bool;
                                fn set_clipped(&mut self, value: bool) -> ();
                                fn new(object: std::collections::HashMap<String, JsValue>)
                                    -> Group;
                            }
                            impl Item_Trait for Group {
                                fn insert_below(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_below(&target, item)
                                }
                                fn on_double_click(&self) -> ItemOnDoubleClick {
                                    let target: Item = self.into();
                                    Item::on_double_click(&target)
                                }
                                fn set_on_double_click(&mut self, value: ItemOnDoubleClick) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_double_click(&mut target, value)
                                }
                                fn view(&self) -> View {
                                    let target: Item = self.into();
                                    Item::view(&target)
                                }
                                fn set_view(&mut self, value: View) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_view(&mut target, value)
                                }
                                fn blend_mode(&self) -> String {
                                    let target: Item = self.into();
                                    Item::blend_mode(&target)
                                }
                                fn set_blend_mode(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_blend_mode(&mut target, value)
                                }
                                fn name(&self) -> String {
                                    let target: Item = self.into();
                                    Item::name(&target)
                                }
                                fn set_name(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_name(&mut target, value)
                                }
                                fn project(&self) -> Project {
                                    let target: Item = self.into();
                                    Item::project(&target)
                                }
                                fn set_project(&mut self, value: Project) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_project(&mut target, value)
                                }
                                fn is_child(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_child(&target, item)
                                }
                                fn global_matrix(&self) -> Matrix {
                                    let target: Item = self.into();
                                    Item::global_matrix(&target)
                                }
                                fn set_global_matrix(&mut self, value: Matrix) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_global_matrix(&mut target, value)
                                }
                                fn on_mouse_leave(&self) -> ItemOnMouseLeave {
                                    let target: Item = self.into();
                                    Item::on_mouse_leave(&target)
                                }
                                fn set_on_mouse_leave(&mut self, value: ItemOnMouseLeave) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_leave(&mut target, value)
                                }
                                fn has_children(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_children(&target)
                                }
                                fn selected(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::selected(&target)
                                }
                                fn set_selected(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_selected(&mut target, value)
                                }
                                fn global_to_local(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::global_to_local(&target, point)
                                }
                                fn shadow_blur(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::shadow_blur(&target)
                                }
                                fn set_shadow_blur(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_shadow_blur(&mut target, value)
                                }
                                fn children(&self) -> Vec<Item> {
                                    let target: Item = self.into();
                                    Item::children(&target)
                                }
                                fn set_children(&mut self, value: Vec<Item>) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_children(&mut target, value)
                                }
                                fn replace_with(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::replace_with(&target, item)
                                }
                                fn import_json(
                                    &self,
                                    json: String,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::import_json(&target, json)
                                }
                                fn insert_child(
                                    &self,
                                    index: f64,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_child(&target, index, item)
                                }
                                fn stroke_join(&self) -> String {
                                    let target: Item = self.into();
                                    Item::stroke_join(&target)
                                }
                                fn set_stroke_join(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_join(&mut target, value)
                                }
                                fn rotation(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::rotation(&target)
                                }
                                fn set_rotation(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_rotation(&mut target, value)
                                }
                                fn scaling(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::scaling(&target)
                                }
                                fn set_scaling(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_scaling(&mut target, value)
                                }
                                fn is_ancestor(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_ancestor(&target, item)
                                }
                                fn emit(
                                    &self,
                                    type_: String,
                                    event: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::emit(&target, type_, event)
                                }
                                fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_up(&target)
                                }
                                fn add_to(
                                    &self,
                                    owner: ItemAddToParamsOwnerParam,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::add_to(&target, owner)
                                }
                                fn stroke_cap(&self) -> String {
                                    let target: Item = self.into();
                                    Item::stroke_cap(&target)
                                }
                                fn set_stroke_cap(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_cap(&mut target, value)
                                }
                                fn on_mouse_drag(&self) -> ItemOnMouseDrag {
                                    let target: Item = self.into();
                                    Item::on_mouse_drag(&target)
                                }
                                fn set_on_mouse_drag(&mut self, value: ItemOnMouseDrag) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_drag(&mut target, value)
                                }
                                fn set(
                                    &self,
                                    props: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::set(&target, props)
                                }
                                fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::reverse_children(&target)
                                }
                                fn matches(
                                    &self,
                                    name: String,
                                    compare: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::matches(&target, name, compare)
                                }
                                fn on_mouse_enter(&self) -> ItemOnMouseEnter {
                                    let target: Item = self.into();
                                    Item::on_mouse_enter(&target)
                                }
                                fn set_on_mouse_enter(&mut self, value: ItemOnMouseEnter) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_enter(&mut target, value)
                                }
                                fn shadow_offset(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::shadow_offset(&target)
                                }
                                fn set_shadow_offset(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_shadow_offset(&mut target, value)
                                }
                                fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_stroke(&target)
                                }
                                fn view_matrix(&self) -> Matrix {
                                    let target: Item = self.into();
                                    Item::view_matrix(&target)
                                }
                                fn set_view_matrix(&mut self, value: Matrix) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_view_matrix(&mut target, value)
                                }
                                fn on_frame(&self) -> ItemOnFrame {
                                    let target: Item = self.into();
                                    Item::on_frame(&target)
                                }
                                fn set_on_frame(&mut self, value: ItemOnFrame) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_frame(&mut target, value)
                                }
                                fn on_mouse_down(&self) -> ItemOnMouseDown {
                                    let target: Item = self.into();
                                    Item::on_mouse_down(&target)
                                }
                                fn set_on_mouse_down(&mut self, value: ItemOnMouseDown) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_down(&mut target, value)
                                }
                                fn is_sibling(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_sibling(&target, item)
                                }
                                fn local_to_global(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::local_to_global(&target, point)
                                }
                                fn first_child(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::first_child(&target)
                                }
                                fn set_first_child(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_first_child(&mut target, value)
                                }
                                fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::send_to_back(&target)
                                }
                                fn clip_mask(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::clip_mask(&target)
                                }
                                fn set_clip_mask(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_clip_mask(&mut target, value)
                                }
                                fn next_sibling(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::next_sibling(&target)
                                }
                                fn set_next_sibling(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_next_sibling(&mut target, value)
                                }
                                fn off(
                                    &self,
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::off(&target, object)
                                }
                                fn rotate(
                                    &self,
                                    angle: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::rotate(&target, angle, center)
                                }
                                fn add_child(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::add_child(&target, item)
                                }
                                fn is_grouped_with(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_grouped_with(&target, item)
                                }
                                fn scale(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::scale(&target, hor, ver, center)
                                }
                                fn hit_test_all(
                                    &self,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Vec<HitResult>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::hit_test_all(&target, point, options)
                                }
                                fn insert_children(
                                    &self,
                                    index: f64,
                                    items: Vec<Item>,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_children(&target, index, items)
                                }
                                fn style(&self) -> Style {
                                    let target: Item = self.into();
                                    Item::style(&target)
                                }
                                fn set_style(&mut self, value: Style) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_style(&mut target, value)
                                }
                                fn position(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::position(&target)
                                }
                                fn set_position(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_position(&mut target, value)
                                }
                                fn transform(
                                    &self,
                                    matrix: Matrix,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::transform(&target, matrix)
                                }
                                fn fill_color(&self) -> ItemFillColor {
                                    let target: Item = self.into();
                                    Item::fill_color(&target)
                                }
                                fn set_fill_color(&mut self, value: ItemFillColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_fill_color(&mut target, value)
                                }
                                fn matrix(&self) -> Matrix {
                                    let target: Item = self.into();
                                    Item::matrix(&target)
                                }
                                fn set_matrix(&mut self, value: Matrix) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_matrix(&mut target, value)
                                }
                                fn id(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::id(&target)
                                }
                                fn set_id(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_id(&mut target, value)
                                }
                                fn tween(
                                    &self,
                                    options: ItemTweenParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::tween(&target, options)
                                }
                                fn reduce(
                                    &self,
                                    options: JsValue,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::reduce(&target, options)
                                }
                                fn internal_bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::internal_bounds(&target)
                                }
                                fn set_internal_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_internal_bounds(&mut target, value)
                                }
                                fn fill_rule(&self) -> String {
                                    let target: Item = self.into();
                                    Item::fill_rule(&target)
                                }
                                fn set_fill_rule(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_fill_rule(&mut target, value)
                                }
                                fn shadow_color(&self) -> ItemShadowColor {
                                    let target: Item = self.into();
                                    Item::shadow_color(&target)
                                }
                                fn set_shadow_color(&mut self, value: ItemShadowColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_shadow_color(&mut target, value)
                                }
                                fn insert_above(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_above(&target, item)
                                }
                                fn responds(
                                    &self,
                                    type_: String,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::responds(&target, type_)
                                }
                                fn handle_bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::handle_bounds(&target)
                                }
                                fn set_handle_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_handle_bounds(&mut target, value)
                                }
                                fn skew(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::skew(&target, hor, ver, center)
                                }
                                fn on_click(&self) -> ItemOnClick {
                                    let target: Item = self.into();
                                    Item::on_click(&target)
                                }
                                fn set_on_click(&mut self, value: ItemOnClick) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_click(&mut target, value)
                                }
                                fn get_items(
                                    &self,
                                    options: ItemGetItemsParamsOptionsParam,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::get_items(&target, options)
                                }
                                fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::is_inserted(&target)
                                }
                                fn get_item(
                                    &self,
                                    options: ItemGetItemParamsOptionsParam,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::get_item(&target, options)
                                }
                                fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_fill(&target)
                                }
                                fn shear(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::shear(&target, hor, ver, center)
                                }
                                fn visible(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::visible(&target)
                                }
                                fn set_visible(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_visible(&mut target, value)
                                }
                                fn previous_sibling(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::previous_sibling(&target)
                                }
                                fn set_previous_sibling(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_previous_sibling(&mut target, value)
                                }
                                fn hit_test(
                                    &self,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<HitResult, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::hit_test(&target, point, options)
                                }
                                fn is_descendant(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_descendant(&target, item)
                                }
                                fn locked(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::locked(&target)
                                }
                                fn set_locked(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_locked(&mut target, value)
                                }
                                fn is_parent(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_parent(&target, item)
                                }
                                fn copy_attributes(
                                    &self,
                                    source: Item,
                                    exclude_matrix: bool,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::copy_attributes(&target, source, exclude_matrix)
                                }
                                fn last_child(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::last_child(&target)
                                }
                                fn set_last_child(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_last_child(&mut target, value)
                                }
                                fn stroke_width(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::stroke_width(&target)
                                }
                                fn set_stroke_width(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_width(&mut target, value)
                                }
                                fn parent(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::parent(&target)
                                }
                                fn set_parent(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_parent(&mut target, value)
                                }
                                fn stroke_bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::stroke_bounds(&target)
                                }
                                fn set_stroke_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_bounds(&mut target, value)
                                }
                                fn translate(
                                    &self,
                                    delta: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::translate(&target, delta)
                                }
                                fn remove(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::remove(&target)
                                }
                                fn parent_to_local(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::parent_to_local(&target, point)
                                }
                                fn bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::bounds(&target)
                                }
                                fn set_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_bounds(&mut target, value)
                                }
                                fn add_children(
                                    &self,
                                    items: Vec<Item>,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::add_children(&target, items)
                                }
                                fn dash_array(&self) -> Vec<f64> {
                                    let target: Item = self.into();
                                    Item::dash_array(&target)
                                }
                                fn set_dash_array(&mut self, value: Vec<f64>) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_dash_array(&mut target, value)
                                }
                                fn on_mouse_up(&self) -> ItemOnMouseUp {
                                    let target: Item = self.into();
                                    Item::on_mouse_up(&target)
                                }
                                fn set_on_mouse_up(&mut self, value: ItemOnMouseUp) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_up(&mut target, value)
                                }
                                fn on(
                                    &self,
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::on(&target, object)
                                }
                                fn remove_on(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::remove_on(&target, options)
                                }
                                fn is_below(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_below(&target, item)
                                }
                                fn apply_matrix(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::apply_matrix(&target)
                                }
                                fn set_apply_matrix(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_apply_matrix(&mut target, value)
                                }
                                fn clone(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::clone(&target, options)
                                }
                                fn contains(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::contains(&target, point)
                                }
                                fn export_json(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<String, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::export_json(&target, options)
                                }
                                fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::bring_to_front(&target)
                                }
                                fn is_above(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_above(&target, item)
                                }
                                fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_drag(&target)
                                }
                                fn data(&self) -> JsValue {
                                    let target: Item = self.into();
                                    Item::data(&target)
                                }
                                fn set_data(&mut self, value: JsValue) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_data(&mut target, value)
                                }
                                fn import_svg(
                                    &self,
                                    svg: ItemImportSvgParamsSvgParam,
                                    on_load: JsValue,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::import_svg(&target, svg, on_load)
                                }
                                fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_shadow(&target)
                                }
                                fn selected_color(&self) -> ItemSelectedColor {
                                    let target: Item = self.into();
                                    Item::selected_color(&target)
                                }
                                fn set_selected_color(&mut self, value: ItemSelectedColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_selected_color(&mut target, value)
                                }
                                fn class_name(&self) -> String {
                                    let target: Item = self.into();
                                    Item::class_name(&target)
                                }
                                fn set_class_name(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_class_name(&mut target, value)
                                }
                                fn export_svg(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<ItemExportSvgReturn, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::export_svg(&target, options)
                                }
                                fn tween_to(
                                    &self,
                                    to: std::collections::HashMap<String, JsValue>,
                                    options: ItemTweenToParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::tween_to(&target, to, options)
                                }
                                fn is_inside(
                                    &self,
                                    rect: Rectangle,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_inside(&target, rect)
                                }
                                fn is_empty(
                                    &self,
                                    recursively: bool,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_empty(&target, recursively)
                                }
                                fn copy_content(
                                    &self,
                                    source: Item,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::copy_content(&target, source)
                                }
                                fn rasterize(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Raster, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::rasterize(&target, options)
                                }
                                fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_move(&target)
                                }
                                fn tween_from(
                                    &self,
                                    from: std::collections::HashMap<String, JsValue>,
                                    options: ItemTweenFromParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::tween_from(&target, from, options)
                                }
                                fn opacity(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::opacity(&target)
                                }
                                fn set_opacity(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_opacity(&mut target, value)
                                }
                                fn dash_offset(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::dash_offset(&target)
                                }
                                fn set_dash_offset(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_dash_offset(&mut target, value)
                                }
                                fn remove_children(
                                    &self,
                                    start: f64,
                                    end: f64,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::remove_children(&target, start, end)
                                }
                                fn on_mouse_move(&self) -> ItemOnMouseMove {
                                    let target: Item = self.into();
                                    Item::on_mouse_move(&target)
                                }
                                fn set_on_mouse_move(&mut self, value: ItemOnMouseMove) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_move(&mut target, value)
                                }
                                fn intersects(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::intersects(&target, item)
                                }
                                fn pivot(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::pivot(&target)
                                }
                                fn set_pivot(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_pivot(&mut target, value)
                                }
                                fn copy_to(
                                    &self,
                                    owner: ItemCopyToParamsOwnerParam,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::copy_to(&target, owner)
                                }
                                fn index(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::index(&target)
                                }
                                fn set_index(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_index(&mut target, value)
                                }
                                fn local_to_parent(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::local_to_parent(&target, point)
                                }
                                fn stroke_color(&self) -> ItemStrokeColor {
                                    let target: Item = self.into();
                                    Item::stroke_color(&target)
                                }
                                fn set_stroke_color(&mut self, value: ItemStrokeColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_color(&mut target, value)
                                }
                                fn layer(&self) -> Layer {
                                    let target: Item = self.into();
                                    Item::layer(&target)
                                }
                                fn set_layer(&mut self, value: Layer) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_layer(&mut target, value)
                                }
                                fn stroke_scaling(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::stroke_scaling(&target)
                                }
                                fn set_stroke_scaling(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_scaling(&mut target, value)
                                }
                                fn fit_bounds(
                                    &self,
                                    rectangle: Rectangle,
                                    fill: bool,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::fit_bounds(&target, rectangle, fill)
                                }
                                fn miter_limit(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::miter_limit(&target)
                                }
                                fn set_miter_limit(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_miter_limit(&mut target, value)
                                }
                                fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_down(&target)
                                }
                            }
                            impl Group_Trait for Group {}
                            impl std::clone::Clone for Group_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for Group_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Group_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                #[wasm_bindgen(js_name = "PaperScript")]
                                type PaperScript_Class;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = execute , method , js_class = "PaperScript" , catch)]
                                fn __TSB_execute(
                                    this: &PaperScript_Class,
                                    code: String,
                                    scope: PaperScope,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<
                                    std::collections::HashMap<String, JsValue>,
                                    JsValue,
                                >;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = compile , method , js_class = "PaperScript" , catch)]
                                fn __TSB_compile(
                                    this: &PaperScript_Class,
                                    code: String,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<
                                    std::collections::HashMap<String, JsValue>,
                                    JsValue,
                                >;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = load , method , js_class = "PaperScript" , catch)]
                                fn __TSB_load(
                                    this: &PaperScript_Class,
                                    script: JsValue,
                                ) -> std::result::Result<PaperScope, JsValue>;
                            }
                            #[derive(std :: clone :: Clone)]
                            struct PaperScript(pub PaperScript_Class);
                            impl PaperScript {
                                #[allow(dead_code)]
                                pub fn execute(
                                    &self,
                                    code: String,
                                    scope: PaperScope,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<
                                    std::collections::HashMap<String, JsValue>,
                                    JsValue,
                                > {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_execute(code, scope, options)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn compile(
                                    &self,
                                    code: String,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<
                                    std::collections::HashMap<String, JsValue>,
                                    JsValue,
                                > {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_compile(code, options)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn load(
                                    &self,
                                    script: JsValue,
                                ) -> std::result::Result<PaperScope, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_load(script)?);
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for PaperScript {
                                fn describe() {
                                    < PaperScript_Class as wasm_bindgen :: describe :: WasmDescribe > :: describe ()
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for PaperScript {
                                type Abi =
                                    <PaperScript_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a PaperScript {
                                type Abi = < & 'a PaperScript_Class as wasm_bindgen :: convert :: IntoWasmAbi > :: Abi ;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for PaperScript {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for PaperScript {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal: PaperScript_Class =
                                        <PaperScript_Class as serde::de::Deserialize>::deserialize(
                                            deserializer,
                                        )?;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait PaperScript_Trait {
                                fn execute(
                                    &self,
                                    code: String,
                                    scope: PaperScope,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<
                                    std::collections::HashMap<String, JsValue>,
                                    JsValue,
                                >;
                                fn compile(
                                    &self,
                                    code: String,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<
                                    std::collections::HashMap<String, JsValue>,
                                    JsValue,
                                >;
                                fn load(
                                    &self,
                                    script: JsValue,
                                ) -> std::result::Result<PaperScope, JsValue>;
                            }
                            impl std::clone::Clone for PaperScript_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for PaperScript_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for PaperScript_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                # [wasm_bindgen (js_name = "TextItem" , extends = Item_Class)]
                                type TextItem_Class;
                                # [wasm_bindgen (method , structural , getter = content , js_class = "TextItem")]
                                fn content(this: &TextItem_Class) -> String;
                                # [wasm_bindgen (method , structural , setter = content , js_class = "TextItem")]
                                fn set_content(this: &TextItem_Class, value: String);
                                # [wasm_bindgen (method , structural , getter = justification , js_class = "TextItem")]
                                fn justification(this: &TextItem_Class) -> String;
                                # [wasm_bindgen (method , structural , setter = justification , js_class = "TextItem")]
                                fn set_justification(this: &TextItem_Class, value: String);
                                # [wasm_bindgen (method , structural , getter = fontSize , js_class = "TextItem")]
                                fn font_size(this: &TextItem_Class) -> TextItemFontSize;
                                # [wasm_bindgen (method , structural , setter = fontSize , js_class = "TextItem")]
                                fn set_font_size(this: &TextItem_Class, value: TextItemFontSize);
                                # [wasm_bindgen (method , structural , getter = fontWeight , js_class = "TextItem")]
                                fn font_weight(this: &TextItem_Class) -> TextItemFontWeight;
                                # [wasm_bindgen (method , structural , setter = fontWeight , js_class = "TextItem")]
                                fn set_font_weight(
                                    this: &TextItem_Class,
                                    value: TextItemFontWeight,
                                );
                                # [wasm_bindgen (method , structural , getter = fontFamily , js_class = "TextItem")]
                                fn font_family(this: &TextItem_Class) -> String;
                                # [wasm_bindgen (method , structural , setter = fontFamily , js_class = "TextItem")]
                                fn set_font_family(this: &TextItem_Class, value: String);
                                # [wasm_bindgen (method , structural , getter = leading , js_class = "TextItem")]
                                fn leading(this: &TextItem_Class) -> TextItemLeading;
                                # [wasm_bindgen (method , structural , setter = leading , js_class = "TextItem")]
                                fn set_leading(this: &TextItem_Class, value: TextItemLeading);
                            }
                            #[derive(std :: clone :: Clone)]
                            struct TextItem(pub TextItem_Class);
                            impl std::convert::From<&TextItem> for Item {
                                fn from(src: &TextItem) -> Item {
                                    let src: &Item_Class = src.0.as_ref();
                                    Item(src.clone())
                                }
                            }
                            impl std::convert::From<&mut TextItem> for Item {
                                fn from(src: &mut TextItem) -> Item {
                                    let src: &Item_Class = src.0.as_ref();
                                    Item(src.clone())
                                }
                            }
                            impl TextItem {
                                #[allow(dead_code)]
                                pub fn content(&self) -> String {
                                    let result = self.0.content();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_content(&self, value: String) -> () {
                                    let result = self.0.set_content(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn justification(&self) -> String {
                                    let result = self.0.justification();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_justification(&self, value: String) -> () {
                                    let result = self.0.set_justification(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn font_size(&self) -> TextItemFontSize {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.font_size()).unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_font_size(&self, value: TextItemFontSize) -> () {
                                    let result = self.0.set_font_size(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn font_weight(&self) -> TextItemFontWeight {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.font_weight()).unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_font_weight(&self, value: TextItemFontWeight) -> () {
                                    let result = self.0.set_font_weight(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn font_family(&self) -> String {
                                    let result = self.0.font_family();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_font_family(&self, value: String) -> () {
                                    let result = self.0.set_font_family(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn leading(&self) -> TextItemLeading {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.leading()).unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_leading(&self, value: TextItemLeading) -> () {
                                    let result = self.0.set_leading(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for TextItem {
                                fn describe() {
                                    < TextItem_Class as wasm_bindgen :: describe :: WasmDescribe > :: describe ()
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for TextItem {
                                type Abi =
                                    <TextItem_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a TextItem {
                                type Abi =
                                    <&'a TextItem_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for TextItem {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for TextItem {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal: TextItem_Class =
                                        <TextItem_Class as serde::de::Deserialize>::deserialize(
                                            deserializer,
                                        )?;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait TextItem_Trait: Item_Trait {
                                fn content(&self) -> String;
                                fn set_content(&mut self, value: String) -> ();
                                fn justification(&self) -> String;
                                fn set_justification(&mut self, value: String) -> ();
                                fn font_size(&self) -> TextItemFontSize;
                                fn set_font_size(&mut self, value: TextItemFontSize) -> ();
                                fn font_weight(&self) -> TextItemFontWeight;
                                fn set_font_weight(&mut self, value: TextItemFontWeight) -> ();
                                fn font_family(&self) -> String;
                                fn set_font_family(&mut self, value: String) -> ();
                                fn leading(&self) -> TextItemLeading;
                                fn set_leading(&mut self, value: TextItemLeading) -> ();
                            }
                            impl Item_Trait for TextItem {
                                fn insert_below(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_below(&target, item)
                                }
                                fn on_double_click(&self) -> ItemOnDoubleClick {
                                    let target: Item = self.into();
                                    Item::on_double_click(&target)
                                }
                                fn set_on_double_click(&mut self, value: ItemOnDoubleClick) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_double_click(&mut target, value)
                                }
                                fn view(&self) -> View {
                                    let target: Item = self.into();
                                    Item::view(&target)
                                }
                                fn set_view(&mut self, value: View) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_view(&mut target, value)
                                }
                                fn blend_mode(&self) -> String {
                                    let target: Item = self.into();
                                    Item::blend_mode(&target)
                                }
                                fn set_blend_mode(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_blend_mode(&mut target, value)
                                }
                                fn name(&self) -> String {
                                    let target: Item = self.into();
                                    Item::name(&target)
                                }
                                fn set_name(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_name(&mut target, value)
                                }
                                fn project(&self) -> Project {
                                    let target: Item = self.into();
                                    Item::project(&target)
                                }
                                fn set_project(&mut self, value: Project) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_project(&mut target, value)
                                }
                                fn is_child(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_child(&target, item)
                                }
                                fn global_matrix(&self) -> Matrix {
                                    let target: Item = self.into();
                                    Item::global_matrix(&target)
                                }
                                fn set_global_matrix(&mut self, value: Matrix) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_global_matrix(&mut target, value)
                                }
                                fn on_mouse_leave(&self) -> ItemOnMouseLeave {
                                    let target: Item = self.into();
                                    Item::on_mouse_leave(&target)
                                }
                                fn set_on_mouse_leave(&mut self, value: ItemOnMouseLeave) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_leave(&mut target, value)
                                }
                                fn has_children(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_children(&target)
                                }
                                fn selected(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::selected(&target)
                                }
                                fn set_selected(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_selected(&mut target, value)
                                }
                                fn global_to_local(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::global_to_local(&target, point)
                                }
                                fn shadow_blur(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::shadow_blur(&target)
                                }
                                fn set_shadow_blur(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_shadow_blur(&mut target, value)
                                }
                                fn children(&self) -> Vec<Item> {
                                    let target: Item = self.into();
                                    Item::children(&target)
                                }
                                fn set_children(&mut self, value: Vec<Item>) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_children(&mut target, value)
                                }
                                fn replace_with(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::replace_with(&target, item)
                                }
                                fn import_json(
                                    &self,
                                    json: String,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::import_json(&target, json)
                                }
                                fn insert_child(
                                    &self,
                                    index: f64,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_child(&target, index, item)
                                }
                                fn stroke_join(&self) -> String {
                                    let target: Item = self.into();
                                    Item::stroke_join(&target)
                                }
                                fn set_stroke_join(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_join(&mut target, value)
                                }
                                fn rotation(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::rotation(&target)
                                }
                                fn set_rotation(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_rotation(&mut target, value)
                                }
                                fn scaling(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::scaling(&target)
                                }
                                fn set_scaling(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_scaling(&mut target, value)
                                }
                                fn is_ancestor(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_ancestor(&target, item)
                                }
                                fn emit(
                                    &self,
                                    type_: String,
                                    event: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::emit(&target, type_, event)
                                }
                                fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_up(&target)
                                }
                                fn add_to(
                                    &self,
                                    owner: ItemAddToParamsOwnerParam,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::add_to(&target, owner)
                                }
                                fn stroke_cap(&self) -> String {
                                    let target: Item = self.into();
                                    Item::stroke_cap(&target)
                                }
                                fn set_stroke_cap(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_cap(&mut target, value)
                                }
                                fn on_mouse_drag(&self) -> ItemOnMouseDrag {
                                    let target: Item = self.into();
                                    Item::on_mouse_drag(&target)
                                }
                                fn set_on_mouse_drag(&mut self, value: ItemOnMouseDrag) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_drag(&mut target, value)
                                }
                                fn set(
                                    &self,
                                    props: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::set(&target, props)
                                }
                                fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::reverse_children(&target)
                                }
                                fn matches(
                                    &self,
                                    name: String,
                                    compare: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::matches(&target, name, compare)
                                }
                                fn on_mouse_enter(&self) -> ItemOnMouseEnter {
                                    let target: Item = self.into();
                                    Item::on_mouse_enter(&target)
                                }
                                fn set_on_mouse_enter(&mut self, value: ItemOnMouseEnter) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_enter(&mut target, value)
                                }
                                fn shadow_offset(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::shadow_offset(&target)
                                }
                                fn set_shadow_offset(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_shadow_offset(&mut target, value)
                                }
                                fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_stroke(&target)
                                }
                                fn view_matrix(&self) -> Matrix {
                                    let target: Item = self.into();
                                    Item::view_matrix(&target)
                                }
                                fn set_view_matrix(&mut self, value: Matrix) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_view_matrix(&mut target, value)
                                }
                                fn on_frame(&self) -> ItemOnFrame {
                                    let target: Item = self.into();
                                    Item::on_frame(&target)
                                }
                                fn set_on_frame(&mut self, value: ItemOnFrame) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_frame(&mut target, value)
                                }
                                fn on_mouse_down(&self) -> ItemOnMouseDown {
                                    let target: Item = self.into();
                                    Item::on_mouse_down(&target)
                                }
                                fn set_on_mouse_down(&mut self, value: ItemOnMouseDown) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_down(&mut target, value)
                                }
                                fn is_sibling(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_sibling(&target, item)
                                }
                                fn local_to_global(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::local_to_global(&target, point)
                                }
                                fn first_child(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::first_child(&target)
                                }
                                fn set_first_child(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_first_child(&mut target, value)
                                }
                                fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::send_to_back(&target)
                                }
                                fn clip_mask(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::clip_mask(&target)
                                }
                                fn set_clip_mask(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_clip_mask(&mut target, value)
                                }
                                fn next_sibling(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::next_sibling(&target)
                                }
                                fn set_next_sibling(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_next_sibling(&mut target, value)
                                }
                                fn off(
                                    &self,
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::off(&target, object)
                                }
                                fn rotate(
                                    &self,
                                    angle: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::rotate(&target, angle, center)
                                }
                                fn add_child(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::add_child(&target, item)
                                }
                                fn is_grouped_with(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_grouped_with(&target, item)
                                }
                                fn scale(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::scale(&target, hor, ver, center)
                                }
                                fn hit_test_all(
                                    &self,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Vec<HitResult>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::hit_test_all(&target, point, options)
                                }
                                fn insert_children(
                                    &self,
                                    index: f64,
                                    items: Vec<Item>,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_children(&target, index, items)
                                }
                                fn style(&self) -> Style {
                                    let target: Item = self.into();
                                    Item::style(&target)
                                }
                                fn set_style(&mut self, value: Style) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_style(&mut target, value)
                                }
                                fn position(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::position(&target)
                                }
                                fn set_position(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_position(&mut target, value)
                                }
                                fn transform(
                                    &self,
                                    matrix: Matrix,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::transform(&target, matrix)
                                }
                                fn fill_color(&self) -> ItemFillColor {
                                    let target: Item = self.into();
                                    Item::fill_color(&target)
                                }
                                fn set_fill_color(&mut self, value: ItemFillColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_fill_color(&mut target, value)
                                }
                                fn matrix(&self) -> Matrix {
                                    let target: Item = self.into();
                                    Item::matrix(&target)
                                }
                                fn set_matrix(&mut self, value: Matrix) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_matrix(&mut target, value)
                                }
                                fn id(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::id(&target)
                                }
                                fn set_id(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_id(&mut target, value)
                                }
                                fn tween(
                                    &self,
                                    options: ItemTweenParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::tween(&target, options)
                                }
                                fn reduce(
                                    &self,
                                    options: JsValue,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::reduce(&target, options)
                                }
                                fn internal_bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::internal_bounds(&target)
                                }
                                fn set_internal_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_internal_bounds(&mut target, value)
                                }
                                fn fill_rule(&self) -> String {
                                    let target: Item = self.into();
                                    Item::fill_rule(&target)
                                }
                                fn set_fill_rule(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_fill_rule(&mut target, value)
                                }
                                fn shadow_color(&self) -> ItemShadowColor {
                                    let target: Item = self.into();
                                    Item::shadow_color(&target)
                                }
                                fn set_shadow_color(&mut self, value: ItemShadowColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_shadow_color(&mut target, value)
                                }
                                fn insert_above(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_above(&target, item)
                                }
                                fn responds(
                                    &self,
                                    type_: String,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::responds(&target, type_)
                                }
                                fn handle_bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::handle_bounds(&target)
                                }
                                fn set_handle_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_handle_bounds(&mut target, value)
                                }
                                fn skew(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::skew(&target, hor, ver, center)
                                }
                                fn on_click(&self) -> ItemOnClick {
                                    let target: Item = self.into();
                                    Item::on_click(&target)
                                }
                                fn set_on_click(&mut self, value: ItemOnClick) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_click(&mut target, value)
                                }
                                fn get_items(
                                    &self,
                                    options: ItemGetItemsParamsOptionsParam,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::get_items(&target, options)
                                }
                                fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::is_inserted(&target)
                                }
                                fn get_item(
                                    &self,
                                    options: ItemGetItemParamsOptionsParam,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::get_item(&target, options)
                                }
                                fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_fill(&target)
                                }
                                fn shear(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::shear(&target, hor, ver, center)
                                }
                                fn visible(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::visible(&target)
                                }
                                fn set_visible(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_visible(&mut target, value)
                                }
                                fn previous_sibling(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::previous_sibling(&target)
                                }
                                fn set_previous_sibling(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_previous_sibling(&mut target, value)
                                }
                                fn hit_test(
                                    &self,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<HitResult, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::hit_test(&target, point, options)
                                }
                                fn is_descendant(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_descendant(&target, item)
                                }
                                fn locked(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::locked(&target)
                                }
                                fn set_locked(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_locked(&mut target, value)
                                }
                                fn is_parent(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_parent(&target, item)
                                }
                                fn copy_attributes(
                                    &self,
                                    source: Item,
                                    exclude_matrix: bool,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::copy_attributes(&target, source, exclude_matrix)
                                }
                                fn last_child(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::last_child(&target)
                                }
                                fn set_last_child(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_last_child(&mut target, value)
                                }
                                fn stroke_width(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::stroke_width(&target)
                                }
                                fn set_stroke_width(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_width(&mut target, value)
                                }
                                fn parent(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::parent(&target)
                                }
                                fn set_parent(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_parent(&mut target, value)
                                }
                                fn stroke_bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::stroke_bounds(&target)
                                }
                                fn set_stroke_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_bounds(&mut target, value)
                                }
                                fn translate(
                                    &self,
                                    delta: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::translate(&target, delta)
                                }
                                fn remove(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::remove(&target)
                                }
                                fn parent_to_local(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::parent_to_local(&target, point)
                                }
                                fn bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::bounds(&target)
                                }
                                fn set_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_bounds(&mut target, value)
                                }
                                fn add_children(
                                    &self,
                                    items: Vec<Item>,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::add_children(&target, items)
                                }
                                fn dash_array(&self) -> Vec<f64> {
                                    let target: Item = self.into();
                                    Item::dash_array(&target)
                                }
                                fn set_dash_array(&mut self, value: Vec<f64>) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_dash_array(&mut target, value)
                                }
                                fn on_mouse_up(&self) -> ItemOnMouseUp {
                                    let target: Item = self.into();
                                    Item::on_mouse_up(&target)
                                }
                                fn set_on_mouse_up(&mut self, value: ItemOnMouseUp) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_up(&mut target, value)
                                }
                                fn on(
                                    &self,
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::on(&target, object)
                                }
                                fn remove_on(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::remove_on(&target, options)
                                }
                                fn is_below(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_below(&target, item)
                                }
                                fn apply_matrix(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::apply_matrix(&target)
                                }
                                fn set_apply_matrix(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_apply_matrix(&mut target, value)
                                }
                                fn clone(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::clone(&target, options)
                                }
                                fn contains(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::contains(&target, point)
                                }
                                fn export_json(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<String, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::export_json(&target, options)
                                }
                                fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::bring_to_front(&target)
                                }
                                fn is_above(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_above(&target, item)
                                }
                                fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_drag(&target)
                                }
                                fn data(&self) -> JsValue {
                                    let target: Item = self.into();
                                    Item::data(&target)
                                }
                                fn set_data(&mut self, value: JsValue) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_data(&mut target, value)
                                }
                                fn import_svg(
                                    &self,
                                    svg: ItemImportSvgParamsSvgParam,
                                    on_load: JsValue,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::import_svg(&target, svg, on_load)
                                }
                                fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_shadow(&target)
                                }
                                fn selected_color(&self) -> ItemSelectedColor {
                                    let target: Item = self.into();
                                    Item::selected_color(&target)
                                }
                                fn set_selected_color(&mut self, value: ItemSelectedColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_selected_color(&mut target, value)
                                }
                                fn class_name(&self) -> String {
                                    let target: Item = self.into();
                                    Item::class_name(&target)
                                }
                                fn set_class_name(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_class_name(&mut target, value)
                                }
                                fn export_svg(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<ItemExportSvgReturn, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::export_svg(&target, options)
                                }
                                fn tween_to(
                                    &self,
                                    to: std::collections::HashMap<String, JsValue>,
                                    options: ItemTweenToParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::tween_to(&target, to, options)
                                }
                                fn is_inside(
                                    &self,
                                    rect: Rectangle,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_inside(&target, rect)
                                }
                                fn is_empty(
                                    &self,
                                    recursively: bool,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_empty(&target, recursively)
                                }
                                fn copy_content(
                                    &self,
                                    source: Item,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::copy_content(&target, source)
                                }
                                fn rasterize(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Raster, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::rasterize(&target, options)
                                }
                                fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_move(&target)
                                }
                                fn tween_from(
                                    &self,
                                    from: std::collections::HashMap<String, JsValue>,
                                    options: ItemTweenFromParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::tween_from(&target, from, options)
                                }
                                fn opacity(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::opacity(&target)
                                }
                                fn set_opacity(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_opacity(&mut target, value)
                                }
                                fn dash_offset(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::dash_offset(&target)
                                }
                                fn set_dash_offset(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_dash_offset(&mut target, value)
                                }
                                fn remove_children(
                                    &self,
                                    start: f64,
                                    end: f64,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::remove_children(&target, start, end)
                                }
                                fn on_mouse_move(&self) -> ItemOnMouseMove {
                                    let target: Item = self.into();
                                    Item::on_mouse_move(&target)
                                }
                                fn set_on_mouse_move(&mut self, value: ItemOnMouseMove) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_move(&mut target, value)
                                }
                                fn intersects(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::intersects(&target, item)
                                }
                                fn pivot(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::pivot(&target)
                                }
                                fn set_pivot(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_pivot(&mut target, value)
                                }
                                fn copy_to(
                                    &self,
                                    owner: ItemCopyToParamsOwnerParam,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::copy_to(&target, owner)
                                }
                                fn index(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::index(&target)
                                }
                                fn set_index(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_index(&mut target, value)
                                }
                                fn local_to_parent(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::local_to_parent(&target, point)
                                }
                                fn stroke_color(&self) -> ItemStrokeColor {
                                    let target: Item = self.into();
                                    Item::stroke_color(&target)
                                }
                                fn set_stroke_color(&mut self, value: ItemStrokeColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_color(&mut target, value)
                                }
                                fn layer(&self) -> Layer {
                                    let target: Item = self.into();
                                    Item::layer(&target)
                                }
                                fn set_layer(&mut self, value: Layer) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_layer(&mut target, value)
                                }
                                fn stroke_scaling(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::stroke_scaling(&target)
                                }
                                fn set_stroke_scaling(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_scaling(&mut target, value)
                                }
                                fn fit_bounds(
                                    &self,
                                    rectangle: Rectangle,
                                    fill: bool,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::fit_bounds(&target, rectangle, fill)
                                }
                                fn miter_limit(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::miter_limit(&target)
                                }
                                fn set_miter_limit(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_miter_limit(&mut target, value)
                                }
                                fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_down(&target)
                                }
                            }
                            impl TextItem_Trait for TextItem {}
                            impl std::clone::Clone for TextItem_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for TextItem_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for TextItem_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                #[wasm_bindgen(js_name = "Size")]
                                type Size_Class;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = subtract , method , js_class = "Size" , catch)]
                                fn __TSB_subtract(
                                    this: &Size_Class,
                                    size: Size,
                                ) -> std::result::Result<Size, JsValue>;
                                #[wasm_bindgen(constructor, js_class = "Size")]
                                pub fn new(
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> Size_Class;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = clone , method , js_class = "Size" , catch)]
                                fn __TSB_clone(
                                    this: &Size_Class,
                                ) -> std::result::Result<Size, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = min , method , js_class = "Size" , catch)]
                                fn __TSB_min(
                                    this: &Size_Class,
                                    size1: Size,
                                    size2: Size,
                                ) -> std::result::Result<Size, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = multiply , method , js_class = "Size" , catch)]
                                fn __TSB_multiply(
                                    this: &Size_Class,
                                    size: Size,
                                ) -> std::result::Result<Size, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isNaN , method , js_class = "Size" , catch)]
                                fn __TSB_is_na_n(
                                    this: &Size_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = ceil , method , js_class = "Size" , catch)]
                                fn __TSB_ceil(
                                    this: &Size_Class,
                                ) -> std::result::Result<Size, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isZero , method , js_class = "Size" , catch)]
                                fn __TSB_is_zero(
                                    this: &Size_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = random , method , js_class = "Size" , catch)]
                                fn __TSB_random(
                                    this: &Size_Class,
                                ) -> std::result::Result<Size, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = set , method , js_class = "Size" , catch , variadic)]
                                fn __TSB_set(
                                    this: &Size_Class,
                                    values: &[JsValue],
                                ) -> std::result::Result<Size, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = round , method , js_class = "Size" , catch)]
                                fn __TSB_round(
                                    this: &Size_Class,
                                ) -> std::result::Result<Size, JsValue>;
                                # [wasm_bindgen (method , structural , getter = width , js_class = "Size")]
                                fn width(this: &Size_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = width , js_class = "Size")]
                                fn set_width(this: &Size_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = modulo , method , js_class = "Size" , catch)]
                                fn __TSB_modulo(
                                    this: &Size_Class,
                                    size: Size,
                                ) -> std::result::Result<Size, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = add , method , js_class = "Size" , catch)]
                                fn __TSB_add(
                                    this: &Size_Class,
                                    size: Size,
                                ) -> std::result::Result<Size, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = max , method , js_class = "Size" , catch)]
                                fn __TSB_max(
                                    this: &Size_Class,
                                    size1: Size,
                                    size2: Size,
                                ) -> std::result::Result<Size, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = floor , method , js_class = "Size" , catch)]
                                fn __TSB_floor(
                                    this: &Size_Class,
                                ) -> std::result::Result<Size, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = divide , method , js_class = "Size" , catch)]
                                fn __TSB_divide(
                                    this: &Size_Class,
                                    size: Size,
                                ) -> std::result::Result<Size, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = toString , method , js_class = "Size" , catch)]
                                fn __TSB_to_string(
                                    this: &Size_Class,
                                ) -> std::result::Result<String, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = abs , method , js_class = "Size" , catch)]
                                fn __TSB_abs(
                                    this: &Size_Class,
                                ) -> std::result::Result<Size, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = equals , method , js_class = "Size" , catch)]
                                fn __TSB_equals(
                                    this: &Size_Class,
                                    size: Size,
                                ) -> std::result::Result<bool, JsValue>;
                                # [wasm_bindgen (method , structural , getter = height , js_class = "Size")]
                                fn height(this: &Size_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = height , js_class = "Size")]
                                fn set_height(this: &Size_Class, value: f64);
                            }
                            #[derive(std :: clone :: Clone)]
                            struct Size(pub Size_Class);
                            impl Size {
                                #[allow(dead_code)]
                                pub fn subtract(
                                    &self,
                                    size: Size,
                                ) -> std::result::Result<Size, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_subtract(size)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn new(
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> Size {
                                    let result = Size_Class::new(object);
                                    let result =
                                        ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result)
                                            .unwrap();
                                    Size(result)
                                }
                                #[allow(dead_code)]
                                pub fn clone(&self) -> std::result::Result<Size, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_clone()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn min(
                                    &self,
                                    size1: Size,
                                    size2: Size,
                                ) -> std::result::Result<Size, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_min(size1, size2)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn multiply(
                                    &self,
                                    size: Size,
                                ) -> std::result::Result<Size, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_multiply(size)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_na_n(&self) -> std::result::Result<bool, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_is_na_n()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn ceil(&self) -> std::result::Result<Size, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_ceil()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_zero(&self) -> std::result::Result<bool, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_is_zero()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn random(&self) -> std::result::Result<Size, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_random()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set(
                                    &self,
                                    values: &[JsValue],
                                ) -> std::result::Result<Size, JsValue>
                                {
                                    let result = std::result::Result::Ok(self.0.__TSB_set(values)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn round(&self) -> std::result::Result<Size, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_round()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn width(&self) -> f64 {
                                    let result = self.0.width();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_width(&self, value: f64) -> () {
                                    let result = self.0.set_width(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn modulo(
                                    &self,
                                    size: Size,
                                ) -> std::result::Result<Size, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_modulo(size)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn add(
                                    &self,
                                    size: Size,
                                ) -> std::result::Result<Size, JsValue>
                                {
                                    let result = std::result::Result::Ok(self.0.__TSB_add(size)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn max(
                                    &self,
                                    size1: Size,
                                    size2: Size,
                                ) -> std::result::Result<Size, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_max(size1, size2)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn floor(&self) -> std::result::Result<Size, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_floor()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn divide(
                                    &self,
                                    size: Size,
                                ) -> std::result::Result<Size, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_divide(size)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_to_string()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn abs(&self) -> std::result::Result<Size, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_abs()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn equals(
                                    &self,
                                    size: Size,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_equals(size)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn height(&self) -> f64 {
                                    let result = self.0.height();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_height(&self, value: f64) -> () {
                                    let result = self.0.set_height(value);
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for Size {
                                fn describe() {
                                    <Size_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for Size {
                                type Abi = <Size_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Size {
                                type Abi =
                                    <&'a Size_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for Size {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Size {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal: Size_Class =
                                        <Size_Class as serde::de::Deserialize>::deserialize(
                                            deserializer,
                                        )?;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait Size_Trait {
                                fn subtract(
                                    &self,
                                    size: Size,
                                ) -> std::result::Result<Size, JsValue>;
                                fn new(object: std::collections::HashMap<String, JsValue>) -> Size;
                                fn clone(&self) -> std::result::Result<Size, JsValue>;
                                fn min(
                                    &self,
                                    size1: Size,
                                    size2: Size,
                                ) -> std::result::Result<Size, JsValue>;
                                fn multiply(
                                    &self,
                                    size: Size,
                                ) -> std::result::Result<Size, JsValue>;
                                fn is_na_n(&self) -> std::result::Result<bool, JsValue>;
                                fn ceil(&self) -> std::result::Result<Size, JsValue>;
                                fn is_zero(&self) -> std::result::Result<bool, JsValue>;
                                fn random(&self) -> std::result::Result<Size, JsValue>;
                                fn set(
                                    &self,
                                    values: &[JsValue],
                                ) -> std::result::Result<Size, JsValue>;
                                fn round(&self) -> std::result::Result<Size, JsValue>;
                                fn width(&self) -> f64;
                                fn set_width(&mut self, value: f64) -> ();
                                fn modulo(&self, size: Size) -> std::result::Result<Size, JsValue>;
                                fn add(&self, size: Size) -> std::result::Result<Size, JsValue>;
                                fn max(
                                    &self,
                                    size1: Size,
                                    size2: Size,
                                ) -> std::result::Result<Size, JsValue>;
                                fn floor(&self) -> std::result::Result<Size, JsValue>;
                                fn divide(&self, size: Size) -> std::result::Result<Size, JsValue>;
                                fn to_string(&self) -> std::result::Result<String, JsValue>;
                                fn abs(&self) -> std::result::Result<Size, JsValue>;
                                fn equals(&self, size: Size) -> std::result::Result<bool, JsValue>;
                                fn height(&self) -> f64;
                                fn set_height(&mut self, value: f64) -> ();
                            }
                            impl std::clone::Clone for Size_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for Size_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Size_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                # [wasm_bindgen (js_name = "PointText" , extends = TextItem_Class)]
                                type PointText_Class;
                                #[wasm_bindgen(constructor, js_class = "PointText")]
                                pub fn new(
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> PointText_Class;
                                # [wasm_bindgen (method , structural , getter = point , js_class = "PointText")]
                                fn point(this: &PointText_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = point , js_class = "PointText")]
                                fn set_point(this: &PointText_Class, value: Point);
                            }
                            #[derive(std :: clone :: Clone)]
                            struct PointText(pub PointText_Class);
                            impl std::convert::From<&PointText> for TextItem {
                                fn from(src: &PointText) -> TextItem {
                                    let src: &TextItem_Class = src.0.as_ref();
                                    TextItem(src.clone())
                                }
                            }
                            impl std::convert::From<&mut PointText> for TextItem {
                                fn from(src: &mut PointText) -> TextItem {
                                    let src: &TextItem_Class = src.0.as_ref();
                                    TextItem(src.clone())
                                }
                            }
                            impl PointText {
                                #[allow(dead_code)]
                                pub fn new(
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> PointText {
                                    let result = PointText_Class::new(object);
                                    let result =
                                        ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result)
                                            .unwrap();
                                    PointText(result)
                                }
                                #[allow(dead_code)]
                                pub fn point(&self) -> Point {
                                    let result = self.0.point();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_point(&self, value: Point) -> () {
                                    let result = self.0.set_point(value);
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for PointText {
                                fn describe() {
                                    < PointText_Class as wasm_bindgen :: describe :: WasmDescribe > :: describe ()
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for PointText {
                                type Abi =
                                    <PointText_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a PointText {
                                type Abi = < & 'a PointText_Class as wasm_bindgen :: convert :: IntoWasmAbi > :: Abi ;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for PointText {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for PointText {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal: PointText_Class =
                                        <PointText_Class as serde::de::Deserialize>::deserialize(
                                            deserializer,
                                        )?;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait PointText_Trait: TextItem_Trait {
                                fn new(
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> PointText;
                                fn point(&self) -> Point;
                                fn set_point(&mut self, value: Point) -> ();
                            }
                            impl TextItem_Trait for PointText
                            where
                                PointText: Item_Trait,
                            {
                                fn content(&self) -> String {
                                    let target: TextItem = self.into();
                                    TextItem::content(&target)
                                }
                                fn set_content(&mut self, value: String) -> () {
                                    let mut target: TextItem = self.into();
                                    TextItem::set_content(&mut target, value)
                                }
                                fn justification(&self) -> String {
                                    let target: TextItem = self.into();
                                    TextItem::justification(&target)
                                }
                                fn set_justification(&mut self, value: String) -> () {
                                    let mut target: TextItem = self.into();
                                    TextItem::set_justification(&mut target, value)
                                }
                                fn font_size(&self) -> TextItemFontSize {
                                    let target: TextItem = self.into();
                                    TextItem::font_size(&target)
                                }
                                fn set_font_size(&mut self, value: TextItemFontSize) -> () {
                                    let mut target: TextItem = self.into();
                                    TextItem::set_font_size(&mut target, value)
                                }
                                fn font_weight(&self) -> TextItemFontWeight {
                                    let target: TextItem = self.into();
                                    TextItem::font_weight(&target)
                                }
                                fn set_font_weight(&mut self, value: TextItemFontWeight) -> () {
                                    let mut target: TextItem = self.into();
                                    TextItem::set_font_weight(&mut target, value)
                                }
                                fn font_family(&self) -> String {
                                    let target: TextItem = self.into();
                                    TextItem::font_family(&target)
                                }
                                fn set_font_family(&mut self, value: String) -> () {
                                    let mut target: TextItem = self.into();
                                    TextItem::set_font_family(&mut target, value)
                                }
                                fn leading(&self) -> TextItemLeading {
                                    let target: TextItem = self.into();
                                    TextItem::leading(&target)
                                }
                                fn set_leading(&mut self, value: TextItemLeading) -> () {
                                    let mut target: TextItem = self.into();
                                    TextItem::set_leading(&mut target, value)
                                }
                            }
                            impl Item_Trait for PointText {
                                fn insert_below(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_below(&target, item)
                                }
                                fn on_double_click(&self) -> ItemOnDoubleClick {
                                    let target: Item = self.into();
                                    Item::on_double_click(&target)
                                }
                                fn set_on_double_click(&mut self, value: ItemOnDoubleClick) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_double_click(&mut target, value)
                                }
                                fn view(&self) -> View {
                                    let target: Item = self.into();
                                    Item::view(&target)
                                }
                                fn set_view(&mut self, value: View) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_view(&mut target, value)
                                }
                                fn blend_mode(&self) -> String {
                                    let target: Item = self.into();
                                    Item::blend_mode(&target)
                                }
                                fn set_blend_mode(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_blend_mode(&mut target, value)
                                }
                                fn name(&self) -> String {
                                    let target: Item = self.into();
                                    Item::name(&target)
                                }
                                fn set_name(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_name(&mut target, value)
                                }
                                fn project(&self) -> Project {
                                    let target: Item = self.into();
                                    Item::project(&target)
                                }
                                fn set_project(&mut self, value: Project) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_project(&mut target, value)
                                }
                                fn is_child(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_child(&target, item)
                                }
                                fn global_matrix(&self) -> Matrix {
                                    let target: Item = self.into();
                                    Item::global_matrix(&target)
                                }
                                fn set_global_matrix(&mut self, value: Matrix) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_global_matrix(&mut target, value)
                                }
                                fn on_mouse_leave(&self) -> ItemOnMouseLeave {
                                    let target: Item = self.into();
                                    Item::on_mouse_leave(&target)
                                }
                                fn set_on_mouse_leave(&mut self, value: ItemOnMouseLeave) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_leave(&mut target, value)
                                }
                                fn has_children(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_children(&target)
                                }
                                fn selected(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::selected(&target)
                                }
                                fn set_selected(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_selected(&mut target, value)
                                }
                                fn global_to_local(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::global_to_local(&target, point)
                                }
                                fn shadow_blur(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::shadow_blur(&target)
                                }
                                fn set_shadow_blur(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_shadow_blur(&mut target, value)
                                }
                                fn children(&self) -> Vec<Item> {
                                    let target: Item = self.into();
                                    Item::children(&target)
                                }
                                fn set_children(&mut self, value: Vec<Item>) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_children(&mut target, value)
                                }
                                fn replace_with(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::replace_with(&target, item)
                                }
                                fn import_json(
                                    &self,
                                    json: String,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::import_json(&target, json)
                                }
                                fn insert_child(
                                    &self,
                                    index: f64,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_child(&target, index, item)
                                }
                                fn stroke_join(&self) -> String {
                                    let target: Item = self.into();
                                    Item::stroke_join(&target)
                                }
                                fn set_stroke_join(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_join(&mut target, value)
                                }
                                fn rotation(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::rotation(&target)
                                }
                                fn set_rotation(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_rotation(&mut target, value)
                                }
                                fn scaling(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::scaling(&target)
                                }
                                fn set_scaling(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_scaling(&mut target, value)
                                }
                                fn is_ancestor(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_ancestor(&target, item)
                                }
                                fn emit(
                                    &self,
                                    type_: String,
                                    event: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::emit(&target, type_, event)
                                }
                                fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_up(&target)
                                }
                                fn add_to(
                                    &self,
                                    owner: ItemAddToParamsOwnerParam,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::add_to(&target, owner)
                                }
                                fn stroke_cap(&self) -> String {
                                    let target: Item = self.into();
                                    Item::stroke_cap(&target)
                                }
                                fn set_stroke_cap(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_cap(&mut target, value)
                                }
                                fn on_mouse_drag(&self) -> ItemOnMouseDrag {
                                    let target: Item = self.into();
                                    Item::on_mouse_drag(&target)
                                }
                                fn set_on_mouse_drag(&mut self, value: ItemOnMouseDrag) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_drag(&mut target, value)
                                }
                                fn set(
                                    &self,
                                    props: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::set(&target, props)
                                }
                                fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::reverse_children(&target)
                                }
                                fn matches(
                                    &self,
                                    name: String,
                                    compare: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::matches(&target, name, compare)
                                }
                                fn on_mouse_enter(&self) -> ItemOnMouseEnter {
                                    let target: Item = self.into();
                                    Item::on_mouse_enter(&target)
                                }
                                fn set_on_mouse_enter(&mut self, value: ItemOnMouseEnter) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_enter(&mut target, value)
                                }
                                fn shadow_offset(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::shadow_offset(&target)
                                }
                                fn set_shadow_offset(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_shadow_offset(&mut target, value)
                                }
                                fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_stroke(&target)
                                }
                                fn view_matrix(&self) -> Matrix {
                                    let target: Item = self.into();
                                    Item::view_matrix(&target)
                                }
                                fn set_view_matrix(&mut self, value: Matrix) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_view_matrix(&mut target, value)
                                }
                                fn on_frame(&self) -> ItemOnFrame {
                                    let target: Item = self.into();
                                    Item::on_frame(&target)
                                }
                                fn set_on_frame(&mut self, value: ItemOnFrame) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_frame(&mut target, value)
                                }
                                fn on_mouse_down(&self) -> ItemOnMouseDown {
                                    let target: Item = self.into();
                                    Item::on_mouse_down(&target)
                                }
                                fn set_on_mouse_down(&mut self, value: ItemOnMouseDown) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_down(&mut target, value)
                                }
                                fn is_sibling(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_sibling(&target, item)
                                }
                                fn local_to_global(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::local_to_global(&target, point)
                                }
                                fn first_child(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::first_child(&target)
                                }
                                fn set_first_child(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_first_child(&mut target, value)
                                }
                                fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::send_to_back(&target)
                                }
                                fn clip_mask(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::clip_mask(&target)
                                }
                                fn set_clip_mask(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_clip_mask(&mut target, value)
                                }
                                fn next_sibling(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::next_sibling(&target)
                                }
                                fn set_next_sibling(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_next_sibling(&mut target, value)
                                }
                                fn off(
                                    &self,
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::off(&target, object)
                                }
                                fn rotate(
                                    &self,
                                    angle: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::rotate(&target, angle, center)
                                }
                                fn add_child(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::add_child(&target, item)
                                }
                                fn is_grouped_with(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_grouped_with(&target, item)
                                }
                                fn scale(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::scale(&target, hor, ver, center)
                                }
                                fn hit_test_all(
                                    &self,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Vec<HitResult>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::hit_test_all(&target, point, options)
                                }
                                fn insert_children(
                                    &self,
                                    index: f64,
                                    items: Vec<Item>,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_children(&target, index, items)
                                }
                                fn style(&self) -> Style {
                                    let target: Item = self.into();
                                    Item::style(&target)
                                }
                                fn set_style(&mut self, value: Style) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_style(&mut target, value)
                                }
                                fn position(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::position(&target)
                                }
                                fn set_position(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_position(&mut target, value)
                                }
                                fn transform(
                                    &self,
                                    matrix: Matrix,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::transform(&target, matrix)
                                }
                                fn fill_color(&self) -> ItemFillColor {
                                    let target: Item = self.into();
                                    Item::fill_color(&target)
                                }
                                fn set_fill_color(&mut self, value: ItemFillColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_fill_color(&mut target, value)
                                }
                                fn matrix(&self) -> Matrix {
                                    let target: Item = self.into();
                                    Item::matrix(&target)
                                }
                                fn set_matrix(&mut self, value: Matrix) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_matrix(&mut target, value)
                                }
                                fn id(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::id(&target)
                                }
                                fn set_id(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_id(&mut target, value)
                                }
                                fn tween(
                                    &self,
                                    options: ItemTweenParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::tween(&target, options)
                                }
                                fn reduce(
                                    &self,
                                    options: JsValue,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::reduce(&target, options)
                                }
                                fn internal_bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::internal_bounds(&target)
                                }
                                fn set_internal_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_internal_bounds(&mut target, value)
                                }
                                fn fill_rule(&self) -> String {
                                    let target: Item = self.into();
                                    Item::fill_rule(&target)
                                }
                                fn set_fill_rule(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_fill_rule(&mut target, value)
                                }
                                fn shadow_color(&self) -> ItemShadowColor {
                                    let target: Item = self.into();
                                    Item::shadow_color(&target)
                                }
                                fn set_shadow_color(&mut self, value: ItemShadowColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_shadow_color(&mut target, value)
                                }
                                fn insert_above(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_above(&target, item)
                                }
                                fn responds(
                                    &self,
                                    type_: String,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::responds(&target, type_)
                                }
                                fn handle_bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::handle_bounds(&target)
                                }
                                fn set_handle_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_handle_bounds(&mut target, value)
                                }
                                fn skew(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::skew(&target, hor, ver, center)
                                }
                                fn on_click(&self) -> ItemOnClick {
                                    let target: Item = self.into();
                                    Item::on_click(&target)
                                }
                                fn set_on_click(&mut self, value: ItemOnClick) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_click(&mut target, value)
                                }
                                fn get_items(
                                    &self,
                                    options: ItemGetItemsParamsOptionsParam,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::get_items(&target, options)
                                }
                                fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::is_inserted(&target)
                                }
                                fn get_item(
                                    &self,
                                    options: ItemGetItemParamsOptionsParam,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::get_item(&target, options)
                                }
                                fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_fill(&target)
                                }
                                fn shear(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::shear(&target, hor, ver, center)
                                }
                                fn visible(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::visible(&target)
                                }
                                fn set_visible(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_visible(&mut target, value)
                                }
                                fn previous_sibling(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::previous_sibling(&target)
                                }
                                fn set_previous_sibling(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_previous_sibling(&mut target, value)
                                }
                                fn hit_test(
                                    &self,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<HitResult, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::hit_test(&target, point, options)
                                }
                                fn is_descendant(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_descendant(&target, item)
                                }
                                fn locked(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::locked(&target)
                                }
                                fn set_locked(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_locked(&mut target, value)
                                }
                                fn is_parent(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_parent(&target, item)
                                }
                                fn copy_attributes(
                                    &self,
                                    source: Item,
                                    exclude_matrix: bool,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::copy_attributes(&target, source, exclude_matrix)
                                }
                                fn last_child(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::last_child(&target)
                                }
                                fn set_last_child(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_last_child(&mut target, value)
                                }
                                fn stroke_width(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::stroke_width(&target)
                                }
                                fn set_stroke_width(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_width(&mut target, value)
                                }
                                fn parent(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::parent(&target)
                                }
                                fn set_parent(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_parent(&mut target, value)
                                }
                                fn stroke_bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::stroke_bounds(&target)
                                }
                                fn set_stroke_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_bounds(&mut target, value)
                                }
                                fn translate(
                                    &self,
                                    delta: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::translate(&target, delta)
                                }
                                fn remove(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::remove(&target)
                                }
                                fn parent_to_local(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::parent_to_local(&target, point)
                                }
                                fn bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::bounds(&target)
                                }
                                fn set_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_bounds(&mut target, value)
                                }
                                fn add_children(
                                    &self,
                                    items: Vec<Item>,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::add_children(&target, items)
                                }
                                fn dash_array(&self) -> Vec<f64> {
                                    let target: Item = self.into();
                                    Item::dash_array(&target)
                                }
                                fn set_dash_array(&mut self, value: Vec<f64>) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_dash_array(&mut target, value)
                                }
                                fn on_mouse_up(&self) -> ItemOnMouseUp {
                                    let target: Item = self.into();
                                    Item::on_mouse_up(&target)
                                }
                                fn set_on_mouse_up(&mut self, value: ItemOnMouseUp) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_up(&mut target, value)
                                }
                                fn on(
                                    &self,
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::on(&target, object)
                                }
                                fn remove_on(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::remove_on(&target, options)
                                }
                                fn is_below(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_below(&target, item)
                                }
                                fn apply_matrix(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::apply_matrix(&target)
                                }
                                fn set_apply_matrix(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_apply_matrix(&mut target, value)
                                }
                                fn clone(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::clone(&target, options)
                                }
                                fn contains(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::contains(&target, point)
                                }
                                fn export_json(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<String, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::export_json(&target, options)
                                }
                                fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::bring_to_front(&target)
                                }
                                fn is_above(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_above(&target, item)
                                }
                                fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_drag(&target)
                                }
                                fn data(&self) -> JsValue {
                                    let target: Item = self.into();
                                    Item::data(&target)
                                }
                                fn set_data(&mut self, value: JsValue) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_data(&mut target, value)
                                }
                                fn import_svg(
                                    &self,
                                    svg: ItemImportSvgParamsSvgParam,
                                    on_load: JsValue,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::import_svg(&target, svg, on_load)
                                }
                                fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_shadow(&target)
                                }
                                fn selected_color(&self) -> ItemSelectedColor {
                                    let target: Item = self.into();
                                    Item::selected_color(&target)
                                }
                                fn set_selected_color(&mut self, value: ItemSelectedColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_selected_color(&mut target, value)
                                }
                                fn class_name(&self) -> String {
                                    let target: Item = self.into();
                                    Item::class_name(&target)
                                }
                                fn set_class_name(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_class_name(&mut target, value)
                                }
                                fn export_svg(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<ItemExportSvgReturn, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::export_svg(&target, options)
                                }
                                fn tween_to(
                                    &self,
                                    to: std::collections::HashMap<String, JsValue>,
                                    options: ItemTweenToParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::tween_to(&target, to, options)
                                }
                                fn is_inside(
                                    &self,
                                    rect: Rectangle,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_inside(&target, rect)
                                }
                                fn is_empty(
                                    &self,
                                    recursively: bool,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_empty(&target, recursively)
                                }
                                fn copy_content(
                                    &self,
                                    source: Item,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::copy_content(&target, source)
                                }
                                fn rasterize(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Raster, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::rasterize(&target, options)
                                }
                                fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_move(&target)
                                }
                                fn tween_from(
                                    &self,
                                    from: std::collections::HashMap<String, JsValue>,
                                    options: ItemTweenFromParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::tween_from(&target, from, options)
                                }
                                fn opacity(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::opacity(&target)
                                }
                                fn set_opacity(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_opacity(&mut target, value)
                                }
                                fn dash_offset(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::dash_offset(&target)
                                }
                                fn set_dash_offset(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_dash_offset(&mut target, value)
                                }
                                fn remove_children(
                                    &self,
                                    start: f64,
                                    end: f64,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::remove_children(&target, start, end)
                                }
                                fn on_mouse_move(&self) -> ItemOnMouseMove {
                                    let target: Item = self.into();
                                    Item::on_mouse_move(&target)
                                }
                                fn set_on_mouse_move(&mut self, value: ItemOnMouseMove) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_move(&mut target, value)
                                }
                                fn intersects(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::intersects(&target, item)
                                }
                                fn pivot(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::pivot(&target)
                                }
                                fn set_pivot(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_pivot(&mut target, value)
                                }
                                fn copy_to(
                                    &self,
                                    owner: ItemCopyToParamsOwnerParam,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::copy_to(&target, owner)
                                }
                                fn index(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::index(&target)
                                }
                                fn set_index(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_index(&mut target, value)
                                }
                                fn local_to_parent(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::local_to_parent(&target, point)
                                }
                                fn stroke_color(&self) -> ItemStrokeColor {
                                    let target: Item = self.into();
                                    Item::stroke_color(&target)
                                }
                                fn set_stroke_color(&mut self, value: ItemStrokeColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_color(&mut target, value)
                                }
                                fn layer(&self) -> Layer {
                                    let target: Item = self.into();
                                    Item::layer(&target)
                                }
                                fn set_layer(&mut self, value: Layer) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_layer(&mut target, value)
                                }
                                fn stroke_scaling(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::stroke_scaling(&target)
                                }
                                fn set_stroke_scaling(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_scaling(&mut target, value)
                                }
                                fn fit_bounds(
                                    &self,
                                    rectangle: Rectangle,
                                    fill: bool,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::fit_bounds(&target, rectangle, fill)
                                }
                                fn miter_limit(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::miter_limit(&target)
                                }
                                fn set_miter_limit(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_miter_limit(&mut target, value)
                                }
                                fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_down(&target)
                                }
                            }
                            impl PointText_Trait for PointText {}
                            impl std::clone::Clone for PointText_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for PointText_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for PointText_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                #[wasm_bindgen(js_name = "PaperScope")]
                                type PaperScope_Class;
                                # [wasm_bindgen (method , structural , getter = Style , js_class = "PaperScope")]
                                fn style(this: &PaperScope_Class) -> Style;
                                # [wasm_bindgen (method , structural , setter = Style , js_class = "PaperScope")]
                                fn set_style(this: &PaperScope_Class, value: Style);
                                # [wasm_bindgen (method , structural , getter = PathItem , js_class = "PaperScope")]
                                fn path_item(this: &PaperScope_Class) -> PathItem;
                                # [wasm_bindgen (method , structural , setter = PathItem , js_class = "PaperScope")]
                                fn set_path_item(this: &PaperScope_Class, value: PathItem);
                                # [wasm_bindgen (method , structural , getter = Point , js_class = "PaperScope")]
                                fn point(this: &PaperScope_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = Point , js_class = "PaperScope")]
                                fn set_point(this: &PaperScope_Class, value: Point);
                                # [wasm_bindgen (method , structural , getter = Color , js_class = "PaperScope")]
                                fn color(this: &PaperScope_Class) -> Color;
                                # [wasm_bindgen (method , structural , setter = Color , js_class = "PaperScope")]
                                fn set_color(this: &PaperScope_Class, value: Color);
                                # [wasm_bindgen (method , structural , getter = Path , js_class = "PaperScope")]
                                fn path(this: &PaperScope_Class) -> Path;
                                # [wasm_bindgen (method , structural , setter = Path , js_class = "PaperScope")]
                                fn set_path(this: &PaperScope_Class, value: Path);
                                # [wasm_bindgen (method , structural , getter = PaperScript , js_class = "PaperScope")]
                                fn paper_script(this: &PaperScope_Class) -> PaperScript;
                                # [wasm_bindgen (method , structural , setter = PaperScript , js_class = "PaperScope")]
                                fn set_paper_script(this: &PaperScope_Class, value: PaperScript);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = get , method , js_class = "PaperScope" , catch)]
                                fn __TSB_get(
                                    this: &PaperScope_Class,
                                    id: JsValue,
                                ) -> std::result::Result<PaperScope, JsValue>;
                                # [wasm_bindgen (method , structural , getter = Curve , js_class = "PaperScope")]
                                fn curve(this: &PaperScope_Class) -> Curve;
                                # [wasm_bindgen (method , structural , setter = Curve , js_class = "PaperScope")]
                                fn set_curve(this: &PaperScope_Class, value: Curve);
                                # [wasm_bindgen (method , structural , getter = View , js_class = "PaperScope")]
                                fn view(this: &PaperScope_Class) -> View;
                                # [wasm_bindgen (method , structural , setter = View , js_class = "PaperScope")]
                                fn set_view(this: &PaperScope_Class, value: View);
                                # [wasm_bindgen (method , structural , getter = Size , js_class = "PaperScope")]
                                fn size(this: &PaperScope_Class) -> Size;
                                # [wasm_bindgen (method , structural , setter = Size , js_class = "PaperScope")]
                                fn set_size(this: &PaperScope_Class, value: Size);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = setup , method , js_class = "PaperScope" , catch)]
                                fn __TSB_setup(
                                    this: &PaperScope_Class,
                                    element: JsValue,
                                ) -> std::result::Result<(), JsValue>;
                                # [wasm_bindgen (method , structural , getter = view , js_class = "PaperScope")]
                                fn view(this: &PaperScope_Class) -> View;
                                # [wasm_bindgen (method , structural , setter = view , js_class = "PaperScope")]
                                fn set_view(this: &PaperScope_Class, value: View);
                                # [wasm_bindgen (method , structural , getter = Matrix , js_class = "PaperScope")]
                                fn matrix(this: &PaperScope_Class) -> Matrix;
                                # [wasm_bindgen (method , structural , setter = Matrix , js_class = "PaperScope")]
                                fn set_matrix(this: &PaperScope_Class, value: Matrix);
                                # [wasm_bindgen (method , structural , getter = tools , js_class = "PaperScope")]
                                fn tools(this: &PaperScope_Class) -> Vec<Tool>;
                                # [wasm_bindgen (method , structural , setter = tools , js_class = "PaperScope")]
                                fn set_tools(this: &PaperScope_Class, value: Vec<Tool>);
                                # [wasm_bindgen (method , structural , getter = project , js_class = "PaperScope")]
                                fn project(this: &PaperScope_Class) -> Project;
                                # [wasm_bindgen (method , structural , setter = project , js_class = "PaperScope")]
                                fn set_project(this: &PaperScope_Class, value: Project);
                                # [wasm_bindgen (method , structural , getter = Group , js_class = "PaperScope")]
                                fn group(this: &PaperScope_Class) -> Group;
                                # [wasm_bindgen (method , structural , setter = Group , js_class = "PaperScope")]
                                fn set_group(this: &PaperScope_Class, value: Group);
                                # [wasm_bindgen (method , structural , getter = Rectangle , js_class = "PaperScope")]
                                fn rectangle(this: &PaperScope_Class) -> Rectangle;
                                # [wasm_bindgen (method , structural , setter = Rectangle , js_class = "PaperScope")]
                                fn set_rectangle(this: &PaperScope_Class, value: Rectangle);
                                # [wasm_bindgen (method , structural , getter = tool , js_class = "PaperScope")]
                                fn tool(this: &PaperScope_Class) -> Tool;
                                # [wasm_bindgen (method , structural , setter = tool , js_class = "PaperScope")]
                                fn set_tool(this: &PaperScope_Class, value: Tool);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = execute , method , js_class = "PaperScope" , catch)]
                                fn __TSB_execute(
                                    this: &PaperScope_Class,
                                    code: String,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<(), JsValue>;
                                # [wasm_bindgen (method , structural , getter = Item , js_class = "PaperScope")]
                                fn item(this: &PaperScope_Class) -> Item;
                                # [wasm_bindgen (method , structural , setter = Item , js_class = "PaperScope")]
                                fn set_item(this: &PaperScope_Class, value: Item);
                                # [wasm_bindgen (method , structural , getter = Key , js_class = "PaperScope")]
                                fn key(this: &PaperScope_Class) -> Key;
                                # [wasm_bindgen (method , structural , setter = Key , js_class = "PaperScope")]
                                fn set_key(this: &PaperScope_Class, value: Key);
                                # [wasm_bindgen (method , structural , getter = version , js_class = "PaperScope")]
                                fn version(this: &PaperScope_Class) -> String;
                                # [wasm_bindgen (method , structural , setter = version , js_class = "PaperScope")]
                                fn set_version(this: &PaperScope_Class, value: String);
                                # [wasm_bindgen (method , structural , getter = GradientStop , js_class = "PaperScope")]
                                fn gradient_stop(this: &PaperScope_Class) -> GradientStop;
                                # [wasm_bindgen (method , structural , setter = GradientStop , js_class = "PaperScope")]
                                fn set_gradient_stop(this: &PaperScope_Class, value: GradientStop);
                                # [wasm_bindgen (method , structural , getter = settings , js_class = "PaperScope")]
                                fn settings(this: &PaperScope_Class) -> JsValue;
                                # [wasm_bindgen (method , structural , setter = settings , js_class = "PaperScope")]
                                fn set_settings(this: &PaperScope_Class, value: JsValue);
                                # [wasm_bindgen (method , structural , getter = Event , js_class = "PaperScope")]
                                fn event(this: &PaperScope_Class) -> Event;
                                # [wasm_bindgen (method , structural , setter = Event , js_class = "PaperScope")]
                                fn set_event(this: &PaperScope_Class, value: Event);
                                # [wasm_bindgen (method , structural , getter = Tool , js_class = "PaperScope")]
                                fn tool(this: &PaperScope_Class) -> Tool;
                                # [wasm_bindgen (method , structural , setter = Tool , js_class = "PaperScope")]
                                fn set_tool(this: &PaperScope_Class, value: Tool);
                                # [wasm_bindgen (method , structural , getter = HitResult , js_class = "PaperScope")]
                                fn hit_result(this: &PaperScope_Class) -> HitResult;
                                # [wasm_bindgen (method , structural , setter = HitResult , js_class = "PaperScope")]
                                fn set_hit_result(this: &PaperScope_Class, value: HitResult);
                                # [wasm_bindgen (method , structural , getter = Layer , js_class = "PaperScope")]
                                fn layer(this: &PaperScope_Class) -> Layer;
                                # [wasm_bindgen (method , structural , setter = Layer , js_class = "PaperScope")]
                                fn set_layer(this: &PaperScope_Class, value: Layer);
                                # [wasm_bindgen (method , structural , getter = KeyEvent , js_class = "PaperScope")]
                                fn key_event(this: &PaperScope_Class) -> KeyEvent;
                                # [wasm_bindgen (method , structural , setter = KeyEvent , js_class = "PaperScope")]
                                fn set_key_event(this: &PaperScope_Class, value: KeyEvent);
                                # [wasm_bindgen (method , structural , getter = projects , js_class = "PaperScope")]
                                fn projects(this: &PaperScope_Class) -> Vec<Project>;
                                # [wasm_bindgen (method , structural , setter = projects , js_class = "PaperScope")]
                                fn set_projects(this: &PaperScope_Class, value: Vec<Project>);
                                # [wasm_bindgen (method , structural , getter = PointText , js_class = "PaperScope")]
                                fn point_text(this: &PaperScope_Class) -> PointText;
                                # [wasm_bindgen (method , structural , setter = PointText , js_class = "PaperScope")]
                                fn set_point_text(this: &PaperScope_Class, value: PointText);
                                # [wasm_bindgen (method , structural , getter = Raster , js_class = "PaperScope")]
                                fn raster(this: &PaperScope_Class) -> Raster;
                                # [wasm_bindgen (method , structural , setter = Raster , js_class = "PaperScope")]
                                fn set_raster(this: &PaperScope_Class, value: Raster);
                                # [wasm_bindgen (method , structural , getter = CurveLocation , js_class = "PaperScope")]
                                fn curve_location(this: &PaperScope_Class) -> CurveLocation;
                                # [wasm_bindgen (method , structural , setter = CurveLocation , js_class = "PaperScope")]
                                fn set_curve_location(
                                    this: &PaperScope_Class,
                                    value: CurveLocation,
                                );
                                # [wasm_bindgen (method , structural , getter = Gradient , js_class = "PaperScope")]
                                fn gradient(this: &PaperScope_Class) -> Gradient;
                                # [wasm_bindgen (method , structural , setter = Gradient , js_class = "PaperScope")]
                                fn set_gradient(this: &PaperScope_Class, value: Gradient);
                                # [wasm_bindgen (method , structural , getter = TextItem , js_class = "PaperScope")]
                                fn text_item(this: &PaperScope_Class) -> TextItem;
                                # [wasm_bindgen (method , structural , setter = TextItem , js_class = "PaperScope")]
                                fn set_text_item(this: &PaperScope_Class, value: TextItem);
                                # [wasm_bindgen (method , structural , getter = SymbolDefinition , js_class = "PaperScope")]
                                fn symbol_definition(this: &PaperScope_Class) -> SymbolDefinition;
                                # [wasm_bindgen (method , structural , setter = SymbolDefinition , js_class = "PaperScope")]
                                fn set_symbol_definition(
                                    this: &PaperScope_Class,
                                    value: SymbolDefinition,
                                );
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = install , method , js_class = "PaperScope" , catch)]
                                fn __TSB_install(
                                    this: &PaperScope_Class,
                                    scope: JsValue,
                                ) -> std::result::Result<(), JsValue>;
                                # [wasm_bindgen (method , structural , getter = Shape , js_class = "PaperScope")]
                                fn shape(this: &PaperScope_Class) -> Shape;
                                # [wasm_bindgen (method , structural , setter = Shape , js_class = "PaperScope")]
                                fn set_shape(this: &PaperScope_Class, value: Shape);
                                # [wasm_bindgen (method , structural , getter = MouseEvent , js_class = "PaperScope")]
                                fn mouse_event(this: &PaperScope_Class) -> MouseEvent;
                                # [wasm_bindgen (method , structural , setter = MouseEvent , js_class = "PaperScope")]
                                fn set_mouse_event(this: &PaperScope_Class, value: MouseEvent);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = activate , method , js_class = "PaperScope" , catch)]
                                fn __TSB_activate(
                                    this: &PaperScope_Class,
                                ) -> std::result::Result<(), JsValue>;
                                # [wasm_bindgen (method , structural , getter = ToolEvent , js_class = "PaperScope")]
                                fn tool_event(this: &PaperScope_Class) -> ToolEvent;
                                # [wasm_bindgen (method , structural , setter = ToolEvent , js_class = "PaperScope")]
                                fn set_tool_event(this: &PaperScope_Class, value: ToolEvent);
                                # [wasm_bindgen (method , structural , getter = PaperScope , js_class = "PaperScope")]
                                fn paper_scope(this: &PaperScope_Class) -> PaperScope;
                                # [wasm_bindgen (method , structural , setter = PaperScope , js_class = "PaperScope")]
                                fn set_paper_scope(this: &PaperScope_Class, value: PaperScope);
                                # [wasm_bindgen (method , structural , getter = Segment , js_class = "PaperScope")]
                                fn segment(this: &PaperScope_Class) -> Segment;
                                # [wasm_bindgen (method , structural , setter = Segment , js_class = "PaperScope")]
                                fn set_segment(this: &PaperScope_Class, value: Segment);
                                #[wasm_bindgen(constructor, js_class = "PaperScope")]
                                pub fn new() -> PaperScope_Class;
                                # [wasm_bindgen (method , structural , getter = CompoundPath , js_class = "PaperScope")]
                                fn compound_path(this: &PaperScope_Class) -> CompoundPath;
                                # [wasm_bindgen (method , structural , setter = CompoundPath , js_class = "PaperScope")]
                                fn set_compound_path(this: &PaperScope_Class, value: CompoundPath);
                                # [wasm_bindgen (method , structural , getter = Project , js_class = "PaperScope")]
                                fn project(this: &PaperScope_Class) -> Project;
                                # [wasm_bindgen (method , structural , setter = Project , js_class = "PaperScope")]
                                fn set_project(this: &PaperScope_Class, value: Project);
                                # [wasm_bindgen (method , structural , getter = Tween , js_class = "PaperScope")]
                                fn tween(this: &PaperScope_Class) -> Tween;
                                # [wasm_bindgen (method , structural , setter = Tween , js_class = "PaperScope")]
                                fn set_tween(this: &PaperScope_Class, value: Tween);
                                # [wasm_bindgen (method , structural , getter = SymbolItem , js_class = "PaperScope")]
                                fn symbol_item(this: &PaperScope_Class) -> SymbolItem;
                                # [wasm_bindgen (method , structural , setter = SymbolItem , js_class = "PaperScope")]
                                fn set_symbol_item(this: &PaperScope_Class, value: SymbolItem);
                            }
                            #[derive(std :: clone :: Clone)]
                            struct PaperScope(pub PaperScope_Class);
                            impl PaperScope {
                                #[allow(dead_code)]
                                pub fn style(&self) -> Style {
                                    let result = self.0.style();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_style(&self, value: Style) -> () {
                                    let result = self.0.set_style(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn path_item(&self) -> PathItem {
                                    let result = self.0.path_item();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_path_item(&self, value: PathItem) -> () {
                                    let result = self.0.set_path_item(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn point(&self) -> Point {
                                    let result = self.0.point();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_point(&self, value: Point) -> () {
                                    let result = self.0.set_point(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn color(&self) -> Color {
                                    let result = self.0.color();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_color(&self, value: Color) -> () {
                                    let result = self.0.set_color(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn path(&self) -> Path {
                                    let result = self.0.path();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_path(&self, value: Path) -> () {
                                    let result = self.0.set_path(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn paper_script(&self) -> PaperScript {
                                    let result = self.0.paper_script();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_paper_script(&self, value: PaperScript) -> () {
                                    let result = self.0.set_paper_script(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get(
                                    &self,
                                    id: JsValue,
                                ) -> std::result::Result<PaperScope, JsValue>
                                {
                                    let result = std::result::Result::Ok(self.0.__TSB_get(id)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn curve(&self) -> Curve {
                                    let result = self.0.curve();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_curve(&self, value: Curve) -> () {
                                    let result = self.0.set_curve(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn view(&self) -> View {
                                    let result = self.0.view();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_view(&self, value: View) -> () {
                                    let result = self.0.set_view(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn size(&self) -> Size {
                                    let result = self.0.size();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_size(&self, value: Size) -> () {
                                    let result = self.0.set_size(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn setup(
                                    &self,
                                    element: PaperScopeSetupParamsElementParam,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_setup(
                                            ts_bindgen_rt::to_jsvalue(&element)
                                                .map_err(ts_bindgen_rt::Error::from)?,
                                        )?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn view(&self) -> View {
                                    let result = self.0.view();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_view(&self, value: View) -> () {
                                    let result = self.0.set_view(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn matrix(&self) -> Matrix {
                                    let result = self.0.matrix();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_matrix(&self, value: Matrix) -> () {
                                    let result = self.0.set_matrix(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn tools(&self) -> Vec<Tool> {
                                    let result = self.0.tools();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_tools(&self, value: Vec<Tool>) -> () {
                                    let result = self.0.set_tools(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn project(&self) -> Project {
                                    let result = self.0.project();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_project(&self, value: Project) -> () {
                                    let result = self.0.set_project(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn group(&self) -> Group {
                                    let result = self.0.group();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_group(&self, value: Group) -> () {
                                    let result = self.0.set_group(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn rectangle(&self) -> Rectangle {
                                    let result = self.0.rectangle();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_rectangle(&self, value: Rectangle) -> () {
                                    let result = self.0.set_rectangle(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn tool(&self) -> Tool {
                                    let result = self.0.tool();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_tool(&self, value: Tool) -> () {
                                    let result = self.0.set_tool(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn execute(
                                    &self,
                                    code: String,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_execute(code, options)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn item(&self) -> Item {
                                    let result = self.0.item();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_item(&self, value: Item) -> () {
                                    let result = self.0.set_item(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn key(&self) -> Key {
                                    let result = self.0.key();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_key(&self, value: Key) -> () {
                                    let result = self.0.set_key(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn version(&self) -> String {
                                    let result = self.0.version();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_version(&self, value: String) -> () {
                                    let result = self.0.set_version(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn gradient_stop(&self) -> GradientStop {
                                    let result = self.0.gradient_stop();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_gradient_stop(&self, value: GradientStop) -> () {
                                    let result = self.0.set_gradient_stop(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn settings(&self) -> JsValue {
                                    let result = self.0.settings();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_settings(&self, value: JsValue) -> () {
                                    let result = self.0.set_settings(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn event(&self) -> Event {
                                    let result = self.0.event();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_event(&self, value: Event) -> () {
                                    let result = self.0.set_event(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn tool(&self) -> Tool {
                                    let result = self.0.tool();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_tool(&self, value: Tool) -> () {
                                    let result = self.0.set_tool(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn hit_result(&self) -> HitResult {
                                    let result = self.0.hit_result();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_hit_result(&self, value: HitResult) -> () {
                                    let result = self.0.set_hit_result(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn layer(&self) -> Layer {
                                    let result = self.0.layer();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_layer(&self, value: Layer) -> () {
                                    let result = self.0.set_layer(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn key_event(&self) -> KeyEvent {
                                    let result = self.0.key_event();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_key_event(&self, value: KeyEvent) -> () {
                                    let result = self.0.set_key_event(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn projects(&self) -> Vec<Project> {
                                    let result = self.0.projects();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_projects(&self, value: Vec<Project>) -> () {
                                    let result = self.0.set_projects(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn point_text(&self) -> PointText {
                                    let result = self.0.point_text();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_point_text(&self, value: PointText) -> () {
                                    let result = self.0.set_point_text(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn raster(&self) -> Raster {
                                    let result = self.0.raster();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_raster(&self, value: Raster) -> () {
                                    let result = self.0.set_raster(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn curve_location(&self) -> CurveLocation {
                                    let result = self.0.curve_location();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_curve_location(&self, value: CurveLocation) -> () {
                                    let result = self.0.set_curve_location(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn gradient(&self) -> Gradient {
                                    let result = self.0.gradient();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_gradient(&self, value: Gradient) -> () {
                                    let result = self.0.set_gradient(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn text_item(&self) -> TextItem {
                                    let result = self.0.text_item();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_text_item(&self, value: TextItem) -> () {
                                    let result = self.0.set_text_item(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn symbol_definition(&self) -> SymbolDefinition {
                                    let result = self.0.symbol_definition();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_symbol_definition(&self, value: SymbolDefinition) -> () {
                                    let result = self.0.set_symbol_definition(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn install(
                                    &self,
                                    scope: JsValue,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_install(scope)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn shape(&self) -> Shape {
                                    let result = self.0.shape();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_shape(&self, value: Shape) -> () {
                                    let result = self.0.set_shape(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn mouse_event(&self) -> MouseEvent {
                                    let result = self.0.mouse_event();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_mouse_event(&self, value: MouseEvent) -> () {
                                    let result = self.0.set_mouse_event(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn activate(&self) -> std::result::Result<(), JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_activate()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn tool_event(&self) -> ToolEvent {
                                    let result = self.0.tool_event();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_tool_event(&self, value: ToolEvent) -> () {
                                    let result = self.0.set_tool_event(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn paper_scope(&self) -> PaperScope {
                                    let result = self.0.paper_scope();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_paper_scope(&self, value: PaperScope) -> () {
                                    let result = self.0.set_paper_scope(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn segment(&self) -> Segment {
                                    let result = self.0.segment();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_segment(&self, value: Segment) -> () {
                                    let result = self.0.set_segment(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn new() -> PaperScope {
                                    let result = PaperScope_Class::new();
                                    let result =
                                        ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result)
                                            .unwrap();
                                    PaperScope(result)
                                }
                                #[allow(dead_code)]
                                pub fn compound_path(&self) -> CompoundPath {
                                    let result = self.0.compound_path();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_compound_path(&self, value: CompoundPath) -> () {
                                    let result = self.0.set_compound_path(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn project(&self) -> Project {
                                    let result = self.0.project();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_project(&self, value: Project) -> () {
                                    let result = self.0.set_project(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn tween(&self) -> Tween {
                                    let result = self.0.tween();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_tween(&self, value: Tween) -> () {
                                    let result = self.0.set_tween(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn symbol_item(&self) -> SymbolItem {
                                    let result = self.0.symbol_item();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_symbol_item(&self, value: SymbolItem) -> () {
                                    let result = self.0.set_symbol_item(value);
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for PaperScope {
                                fn describe() {
                                    < PaperScope_Class as wasm_bindgen :: describe :: WasmDescribe > :: describe ()
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for PaperScope {
                                type Abi =
                                    <PaperScope_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a PaperScope {
                                type Abi = < & 'a PaperScope_Class as wasm_bindgen :: convert :: IntoWasmAbi > :: Abi ;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for PaperScope {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for PaperScope {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal: PaperScope_Class =
                                        <PaperScope_Class as serde::de::Deserialize>::deserialize(
                                            deserializer,
                                        )?;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait PaperScope_Trait {
                                fn style(&self) -> Style;
                                fn set_style(&mut self, value: Style) -> ();
                                fn path_item(&self) -> PathItem;
                                fn set_path_item(&mut self, value: PathItem) -> ();
                                fn point(&self) -> Point;
                                fn set_point(&mut self, value: Point) -> ();
                                fn color(&self) -> Color;
                                fn set_color(&mut self, value: Color) -> ();
                                fn path(&self) -> Path;
                                fn set_path(&mut self, value: Path) -> ();
                                fn paper_script(&self) -> PaperScript;
                                fn set_paper_script(&mut self, value: PaperScript) -> ();
                                fn get(
                                    &self,
                                    id: JsValue,
                                ) -> std::result::Result<PaperScope, JsValue>;
                                fn curve(&self) -> Curve;
                                fn set_curve(&mut self, value: Curve) -> ();
                                fn view(&self) -> View;
                                fn set_view(&mut self, value: View) -> ();
                                fn size(&self) -> Size;
                                fn set_size(&mut self, value: Size) -> ();
                                fn setup(
                                    &self,
                                    element: PaperScopeSetupParamsElementParam,
                                ) -> std::result::Result<(), JsValue>;
                                fn view(&self) -> View;
                                fn set_view(&mut self, value: View) -> ();
                                fn matrix(&self) -> Matrix;
                                fn set_matrix(&mut self, value: Matrix) -> ();
                                fn tools(&self) -> Vec<Tool>;
                                fn set_tools(&mut self, value: Vec<Tool>) -> ();
                                fn project(&self) -> Project;
                                fn set_project(&mut self, value: Project) -> ();
                                fn group(&self) -> Group;
                                fn set_group(&mut self, value: Group) -> ();
                                fn rectangle(&self) -> Rectangle;
                                fn set_rectangle(&mut self, value: Rectangle) -> ();
                                fn tool(&self) -> Tool;
                                fn set_tool(&mut self, value: Tool) -> ();
                                fn execute(
                                    &self,
                                    code: String,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<(), JsValue>;
                                fn item(&self) -> Item;
                                fn set_item(&mut self, value: Item) -> ();
                                fn key(&self) -> Key;
                                fn set_key(&mut self, value: Key) -> ();
                                fn version(&self) -> String;
                                fn set_version(&mut self, value: String) -> ();
                                fn gradient_stop(&self) -> GradientStop;
                                fn set_gradient_stop(&mut self, value: GradientStop) -> ();
                                fn settings(&self) -> JsValue;
                                fn set_settings(&mut self, value: JsValue) -> ();
                                fn event(&self) -> Event;
                                fn set_event(&mut self, value: Event) -> ();
                                fn tool(&self) -> Tool;
                                fn set_tool(&mut self, value: Tool) -> ();
                                fn hit_result(&self) -> HitResult;
                                fn set_hit_result(&mut self, value: HitResult) -> ();
                                fn layer(&self) -> Layer;
                                fn set_layer(&mut self, value: Layer) -> ();
                                fn key_event(&self) -> KeyEvent;
                                fn set_key_event(&mut self, value: KeyEvent) -> ();
                                fn projects(&self) -> Vec<Project>;
                                fn set_projects(&mut self, value: Vec<Project>) -> ();
                                fn point_text(&self) -> PointText;
                                fn set_point_text(&mut self, value: PointText) -> ();
                                fn raster(&self) -> Raster;
                                fn set_raster(&mut self, value: Raster) -> ();
                                fn curve_location(&self) -> CurveLocation;
                                fn set_curve_location(&mut self, value: CurveLocation) -> ();
                                fn gradient(&self) -> Gradient;
                                fn set_gradient(&mut self, value: Gradient) -> ();
                                fn text_item(&self) -> TextItem;
                                fn set_text_item(&mut self, value: TextItem) -> ();
                                fn symbol_definition(&self) -> SymbolDefinition;
                                fn set_symbol_definition(&mut self, value: SymbolDefinition) -> ();
                                fn install(
                                    &self,
                                    scope: JsValue,
                                ) -> std::result::Result<(), JsValue>;
                                fn shape(&self) -> Shape;
                                fn set_shape(&mut self, value: Shape) -> ();
                                fn mouse_event(&self) -> MouseEvent;
                                fn set_mouse_event(&mut self, value: MouseEvent) -> ();
                                fn activate(&self) -> std::result::Result<(), JsValue>;
                                fn tool_event(&self) -> ToolEvent;
                                fn set_tool_event(&mut self, value: ToolEvent) -> ();
                                fn paper_scope(&self) -> PaperScope;
                                fn set_paper_scope(&mut self, value: PaperScope) -> ();
                                fn segment(&self) -> Segment;
                                fn set_segment(&mut self, value: Segment) -> ();
                                fn new() -> PaperScope;
                                fn compound_path(&self) -> CompoundPath;
                                fn set_compound_path(&mut self, value: CompoundPath) -> ();
                                fn project(&self) -> Project;
                                fn set_project(&mut self, value: Project) -> ();
                                fn tween(&self) -> Tween;
                                fn set_tween(&mut self, value: Tween) -> ();
                                fn symbol_item(&self) -> SymbolItem;
                                fn set_symbol_item(&mut self, value: SymbolItem) -> ();
                            }
                            impl std::clone::Clone for PaperScope_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for PaperScope_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for PaperScope_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                #[wasm_bindgen(js_name = "Tool")]
                                type Tool_Class;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = responds , method , js_class = "Tool" , catch)]
                                fn __TSB_responds(
                                    this: &Tool_Class,
                                    type_: String,
                                ) -> std::result::Result<bool, JsValue>;
                                # [wasm_bindgen (method , structural , getter = fixedDistance , js_class = "Tool")]
                                fn fixed_distance(this: &Tool_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = fixedDistance , js_class = "Tool")]
                                fn set_fixed_distance(this: &Tool_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = maxDistance , js_class = "Tool")]
                                fn max_distance(this: &Tool_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = maxDistance , js_class = "Tool")]
                                fn set_max_distance(this: &Tool_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = activate , method , js_class = "Tool" , catch)]
                                fn __TSB_activate(
                                    this: &Tool_Class,
                                ) -> std::result::Result<(), JsValue>;
                                # [wasm_bindgen (method , structural , getter = onKeyDown , js_class = "Tool")]
                                fn on_key_down(this: &Tool_Class) -> ToolOnKeyDown;
                                # [wasm_bindgen (method , structural , setter = onKeyDown , js_class = "Tool")]
                                fn set_on_key_down(this: &Tool_Class, value: ToolOnKeyDown);
                                # [wasm_bindgen (method , structural , getter = minDistance , js_class = "Tool")]
                                fn min_distance(this: &Tool_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = minDistance , js_class = "Tool")]
                                fn set_min_distance(this: &Tool_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = onMouseDown , js_class = "Tool")]
                                fn on_mouse_down(this: &Tool_Class) -> ToolOnMouseDown;
                                # [wasm_bindgen (method , structural , setter = onMouseDown , js_class = "Tool")]
                                fn set_on_mouse_down(this: &Tool_Class, value: ToolOnMouseDown);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = emit , method , js_class = "Tool" , catch)]
                                fn __TSB_emit(
                                    this: &Tool_Class,
                                    type_: String,
                                    event: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = on , method , js_class = "Tool" , catch)]
                                fn __TSB_on(
                                    this: &Tool_Class,
                                    param: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Tool, JsValue>;
                                # [wasm_bindgen (method , structural , getter = onMouseDrag , js_class = "Tool")]
                                fn on_mouse_drag(this: &Tool_Class) -> ToolOnMouseDrag;
                                # [wasm_bindgen (method , structural , setter = onMouseDrag , js_class = "Tool")]
                                fn set_on_mouse_drag(this: &Tool_Class, value: ToolOnMouseDrag);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = off , method , js_class = "Tool" , catch)]
                                fn __TSB_off(
                                    this: &Tool_Class,
                                    param: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Tool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = remove , method , js_class = "Tool" , catch)]
                                fn __TSB_remove(
                                    this: &Tool_Class,
                                ) -> std::result::Result<(), JsValue>;
                                # [wasm_bindgen (method , structural , getter = onKeyUp , js_class = "Tool")]
                                fn on_key_up(this: &Tool_Class) -> ToolOnKeyUp;
                                # [wasm_bindgen (method , structural , setter = onKeyUp , js_class = "Tool")]
                                fn set_on_key_up(this: &Tool_Class, value: ToolOnKeyUp);
                                # [wasm_bindgen (method , structural , getter = onMouseUp , js_class = "Tool")]
                                fn on_mouse_up(this: &Tool_Class) -> ToolOnMouseUp;
                                # [wasm_bindgen (method , structural , setter = onMouseUp , js_class = "Tool")]
                                fn set_on_mouse_up(this: &Tool_Class, value: ToolOnMouseUp);
                                # [wasm_bindgen (method , structural , getter = onMouseMove , js_class = "Tool")]
                                fn on_mouse_move(this: &Tool_Class) -> ToolOnMouseMove;
                                # [wasm_bindgen (method , structural , setter = onMouseMove , js_class = "Tool")]
                                fn set_on_mouse_move(this: &Tool_Class, value: ToolOnMouseMove);
                            }
                            #[derive(std :: clone :: Clone)]
                            struct Tool(pub Tool_Class);
                            impl Tool {
                                #[allow(dead_code)]
                                pub fn responds(
                                    &self,
                                    type_: String,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_responds(type_)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn fixed_distance(&self) -> f64 {
                                    let result = self.0.fixed_distance();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_fixed_distance(&self, value: f64) -> () {
                                    let result = self.0.set_fixed_distance(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn max_distance(&self) -> f64 {
                                    let result = self.0.max_distance();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_max_distance(&self, value: f64) -> () {
                                    let result = self.0.set_max_distance(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn activate(&self) -> std::result::Result<(), JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_activate()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn on_key_down(&self) -> ToolOnKeyDown {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.on_key_down()).unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_on_key_down(&self, value: ToolOnKeyDown) -> () {
                                    let result = self.0.set_on_key_down(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn min_distance(&self) -> f64 {
                                    let result = self.0.min_distance();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_min_distance(&self, value: f64) -> () {
                                    let result = self.0.set_min_distance(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn on_mouse_down(&self) -> ToolOnMouseDown {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_down())
                                            .unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_on_mouse_down(&self, value: ToolOnMouseDown) -> () {
                                    let result = self.0.set_on_mouse_down(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn emit(
                                    &self,
                                    type_: String,
                                    event: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_emit(type_, event)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn on(
                                    &self,
                                    param: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Tool, JsValue>
                                {
                                    let result = std::result::Result::Ok(self.0.__TSB_on(param)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn on_mouse_drag(&self) -> ToolOnMouseDrag {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_drag())
                                            .unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_on_mouse_drag(&self, value: ToolOnMouseDrag) -> () {
                                    let result = self.0.set_on_mouse_drag(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn off(
                                    &self,
                                    param: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Tool, JsValue>
                                {
                                    let result = std::result::Result::Ok(self.0.__TSB_off(param)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn remove(&self) -> std::result::Result<(), JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_remove()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn on_key_up(&self) -> ToolOnKeyUp {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.on_key_up()).unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_on_key_up(&self, value: ToolOnKeyUp) -> () {
                                    let result = self.0.set_on_key_up(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn on_mouse_up(&self) -> ToolOnMouseUp {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_up()).unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_on_mouse_up(&self, value: ToolOnMouseUp) -> () {
                                    let result = self.0.set_on_mouse_up(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn on_mouse_move(&self) -> ToolOnMouseMove {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_move())
                                            .unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_on_mouse_move(&self, value: ToolOnMouseMove) -> () {
                                    let result = self.0.set_on_mouse_move(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for Tool {
                                fn describe() {
                                    <Tool_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for Tool {
                                type Abi = <Tool_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Tool {
                                type Abi =
                                    <&'a Tool_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for Tool {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Tool {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal: Tool_Class =
                                        <Tool_Class as serde::de::Deserialize>::deserialize(
                                            deserializer,
                                        )?;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait Tool_Trait {
                                fn responds(
                                    &self,
                                    type_: String,
                                ) -> std::result::Result<bool, JsValue>;
                                fn fixed_distance(&self) -> f64;
                                fn set_fixed_distance(&mut self, value: f64) -> ();
                                fn max_distance(&self) -> f64;
                                fn set_max_distance(&mut self, value: f64) -> ();
                                fn activate(&self) -> std::result::Result<(), JsValue>;
                                fn on_key_down(&self) -> ToolOnKeyDown;
                                fn set_on_key_down(&mut self, value: ToolOnKeyDown) -> ();
                                fn min_distance(&self) -> f64;
                                fn set_min_distance(&mut self, value: f64) -> ();
                                fn on_mouse_down(&self) -> ToolOnMouseDown;
                                fn set_on_mouse_down(&mut self, value: ToolOnMouseDown) -> ();
                                fn emit(
                                    &self,
                                    type_: String,
                                    event: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>;
                                fn on(
                                    &self,
                                    param: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Tool, JsValue>;
                                fn on_mouse_drag(&self) -> ToolOnMouseDrag;
                                fn set_on_mouse_drag(&mut self, value: ToolOnMouseDrag) -> ();
                                fn off(
                                    &self,
                                    param: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Tool, JsValue>;
                                fn remove(&self) -> std::result::Result<(), JsValue>;
                                fn on_key_up(&self) -> ToolOnKeyUp;
                                fn set_on_key_up(&mut self, value: ToolOnKeyUp) -> ();
                                fn on_mouse_up(&self) -> ToolOnMouseUp;
                                fn set_on_mouse_up(&mut self, value: ToolOnMouseUp) -> ();
                                fn on_mouse_move(&self) -> ToolOnMouseMove;
                                fn set_on_mouse_move(&mut self, value: ToolOnMouseMove) -> ();
                            }
                            impl std::clone::Clone for Tool_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for Tool_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Tool_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                # [wasm_bindgen (js_name = "PathItem" , extends = Item_Class)]
                                type PathItem_Class;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = cubicCurveBy , method , js_class = "PathItem" , catch)]
                                fn __TSB_cubic_curve_by(
                                    this: &PathItem_Class,
                                    handle1: Point,
                                    handle2: Point,
                                    to: Point,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = curveBy , method , js_class = "PathItem" , catch)]
                                fn __TSB_curve_by(
                                    this: &PathItem_Class,
                                    through: Point,
                                    to: Point,
                                    time: f64,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = closePath , method , js_class = "PathItem" , catch)]
                                fn __TSB_close_path(
                                    this: &PathItem_Class,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = simplify , method , js_class = "PathItem" , catch)]
                                fn __TSB_simplify(
                                    this: &PathItem_Class,
                                    tolerance: f64,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = reverse , method , js_class = "PathItem" , catch)]
                                fn __TSB_reverse(
                                    this: &PathItem_Class,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = quadraticCurveBy , method , js_class = "PathItem" , catch)]
                                fn __TSB_quadratic_curve_by(
                                    this: &PathItem_Class,
                                    handle: Point,
                                    to: Point,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getIntersections , method , js_class = "PathItem" , catch)]
                                fn __TSB_get_intersections(
                                    this: &PathItem_Class,
                                    path: PathItem,
                                    include: JsValue,
                                ) -> std::result::Result<Vec<CurveLocation>, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getNearestPoint , method , js_class = "PathItem" , catch)]
                                fn __TSB_get_nearest_point(
                                    this: &PathItem_Class,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = moveTo , method , js_class = "PathItem" , catch)]
                                fn __TSB_move_to(
                                    this: &PathItem_Class,
                                    point: Point,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = exclude , method , js_class = "PathItem" , catch)]
                                fn __TSB_exclude(
                                    this: &PathItem_Class,
                                    path: PathItem,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<PathItem, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = interpolate , method , js_class = "PathItem" , catch)]
                                fn __TSB_interpolate(
                                    this: &PathItem_Class,
                                    from: PathItem,
                                    to: PathItem,
                                    factor: f64,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = compare , method , js_class = "PathItem" , catch)]
                                fn __TSB_compare(
                                    this: &PathItem_Class,
                                    path: PathItem,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = arcBy , method , js_class = "PathItem" , catch)]
                                fn __TSB_arc_by(
                                    this: &PathItem_Class,
                                    to: Point,
                                    clockwise: bool,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = lineTo , method , js_class = "PathItem" , catch)]
                                fn __TSB_line_to(
                                    this: &PathItem_Class,
                                    point: Point,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = lineBy , method , js_class = "PathItem" , catch)]
                                fn __TSB_line_by(
                                    this: &PathItem_Class,
                                    point: Point,
                                ) -> std::result::Result<(), JsValue>;
                                # [wasm_bindgen (method , structural , getter = pathData , js_class = "PathItem")]
                                fn path_data(this: &PathItem_Class) -> String;
                                # [wasm_bindgen (method , structural , setter = pathData , js_class = "PathItem")]
                                fn set_path_data(this: &PathItem_Class, value: String);
                                # [wasm_bindgen (method , structural , getter = interiorPoint , js_class = "PathItem")]
                                fn interior_point(this: &PathItem_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = interiorPoint , js_class = "PathItem")]
                                fn set_interior_point(this: &PathItem_Class, value: Point);
                                # [wasm_bindgen (method , structural , getter = clockwise , js_class = "PathItem")]
                                fn clockwise(this: &PathItem_Class) -> bool;
                                # [wasm_bindgen (method , structural , setter = clockwise , js_class = "PathItem")]
                                fn set_clockwise(this: &PathItem_Class, value: bool);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = smooth , method , js_class = "PathItem" , catch)]
                                fn __TSB_smooth(
                                    this: &PathItem_Class,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getNearestLocation , method , js_class = "PathItem" , catch)]
                                fn __TSB_get_nearest_location(
                                    this: &PathItem_Class,
                                    point: Point,
                                ) -> std::result::Result<CurveLocation, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = divide , method , js_class = "PathItem" , catch)]
                                fn __TSB_divide(
                                    this: &PathItem_Class,
                                    path: PathItem,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<PathItem, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = cubicCurveTo , method , js_class = "PathItem" , catch)]
                                fn __TSB_cubic_curve_to(
                                    this: &PathItem_Class,
                                    handle1: Point,
                                    handle2: Point,
                                    to: Point,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = subtract , method , js_class = "PathItem" , catch)]
                                fn __TSB_subtract(
                                    this: &PathItem_Class,
                                    path: PathItem,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<PathItem, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = moveBy , method , js_class = "PathItem" , catch)]
                                fn __TSB_move_by(
                                    this: &PathItem_Class,
                                    to: Point,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = quadraticCurveTo , method , js_class = "PathItem" , catch)]
                                fn __TSB_quadratic_curve_to(
                                    this: &PathItem_Class,
                                    handle: Point,
                                    to: Point,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getCrossings , method , js_class = "PathItem" , catch)]
                                fn __TSB_get_crossings(
                                    this: &PathItem_Class,
                                    path: PathItem,
                                ) -> std::result::Result<Vec<CurveLocation>, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = curveTo , method , js_class = "PathItem" , catch)]
                                fn __TSB_curve_to(
                                    this: &PathItem_Class,
                                    through: Point,
                                    to: Point,
                                    time: f64,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = arcTo , method , js_class = "PathItem" , catch)]
                                fn __TSB_arc_to(
                                    this: &PathItem_Class,
                                    to: Point,
                                    clockwise: bool,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = unite , method , js_class = "PathItem" , catch)]
                                fn __TSB_unite(
                                    this: &PathItem_Class,
                                    path: PathItem,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<PathItem, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = flatten , method , js_class = "PathItem" , catch)]
                                fn __TSB_flatten(
                                    this: &PathItem_Class,
                                    flatness: f64,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = intersect , method , js_class = "PathItem" , catch)]
                                fn __TSB_intersect(
                                    this: &PathItem_Class,
                                    path: PathItem,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<PathItem, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = reorient , method , js_class = "PathItem" , catch)]
                                fn __TSB_reorient(
                                    this: &PathItem_Class,
                                    non_zero: bool,
                                    clockwise: bool,
                                ) -> std::result::Result<PathItem, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = create , method , js_class = "PathItem" , catch)]
                                fn __TSB_create(
                                    this: &PathItem_Class,
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>;
                            }
                            #[derive(std :: clone :: Clone)]
                            struct PathItem(pub PathItem_Class);
                            impl std::convert::From<&PathItem> for Item {
                                fn from(src: &PathItem) -> Item {
                                    let src: &Item_Class = src.0.as_ref();
                                    Item(src.clone())
                                }
                            }
                            impl std::convert::From<&mut PathItem> for Item {
                                fn from(src: &mut PathItem) -> Item {
                                    let src: &Item_Class = src.0.as_ref();
                                    Item(src.clone())
                                }
                            }
                            impl PathItem {
                                #[allow(dead_code)]
                                pub fn cubic_curve_by(
                                    &self,
                                    handle1: Point,
                                    handle2: Point,
                                    to: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_cubic_curve_by(handle1, handle2, to)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn curve_by(
                                    &self,
                                    through: Point,
                                    to: Point,
                                    time: f64,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_curve_by(through, to, time)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn close_path(&self) -> std::result::Result<(), JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_close_path()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn simplify(
                                    &self,
                                    tolerance: f64,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_simplify(tolerance)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn reverse(&self) -> std::result::Result<(), JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_reverse()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn quadratic_curve_by(
                                    &self,
                                    handle: Point,
                                    to: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_quadratic_curve_by(handle, to)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_intersections(
                                    &self,
                                    path: PathItem,
                                    include: JsValue,
                                ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_intersections(path, include)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_nearest_point(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_nearest_point(point)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn move_to(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_move_to(point)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn exclude(
                                    &self,
                                    path: PathItem,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<PathItem, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_exclude(path, options)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn interpolate(
                                    &self,
                                    from: PathItem,
                                    to: PathItem,
                                    factor: f64,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_interpolate(from, to, factor)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn compare(
                                    &self,
                                    path: PathItem,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_compare(path)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn arc_by(
                                    &self,
                                    to: Point,
                                    clockwise: bool,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_arc_by(to, clockwise)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn line_to(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_line_to(point)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn line_by(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_line_by(point)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn path_data(&self) -> String {
                                    let result = self.0.path_data();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_path_data(&self, value: String) -> () {
                                    let result = self.0.set_path_data(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn interior_point(&self) -> Point {
                                    let result = self.0.interior_point();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_interior_point(&self, value: Point) -> () {
                                    let result = self.0.set_interior_point(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn clockwise(&self) -> bool {
                                    let result = self.0.clockwise();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_clockwise(&self, value: bool) -> () {
                                    let result = self.0.set_clockwise(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn smooth(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_smooth(options)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_nearest_location(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<CurveLocation, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_nearest_location(point)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn divide(
                                    &self,
                                    path: PathItem,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<PathItem, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_divide(path, options)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn cubic_curve_to(
                                    &self,
                                    handle1: Point,
                                    handle2: Point,
                                    to: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_cubic_curve_to(handle1, handle2, to)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn subtract(
                                    &self,
                                    path: PathItem,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<PathItem, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_subtract(path, options)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn move_by(
                                    &self,
                                    to: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result = std::result::Result::Ok(self.0.__TSB_move_by(to)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn quadratic_curve_to(
                                    &self,
                                    handle: Point,
                                    to: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_quadratic_curve_to(handle, to)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_crossings(
                                    &self,
                                    path: PathItem,
                                ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_get_crossings(path)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn curve_to(
                                    &self,
                                    through: Point,
                                    to: Point,
                                    time: f64,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_curve_to(through, to, time)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn arc_to(
                                    &self,
                                    to: Point,
                                    clockwise: bool,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_arc_to(to, clockwise)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn unite(
                                    &self,
                                    path: PathItem,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<PathItem, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_unite(path, options)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn flatten(
                                    &self,
                                    flatness: f64,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_flatten(flatness)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn intersect(
                                    &self,
                                    path: PathItem,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<PathItem, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_intersect(path, options)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn reorient(
                                    &self,
                                    non_zero: bool,
                                    clockwise: bool,
                                ) -> std::result::Result<PathItem, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_reorient(non_zero, clockwise)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn create(
                                    &self,
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<PathItemCreateReturn, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        ts_bindgen_rt::from_jsvalue(&self.0.__TSB_create(object)?)
                                            .unwrap(),
                                    );
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for PathItem {
                                fn describe() {
                                    < PathItem_Class as wasm_bindgen :: describe :: WasmDescribe > :: describe ()
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for PathItem {
                                type Abi =
                                    <PathItem_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a PathItem {
                                type Abi =
                                    <&'a PathItem_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for PathItem {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for PathItem {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal: PathItem_Class =
                                        <PathItem_Class as serde::de::Deserialize>::deserialize(
                                            deserializer,
                                        )?;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait PathItem_Trait: Item_Trait {
                                fn cubic_curve_by(
                                    &self,
                                    handle1: Point,
                                    handle2: Point,
                                    to: Point,
                                ) -> std::result::Result<(), JsValue>;
                                fn curve_by(
                                    &self,
                                    through: Point,
                                    to: Point,
                                    time: f64,
                                ) -> std::result::Result<(), JsValue>;
                                fn close_path(&self) -> std::result::Result<(), JsValue>;
                                fn simplify(
                                    &self,
                                    tolerance: f64,
                                ) -> std::result::Result<bool, JsValue>;
                                fn reverse(&self) -> std::result::Result<(), JsValue>;
                                fn quadratic_curve_by(
                                    &self,
                                    handle: Point,
                                    to: Point,
                                ) -> std::result::Result<(), JsValue>;
                                fn get_intersections(
                                    &self,
                                    path: PathItem,
                                    include: JsValue,
                                ) -> std::result::Result<Vec<CurveLocation>, JsValue>;
                                fn get_nearest_point(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                fn move_to(&self, point: Point)
                                    -> std::result::Result<(), JsValue>;
                                fn exclude(
                                    &self,
                                    path: PathItem,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<PathItem, JsValue>;
                                fn interpolate(
                                    &self,
                                    from: PathItem,
                                    to: PathItem,
                                    factor: f64,
                                ) -> std::result::Result<(), JsValue>;
                                fn compare(
                                    &self,
                                    path: PathItem,
                                ) -> std::result::Result<bool, JsValue>;
                                fn arc_by(
                                    &self,
                                    to: Point,
                                    clockwise: bool,
                                ) -> std::result::Result<(), JsValue>;
                                fn line_to(&self, point: Point)
                                    -> std::result::Result<(), JsValue>;
                                fn line_by(&self, point: Point)
                                    -> std::result::Result<(), JsValue>;
                                fn path_data(&self) -> String;
                                fn set_path_data(&mut self, value: String) -> ();
                                fn interior_point(&self) -> Point;
                                fn set_interior_point(&mut self, value: Point) -> ();
                                fn clockwise(&self) -> bool;
                                fn set_clockwise(&mut self, value: bool) -> ();
                                fn smooth(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<(), JsValue>;
                                fn get_nearest_location(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<CurveLocation, JsValue>;
                                fn divide(
                                    &self,
                                    path: PathItem,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<PathItem, JsValue>;
                                fn cubic_curve_to(
                                    &self,
                                    handle1: Point,
                                    handle2: Point,
                                    to: Point,
                                ) -> std::result::Result<(), JsValue>;
                                fn subtract(
                                    &self,
                                    path: PathItem,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<PathItem, JsValue>;
                                fn move_by(&self, to: Point) -> std::result::Result<(), JsValue>;
                                fn quadratic_curve_to(
                                    &self,
                                    handle: Point,
                                    to: Point,
                                ) -> std::result::Result<(), JsValue>;
                                fn get_crossings(
                                    &self,
                                    path: PathItem,
                                ) -> std::result::Result<Vec<CurveLocation>, JsValue>;
                                fn curve_to(
                                    &self,
                                    through: Point,
                                    to: Point,
                                    time: f64,
                                ) -> std::result::Result<(), JsValue>;
                                fn arc_to(
                                    &self,
                                    to: Point,
                                    clockwise: bool,
                                ) -> std::result::Result<(), JsValue>;
                                fn unite(
                                    &self,
                                    path: PathItem,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<PathItem, JsValue>;
                                fn flatten(
                                    &self,
                                    flatness: f64,
                                ) -> std::result::Result<(), JsValue>;
                                fn intersect(
                                    &self,
                                    path: PathItem,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<PathItem, JsValue>;
                                fn reorient(
                                    &self,
                                    non_zero: bool,
                                    clockwise: bool,
                                ) -> std::result::Result<PathItem, JsValue>;
                                fn create(
                                    &self,
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<PathItemCreateReturn, JsValue>;
                            }
                            impl Item_Trait for PathItem {
                                fn insert_below(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_below(&target, item)
                                }
                                fn on_double_click(&self) -> ItemOnDoubleClick {
                                    let target: Item = self.into();
                                    Item::on_double_click(&target)
                                }
                                fn set_on_double_click(&mut self, value: ItemOnDoubleClick) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_double_click(&mut target, value)
                                }
                                fn view(&self) -> View {
                                    let target: Item = self.into();
                                    Item::view(&target)
                                }
                                fn set_view(&mut self, value: View) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_view(&mut target, value)
                                }
                                fn blend_mode(&self) -> String {
                                    let target: Item = self.into();
                                    Item::blend_mode(&target)
                                }
                                fn set_blend_mode(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_blend_mode(&mut target, value)
                                }
                                fn name(&self) -> String {
                                    let target: Item = self.into();
                                    Item::name(&target)
                                }
                                fn set_name(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_name(&mut target, value)
                                }
                                fn project(&self) -> Project {
                                    let target: Item = self.into();
                                    Item::project(&target)
                                }
                                fn set_project(&mut self, value: Project) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_project(&mut target, value)
                                }
                                fn is_child(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_child(&target, item)
                                }
                                fn global_matrix(&self) -> Matrix {
                                    let target: Item = self.into();
                                    Item::global_matrix(&target)
                                }
                                fn set_global_matrix(&mut self, value: Matrix) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_global_matrix(&mut target, value)
                                }
                                fn on_mouse_leave(&self) -> ItemOnMouseLeave {
                                    let target: Item = self.into();
                                    Item::on_mouse_leave(&target)
                                }
                                fn set_on_mouse_leave(&mut self, value: ItemOnMouseLeave) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_leave(&mut target, value)
                                }
                                fn has_children(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_children(&target)
                                }
                                fn selected(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::selected(&target)
                                }
                                fn set_selected(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_selected(&mut target, value)
                                }
                                fn global_to_local(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::global_to_local(&target, point)
                                }
                                fn shadow_blur(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::shadow_blur(&target)
                                }
                                fn set_shadow_blur(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_shadow_blur(&mut target, value)
                                }
                                fn children(&self) -> Vec<Item> {
                                    let target: Item = self.into();
                                    Item::children(&target)
                                }
                                fn set_children(&mut self, value: Vec<Item>) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_children(&mut target, value)
                                }
                                fn replace_with(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::replace_with(&target, item)
                                }
                                fn import_json(
                                    &self,
                                    json: String,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::import_json(&target, json)
                                }
                                fn insert_child(
                                    &self,
                                    index: f64,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_child(&target, index, item)
                                }
                                fn stroke_join(&self) -> String {
                                    let target: Item = self.into();
                                    Item::stroke_join(&target)
                                }
                                fn set_stroke_join(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_join(&mut target, value)
                                }
                                fn rotation(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::rotation(&target)
                                }
                                fn set_rotation(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_rotation(&mut target, value)
                                }
                                fn scaling(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::scaling(&target)
                                }
                                fn set_scaling(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_scaling(&mut target, value)
                                }
                                fn is_ancestor(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_ancestor(&target, item)
                                }
                                fn emit(
                                    &self,
                                    type_: String,
                                    event: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::emit(&target, type_, event)
                                }
                                fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_up(&target)
                                }
                                fn add_to(
                                    &self,
                                    owner: ItemAddToParamsOwnerParam,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::add_to(&target, owner)
                                }
                                fn stroke_cap(&self) -> String {
                                    let target: Item = self.into();
                                    Item::stroke_cap(&target)
                                }
                                fn set_stroke_cap(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_cap(&mut target, value)
                                }
                                fn on_mouse_drag(&self) -> ItemOnMouseDrag {
                                    let target: Item = self.into();
                                    Item::on_mouse_drag(&target)
                                }
                                fn set_on_mouse_drag(&mut self, value: ItemOnMouseDrag) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_drag(&mut target, value)
                                }
                                fn set(
                                    &self,
                                    props: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::set(&target, props)
                                }
                                fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::reverse_children(&target)
                                }
                                fn matches(
                                    &self,
                                    name: String,
                                    compare: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::matches(&target, name, compare)
                                }
                                fn on_mouse_enter(&self) -> ItemOnMouseEnter {
                                    let target: Item = self.into();
                                    Item::on_mouse_enter(&target)
                                }
                                fn set_on_mouse_enter(&mut self, value: ItemOnMouseEnter) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_enter(&mut target, value)
                                }
                                fn shadow_offset(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::shadow_offset(&target)
                                }
                                fn set_shadow_offset(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_shadow_offset(&mut target, value)
                                }
                                fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_stroke(&target)
                                }
                                fn view_matrix(&self) -> Matrix {
                                    let target: Item = self.into();
                                    Item::view_matrix(&target)
                                }
                                fn set_view_matrix(&mut self, value: Matrix) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_view_matrix(&mut target, value)
                                }
                                fn on_frame(&self) -> ItemOnFrame {
                                    let target: Item = self.into();
                                    Item::on_frame(&target)
                                }
                                fn set_on_frame(&mut self, value: ItemOnFrame) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_frame(&mut target, value)
                                }
                                fn on_mouse_down(&self) -> ItemOnMouseDown {
                                    let target: Item = self.into();
                                    Item::on_mouse_down(&target)
                                }
                                fn set_on_mouse_down(&mut self, value: ItemOnMouseDown) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_down(&mut target, value)
                                }
                                fn is_sibling(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_sibling(&target, item)
                                }
                                fn local_to_global(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::local_to_global(&target, point)
                                }
                                fn first_child(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::first_child(&target)
                                }
                                fn set_first_child(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_first_child(&mut target, value)
                                }
                                fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::send_to_back(&target)
                                }
                                fn clip_mask(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::clip_mask(&target)
                                }
                                fn set_clip_mask(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_clip_mask(&mut target, value)
                                }
                                fn next_sibling(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::next_sibling(&target)
                                }
                                fn set_next_sibling(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_next_sibling(&mut target, value)
                                }
                                fn off(
                                    &self,
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::off(&target, object)
                                }
                                fn rotate(
                                    &self,
                                    angle: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::rotate(&target, angle, center)
                                }
                                fn add_child(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::add_child(&target, item)
                                }
                                fn is_grouped_with(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_grouped_with(&target, item)
                                }
                                fn scale(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::scale(&target, hor, ver, center)
                                }
                                fn hit_test_all(
                                    &self,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Vec<HitResult>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::hit_test_all(&target, point, options)
                                }
                                fn insert_children(
                                    &self,
                                    index: f64,
                                    items: Vec<Item>,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_children(&target, index, items)
                                }
                                fn style(&self) -> Style {
                                    let target: Item = self.into();
                                    Item::style(&target)
                                }
                                fn set_style(&mut self, value: Style) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_style(&mut target, value)
                                }
                                fn position(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::position(&target)
                                }
                                fn set_position(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_position(&mut target, value)
                                }
                                fn transform(
                                    &self,
                                    matrix: Matrix,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::transform(&target, matrix)
                                }
                                fn fill_color(&self) -> ItemFillColor {
                                    let target: Item = self.into();
                                    Item::fill_color(&target)
                                }
                                fn set_fill_color(&mut self, value: ItemFillColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_fill_color(&mut target, value)
                                }
                                fn matrix(&self) -> Matrix {
                                    let target: Item = self.into();
                                    Item::matrix(&target)
                                }
                                fn set_matrix(&mut self, value: Matrix) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_matrix(&mut target, value)
                                }
                                fn id(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::id(&target)
                                }
                                fn set_id(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_id(&mut target, value)
                                }
                                fn tween(
                                    &self,
                                    options: ItemTweenParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::tween(&target, options)
                                }
                                fn reduce(
                                    &self,
                                    options: JsValue,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::reduce(&target, options)
                                }
                                fn internal_bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::internal_bounds(&target)
                                }
                                fn set_internal_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_internal_bounds(&mut target, value)
                                }
                                fn fill_rule(&self) -> String {
                                    let target: Item = self.into();
                                    Item::fill_rule(&target)
                                }
                                fn set_fill_rule(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_fill_rule(&mut target, value)
                                }
                                fn shadow_color(&self) -> ItemShadowColor {
                                    let target: Item = self.into();
                                    Item::shadow_color(&target)
                                }
                                fn set_shadow_color(&mut self, value: ItemShadowColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_shadow_color(&mut target, value)
                                }
                                fn insert_above(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_above(&target, item)
                                }
                                fn responds(
                                    &self,
                                    type_: String,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::responds(&target, type_)
                                }
                                fn handle_bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::handle_bounds(&target)
                                }
                                fn set_handle_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_handle_bounds(&mut target, value)
                                }
                                fn skew(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::skew(&target, hor, ver, center)
                                }
                                fn on_click(&self) -> ItemOnClick {
                                    let target: Item = self.into();
                                    Item::on_click(&target)
                                }
                                fn set_on_click(&mut self, value: ItemOnClick) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_click(&mut target, value)
                                }
                                fn get_items(
                                    &self,
                                    options: ItemGetItemsParamsOptionsParam,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::get_items(&target, options)
                                }
                                fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::is_inserted(&target)
                                }
                                fn get_item(
                                    &self,
                                    options: ItemGetItemParamsOptionsParam,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::get_item(&target, options)
                                }
                                fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_fill(&target)
                                }
                                fn shear(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::shear(&target, hor, ver, center)
                                }
                                fn visible(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::visible(&target)
                                }
                                fn set_visible(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_visible(&mut target, value)
                                }
                                fn previous_sibling(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::previous_sibling(&target)
                                }
                                fn set_previous_sibling(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_previous_sibling(&mut target, value)
                                }
                                fn hit_test(
                                    &self,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<HitResult, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::hit_test(&target, point, options)
                                }
                                fn is_descendant(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_descendant(&target, item)
                                }
                                fn locked(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::locked(&target)
                                }
                                fn set_locked(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_locked(&mut target, value)
                                }
                                fn is_parent(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_parent(&target, item)
                                }
                                fn copy_attributes(
                                    &self,
                                    source: Item,
                                    exclude_matrix: bool,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::copy_attributes(&target, source, exclude_matrix)
                                }
                                fn last_child(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::last_child(&target)
                                }
                                fn set_last_child(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_last_child(&mut target, value)
                                }
                                fn stroke_width(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::stroke_width(&target)
                                }
                                fn set_stroke_width(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_width(&mut target, value)
                                }
                                fn parent(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::parent(&target)
                                }
                                fn set_parent(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_parent(&mut target, value)
                                }
                                fn stroke_bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::stroke_bounds(&target)
                                }
                                fn set_stroke_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_bounds(&mut target, value)
                                }
                                fn translate(
                                    &self,
                                    delta: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::translate(&target, delta)
                                }
                                fn remove(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::remove(&target)
                                }
                                fn parent_to_local(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::parent_to_local(&target, point)
                                }
                                fn bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::bounds(&target)
                                }
                                fn set_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_bounds(&mut target, value)
                                }
                                fn add_children(
                                    &self,
                                    items: Vec<Item>,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::add_children(&target, items)
                                }
                                fn dash_array(&self) -> Vec<f64> {
                                    let target: Item = self.into();
                                    Item::dash_array(&target)
                                }
                                fn set_dash_array(&mut self, value: Vec<f64>) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_dash_array(&mut target, value)
                                }
                                fn on_mouse_up(&self) -> ItemOnMouseUp {
                                    let target: Item = self.into();
                                    Item::on_mouse_up(&target)
                                }
                                fn set_on_mouse_up(&mut self, value: ItemOnMouseUp) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_up(&mut target, value)
                                }
                                fn on(
                                    &self,
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::on(&target, object)
                                }
                                fn remove_on(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::remove_on(&target, options)
                                }
                                fn is_below(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_below(&target, item)
                                }
                                fn apply_matrix(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::apply_matrix(&target)
                                }
                                fn set_apply_matrix(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_apply_matrix(&mut target, value)
                                }
                                fn clone(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::clone(&target, options)
                                }
                                fn contains(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::contains(&target, point)
                                }
                                fn export_json(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<String, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::export_json(&target, options)
                                }
                                fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::bring_to_front(&target)
                                }
                                fn is_above(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_above(&target, item)
                                }
                                fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_drag(&target)
                                }
                                fn data(&self) -> JsValue {
                                    let target: Item = self.into();
                                    Item::data(&target)
                                }
                                fn set_data(&mut self, value: JsValue) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_data(&mut target, value)
                                }
                                fn import_svg(
                                    &self,
                                    svg: ItemImportSvgParamsSvgParam,
                                    on_load: JsValue,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::import_svg(&target, svg, on_load)
                                }
                                fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_shadow(&target)
                                }
                                fn selected_color(&self) -> ItemSelectedColor {
                                    let target: Item = self.into();
                                    Item::selected_color(&target)
                                }
                                fn set_selected_color(&mut self, value: ItemSelectedColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_selected_color(&mut target, value)
                                }
                                fn class_name(&self) -> String {
                                    let target: Item = self.into();
                                    Item::class_name(&target)
                                }
                                fn set_class_name(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_class_name(&mut target, value)
                                }
                                fn export_svg(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<ItemExportSvgReturn, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::export_svg(&target, options)
                                }
                                fn tween_to(
                                    &self,
                                    to: std::collections::HashMap<String, JsValue>,
                                    options: ItemTweenToParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::tween_to(&target, to, options)
                                }
                                fn is_inside(
                                    &self,
                                    rect: Rectangle,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_inside(&target, rect)
                                }
                                fn is_empty(
                                    &self,
                                    recursively: bool,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_empty(&target, recursively)
                                }
                                fn copy_content(
                                    &self,
                                    source: Item,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::copy_content(&target, source)
                                }
                                fn rasterize(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Raster, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::rasterize(&target, options)
                                }
                                fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_move(&target)
                                }
                                fn tween_from(
                                    &self,
                                    from: std::collections::HashMap<String, JsValue>,
                                    options: ItemTweenFromParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::tween_from(&target, from, options)
                                }
                                fn opacity(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::opacity(&target)
                                }
                                fn set_opacity(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_opacity(&mut target, value)
                                }
                                fn dash_offset(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::dash_offset(&target)
                                }
                                fn set_dash_offset(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_dash_offset(&mut target, value)
                                }
                                fn remove_children(
                                    &self,
                                    start: f64,
                                    end: f64,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::remove_children(&target, start, end)
                                }
                                fn on_mouse_move(&self) -> ItemOnMouseMove {
                                    let target: Item = self.into();
                                    Item::on_mouse_move(&target)
                                }
                                fn set_on_mouse_move(&mut self, value: ItemOnMouseMove) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_move(&mut target, value)
                                }
                                fn intersects(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::intersects(&target, item)
                                }
                                fn pivot(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::pivot(&target)
                                }
                                fn set_pivot(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_pivot(&mut target, value)
                                }
                                fn copy_to(
                                    &self,
                                    owner: ItemCopyToParamsOwnerParam,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::copy_to(&target, owner)
                                }
                                fn index(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::index(&target)
                                }
                                fn set_index(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_index(&mut target, value)
                                }
                                fn local_to_parent(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::local_to_parent(&target, point)
                                }
                                fn stroke_color(&self) -> ItemStrokeColor {
                                    let target: Item = self.into();
                                    Item::stroke_color(&target)
                                }
                                fn set_stroke_color(&mut self, value: ItemStrokeColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_color(&mut target, value)
                                }
                                fn layer(&self) -> Layer {
                                    let target: Item = self.into();
                                    Item::layer(&target)
                                }
                                fn set_layer(&mut self, value: Layer) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_layer(&mut target, value)
                                }
                                fn stroke_scaling(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::stroke_scaling(&target)
                                }
                                fn set_stroke_scaling(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_scaling(&mut target, value)
                                }
                                fn fit_bounds(
                                    &self,
                                    rectangle: Rectangle,
                                    fill: bool,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::fit_bounds(&target, rectangle, fill)
                                }
                                fn miter_limit(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::miter_limit(&target)
                                }
                                fn set_miter_limit(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_miter_limit(&mut target, value)
                                }
                                fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_down(&target)
                                }
                            }
                            impl PathItem_Trait for PathItem {}
                            impl std::clone::Clone for PathItem_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for PathItem_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for PathItem_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                # [wasm_bindgen (js_name = "Path" , extends = PathItem_Class)]
                                type Path_Class;
                                # [wasm_bindgen (method , structural , getter = length , js_class = "Path")]
                                fn length(this: &Path_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = length , js_class = "Path")]
                                fn set_length(this: &Path_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getNormalAt , method , js_class = "Path" , catch)]
                                fn __TSB_get_normal_at(
                                    this: &Path_Class,
                                    offset: f64,
                                ) -> std::result::Result<Point, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getWeightedNormalAt , method , js_class = "Path" , catch)]
                                fn __TSB_get_weighted_normal_at(
                                    this: &Path_Class,
                                    offset: f64,
                                ) -> std::result::Result<Point, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = add , method , js_class = "Path" , catch , variadic)]
                                fn __TSB_add(
                                    this: &Path_Class,
                                    segment: &[JsValue],
                                ) -> std::result::Result<JsValue, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getOffsetsWithTangent , method , js_class = "Path" , catch)]
                                fn __TSB_get_offsets_with_tangent(
                                    this: &Path_Class,
                                    tangent: Point,
                                ) -> std::result::Result<Vec<f64>, JsValue>;
                                # [wasm_bindgen (method , structural , getter = firstSegment , js_class = "Path")]
                                fn first_segment(this: &Path_Class) -> Segment;
                                # [wasm_bindgen (method , structural , setter = firstSegment , js_class = "Path")]
                                fn set_first_segment(this: &Path_Class, value: Segment);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = toShape , method , js_class = "Path" , catch)]
                                fn __TSB_to_shape(
                                    this: &Path_Class,
                                    insert: bool,
                                ) -> std::result::Result<Shape, JsValue>;
                                #[wasm_bindgen(constructor, js_class = "Path")]
                                pub fn new(
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> Path_Class;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getTangentAt , method , js_class = "Path" , catch)]
                                fn __TSB_get_tangent_at(
                                    this: &Path_Class,
                                    offset: f64,
                                ) -> std::result::Result<Point, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = join , method , js_class = "Path" , catch)]
                                fn __TSB_join(
                                    this: &Path_Class,
                                    path: Path,
                                    tolerance: f64,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getWeightedTangentAt , method , js_class = "Path" , catch)]
                                fn __TSB_get_weighted_tangent_at(
                                    this: &Path_Class,
                                    offset: f64,
                                ) -> std::result::Result<Point, JsValue>;
                                # [wasm_bindgen (method , structural , getter = fullySelected , js_class = "Path")]
                                fn fully_selected(this: &Path_Class) -> bool;
                                # [wasm_bindgen (method , structural , setter = fullySelected , js_class = "Path")]
                                fn set_fully_selected(this: &Path_Class, value: bool);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = reduce , method , js_class = "Path" , catch)]
                                fn __TSB_reduce(
                                    this: &Path_Class,
                                    options: JsValue,
                                ) -> std::result::Result<Path, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = addSegments , method , js_class = "Path" , catch)]
                                fn __TSB_add_segments(
                                    this: &Path_Class,
                                    segments: Vec<Segment>,
                                ) -> std::result::Result<Vec<Segment>, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = splitAt , method , js_class = "Path" , catch)]
                                fn __TSB_split_at(
                                    this: &Path_Class,
                                    location: JsValue,
                                ) -> std::result::Result<Path, JsValue>;
                                # [wasm_bindgen (method , structural , getter = lastCurve , js_class = "Path")]
                                fn last_curve(this: &Path_Class) -> Curve;
                                # [wasm_bindgen (method , structural , setter = lastCurve , js_class = "Path")]
                                fn set_last_curve(this: &Path_Class, value: Curve);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = removeSegments , method , js_class = "Path" , catch)]
                                fn __TSB_remove_segments(
                                    this: &Path_Class,
                                    from: f64,
                                    to: f64,
                                ) -> std::result::Result<Vec<Segment>, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getLocationOf , method , js_class = "Path" , catch)]
                                fn __TSB_get_location_of(
                                    this: &Path_Class,
                                    point: Point,
                                ) -> std::result::Result<CurveLocation, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = hasHandles , method , js_class = "Path" , catch)]
                                fn __TSB_has_handles(
                                    this: &Path_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getOffsetOf , method , js_class = "Path" , catch)]
                                fn __TSB_get_offset_of(
                                    this: &Path_Class,
                                    point: Point,
                                ) -> std::result::Result<f64, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getPointAt , method , js_class = "Path" , catch)]
                                fn __TSB_get_point_at(
                                    this: &Path_Class,
                                    offset: f64,
                                ) -> std::result::Result<Point, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = insert , method , js_class = "Path" , catch)]
                                fn __TSB_insert(
                                    this: &Path_Class,
                                    index: f64,
                                    segment: JsValue,
                                ) -> std::result::Result<Segment, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = insertSegments , method , js_class = "Path" , catch)]
                                fn __TSB_insert_segments(
                                    this: &Path_Class,
                                    index: f64,
                                    segments: Vec<Segment>,
                                ) -> std::result::Result<Vec<Segment>, JsValue>;
                                # [wasm_bindgen (method , structural , getter = lastSegment , js_class = "Path")]
                                fn last_segment(this: &Path_Class) -> Segment;
                                # [wasm_bindgen (method , structural , setter = lastSegment , js_class = "Path")]
                                fn set_last_segment(this: &Path_Class, value: Segment);
                                # [wasm_bindgen (method , structural , getter = segments , js_class = "Path")]
                                fn segments(this: &Path_Class) -> Vec<Segment>;
                                # [wasm_bindgen (method , structural , setter = segments , js_class = "Path")]
                                fn set_segments(this: &Path_Class, value: Vec<Segment>);
                                # [wasm_bindgen (method , structural , getter = closed , js_class = "Path")]
                                fn closed(this: &Path_Class) -> bool;
                                # [wasm_bindgen (method , structural , setter = closed , js_class = "Path")]
                                fn set_closed(this: &Path_Class, value: bool);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getLocationAt , method , js_class = "Path" , catch)]
                                fn __TSB_get_location_at(
                                    this: &Path_Class,
                                    offset: f64,
                                ) -> std::result::Result<CurveLocation, JsValue>;
                                # [wasm_bindgen (method , structural , getter = curves , js_class = "Path")]
                                fn curves(this: &Path_Class) -> Vec<Curve>;
                                # [wasm_bindgen (method , structural , setter = curves , js_class = "Path")]
                                fn set_curves(this: &Path_Class, value: Vec<Curve>);
                                # [wasm_bindgen (method , structural , getter = firstCurve , js_class = "Path")]
                                fn first_curve(this: &Path_Class) -> Curve;
                                # [wasm_bindgen (method , structural , setter = firstCurve , js_class = "Path")]
                                fn set_first_curve(this: &Path_Class, value: Curve);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getCurvatureAt , method , js_class = "Path" , catch)]
                                fn __TSB_get_curvature_at(
                                    this: &Path_Class,
                                    offset: f64,
                                ) -> std::result::Result<f64, JsValue>;
                                # [wasm_bindgen (method , structural , getter = area , js_class = "Path")]
                                fn area(this: &Path_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = area , js_class = "Path")]
                                fn set_area(this: &Path_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = clearHandles , method , js_class = "Path" , catch)]
                                fn __TSB_clear_handles(
                                    this: &Path_Class,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = removeSegment , method , js_class = "Path" , catch)]
                                fn __TSB_remove_segment(
                                    this: &Path_Class,
                                    index: f64,
                                ) -> std::result::Result<Segment, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = divideAt , method , js_class = "Path" , catch)]
                                fn __TSB_divide_at(
                                    this: &Path_Class,
                                    location: JsValue,
                                ) -> std::result::Result<Segment, JsValue>;
                            }
                            #[derive(std :: clone :: Clone)]
                            struct Path(pub Path_Class);
                            impl std::convert::From<&Path> for PathItem {
                                fn from(src: &Path) -> PathItem {
                                    let src: &PathItem_Class = src.0.as_ref();
                                    PathItem(src.clone())
                                }
                            }
                            impl std::convert::From<&mut Path> for PathItem {
                                fn from(src: &mut Path) -> PathItem {
                                    let src: &PathItem_Class = src.0.as_ref();
                                    PathItem(src.clone())
                                }
                            }
                            impl Path {
                                #[allow(dead_code)]
                                pub fn length(&self) -> f64 {
                                    let result = self.0.length();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_length(&self, value: f64) -> () {
                                    let result = self.0.set_length(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_normal_at(
                                    &self,
                                    offset: f64,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_normal_at(offset)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_weighted_normal_at(
                                    &self,
                                    offset: f64,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_weighted_normal_at(offset)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn add(
                                    &self,
                                    segment: &[PathAddParamsSegmentParam],
                                ) -> std::result::Result<PathAddReturn, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        ts_bindgen_rt::from_jsvalue(
                                            &self.0.__TSB_add(
                                                ts_bindgen_rt::to_jsvalue(&segment)
                                                    .map_err(ts_bindgen_rt::Error::from)?,
                                            )?,
                                        )
                                        .unwrap(),
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_offsets_with_tangent(
                                    &self,
                                    tangent: Point,
                                ) -> std::result::Result<Vec<f64>, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_offsets_with_tangent(tangent)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn first_segment(&self) -> Segment {
                                    let result = self.0.first_segment();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_first_segment(&self, value: Segment) -> () {
                                    let result = self.0.set_first_segment(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn to_shape(
                                    &self,
                                    insert: bool,
                                ) -> std::result::Result<Shape, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_to_shape(insert)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn new(
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> Path {
                                    let result = Path_Class::new(object);
                                    let result =
                                        ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result)
                                            .unwrap();
                                    Path(result)
                                }
                                #[allow(dead_code)]
                                pub fn get_tangent_at(
                                    &self,
                                    offset: f64,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_tangent_at(offset)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn join(
                                    &self,
                                    path: Path,
                                    tolerance: f64,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_join(path, tolerance)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_weighted_tangent_at(
                                    &self,
                                    offset: f64,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_weighted_tangent_at(offset)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn fully_selected(&self) -> bool {
                                    let result = self.0.fully_selected();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_fully_selected(&self, value: bool) -> () {
                                    let result = self.0.set_fully_selected(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn reduce(
                                    &self,
                                    options: JsValue,
                                ) -> std::result::Result<Path, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_reduce(options)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn add_segments(
                                    &self,
                                    segments: Vec<Segment>,
                                ) -> std::result::Result<Vec<Segment>, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_add_segments(segments)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn split_at(
                                    &self,
                                    location: PathSplitAtParamsLocationParam,
                                ) -> std::result::Result<Path, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_split_at(
                                            ts_bindgen_rt::to_jsvalue(&location)
                                                .map_err(ts_bindgen_rt::Error::from)?,
                                        )?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn last_curve(&self) -> Curve {
                                    let result = self.0.last_curve();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_last_curve(&self, value: Curve) -> () {
                                    let result = self.0.set_last_curve(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn remove_segments(
                                    &self,
                                    from: f64,
                                    to: f64,
                                ) -> std::result::Result<Vec<Segment>, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_remove_segments(from, to)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_location_of(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<CurveLocation, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_location_of(point)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_has_handles()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_offset_of(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<f64, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_get_offset_of(point)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_point_at(
                                    &self,
                                    offset: f64,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_get_point_at(offset)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn insert(
                                    &self,
                                    index: f64,
                                    segment: PathInsertParamsSegmentParam,
                                ) -> std::result::Result<Segment, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_insert(
                                            index,
                                            ts_bindgen_rt::to_jsvalue(&segment)
                                                .map_err(ts_bindgen_rt::Error::from)?,
                                        )?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn insert_segments(
                                    &self,
                                    index: f64,
                                    segments: Vec<Segment>,
                                ) -> std::result::Result<Vec<Segment>, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_insert_segments(index, segments)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn last_segment(&self) -> Segment {
                                    let result = self.0.last_segment();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_last_segment(&self, value: Segment) -> () {
                                    let result = self.0.set_last_segment(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn segments(&self) -> Vec<Segment> {
                                    let result = self.0.segments();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_segments(&self, value: Vec<Segment>) -> () {
                                    let result = self.0.set_segments(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn closed(&self) -> bool {
                                    let result = self.0.closed();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_closed(&self, value: bool) -> () {
                                    let result = self.0.set_closed(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_location_at(
                                    &self,
                                    offset: f64,
                                ) -> std::result::Result<CurveLocation, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_location_at(offset)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn curves(&self) -> Vec<Curve> {
                                    let result = self.0.curves();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_curves(&self, value: Vec<Curve>) -> () {
                                    let result = self.0.set_curves(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn first_curve(&self) -> Curve {
                                    let result = self.0.first_curve();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_first_curve(&self, value: Curve) -> () {
                                    let result = self.0.set_first_curve(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_curvature_at(
                                    &self,
                                    offset: f64,
                                ) -> std::result::Result<f64, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_curvature_at(offset)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn area(&self) -> f64 {
                                    let result = self.0.area();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_area(&self, value: f64) -> () {
                                    let result = self.0.set_area(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_clear_handles()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn remove_segment(
                                    &self,
                                    index: f64,
                                ) -> std::result::Result<Segment, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_remove_segment(index)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn divide_at(
                                    &self,
                                    location: PathDivideAtParamsLocationParam,
                                ) -> std::result::Result<Segment, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_divide_at(
                                            ts_bindgen_rt::to_jsvalue(&location)
                                                .map_err(ts_bindgen_rt::Error::from)?,
                                        )?,
                                    );
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for Path {
                                fn describe() {
                                    <Path_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for Path {
                                type Abi = <Path_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Path {
                                type Abi =
                                    <&'a Path_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for Path {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Path {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal: Path_Class =
                                        <Path_Class as serde::de::Deserialize>::deserialize(
                                            deserializer,
                                        )?;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait Path_Trait: PathItem_Trait {
                                fn length(&self) -> f64;
                                fn set_length(&mut self, value: f64) -> ();
                                fn get_normal_at(
                                    &self,
                                    offset: f64,
                                ) -> std::result::Result<Point, JsValue>;
                                fn get_weighted_normal_at(
                                    &self,
                                    offset: f64,
                                ) -> std::result::Result<Point, JsValue>;
                                fn add(
                                    &self,
                                    segment: &[PathAddParamsSegmentParam],
                                ) -> std::result::Result<PathAddReturn, JsValue>;
                                fn get_offsets_with_tangent(
                                    &self,
                                    tangent: Point,
                                ) -> std::result::Result<Vec<f64>, JsValue>;
                                fn first_segment(&self) -> Segment;
                                fn set_first_segment(&mut self, value: Segment) -> ();
                                fn to_shape(
                                    &self,
                                    insert: bool,
                                ) -> std::result::Result<Shape, JsValue>;
                                fn new(object: std::collections::HashMap<String, JsValue>) -> Path;
                                fn get_tangent_at(
                                    &self,
                                    offset: f64,
                                ) -> std::result::Result<Point, JsValue>;
                                fn join(
                                    &self,
                                    path: Path,
                                    tolerance: f64,
                                ) -> std::result::Result<(), JsValue>;
                                fn get_weighted_tangent_at(
                                    &self,
                                    offset: f64,
                                ) -> std::result::Result<Point, JsValue>;
                                fn fully_selected(&self) -> bool;
                                fn set_fully_selected(&mut self, value: bool) -> ();
                                fn reduce(
                                    &self,
                                    options: JsValue,
                                ) -> std::result::Result<Path, JsValue>;
                                fn add_segments(
                                    &self,
                                    segments: Vec<Segment>,
                                ) -> std::result::Result<Vec<Segment>, JsValue>;
                                fn split_at(
                                    &self,
                                    location: PathSplitAtParamsLocationParam,
                                ) -> std::result::Result<Path, JsValue>;
                                fn last_curve(&self) -> Curve;
                                fn set_last_curve(&mut self, value: Curve) -> ();
                                fn remove_segments(
                                    &self,
                                    from: f64,
                                    to: f64,
                                ) -> std::result::Result<Vec<Segment>, JsValue>;
                                fn get_location_of(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<CurveLocation, JsValue>;
                                fn has_handles(&self) -> std::result::Result<bool, JsValue>;
                                fn get_offset_of(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<f64, JsValue>;
                                fn get_point_at(
                                    &self,
                                    offset: f64,
                                ) -> std::result::Result<Point, JsValue>;
                                fn insert(
                                    &self,
                                    index: f64,
                                    segment: PathInsertParamsSegmentParam,
                                ) -> std::result::Result<Segment, JsValue>;
                                fn insert_segments(
                                    &self,
                                    index: f64,
                                    segments: Vec<Segment>,
                                ) -> std::result::Result<Vec<Segment>, JsValue>;
                                fn last_segment(&self) -> Segment;
                                fn set_last_segment(&mut self, value: Segment) -> ();
                                fn segments(&self) -> Vec<Segment>;
                                fn set_segments(&mut self, value: Vec<Segment>) -> ();
                                fn closed(&self) -> bool;
                                fn set_closed(&mut self, value: bool) -> ();
                                fn get_location_at(
                                    &self,
                                    offset: f64,
                                ) -> std::result::Result<CurveLocation, JsValue>;
                                fn curves(&self) -> Vec<Curve>;
                                fn set_curves(&mut self, value: Vec<Curve>) -> ();
                                fn first_curve(&self) -> Curve;
                                fn set_first_curve(&mut self, value: Curve) -> ();
                                fn get_curvature_at(
                                    &self,
                                    offset: f64,
                                ) -> std::result::Result<f64, JsValue>;
                                fn area(&self) -> f64;
                                fn set_area(&mut self, value: f64) -> ();
                                fn clear_handles(&self) -> std::result::Result<(), JsValue>;
                                fn remove_segment(
                                    &self,
                                    index: f64,
                                ) -> std::result::Result<Segment, JsValue>;
                                fn divide_at(
                                    &self,
                                    location: PathDivideAtParamsLocationParam,
                                ) -> std::result::Result<Segment, JsValue>;
                            }
                            impl PathItem_Trait for Path
                            where
                                Path: Item_Trait,
                            {
                                fn cubic_curve_by(
                                    &self,
                                    handle1: Point,
                                    handle2: Point,
                                    to: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::cubic_curve_by(&target, handle1, handle2, to)
                                }
                                fn curve_by(
                                    &self,
                                    through: Point,
                                    to: Point,
                                    time: f64,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::curve_by(&target, through, to, time)
                                }
                                fn close_path(&self) -> std::result::Result<(), JsValue> {
                                    let target: PathItem = self.into();
                                    PathItem::close_path(&target)
                                }
                                fn simplify(
                                    &self,
                                    tolerance: f64,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::simplify(&target, tolerance)
                                }
                                fn reverse(&self) -> std::result::Result<(), JsValue> {
                                    let target: PathItem = self.into();
                                    PathItem::reverse(&target)
                                }
                                fn quadratic_curve_by(
                                    &self,
                                    handle: Point,
                                    to: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::quadratic_curve_by(&target, handle, to)
                                }
                                fn get_intersections(
                                    &self,
                                    path: PathItem,
                                    include: JsValue,
                                ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::get_intersections(&target, path, include)
                                }
                                fn get_nearest_point(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::get_nearest_point(&target, point)
                                }
                                fn move_to(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::move_to(&target, point)
                                }
                                fn exclude(
                                    &self,
                                    path: PathItem,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<PathItem, JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::exclude(&target, path, options)
                                }
                                fn interpolate(
                                    &self,
                                    from: PathItem,
                                    to: PathItem,
                                    factor: f64,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::interpolate(&target, from, to, factor)
                                }
                                fn compare(
                                    &self,
                                    path: PathItem,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::compare(&target, path)
                                }
                                fn arc_by(
                                    &self,
                                    to: Point,
                                    clockwise: bool,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::arc_by(&target, to, clockwise)
                                }
                                fn line_to(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::line_to(&target, point)
                                }
                                fn line_by(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::line_by(&target, point)
                                }
                                fn path_data(&self) -> String {
                                    let target: PathItem = self.into();
                                    PathItem::path_data(&target)
                                }
                                fn set_path_data(&mut self, value: String) -> () {
                                    let mut target: PathItem = self.into();
                                    PathItem::set_path_data(&mut target, value)
                                }
                                fn interior_point(&self) -> Point {
                                    let target: PathItem = self.into();
                                    PathItem::interior_point(&target)
                                }
                                fn set_interior_point(&mut self, value: Point) -> () {
                                    let mut target: PathItem = self.into();
                                    PathItem::set_interior_point(&mut target, value)
                                }
                                fn clockwise(&self) -> bool {
                                    let target: PathItem = self.into();
                                    PathItem::clockwise(&target)
                                }
                                fn set_clockwise(&mut self, value: bool) -> () {
                                    let mut target: PathItem = self.into();
                                    PathItem::set_clockwise(&mut target, value)
                                }
                                fn smooth(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::smooth(&target, options)
                                }
                                fn get_nearest_location(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<CurveLocation, JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::get_nearest_location(&target, point)
                                }
                                fn divide(
                                    &self,
                                    path: PathItem,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<PathItem, JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::divide(&target, path, options)
                                }
                                fn cubic_curve_to(
                                    &self,
                                    handle1: Point,
                                    handle2: Point,
                                    to: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::cubic_curve_to(&target, handle1, handle2, to)
                                }
                                fn subtract(
                                    &self,
                                    path: PathItem,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<PathItem, JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::subtract(&target, path, options)
                                }
                                fn move_by(&self, to: Point) -> std::result::Result<(), JsValue> {
                                    let target: PathItem = self.into();
                                    PathItem::move_by(&target, to)
                                }
                                fn quadratic_curve_to(
                                    &self,
                                    handle: Point,
                                    to: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::quadratic_curve_to(&target, handle, to)
                                }
                                fn get_crossings(
                                    &self,
                                    path: PathItem,
                                ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::get_crossings(&target, path)
                                }
                                fn curve_to(
                                    &self,
                                    through: Point,
                                    to: Point,
                                    time: f64,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::curve_to(&target, through, to, time)
                                }
                                fn arc_to(
                                    &self,
                                    to: Point,
                                    clockwise: bool,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::arc_to(&target, to, clockwise)
                                }
                                fn unite(
                                    &self,
                                    path: PathItem,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<PathItem, JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::unite(&target, path, options)
                                }
                                fn flatten(
                                    &self,
                                    flatness: f64,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::flatten(&target, flatness)
                                }
                                fn intersect(
                                    &self,
                                    path: PathItem,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<PathItem, JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::intersect(&target, path, options)
                                }
                                fn reorient(
                                    &self,
                                    non_zero: bool,
                                    clockwise: bool,
                                ) -> std::result::Result<PathItem, JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::reorient(&target, non_zero, clockwise)
                                }
                                fn create(
                                    &self,
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<PathItemCreateReturn, JsValue>
                                {
                                    let target: PathItem = self.into();
                                    PathItem::create(&target, object)
                                }
                            }
                            impl Item_Trait for Path {
                                fn insert_below(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_below(&target, item)
                                }
                                fn on_double_click(&self) -> ItemOnDoubleClick {
                                    let target: Item = self.into();
                                    Item::on_double_click(&target)
                                }
                                fn set_on_double_click(&mut self, value: ItemOnDoubleClick) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_double_click(&mut target, value)
                                }
                                fn view(&self) -> View {
                                    let target: Item = self.into();
                                    Item::view(&target)
                                }
                                fn set_view(&mut self, value: View) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_view(&mut target, value)
                                }
                                fn blend_mode(&self) -> String {
                                    let target: Item = self.into();
                                    Item::blend_mode(&target)
                                }
                                fn set_blend_mode(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_blend_mode(&mut target, value)
                                }
                                fn name(&self) -> String {
                                    let target: Item = self.into();
                                    Item::name(&target)
                                }
                                fn set_name(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_name(&mut target, value)
                                }
                                fn project(&self) -> Project {
                                    let target: Item = self.into();
                                    Item::project(&target)
                                }
                                fn set_project(&mut self, value: Project) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_project(&mut target, value)
                                }
                                fn is_child(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_child(&target, item)
                                }
                                fn global_matrix(&self) -> Matrix {
                                    let target: Item = self.into();
                                    Item::global_matrix(&target)
                                }
                                fn set_global_matrix(&mut self, value: Matrix) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_global_matrix(&mut target, value)
                                }
                                fn on_mouse_leave(&self) -> ItemOnMouseLeave {
                                    let target: Item = self.into();
                                    Item::on_mouse_leave(&target)
                                }
                                fn set_on_mouse_leave(&mut self, value: ItemOnMouseLeave) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_leave(&mut target, value)
                                }
                                fn has_children(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_children(&target)
                                }
                                fn selected(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::selected(&target)
                                }
                                fn set_selected(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_selected(&mut target, value)
                                }
                                fn global_to_local(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::global_to_local(&target, point)
                                }
                                fn shadow_blur(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::shadow_blur(&target)
                                }
                                fn set_shadow_blur(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_shadow_blur(&mut target, value)
                                }
                                fn children(&self) -> Vec<Item> {
                                    let target: Item = self.into();
                                    Item::children(&target)
                                }
                                fn set_children(&mut self, value: Vec<Item>) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_children(&mut target, value)
                                }
                                fn replace_with(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::replace_with(&target, item)
                                }
                                fn import_json(
                                    &self,
                                    json: String,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::import_json(&target, json)
                                }
                                fn insert_child(
                                    &self,
                                    index: f64,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_child(&target, index, item)
                                }
                                fn stroke_join(&self) -> String {
                                    let target: Item = self.into();
                                    Item::stroke_join(&target)
                                }
                                fn set_stroke_join(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_join(&mut target, value)
                                }
                                fn rotation(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::rotation(&target)
                                }
                                fn set_rotation(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_rotation(&mut target, value)
                                }
                                fn scaling(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::scaling(&target)
                                }
                                fn set_scaling(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_scaling(&mut target, value)
                                }
                                fn is_ancestor(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_ancestor(&target, item)
                                }
                                fn emit(
                                    &self,
                                    type_: String,
                                    event: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::emit(&target, type_, event)
                                }
                                fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_up(&target)
                                }
                                fn add_to(
                                    &self,
                                    owner: ItemAddToParamsOwnerParam,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::add_to(&target, owner)
                                }
                                fn stroke_cap(&self) -> String {
                                    let target: Item = self.into();
                                    Item::stroke_cap(&target)
                                }
                                fn set_stroke_cap(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_cap(&mut target, value)
                                }
                                fn on_mouse_drag(&self) -> ItemOnMouseDrag {
                                    let target: Item = self.into();
                                    Item::on_mouse_drag(&target)
                                }
                                fn set_on_mouse_drag(&mut self, value: ItemOnMouseDrag) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_drag(&mut target, value)
                                }
                                fn set(
                                    &self,
                                    props: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::set(&target, props)
                                }
                                fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::reverse_children(&target)
                                }
                                fn matches(
                                    &self,
                                    name: String,
                                    compare: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::matches(&target, name, compare)
                                }
                                fn on_mouse_enter(&self) -> ItemOnMouseEnter {
                                    let target: Item = self.into();
                                    Item::on_mouse_enter(&target)
                                }
                                fn set_on_mouse_enter(&mut self, value: ItemOnMouseEnter) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_enter(&mut target, value)
                                }
                                fn shadow_offset(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::shadow_offset(&target)
                                }
                                fn set_shadow_offset(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_shadow_offset(&mut target, value)
                                }
                                fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_stroke(&target)
                                }
                                fn view_matrix(&self) -> Matrix {
                                    let target: Item = self.into();
                                    Item::view_matrix(&target)
                                }
                                fn set_view_matrix(&mut self, value: Matrix) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_view_matrix(&mut target, value)
                                }
                                fn on_frame(&self) -> ItemOnFrame {
                                    let target: Item = self.into();
                                    Item::on_frame(&target)
                                }
                                fn set_on_frame(&mut self, value: ItemOnFrame) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_frame(&mut target, value)
                                }
                                fn on_mouse_down(&self) -> ItemOnMouseDown {
                                    let target: Item = self.into();
                                    Item::on_mouse_down(&target)
                                }
                                fn set_on_mouse_down(&mut self, value: ItemOnMouseDown) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_down(&mut target, value)
                                }
                                fn is_sibling(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_sibling(&target, item)
                                }
                                fn local_to_global(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::local_to_global(&target, point)
                                }
                                fn first_child(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::first_child(&target)
                                }
                                fn set_first_child(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_first_child(&mut target, value)
                                }
                                fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::send_to_back(&target)
                                }
                                fn clip_mask(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::clip_mask(&target)
                                }
                                fn set_clip_mask(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_clip_mask(&mut target, value)
                                }
                                fn next_sibling(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::next_sibling(&target)
                                }
                                fn set_next_sibling(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_next_sibling(&mut target, value)
                                }
                                fn off(
                                    &self,
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::off(&target, object)
                                }
                                fn rotate(
                                    &self,
                                    angle: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::rotate(&target, angle, center)
                                }
                                fn add_child(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::add_child(&target, item)
                                }
                                fn is_grouped_with(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_grouped_with(&target, item)
                                }
                                fn scale(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::scale(&target, hor, ver, center)
                                }
                                fn hit_test_all(
                                    &self,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Vec<HitResult>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::hit_test_all(&target, point, options)
                                }
                                fn insert_children(
                                    &self,
                                    index: f64,
                                    items: Vec<Item>,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_children(&target, index, items)
                                }
                                fn style(&self) -> Style {
                                    let target: Item = self.into();
                                    Item::style(&target)
                                }
                                fn set_style(&mut self, value: Style) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_style(&mut target, value)
                                }
                                fn position(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::position(&target)
                                }
                                fn set_position(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_position(&mut target, value)
                                }
                                fn transform(
                                    &self,
                                    matrix: Matrix,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::transform(&target, matrix)
                                }
                                fn fill_color(&self) -> ItemFillColor {
                                    let target: Item = self.into();
                                    Item::fill_color(&target)
                                }
                                fn set_fill_color(&mut self, value: ItemFillColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_fill_color(&mut target, value)
                                }
                                fn matrix(&self) -> Matrix {
                                    let target: Item = self.into();
                                    Item::matrix(&target)
                                }
                                fn set_matrix(&mut self, value: Matrix) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_matrix(&mut target, value)
                                }
                                fn id(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::id(&target)
                                }
                                fn set_id(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_id(&mut target, value)
                                }
                                fn tween(
                                    &self,
                                    options: ItemTweenParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::tween(&target, options)
                                }
                                fn reduce(
                                    &self,
                                    options: JsValue,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::reduce(&target, options)
                                }
                                fn internal_bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::internal_bounds(&target)
                                }
                                fn set_internal_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_internal_bounds(&mut target, value)
                                }
                                fn fill_rule(&self) -> String {
                                    let target: Item = self.into();
                                    Item::fill_rule(&target)
                                }
                                fn set_fill_rule(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_fill_rule(&mut target, value)
                                }
                                fn shadow_color(&self) -> ItemShadowColor {
                                    let target: Item = self.into();
                                    Item::shadow_color(&target)
                                }
                                fn set_shadow_color(&mut self, value: ItemShadowColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_shadow_color(&mut target, value)
                                }
                                fn insert_above(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_above(&target, item)
                                }
                                fn responds(
                                    &self,
                                    type_: String,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::responds(&target, type_)
                                }
                                fn handle_bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::handle_bounds(&target)
                                }
                                fn set_handle_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_handle_bounds(&mut target, value)
                                }
                                fn skew(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::skew(&target, hor, ver, center)
                                }
                                fn on_click(&self) -> ItemOnClick {
                                    let target: Item = self.into();
                                    Item::on_click(&target)
                                }
                                fn set_on_click(&mut self, value: ItemOnClick) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_click(&mut target, value)
                                }
                                fn get_items(
                                    &self,
                                    options: ItemGetItemsParamsOptionsParam,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::get_items(&target, options)
                                }
                                fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::is_inserted(&target)
                                }
                                fn get_item(
                                    &self,
                                    options: ItemGetItemParamsOptionsParam,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::get_item(&target, options)
                                }
                                fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_fill(&target)
                                }
                                fn shear(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::shear(&target, hor, ver, center)
                                }
                                fn visible(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::visible(&target)
                                }
                                fn set_visible(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_visible(&mut target, value)
                                }
                                fn previous_sibling(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::previous_sibling(&target)
                                }
                                fn set_previous_sibling(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_previous_sibling(&mut target, value)
                                }
                                fn hit_test(
                                    &self,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<HitResult, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::hit_test(&target, point, options)
                                }
                                fn is_descendant(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_descendant(&target, item)
                                }
                                fn locked(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::locked(&target)
                                }
                                fn set_locked(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_locked(&mut target, value)
                                }
                                fn is_parent(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_parent(&target, item)
                                }
                                fn copy_attributes(
                                    &self,
                                    source: Item,
                                    exclude_matrix: bool,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::copy_attributes(&target, source, exclude_matrix)
                                }
                                fn last_child(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::last_child(&target)
                                }
                                fn set_last_child(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_last_child(&mut target, value)
                                }
                                fn stroke_width(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::stroke_width(&target)
                                }
                                fn set_stroke_width(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_width(&mut target, value)
                                }
                                fn parent(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::parent(&target)
                                }
                                fn set_parent(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_parent(&mut target, value)
                                }
                                fn stroke_bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::stroke_bounds(&target)
                                }
                                fn set_stroke_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_bounds(&mut target, value)
                                }
                                fn translate(
                                    &self,
                                    delta: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::translate(&target, delta)
                                }
                                fn remove(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::remove(&target)
                                }
                                fn parent_to_local(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::parent_to_local(&target, point)
                                }
                                fn bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::bounds(&target)
                                }
                                fn set_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_bounds(&mut target, value)
                                }
                                fn add_children(
                                    &self,
                                    items: Vec<Item>,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::add_children(&target, items)
                                }
                                fn dash_array(&self) -> Vec<f64> {
                                    let target: Item = self.into();
                                    Item::dash_array(&target)
                                }
                                fn set_dash_array(&mut self, value: Vec<f64>) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_dash_array(&mut target, value)
                                }
                                fn on_mouse_up(&self) -> ItemOnMouseUp {
                                    let target: Item = self.into();
                                    Item::on_mouse_up(&target)
                                }
                                fn set_on_mouse_up(&mut self, value: ItemOnMouseUp) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_up(&mut target, value)
                                }
                                fn on(
                                    &self,
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::on(&target, object)
                                }
                                fn remove_on(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::remove_on(&target, options)
                                }
                                fn is_below(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_below(&target, item)
                                }
                                fn apply_matrix(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::apply_matrix(&target)
                                }
                                fn set_apply_matrix(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_apply_matrix(&mut target, value)
                                }
                                fn clone(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::clone(&target, options)
                                }
                                fn contains(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::contains(&target, point)
                                }
                                fn export_json(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<String, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::export_json(&target, options)
                                }
                                fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::bring_to_front(&target)
                                }
                                fn is_above(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_above(&target, item)
                                }
                                fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_drag(&target)
                                }
                                fn data(&self) -> JsValue {
                                    let target: Item = self.into();
                                    Item::data(&target)
                                }
                                fn set_data(&mut self, value: JsValue) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_data(&mut target, value)
                                }
                                fn import_svg(
                                    &self,
                                    svg: ItemImportSvgParamsSvgParam,
                                    on_load: JsValue,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::import_svg(&target, svg, on_load)
                                }
                                fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_shadow(&target)
                                }
                                fn selected_color(&self) -> ItemSelectedColor {
                                    let target: Item = self.into();
                                    Item::selected_color(&target)
                                }
                                fn set_selected_color(&mut self, value: ItemSelectedColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_selected_color(&mut target, value)
                                }
                                fn class_name(&self) -> String {
                                    let target: Item = self.into();
                                    Item::class_name(&target)
                                }
                                fn set_class_name(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_class_name(&mut target, value)
                                }
                                fn export_svg(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<ItemExportSvgReturn, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::export_svg(&target, options)
                                }
                                fn tween_to(
                                    &self,
                                    to: std::collections::HashMap<String, JsValue>,
                                    options: ItemTweenToParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::tween_to(&target, to, options)
                                }
                                fn is_inside(
                                    &self,
                                    rect: Rectangle,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_inside(&target, rect)
                                }
                                fn is_empty(
                                    &self,
                                    recursively: bool,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_empty(&target, recursively)
                                }
                                fn copy_content(
                                    &self,
                                    source: Item,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::copy_content(&target, source)
                                }
                                fn rasterize(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Raster, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::rasterize(&target, options)
                                }
                                fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_move(&target)
                                }
                                fn tween_from(
                                    &self,
                                    from: std::collections::HashMap<String, JsValue>,
                                    options: ItemTweenFromParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::tween_from(&target, from, options)
                                }
                                fn opacity(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::opacity(&target)
                                }
                                fn set_opacity(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_opacity(&mut target, value)
                                }
                                fn dash_offset(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::dash_offset(&target)
                                }
                                fn set_dash_offset(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_dash_offset(&mut target, value)
                                }
                                fn remove_children(
                                    &self,
                                    start: f64,
                                    end: f64,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::remove_children(&target, start, end)
                                }
                                fn on_mouse_move(&self) -> ItemOnMouseMove {
                                    let target: Item = self.into();
                                    Item::on_mouse_move(&target)
                                }
                                fn set_on_mouse_move(&mut self, value: ItemOnMouseMove) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_move(&mut target, value)
                                }
                                fn intersects(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::intersects(&target, item)
                                }
                                fn pivot(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::pivot(&target)
                                }
                                fn set_pivot(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_pivot(&mut target, value)
                                }
                                fn copy_to(
                                    &self,
                                    owner: ItemCopyToParamsOwnerParam,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::copy_to(&target, owner)
                                }
                                fn index(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::index(&target)
                                }
                                fn set_index(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_index(&mut target, value)
                                }
                                fn local_to_parent(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::local_to_parent(&target, point)
                                }
                                fn stroke_color(&self) -> ItemStrokeColor {
                                    let target: Item = self.into();
                                    Item::stroke_color(&target)
                                }
                                fn set_stroke_color(&mut self, value: ItemStrokeColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_color(&mut target, value)
                                }
                                fn layer(&self) -> Layer {
                                    let target: Item = self.into();
                                    Item::layer(&target)
                                }
                                fn set_layer(&mut self, value: Layer) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_layer(&mut target, value)
                                }
                                fn stroke_scaling(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::stroke_scaling(&target)
                                }
                                fn set_stroke_scaling(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_scaling(&mut target, value)
                                }
                                fn fit_bounds(
                                    &self,
                                    rectangle: Rectangle,
                                    fill: bool,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::fit_bounds(&target, rectangle, fill)
                                }
                                fn miter_limit(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::miter_limit(&target)
                                }
                                fn set_miter_limit(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_miter_limit(&mut target, value)
                                }
                                fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_down(&target)
                                }
                            }
                            impl Path_Trait for Path {}
                            impl std::clone::Clone for Path_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for Path_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Path_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                #[wasm_bindgen(js_name = "Point")]
                                type Point_Class;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = subtract , method , js_class = "Point" , catch)]
                                fn __TSB_subtract(
                                    this: &Point_Class,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isOrthogonal , method , js_class = "Point" , catch)]
                                fn __TSB_is_orthogonal(
                                    this: &Point_Class,
                                    point: Point,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = toString , method , js_class = "Point" , catch)]
                                fn __TSB_to_string(
                                    this: &Point_Class,
                                ) -> std::result::Result<String, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getDistance , method , js_class = "Point" , catch)]
                                fn __TSB_get_distance(
                                    this: &Point_Class,
                                    point: Point,
                                    squared: bool,
                                ) -> std::result::Result<f64, JsValue>;
                                # [wasm_bindgen (method , structural , getter = angle , js_class = "Point")]
                                fn angle(this: &Point_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = angle , js_class = "Point")]
                                fn set_angle(this: &Point_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isZero , method , js_class = "Point" , catch)]
                                fn __TSB_is_zero(
                                    this: &Point_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = abs , method , js_class = "Point" , catch)]
                                fn __TSB_abs(
                                    this: &Point_Class,
                                ) -> std::result::Result<Point, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = ceil , method , js_class = "Point" , catch)]
                                fn __TSB_ceil(
                                    this: &Point_Class,
                                ) -> std::result::Result<Point, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = multiply , method , js_class = "Point" , catch)]
                                fn __TSB_multiply(
                                    this: &Point_Class,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getDirectedAngle , method , js_class = "Point" , catch)]
                                fn __TSB_get_directed_angle(
                                    this: &Point_Class,
                                    point: Point,
                                ) -> std::result::Result<f64, JsValue>;
                                # [wasm_bindgen (method , structural , getter = x , js_class = "Point")]
                                fn x(this: &Point_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = x , js_class = "Point")]
                                fn set_x(this: &Point_Class, value: f64);
                                #[wasm_bindgen(constructor, js_class = "Point")]
                                pub fn new(
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> Point_Class;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = max , method , js_class = "Point" , catch)]
                                fn __TSB_max(
                                    this: &Point_Class,
                                    point1: Point,
                                    point2: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isClose , method , js_class = "Point" , catch)]
                                fn __TSB_is_close(
                                    this: &Point_Class,
                                    point: Point,
                                    tolerance: f64,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = project , method , js_class = "Point" , catch)]
                                fn __TSB_project(
                                    this: &Point_Class,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = random , method , js_class = "Point" , catch)]
                                fn __TSB_random(
                                    this: &Point_Class,
                                ) -> std::result::Result<Point, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = equals , method , js_class = "Point" , catch)]
                                fn __TSB_equals(
                                    this: &Point_Class,
                                    point: Point,
                                ) -> std::result::Result<bool, JsValue>;
                                # [wasm_bindgen (method , structural , getter = selected , js_class = "Point")]
                                fn selected(this: &Point_Class) -> bool;
                                # [wasm_bindgen (method , structural , setter = selected , js_class = "Point")]
                                fn set_selected(this: &Point_Class, value: bool);
                                # [wasm_bindgen (method , structural , getter = quadrant , js_class = "Point")]
                                fn quadrant(this: &Point_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = quadrant , js_class = "Point")]
                                fn set_quadrant(this: &Point_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = modulo , method , js_class = "Point" , catch)]
                                fn __TSB_modulo(
                                    this: &Point_Class,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isInQuadrant , method , js_class = "Point" , catch)]
                                fn __TSB_is_in_quadrant(
                                    this: &Point_Class,
                                    quadrant: f64,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = round , method , js_class = "Point" , catch)]
                                fn __TSB_round(
                                    this: &Point_Class,
                                ) -> std::result::Result<Point, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = floor , method , js_class = "Point" , catch)]
                                fn __TSB_floor(
                                    this: &Point_Class,
                                ) -> std::result::Result<Point, JsValue>;
                                # [wasm_bindgen (method , structural , getter = length , js_class = "Point")]
                                fn length(this: &Point_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = length , js_class = "Point")]
                                fn set_length(this: &Point_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isInside , method , js_class = "Point" , catch)]
                                fn __TSB_is_inside(
                                    this: &Point_Class,
                                    rect: Rectangle,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getAngleInRadians , method , js_class = "Point" , catch)]
                                fn __TSB_get_angle_in_radians(
                                    this: &Point_Class,
                                    point: Point,
                                ) -> std::result::Result<f64, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = rotate , method , js_class = "Point" , catch)]
                                fn __TSB_rotate(
                                    this: &Point_Class,
                                    angle: f64,
                                    center: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = set , method , js_class = "Point" , catch , variadic)]
                                fn __TSB_set(
                                    this: &Point_Class,
                                    values: &[JsValue],
                                ) -> std::result::Result<Point, JsValue>;
                                # [wasm_bindgen (method , structural , getter = y , js_class = "Point")]
                                fn y(this: &Point_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = y , js_class = "Point")]
                                fn set_y(this: &Point_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = clone , method , js_class = "Point" , catch)]
                                fn __TSB_clone(
                                    this: &Point_Class,
                                ) -> std::result::Result<Point, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = cross , method , js_class = "Point" , catch)]
                                fn __TSB_cross(
                                    this: &Point_Class,
                                    point: Point,
                                ) -> std::result::Result<f64, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isNaN , method , js_class = "Point" , catch)]
                                fn __TSB_is_na_n(
                                    this: &Point_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getAngle , method , js_class = "Point" , catch)]
                                fn __TSB_get_angle(
                                    this: &Point_Class,
                                    point: Point,
                                ) -> std::result::Result<f64, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = add , method , js_class = "Point" , catch)]
                                fn __TSB_add(
                                    this: &Point_Class,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = min , method , js_class = "Point" , catch)]
                                fn __TSB_min(
                                    this: &Point_Class,
                                    point1: Point,
                                    point2: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = transform , method , js_class = "Point" , catch)]
                                fn __TSB_transform(
                                    this: &Point_Class,
                                    matrix: Matrix,
                                ) -> std::result::Result<Point, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isCollinear , method , js_class = "Point" , catch)]
                                fn __TSB_is_collinear(
                                    this: &Point_Class,
                                    point: Point,
                                ) -> std::result::Result<bool, JsValue>;
                                # [wasm_bindgen (method , structural , getter = angleInRadians , js_class = "Point")]
                                fn angle_in_radians(this: &Point_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = angleInRadians , js_class = "Point")]
                                fn set_angle_in_radians(this: &Point_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = normalize , method , js_class = "Point" , catch)]
                                fn __TSB_normalize(
                                    this: &Point_Class,
                                    length: f64,
                                ) -> std::result::Result<Point, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = dot , method , js_class = "Point" , catch)]
                                fn __TSB_dot(
                                    this: &Point_Class,
                                    point: Point,
                                ) -> std::result::Result<f64, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = divide , method , js_class = "Point" , catch)]
                                fn __TSB_divide(
                                    this: &Point_Class,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>;
                            }
                            #[derive(std :: clone :: Clone)]
                            struct Point(pub Point_Class);
                            impl Point {
                                #[allow(dead_code)]
                                pub fn subtract(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_subtract(point)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_orthogonal(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_is_orthogonal(point)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_to_string()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_distance(
                                    &self,
                                    point: Point,
                                    squared: bool,
                                ) -> std::result::Result<f64, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_distance(point, squared)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn angle(&self) -> f64 {
                                    let result = self.0.angle();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_angle(&self, value: f64) -> () {
                                    let result = self.0.set_angle(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_zero(&self) -> std::result::Result<bool, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_is_zero()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn abs(&self) -> std::result::Result<Point, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_abs()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn ceil(&self) -> std::result::Result<Point, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_ceil()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn multiply(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_multiply(point)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_directed_angle(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<f64, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_directed_angle(point)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn x(&self) -> f64 {
                                    let result = self.0.x();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_x(&self, value: f64) -> () {
                                    let result = self.0.set_x(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn new(
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> Point {
                                    let result = Point_Class::new(object);
                                    let result =
                                        ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result)
                                            .unwrap();
                                    Point(result)
                                }
                                #[allow(dead_code)]
                                pub fn max(
                                    &self,
                                    point1: Point,
                                    point2: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_max(point1, point2)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_close(
                                    &self,
                                    point: Point,
                                    tolerance: f64,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_is_close(point, tolerance)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn project(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_project(point)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn random(&self) -> std::result::Result<Point, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_random()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn equals(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_equals(point)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn selected(&self) -> bool {
                                    let result = self.0.selected();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_selected(&self, value: bool) -> () {
                                    let result = self.0.set_selected(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn quadrant(&self) -> f64 {
                                    let result = self.0.quadrant();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_quadrant(&self, value: f64) -> () {
                                    let result = self.0.set_quadrant(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn modulo(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_modulo(point)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_in_quadrant(
                                    &self,
                                    quadrant: f64,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_is_in_quadrant(quadrant)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn round(&self) -> std::result::Result<Point, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_round()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn floor(&self) -> std::result::Result<Point, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_floor()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn length(&self) -> f64 {
                                    let result = self.0.length();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_length(&self, value: f64) -> () {
                                    let result = self.0.set_length(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_inside(
                                    &self,
                                    rect: Rectangle,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_is_inside(rect)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_angle_in_radians(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<f64, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_angle_in_radians(point)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn rotate(
                                    &self,
                                    angle: f64,
                                    center: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_rotate(angle, center)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set(
                                    &self,
                                    values: &[JsValue],
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result = std::result::Result::Ok(self.0.__TSB_set(values)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn y(&self) -> f64 {
                                    let result = self.0.y();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_y(&self, value: f64) -> () {
                                    let result = self.0.set_y(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn clone(&self) -> std::result::Result<Point, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_clone()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn cross(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<f64, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_cross(point)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_na_n(&self) -> std::result::Result<bool, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_is_na_n()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_angle(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<f64, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_get_angle(point)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn add(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result = std::result::Result::Ok(self.0.__TSB_add(point)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn min(
                                    &self,
                                    point1: Point,
                                    point2: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_min(point1, point2)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn transform(
                                    &self,
                                    matrix: Matrix,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_transform(matrix)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_collinear(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_is_collinear(point)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn angle_in_radians(&self) -> f64 {
                                    let result = self.0.angle_in_radians();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_angle_in_radians(&self, value: f64) -> () {
                                    let result = self.0.set_angle_in_radians(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn normalize(
                                    &self,
                                    length: f64,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_normalize(length)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn dot(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<f64, JsValue>
                                {
                                    let result = std::result::Result::Ok(self.0.__TSB_dot(point)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn divide(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_divide(point)?);
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for Point {
                                fn describe() {
                                    <Point_Class as wasm_bindgen::describe::WasmDescribe>::describe(
                                    )
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for Point {
                                type Abi = <Point_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Point {
                                type Abi =
                                    <&'a Point_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for Point {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Point {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal: Point_Class =
                                        <Point_Class as serde::de::Deserialize>::deserialize(
                                            deserializer,
                                        )?;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait Point_Trait {
                                fn subtract(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                fn is_orthogonal(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<bool, JsValue>;
                                fn to_string(&self) -> std::result::Result<String, JsValue>;
                                fn get_distance(
                                    &self,
                                    point: Point,
                                    squared: bool,
                                ) -> std::result::Result<f64, JsValue>;
                                fn angle(&self) -> f64;
                                fn set_angle(&mut self, value: f64) -> ();
                                fn is_zero(&self) -> std::result::Result<bool, JsValue>;
                                fn abs(&self) -> std::result::Result<Point, JsValue>;
                                fn ceil(&self) -> std::result::Result<Point, JsValue>;
                                fn multiply(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                fn get_directed_angle(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<f64, JsValue>;
                                fn x(&self) -> f64;
                                fn set_x(&mut self, value: f64) -> ();
                                fn new(object: std::collections::HashMap<String, JsValue>)
                                    -> Point;
                                fn max(
                                    &self,
                                    point1: Point,
                                    point2: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                fn is_close(
                                    &self,
                                    point: Point,
                                    tolerance: f64,
                                ) -> std::result::Result<bool, JsValue>;
                                fn project(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                fn random(&self) -> std::result::Result<Point, JsValue>;
                                fn equals(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<bool, JsValue>;
                                fn selected(&self) -> bool;
                                fn set_selected(&mut self, value: bool) -> ();
                                fn quadrant(&self) -> f64;
                                fn set_quadrant(&mut self, value: f64) -> ();
                                fn modulo(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                fn is_in_quadrant(
                                    &self,
                                    quadrant: f64,
                                ) -> std::result::Result<bool, JsValue>;
                                fn round(&self) -> std::result::Result<Point, JsValue>;
                                fn floor(&self) -> std::result::Result<Point, JsValue>;
                                fn length(&self) -> f64;
                                fn set_length(&mut self, value: f64) -> ();
                                fn is_inside(
                                    &self,
                                    rect: Rectangle,
                                ) -> std::result::Result<bool, JsValue>;
                                fn get_angle_in_radians(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<f64, JsValue>;
                                fn rotate(
                                    &self,
                                    angle: f64,
                                    center: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                fn set(
                                    &self,
                                    values: &[JsValue],
                                ) -> std::result::Result<Point, JsValue>;
                                fn y(&self) -> f64;
                                fn set_y(&mut self, value: f64) -> ();
                                fn clone(&self) -> std::result::Result<Point, JsValue>;
                                fn cross(&self, point: Point) -> std::result::Result<f64, JsValue>;
                                fn is_na_n(&self) -> std::result::Result<bool, JsValue>;
                                fn get_angle(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<f64, JsValue>;
                                fn add(&self, point: Point) -> std::result::Result<Point, JsValue>;
                                fn min(
                                    &self,
                                    point1: Point,
                                    point2: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                fn transform(
                                    &self,
                                    matrix: Matrix,
                                ) -> std::result::Result<Point, JsValue>;
                                fn is_collinear(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<bool, JsValue>;
                                fn angle_in_radians(&self) -> f64;
                                fn set_angle_in_radians(&mut self, value: f64) -> ();
                                fn normalize(
                                    &self,
                                    length: f64,
                                ) -> std::result::Result<Point, JsValue>;
                                fn dot(&self, point: Point) -> std::result::Result<f64, JsValue>;
                                fn divide(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>;
                            }
                            impl std::clone::Clone for Point_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for Point_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Point_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                # [wasm_bindgen (js_name = "Layer" , extends = Group_Class)]
                                type Layer_Class;
                                #[wasm_bindgen(constructor, js_class = "Layer")]
                                pub fn new(
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> Layer_Class;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = activate , method , js_class = "Layer" , catch)]
                                fn __TSB_activate(
                                    this: &Layer_Class,
                                ) -> std::result::Result<(), JsValue>;
                            }
                            #[derive(std :: clone :: Clone)]
                            struct Layer(pub Layer_Class);
                            impl std::convert::From<&Layer> for Group {
                                fn from(src: &Layer) -> Group {
                                    let src: &Group_Class = src.0.as_ref();
                                    Group(src.clone())
                                }
                            }
                            impl std::convert::From<&mut Layer> for Group {
                                fn from(src: &mut Layer) -> Group {
                                    let src: &Group_Class = src.0.as_ref();
                                    Group(src.clone())
                                }
                            }
                            impl Layer {
                                #[allow(dead_code)]
                                pub fn new(
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> Layer {
                                    let result = Layer_Class::new(object);
                                    let result =
                                        ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result)
                                            .unwrap();
                                    Layer(result)
                                }
                                #[allow(dead_code)]
                                pub fn activate(&self) -> std::result::Result<(), JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_activate()?);
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for Layer {
                                fn describe() {
                                    <Layer_Class as wasm_bindgen::describe::WasmDescribe>::describe(
                                    )
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for Layer {
                                type Abi = <Layer_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Layer {
                                type Abi =
                                    <&'a Layer_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for Layer {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Layer {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal: Layer_Class =
                                        <Layer_Class as serde::de::Deserialize>::deserialize(
                                            deserializer,
                                        )?;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait Layer_Trait: Group_Trait {
                                fn new(object: std::collections::HashMap<String, JsValue>)
                                    -> Layer;
                                fn activate(&self) -> std::result::Result<(), JsValue>;
                            }
                            impl Group_Trait for Layer
                            where
                                Layer: Item_Trait,
                            {
                                fn clipped(&self) -> bool {
                                    let target: Group = self.into();
                                    Group::clipped(&target)
                                }
                                fn set_clipped(&mut self, value: bool) -> () {
                                    let mut target: Group = self.into();
                                    Group::set_clipped(&mut target, value)
                                }
                                fn new(
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> Layer {
                                    Group::new(object)
                                }
                            }
                            impl Item_Trait for Layer {
                                fn insert_below(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_below(&target, item)
                                }
                                fn on_double_click(&self) -> ItemOnDoubleClick {
                                    let target: Item = self.into();
                                    Item::on_double_click(&target)
                                }
                                fn set_on_double_click(&mut self, value: ItemOnDoubleClick) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_double_click(&mut target, value)
                                }
                                fn view(&self) -> View {
                                    let target: Item = self.into();
                                    Item::view(&target)
                                }
                                fn set_view(&mut self, value: View) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_view(&mut target, value)
                                }
                                fn blend_mode(&self) -> String {
                                    let target: Item = self.into();
                                    Item::blend_mode(&target)
                                }
                                fn set_blend_mode(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_blend_mode(&mut target, value)
                                }
                                fn name(&self) -> String {
                                    let target: Item = self.into();
                                    Item::name(&target)
                                }
                                fn set_name(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_name(&mut target, value)
                                }
                                fn project(&self) -> Project {
                                    let target: Item = self.into();
                                    Item::project(&target)
                                }
                                fn set_project(&mut self, value: Project) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_project(&mut target, value)
                                }
                                fn is_child(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_child(&target, item)
                                }
                                fn global_matrix(&self) -> Matrix {
                                    let target: Item = self.into();
                                    Item::global_matrix(&target)
                                }
                                fn set_global_matrix(&mut self, value: Matrix) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_global_matrix(&mut target, value)
                                }
                                fn on_mouse_leave(&self) -> ItemOnMouseLeave {
                                    let target: Item = self.into();
                                    Item::on_mouse_leave(&target)
                                }
                                fn set_on_mouse_leave(&mut self, value: ItemOnMouseLeave) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_leave(&mut target, value)
                                }
                                fn has_children(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_children(&target)
                                }
                                fn selected(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::selected(&target)
                                }
                                fn set_selected(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_selected(&mut target, value)
                                }
                                fn global_to_local(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::global_to_local(&target, point)
                                }
                                fn shadow_blur(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::shadow_blur(&target)
                                }
                                fn set_shadow_blur(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_shadow_blur(&mut target, value)
                                }
                                fn children(&self) -> Vec<Item> {
                                    let target: Item = self.into();
                                    Item::children(&target)
                                }
                                fn set_children(&mut self, value: Vec<Item>) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_children(&mut target, value)
                                }
                                fn replace_with(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::replace_with(&target, item)
                                }
                                fn import_json(
                                    &self,
                                    json: String,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::import_json(&target, json)
                                }
                                fn insert_child(
                                    &self,
                                    index: f64,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_child(&target, index, item)
                                }
                                fn stroke_join(&self) -> String {
                                    let target: Item = self.into();
                                    Item::stroke_join(&target)
                                }
                                fn set_stroke_join(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_join(&mut target, value)
                                }
                                fn rotation(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::rotation(&target)
                                }
                                fn set_rotation(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_rotation(&mut target, value)
                                }
                                fn scaling(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::scaling(&target)
                                }
                                fn set_scaling(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_scaling(&mut target, value)
                                }
                                fn is_ancestor(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_ancestor(&target, item)
                                }
                                fn emit(
                                    &self,
                                    type_: String,
                                    event: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::emit(&target, type_, event)
                                }
                                fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_up(&target)
                                }
                                fn add_to(
                                    &self,
                                    owner: ItemAddToParamsOwnerParam,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::add_to(&target, owner)
                                }
                                fn stroke_cap(&self) -> String {
                                    let target: Item = self.into();
                                    Item::stroke_cap(&target)
                                }
                                fn set_stroke_cap(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_cap(&mut target, value)
                                }
                                fn on_mouse_drag(&self) -> ItemOnMouseDrag {
                                    let target: Item = self.into();
                                    Item::on_mouse_drag(&target)
                                }
                                fn set_on_mouse_drag(&mut self, value: ItemOnMouseDrag) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_drag(&mut target, value)
                                }
                                fn set(
                                    &self,
                                    props: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::set(&target, props)
                                }
                                fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::reverse_children(&target)
                                }
                                fn matches(
                                    &self,
                                    name: String,
                                    compare: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::matches(&target, name, compare)
                                }
                                fn on_mouse_enter(&self) -> ItemOnMouseEnter {
                                    let target: Item = self.into();
                                    Item::on_mouse_enter(&target)
                                }
                                fn set_on_mouse_enter(&mut self, value: ItemOnMouseEnter) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_enter(&mut target, value)
                                }
                                fn shadow_offset(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::shadow_offset(&target)
                                }
                                fn set_shadow_offset(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_shadow_offset(&mut target, value)
                                }
                                fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_stroke(&target)
                                }
                                fn view_matrix(&self) -> Matrix {
                                    let target: Item = self.into();
                                    Item::view_matrix(&target)
                                }
                                fn set_view_matrix(&mut self, value: Matrix) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_view_matrix(&mut target, value)
                                }
                                fn on_frame(&self) -> ItemOnFrame {
                                    let target: Item = self.into();
                                    Item::on_frame(&target)
                                }
                                fn set_on_frame(&mut self, value: ItemOnFrame) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_frame(&mut target, value)
                                }
                                fn on_mouse_down(&self) -> ItemOnMouseDown {
                                    let target: Item = self.into();
                                    Item::on_mouse_down(&target)
                                }
                                fn set_on_mouse_down(&mut self, value: ItemOnMouseDown) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_down(&mut target, value)
                                }
                                fn is_sibling(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_sibling(&target, item)
                                }
                                fn local_to_global(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::local_to_global(&target, point)
                                }
                                fn first_child(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::first_child(&target)
                                }
                                fn set_first_child(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_first_child(&mut target, value)
                                }
                                fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::send_to_back(&target)
                                }
                                fn clip_mask(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::clip_mask(&target)
                                }
                                fn set_clip_mask(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_clip_mask(&mut target, value)
                                }
                                fn next_sibling(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::next_sibling(&target)
                                }
                                fn set_next_sibling(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_next_sibling(&mut target, value)
                                }
                                fn off(
                                    &self,
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::off(&target, object)
                                }
                                fn rotate(
                                    &self,
                                    angle: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::rotate(&target, angle, center)
                                }
                                fn add_child(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::add_child(&target, item)
                                }
                                fn is_grouped_with(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_grouped_with(&target, item)
                                }
                                fn scale(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::scale(&target, hor, ver, center)
                                }
                                fn hit_test_all(
                                    &self,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Vec<HitResult>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::hit_test_all(&target, point, options)
                                }
                                fn insert_children(
                                    &self,
                                    index: f64,
                                    items: Vec<Item>,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_children(&target, index, items)
                                }
                                fn style(&self) -> Style {
                                    let target: Item = self.into();
                                    Item::style(&target)
                                }
                                fn set_style(&mut self, value: Style) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_style(&mut target, value)
                                }
                                fn position(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::position(&target)
                                }
                                fn set_position(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_position(&mut target, value)
                                }
                                fn transform(
                                    &self,
                                    matrix: Matrix,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::transform(&target, matrix)
                                }
                                fn fill_color(&self) -> ItemFillColor {
                                    let target: Item = self.into();
                                    Item::fill_color(&target)
                                }
                                fn set_fill_color(&mut self, value: ItemFillColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_fill_color(&mut target, value)
                                }
                                fn matrix(&self) -> Matrix {
                                    let target: Item = self.into();
                                    Item::matrix(&target)
                                }
                                fn set_matrix(&mut self, value: Matrix) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_matrix(&mut target, value)
                                }
                                fn id(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::id(&target)
                                }
                                fn set_id(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_id(&mut target, value)
                                }
                                fn tween(
                                    &self,
                                    options: ItemTweenParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::tween(&target, options)
                                }
                                fn reduce(
                                    &self,
                                    options: JsValue,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::reduce(&target, options)
                                }
                                fn internal_bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::internal_bounds(&target)
                                }
                                fn set_internal_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_internal_bounds(&mut target, value)
                                }
                                fn fill_rule(&self) -> String {
                                    let target: Item = self.into();
                                    Item::fill_rule(&target)
                                }
                                fn set_fill_rule(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_fill_rule(&mut target, value)
                                }
                                fn shadow_color(&self) -> ItemShadowColor {
                                    let target: Item = self.into();
                                    Item::shadow_color(&target)
                                }
                                fn set_shadow_color(&mut self, value: ItemShadowColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_shadow_color(&mut target, value)
                                }
                                fn insert_above(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_above(&target, item)
                                }
                                fn responds(
                                    &self,
                                    type_: String,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::responds(&target, type_)
                                }
                                fn handle_bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::handle_bounds(&target)
                                }
                                fn set_handle_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_handle_bounds(&mut target, value)
                                }
                                fn skew(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::skew(&target, hor, ver, center)
                                }
                                fn on_click(&self) -> ItemOnClick {
                                    let target: Item = self.into();
                                    Item::on_click(&target)
                                }
                                fn set_on_click(&mut self, value: ItemOnClick) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_click(&mut target, value)
                                }
                                fn get_items(
                                    &self,
                                    options: ItemGetItemsParamsOptionsParam,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::get_items(&target, options)
                                }
                                fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::is_inserted(&target)
                                }
                                fn get_item(
                                    &self,
                                    options: ItemGetItemParamsOptionsParam,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::get_item(&target, options)
                                }
                                fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_fill(&target)
                                }
                                fn shear(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::shear(&target, hor, ver, center)
                                }
                                fn visible(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::visible(&target)
                                }
                                fn set_visible(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_visible(&mut target, value)
                                }
                                fn previous_sibling(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::previous_sibling(&target)
                                }
                                fn set_previous_sibling(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_previous_sibling(&mut target, value)
                                }
                                fn hit_test(
                                    &self,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<HitResult, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::hit_test(&target, point, options)
                                }
                                fn is_descendant(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_descendant(&target, item)
                                }
                                fn locked(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::locked(&target)
                                }
                                fn set_locked(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_locked(&mut target, value)
                                }
                                fn is_parent(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_parent(&target, item)
                                }
                                fn copy_attributes(
                                    &self,
                                    source: Item,
                                    exclude_matrix: bool,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::copy_attributes(&target, source, exclude_matrix)
                                }
                                fn last_child(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::last_child(&target)
                                }
                                fn set_last_child(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_last_child(&mut target, value)
                                }
                                fn stroke_width(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::stroke_width(&target)
                                }
                                fn set_stroke_width(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_width(&mut target, value)
                                }
                                fn parent(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::parent(&target)
                                }
                                fn set_parent(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_parent(&mut target, value)
                                }
                                fn stroke_bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::stroke_bounds(&target)
                                }
                                fn set_stroke_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_bounds(&mut target, value)
                                }
                                fn translate(
                                    &self,
                                    delta: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::translate(&target, delta)
                                }
                                fn remove(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::remove(&target)
                                }
                                fn parent_to_local(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::parent_to_local(&target, point)
                                }
                                fn bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::bounds(&target)
                                }
                                fn set_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_bounds(&mut target, value)
                                }
                                fn add_children(
                                    &self,
                                    items: Vec<Item>,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::add_children(&target, items)
                                }
                                fn dash_array(&self) -> Vec<f64> {
                                    let target: Item = self.into();
                                    Item::dash_array(&target)
                                }
                                fn set_dash_array(&mut self, value: Vec<f64>) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_dash_array(&mut target, value)
                                }
                                fn on_mouse_up(&self) -> ItemOnMouseUp {
                                    let target: Item = self.into();
                                    Item::on_mouse_up(&target)
                                }
                                fn set_on_mouse_up(&mut self, value: ItemOnMouseUp) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_up(&mut target, value)
                                }
                                fn on(
                                    &self,
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::on(&target, object)
                                }
                                fn remove_on(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::remove_on(&target, options)
                                }
                                fn is_below(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_below(&target, item)
                                }
                                fn apply_matrix(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::apply_matrix(&target)
                                }
                                fn set_apply_matrix(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_apply_matrix(&mut target, value)
                                }
                                fn clone(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::clone(&target, options)
                                }
                                fn contains(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::contains(&target, point)
                                }
                                fn export_json(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<String, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::export_json(&target, options)
                                }
                                fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::bring_to_front(&target)
                                }
                                fn is_above(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_above(&target, item)
                                }
                                fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_drag(&target)
                                }
                                fn data(&self) -> JsValue {
                                    let target: Item = self.into();
                                    Item::data(&target)
                                }
                                fn set_data(&mut self, value: JsValue) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_data(&mut target, value)
                                }
                                fn import_svg(
                                    &self,
                                    svg: ItemImportSvgParamsSvgParam,
                                    on_load: JsValue,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::import_svg(&target, svg, on_load)
                                }
                                fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_shadow(&target)
                                }
                                fn selected_color(&self) -> ItemSelectedColor {
                                    let target: Item = self.into();
                                    Item::selected_color(&target)
                                }
                                fn set_selected_color(&mut self, value: ItemSelectedColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_selected_color(&mut target, value)
                                }
                                fn class_name(&self) -> String {
                                    let target: Item = self.into();
                                    Item::class_name(&target)
                                }
                                fn set_class_name(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_class_name(&mut target, value)
                                }
                                fn export_svg(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<ItemExportSvgReturn, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::export_svg(&target, options)
                                }
                                fn tween_to(
                                    &self,
                                    to: std::collections::HashMap<String, JsValue>,
                                    options: ItemTweenToParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::tween_to(&target, to, options)
                                }
                                fn is_inside(
                                    &self,
                                    rect: Rectangle,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_inside(&target, rect)
                                }
                                fn is_empty(
                                    &self,
                                    recursively: bool,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_empty(&target, recursively)
                                }
                                fn copy_content(
                                    &self,
                                    source: Item,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::copy_content(&target, source)
                                }
                                fn rasterize(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Raster, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::rasterize(&target, options)
                                }
                                fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_move(&target)
                                }
                                fn tween_from(
                                    &self,
                                    from: std::collections::HashMap<String, JsValue>,
                                    options: ItemTweenFromParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::tween_from(&target, from, options)
                                }
                                fn opacity(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::opacity(&target)
                                }
                                fn set_opacity(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_opacity(&mut target, value)
                                }
                                fn dash_offset(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::dash_offset(&target)
                                }
                                fn set_dash_offset(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_dash_offset(&mut target, value)
                                }
                                fn remove_children(
                                    &self,
                                    start: f64,
                                    end: f64,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::remove_children(&target, start, end)
                                }
                                fn on_mouse_move(&self) -> ItemOnMouseMove {
                                    let target: Item = self.into();
                                    Item::on_mouse_move(&target)
                                }
                                fn set_on_mouse_move(&mut self, value: ItemOnMouseMove) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_move(&mut target, value)
                                }
                                fn intersects(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::intersects(&target, item)
                                }
                                fn pivot(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::pivot(&target)
                                }
                                fn set_pivot(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_pivot(&mut target, value)
                                }
                                fn copy_to(
                                    &self,
                                    owner: ItemCopyToParamsOwnerParam,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::copy_to(&target, owner)
                                }
                                fn index(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::index(&target)
                                }
                                fn set_index(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_index(&mut target, value)
                                }
                                fn local_to_parent(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::local_to_parent(&target, point)
                                }
                                fn stroke_color(&self) -> ItemStrokeColor {
                                    let target: Item = self.into();
                                    Item::stroke_color(&target)
                                }
                                fn set_stroke_color(&mut self, value: ItemStrokeColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_color(&mut target, value)
                                }
                                fn layer(&self) -> Layer {
                                    let target: Item = self.into();
                                    Item::layer(&target)
                                }
                                fn set_layer(&mut self, value: Layer) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_layer(&mut target, value)
                                }
                                fn stroke_scaling(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::stroke_scaling(&target)
                                }
                                fn set_stroke_scaling(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_scaling(&mut target, value)
                                }
                                fn fit_bounds(
                                    &self,
                                    rectangle: Rectangle,
                                    fill: bool,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::fit_bounds(&target, rectangle, fill)
                                }
                                fn miter_limit(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::miter_limit(&target)
                                }
                                fn set_miter_limit(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_miter_limit(&mut target, value)
                                }
                                fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_down(&target)
                                }
                            }
                            impl Layer_Trait for Layer {}
                            impl std::clone::Clone for Layer_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for Layer_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Layer_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                #[wasm_bindgen(js_name = "View")]
                                type View_Class;
                                # [wasm_bindgen (method , structural , getter = resolution , js_class = "View")]
                                fn resolution(this: &View_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = resolution , js_class = "View")]
                                fn set_resolution(this: &View_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = onFrame , js_class = "View")]
                                fn on_frame(this: &View_Class) -> ViewOnFrame;
                                # [wasm_bindgen (method , structural , setter = onFrame , js_class = "View")]
                                fn set_on_frame(this: &View_Class, value: ViewOnFrame);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = update , method , js_class = "View" , catch)]
                                fn __TSB_update(
                                    this: &View_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = rotate , method , js_class = "View" , catch)]
                                fn __TSB_rotate(
                                    this: &View_Class,
                                    angle: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>;
                                # [wasm_bindgen (method , structural , getter = rotation , js_class = "View")]
                                fn rotation(this: &View_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = rotation , js_class = "View")]
                                fn set_rotation(this: &View_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = onDoubleClick , js_class = "View")]
                                fn on_double_click(this: &View_Class) -> ViewOnDoubleClick;
                                # [wasm_bindgen (method , structural , setter = onDoubleClick , js_class = "View")]
                                fn set_on_double_click(this: &View_Class, value: ViewOnDoubleClick);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = translate , method , js_class = "View" , catch)]
                                fn __TSB_translate(
                                    this: &View_Class,
                                    delta: Point,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isInserted , method , js_class = "View" , catch)]
                                fn __TSB_is_inserted(
                                    this: &View_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                # [wasm_bindgen (method , structural , getter = onMouseDrag , js_class = "View")]
                                fn on_mouse_drag(this: &View_Class) -> ViewOnMouseDrag;
                                # [wasm_bindgen (method , structural , setter = onMouseDrag , js_class = "View")]
                                fn set_on_mouse_drag(this: &View_Class, value: ViewOnMouseDrag);
                                # [wasm_bindgen (method , structural , getter = onMouseDown , js_class = "View")]
                                fn on_mouse_down(this: &View_Class) -> ViewOnMouseDown;
                                # [wasm_bindgen (method , structural , setter = onMouseDown , js_class = "View")]
                                fn set_on_mouse_down(this: &View_Class, value: ViewOnMouseDown);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = off , method , js_class = "View" , catch)]
                                fn __TSB_off(
                                    this: &View_Class,
                                    param: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<View, JsValue>;
                                # [wasm_bindgen (method , structural , getter = onMouseUp , js_class = "View")]
                                fn on_mouse_up(this: &View_Class) -> ViewOnMouseUp;
                                # [wasm_bindgen (method , structural , setter = onMouseUp , js_class = "View")]
                                fn set_on_mouse_up(this: &View_Class, value: ViewOnMouseUp);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = remove , method , js_class = "View" , catch)]
                                fn __TSB_remove(
                                    this: &View_Class,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = emit , method , js_class = "View" , catch)]
                                fn __TSB_emit(
                                    this: &View_Class,
                                    type_: String,
                                    event: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = scale , method , js_class = "View" , catch)]
                                fn __TSB_scale(
                                    this: &View_Class,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>;
                                # [wasm_bindgen (method , structural , getter = viewSize , js_class = "View")]
                                fn view_size(this: &View_Class) -> Size;
                                # [wasm_bindgen (method , structural , setter = viewSize , js_class = "View")]
                                fn set_view_size(this: &View_Class, value: Size);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = projectToView , method , js_class = "View" , catch)]
                                fn __TSB_project_to_view(
                                    this: &View_Class,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = on , method , js_class = "View" , catch)]
                                fn __TSB_on(
                                    this: &View_Class,
                                    param: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<View, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = viewToProject , method , js_class = "View" , catch)]
                                fn __TSB_view_to_project(
                                    this: &View_Class,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                # [wasm_bindgen (method , structural , getter = onClick , js_class = "View")]
                                fn on_click(this: &View_Class) -> ViewOnClick;
                                # [wasm_bindgen (method , structural , setter = onClick , js_class = "View")]
                                fn set_on_click(this: &View_Class, value: ViewOnClick);
                                # [wasm_bindgen (method , structural , getter = center , js_class = "View")]
                                fn center(this: &View_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = center , js_class = "View")]
                                fn set_center(this: &View_Class, value: Point);
                                # [wasm_bindgen (method , structural , getter = autoUpdate , js_class = "View")]
                                fn auto_update(this: &View_Class) -> bool;
                                # [wasm_bindgen (method , structural , setter = autoUpdate , js_class = "View")]
                                fn set_auto_update(this: &View_Class, value: bool);
                                # [wasm_bindgen (method , structural , getter = bounds , js_class = "View")]
                                fn bounds(this: &View_Class) -> Rectangle;
                                # [wasm_bindgen (method , structural , setter = bounds , js_class = "View")]
                                fn set_bounds(this: &View_Class, value: Rectangle);
                                # [wasm_bindgen (method , structural , getter = pixelRatio , js_class = "View")]
                                fn pixel_ratio(this: &View_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = pixelRatio , js_class = "View")]
                                fn set_pixel_ratio(this: &View_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = size , js_class = "View")]
                                fn size(this: &View_Class) -> Size;
                                # [wasm_bindgen (method , structural , setter = size , js_class = "View")]
                                fn set_size(this: &View_Class, value: Size);
                                # [wasm_bindgen (method , structural , getter = matrix , js_class = "View")]
                                fn matrix(this: &View_Class) -> Matrix;
                                # [wasm_bindgen (method , structural , setter = matrix , js_class = "View")]
                                fn set_matrix(this: &View_Class, value: Matrix);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isVisible , method , js_class = "View" , catch)]
                                fn __TSB_is_visible(
                                    this: &View_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = transform , method , js_class = "View" , catch)]
                                fn __TSB_transform(
                                    this: &View_Class,
                                    matrix: Matrix,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = getEventPoint , method , js_class = "View" , catch)]
                                fn __TSB_get_event_point(
                                    this: &View_Class,
                                    event: Event,
                                ) -> std::result::Result<Point, JsValue>;
                                # [wasm_bindgen (method , structural , getter = zoom , js_class = "View")]
                                fn zoom(this: &View_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = zoom , js_class = "View")]
                                fn set_zoom(this: &View_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = onMouseLeave , js_class = "View")]
                                fn on_mouse_leave(this: &View_Class) -> ViewOnMouseLeave;
                                # [wasm_bindgen (method , structural , setter = onMouseLeave , js_class = "View")]
                                fn set_on_mouse_leave(this: &View_Class, value: ViewOnMouseLeave);
                                # [wasm_bindgen (method , structural , getter = scaling , js_class = "View")]
                                fn scaling(this: &View_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = scaling , js_class = "View")]
                                fn set_scaling(this: &View_Class, value: Point);
                                # [wasm_bindgen (method , structural , getter = onMouseMove , js_class = "View")]
                                fn on_mouse_move(this: &View_Class) -> ViewOnMouseMove;
                                # [wasm_bindgen (method , structural , setter = onMouseMove , js_class = "View")]
                                fn set_on_mouse_move(this: &View_Class, value: ViewOnMouseMove);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = requestUpdate , method , js_class = "View" , catch)]
                                fn __TSB_request_update(
                                    this: &View_Class,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = skew , method , js_class = "View" , catch)]
                                fn __TSB_skew(
                                    this: &View_Class,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>;
                                # [wasm_bindgen (method , structural , getter = element , js_class = "View")]
                                fn element(this: &View_Class) -> JsValue;
                                # [wasm_bindgen (method , structural , setter = element , js_class = "View")]
                                fn set_element(this: &View_Class, value: JsValue);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = responds , method , js_class = "View" , catch)]
                                fn __TSB_responds(
                                    this: &View_Class,
                                    type_: String,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = pause , method , js_class = "View" , catch)]
                                fn __TSB_pause(
                                    this: &View_Class,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = play , method , js_class = "View" , catch)]
                                fn __TSB_play(
                                    this: &View_Class,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = shear , method , js_class = "View" , catch)]
                                fn __TSB_shear(
                                    this: &View_Class,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>;
                                # [wasm_bindgen (method , structural , getter = onMouseEnter , js_class = "View")]
                                fn on_mouse_enter(this: &View_Class) -> ViewOnMouseEnter;
                                # [wasm_bindgen (method , structural , setter = onMouseEnter , js_class = "View")]
                                fn set_on_mouse_enter(this: &View_Class, value: ViewOnMouseEnter);
                                # [wasm_bindgen (method , structural , getter = onResize , js_class = "View")]
                                fn on_resize(this: &View_Class) -> ViewOnResize;
                                # [wasm_bindgen (method , structural , setter = onResize , js_class = "View")]
                                fn set_on_resize(this: &View_Class, value: ViewOnResize);
                            }
                            #[derive(std :: clone :: Clone)]
                            struct View(pub View_Class);
                            impl View {
                                #[allow(dead_code)]
                                pub fn resolution(&self) -> f64 {
                                    let result = self.0.resolution();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_resolution(&self, value: f64) -> () {
                                    let result = self.0.set_resolution(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn on_frame(&self) -> ViewOnFrame {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.on_frame()).unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_on_frame(&self, value: ViewOnFrame) -> () {
                                    let result = self.0.set_on_frame(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn update(&self) -> std::result::Result<bool, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_update()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn rotate(
                                    &self,
                                    angle: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_rotate(angle, center)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn rotation(&self) -> f64 {
                                    let result = self.0.rotation();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_rotation(&self, value: f64) -> () {
                                    let result = self.0.set_rotation(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn on_double_click(&self) -> ViewOnDoubleClick {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.on_double_click())
                                            .unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_on_double_click(&self, value: ViewOnDoubleClick) -> () {
                                    let result = self.0.set_on_double_click(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn translate(
                                    &self,
                                    delta: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_translate(delta)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_is_inserted()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn on_mouse_drag(&self) -> ViewOnMouseDrag {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_drag())
                                            .unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_on_mouse_drag(&self, value: ViewOnMouseDrag) -> () {
                                    let result = self.0.set_on_mouse_drag(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn on_mouse_down(&self) -> ViewOnMouseDown {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_down())
                                            .unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_on_mouse_down(&self, value: ViewOnMouseDown) -> () {
                                    let result = self.0.set_on_mouse_down(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn off(
                                    &self,
                                    param: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<View, JsValue>
                                {
                                    let result = std::result::Result::Ok(self.0.__TSB_off(param)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn on_mouse_up(&self) -> ViewOnMouseUp {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_up()).unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_on_mouse_up(&self, value: ViewOnMouseUp) -> () {
                                    let result = self.0.set_on_mouse_up(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn remove(&self) -> std::result::Result<(), JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_remove()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn emit(
                                    &self,
                                    type_: String,
                                    event: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_emit(type_, event)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn scale(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_scale(hor, ver, center)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn view_size(&self) -> Size {
                                    let result = self.0.view_size();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_view_size(&self, value: Size) -> () {
                                    let result = self.0.set_view_size(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn project_to_view(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_project_to_view(point)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn on(
                                    &self,
                                    param: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<View, JsValue>
                                {
                                    let result = std::result::Result::Ok(self.0.__TSB_on(param)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn view_to_project(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_view_to_project(point)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn on_click(&self) -> ViewOnClick {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.on_click()).unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_on_click(&self, value: ViewOnClick) -> () {
                                    let result = self.0.set_on_click(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn center(&self) -> Point {
                                    let result = self.0.center();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_center(&self, value: Point) -> () {
                                    let result = self.0.set_center(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn auto_update(&self) -> bool {
                                    let result = self.0.auto_update();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_auto_update(&self, value: bool) -> () {
                                    let result = self.0.set_auto_update(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn bounds(&self) -> Rectangle {
                                    let result = self.0.bounds();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_bounds(&self, value: Rectangle) -> () {
                                    let result = self.0.set_bounds(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn pixel_ratio(&self) -> f64 {
                                    let result = self.0.pixel_ratio();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_pixel_ratio(&self, value: f64) -> () {
                                    let result = self.0.set_pixel_ratio(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn size(&self) -> Size {
                                    let result = self.0.size();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_size(&self, value: Size) -> () {
                                    let result = self.0.set_size(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn matrix(&self) -> Matrix {
                                    let result = self.0.matrix();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_matrix(&self, value: Matrix) -> () {
                                    let result = self.0.set_matrix(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_visible(&self) -> std::result::Result<bool, JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_is_visible()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn transform(
                                    &self,
                                    matrix: Matrix,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_transform(matrix)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn get_event_point(
                                    &self,
                                    event: Event,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_get_event_point(event)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn zoom(&self) -> f64 {
                                    let result = self.0.zoom();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_zoom(&self, value: f64) -> () {
                                    let result = self.0.set_zoom(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn on_mouse_leave(&self) -> ViewOnMouseLeave {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_leave())
                                            .unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_on_mouse_leave(&self, value: ViewOnMouseLeave) -> () {
                                    let result = self.0.set_on_mouse_leave(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn scaling(&self) -> Point {
                                    let result = self.0.scaling();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_scaling(&self, value: Point) -> () {
                                    let result = self.0.set_scaling(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn on_mouse_move(&self) -> ViewOnMouseMove {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_move())
                                            .unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_on_mouse_move(&self, value: ViewOnMouseMove) -> () {
                                    let result = self.0.set_on_mouse_move(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn request_update(&self) -> std::result::Result<(), JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_request_update()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn skew(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_skew(hor, ver, center)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn element(&self) -> JsValue {
                                    let result = self.0.element();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_element(&self, value: JsValue) -> () {
                                    let result = self.0.set_element(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn responds(
                                    &self,
                                    type_: String,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_responds(type_)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn pause(&self) -> std::result::Result<(), JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_pause()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn play(&self) -> std::result::Result<(), JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_play()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn shear(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_shear(hor, ver, center)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn on_mouse_enter(&self) -> ViewOnMouseEnter {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.on_mouse_enter())
                                            .unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_on_mouse_enter(&self, value: ViewOnMouseEnter) -> () {
                                    let result = self.0.set_on_mouse_enter(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn on_resize(&self) -> ViewOnResize {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.on_resize()).unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_on_resize(&self, value: ViewOnResize) -> () {
                                    let result = self.0.set_on_resize(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for View {
                                fn describe() {
                                    <View_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for View {
                                type Abi = <View_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a View {
                                type Abi =
                                    <&'a View_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for View {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for View {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal: View_Class =
                                        <View_Class as serde::de::Deserialize>::deserialize(
                                            deserializer,
                                        )?;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait View_Trait {
                                fn resolution(&self) -> f64;
                                fn set_resolution(&mut self, value: f64) -> ();
                                fn on_frame(&self) -> ViewOnFrame;
                                fn set_on_frame(&mut self, value: ViewOnFrame) -> ();
                                fn update(&self) -> std::result::Result<bool, JsValue>;
                                fn rotate(
                                    &self,
                                    angle: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>;
                                fn rotation(&self) -> f64;
                                fn set_rotation(&mut self, value: f64) -> ();
                                fn on_double_click(&self) -> ViewOnDoubleClick;
                                fn set_on_double_click(&mut self, value: ViewOnDoubleClick) -> ();
                                fn translate(
                                    &self,
                                    delta: Point,
                                ) -> std::result::Result<(), JsValue>;
                                fn is_inserted(&self) -> std::result::Result<bool, JsValue>;
                                fn on_mouse_drag(&self) -> ViewOnMouseDrag;
                                fn set_on_mouse_drag(&mut self, value: ViewOnMouseDrag) -> ();
                                fn on_mouse_down(&self) -> ViewOnMouseDown;
                                fn set_on_mouse_down(&mut self, value: ViewOnMouseDown) -> ();
                                fn off(
                                    &self,
                                    param: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<View, JsValue>;
                                fn on_mouse_up(&self) -> ViewOnMouseUp;
                                fn set_on_mouse_up(&mut self, value: ViewOnMouseUp) -> ();
                                fn remove(&self) -> std::result::Result<(), JsValue>;
                                fn emit(
                                    &self,
                                    type_: String,
                                    event: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>;
                                fn scale(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>;
                                fn view_size(&self) -> Size;
                                fn set_view_size(&mut self, value: Size) -> ();
                                fn project_to_view(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                fn on(
                                    &self,
                                    param: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<View, JsValue>;
                                fn view_to_project(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                fn on_click(&self) -> ViewOnClick;
                                fn set_on_click(&mut self, value: ViewOnClick) -> ();
                                fn center(&self) -> Point;
                                fn set_center(&mut self, value: Point) -> ();
                                fn auto_update(&self) -> bool;
                                fn set_auto_update(&mut self, value: bool) -> ();
                                fn bounds(&self) -> Rectangle;
                                fn set_bounds(&mut self, value: Rectangle) -> ();
                                fn pixel_ratio(&self) -> f64;
                                fn set_pixel_ratio(&mut self, value: f64) -> ();
                                fn size(&self) -> Size;
                                fn set_size(&mut self, value: Size) -> ();
                                fn matrix(&self) -> Matrix;
                                fn set_matrix(&mut self, value: Matrix) -> ();
                                fn is_visible(&self) -> std::result::Result<bool, JsValue>;
                                fn transform(
                                    &self,
                                    matrix: Matrix,
                                ) -> std::result::Result<(), JsValue>;
                                fn get_event_point(
                                    &self,
                                    event: Event,
                                ) -> std::result::Result<Point, JsValue>;
                                fn zoom(&self) -> f64;
                                fn set_zoom(&mut self, value: f64) -> ();
                                fn on_mouse_leave(&self) -> ViewOnMouseLeave;
                                fn set_on_mouse_leave(&mut self, value: ViewOnMouseLeave) -> ();
                                fn scaling(&self) -> Point;
                                fn set_scaling(&mut self, value: Point) -> ();
                                fn on_mouse_move(&self) -> ViewOnMouseMove;
                                fn set_on_mouse_move(&mut self, value: ViewOnMouseMove) -> ();
                                fn request_update(&self) -> std::result::Result<(), JsValue>;
                                fn skew(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>;
                                fn element(&self) -> JsValue;
                                fn set_element(&mut self, value: JsValue) -> ();
                                fn responds(
                                    &self,
                                    type_: String,
                                ) -> std::result::Result<bool, JsValue>;
                                fn pause(&self) -> std::result::Result<(), JsValue>;
                                fn play(&self) -> std::result::Result<(), JsValue>;
                                fn shear(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>;
                                fn on_mouse_enter(&self) -> ViewOnMouseEnter;
                                fn set_on_mouse_enter(&mut self, value: ViewOnMouseEnter) -> ();
                                fn on_resize(&self) -> ViewOnResize;
                                fn set_on_resize(&mut self, value: ViewOnResize) -> ();
                            }
                            impl std::clone::Clone for View_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for View_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for View_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                #[wasm_bindgen(js_name = "Rectangle")]
                                type Rectangle_Class;
                                # [wasm_bindgen (method , structural , getter = width , js_class = "Rectangle")]
                                fn width(this: &Rectangle_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = width , js_class = "Rectangle")]
                                fn set_width(this: &Rectangle_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = x , js_class = "Rectangle")]
                                fn x(this: &Rectangle_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = x , js_class = "Rectangle")]
                                fn set_x(this: &Rectangle_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = include , method , js_class = "Rectangle" , catch)]
                                fn __TSB_include(
                                    this: &Rectangle_Class,
                                    point: Point,
                                ) -> std::result::Result<Rectangle, JsValue>;
                                # [wasm_bindgen (method , structural , getter = leftCenter , js_class = "Rectangle")]
                                fn left_center(this: &Rectangle_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = leftCenter , js_class = "Rectangle")]
                                fn set_left_center(this: &Rectangle_Class, value: Point);
                                # [wasm_bindgen (method , structural , getter = top , js_class = "Rectangle")]
                                fn top(this: &Rectangle_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = top , js_class = "Rectangle")]
                                fn set_top(this: &Rectangle_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = topLeft , js_class = "Rectangle")]
                                fn top_left(this: &Rectangle_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = topLeft , js_class = "Rectangle")]
                                fn set_top_left(this: &Rectangle_Class, value: Point);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = clone , method , js_class = "Rectangle" , catch)]
                                fn __TSB_clone(
                                    this: &Rectangle_Class,
                                ) -> std::result::Result<Rectangle, JsValue>;
                                # [wasm_bindgen (method , structural , getter = bottom , js_class = "Rectangle")]
                                fn bottom(this: &Rectangle_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = bottom , js_class = "Rectangle")]
                                fn set_bottom(this: &Rectangle_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = topCenter , js_class = "Rectangle")]
                                fn top_center(this: &Rectangle_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = topCenter , js_class = "Rectangle")]
                                fn set_top_center(this: &Rectangle_Class, value: Point);
                                # [wasm_bindgen (method , structural , getter = bottomCenter , js_class = "Rectangle")]
                                fn bottom_center(this: &Rectangle_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = bottomCenter , js_class = "Rectangle")]
                                fn set_bottom_center(this: &Rectangle_Class, value: Point);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = toString , method , js_class = "Rectangle" , catch)]
                                fn __TSB_to_string(
                                    this: &Rectangle_Class,
                                ) -> std::result::Result<String, JsValue>;
                                # [wasm_bindgen (method , structural , getter = bottomRight , js_class = "Rectangle")]
                                fn bottom_right(this: &Rectangle_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = bottomRight , js_class = "Rectangle")]
                                fn set_bottom_right(this: &Rectangle_Class, value: Point);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = set , method , js_class = "Rectangle" , catch , variadic)]
                                fn __TSB_set(
                                    this: &Rectangle_Class,
                                    values: &[JsValue],
                                ) -> std::result::Result<Rectangle, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = intersects , method , js_class = "Rectangle" , catch)]
                                fn __TSB_intersects(
                                    this: &Rectangle_Class,
                                    rect: Rectangle,
                                    epsilon: f64,
                                ) -> std::result::Result<bool, JsValue>;
                                # [wasm_bindgen (method , structural , getter = right , js_class = "Rectangle")]
                                fn right(this: &Rectangle_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = right , js_class = "Rectangle")]
                                fn set_right(this: &Rectangle_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = rightCenter , js_class = "Rectangle")]
                                fn right_center(this: &Rectangle_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = rightCenter , js_class = "Rectangle")]
                                fn set_right_center(this: &Rectangle_Class, value: Point);
                                # [wasm_bindgen (method , structural , getter = point , js_class = "Rectangle")]
                                fn point(this: &Rectangle_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = point , js_class = "Rectangle")]
                                fn set_point(this: &Rectangle_Class, value: Point);
                                # [wasm_bindgen (method , structural , getter = y , js_class = "Rectangle")]
                                fn y(this: &Rectangle_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = y , js_class = "Rectangle")]
                                fn set_y(this: &Rectangle_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = expand , method , js_class = "Rectangle" , catch)]
                                fn __TSB_expand(
                                    this: &Rectangle_Class,
                                    hor: f64,
                                    ver: f64,
                                ) -> std::result::Result<Rectangle, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = contains , method , js_class = "Rectangle" , catch)]
                                fn __TSB_contains(
                                    this: &Rectangle_Class,
                                    rect: Rectangle,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = equals , method , js_class = "Rectangle" , catch)]
                                fn __TSB_equals(
                                    this: &Rectangle_Class,
                                    rect: Rectangle,
                                ) -> std::result::Result<bool, JsValue>;
                                # [wasm_bindgen (method , structural , getter = center , js_class = "Rectangle")]
                                fn center(this: &Rectangle_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = center , js_class = "Rectangle")]
                                fn set_center(this: &Rectangle_Class, value: Point);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = intersect , method , js_class = "Rectangle" , catch)]
                                fn __TSB_intersect(
                                    this: &Rectangle_Class,
                                    rect: Rectangle,
                                ) -> std::result::Result<Rectangle, JsValue>;
                                # [wasm_bindgen (method , structural , getter = topRight , js_class = "Rectangle")]
                                fn top_right(this: &Rectangle_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = topRight , js_class = "Rectangle")]
                                fn set_top_right(this: &Rectangle_Class, value: Point);
                                # [wasm_bindgen (method , structural , getter = selected , js_class = "Rectangle")]
                                fn selected(this: &Rectangle_Class) -> bool;
                                # [wasm_bindgen (method , structural , setter = selected , js_class = "Rectangle")]
                                fn set_selected(this: &Rectangle_Class, value: bool);
                                # [wasm_bindgen (method , structural , getter = area , js_class = "Rectangle")]
                                fn area(this: &Rectangle_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = area , js_class = "Rectangle")]
                                fn set_area(this: &Rectangle_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = height , js_class = "Rectangle")]
                                fn height(this: &Rectangle_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = height , js_class = "Rectangle")]
                                fn set_height(this: &Rectangle_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = bottomLeft , js_class = "Rectangle")]
                                fn bottom_left(this: &Rectangle_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = bottomLeft , js_class = "Rectangle")]
                                fn set_bottom_left(this: &Rectangle_Class, value: Point);
                                #[wasm_bindgen(constructor, js_class = "Rectangle")]
                                pub fn new(
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> Rectangle_Class;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isEmpty , method , js_class = "Rectangle" , catch)]
                                fn __TSB_is_empty(
                                    this: &Rectangle_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = scale , method , js_class = "Rectangle" , catch)]
                                fn __TSB_scale(
                                    this: &Rectangle_Class,
                                    hor: f64,
                                    ver: f64,
                                ) -> std::result::Result<Rectangle, JsValue>;
                                # [wasm_bindgen (method , structural , getter = size , js_class = "Rectangle")]
                                fn size(this: &Rectangle_Class) -> Size;
                                # [wasm_bindgen (method , structural , setter = size , js_class = "Rectangle")]
                                fn set_size(this: &Rectangle_Class, value: Size);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = unite , method , js_class = "Rectangle" , catch)]
                                fn __TSB_unite(
                                    this: &Rectangle_Class,
                                    rect: Rectangle,
                                ) -> std::result::Result<Rectangle, JsValue>;
                                # [wasm_bindgen (method , structural , getter = left , js_class = "Rectangle")]
                                fn left(this: &Rectangle_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = left , js_class = "Rectangle")]
                                fn set_left(this: &Rectangle_Class, value: f64);
                            }
                            #[derive(std :: clone :: Clone)]
                            struct Rectangle(pub Rectangle_Class);
                            impl Rectangle {
                                #[allow(dead_code)]
                                pub fn width(&self) -> f64 {
                                    let result = self.0.width();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_width(&self, value: f64) -> () {
                                    let result = self.0.set_width(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn x(&self) -> f64 {
                                    let result = self.0.x();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_x(&self, value: f64) -> () {
                                    let result = self.0.set_x(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn include(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Rectangle, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_include(point)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn left_center(&self) -> Point {
                                    let result = self.0.left_center();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_left_center(&self, value: Point) -> () {
                                    let result = self.0.set_left_center(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn top(&self) -> f64 {
                                    let result = self.0.top();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_top(&self, value: f64) -> () {
                                    let result = self.0.set_top(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn top_left(&self) -> Point {
                                    let result = self.0.top_left();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_top_left(&self, value: Point) -> () {
                                    let result = self.0.set_top_left(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn clone(&self) -> std::result::Result<Rectangle, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_clone()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn bottom(&self) -> f64 {
                                    let result = self.0.bottom();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_bottom(&self, value: f64) -> () {
                                    let result = self.0.set_bottom(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn top_center(&self) -> Point {
                                    let result = self.0.top_center();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_top_center(&self, value: Point) -> () {
                                    let result = self.0.set_top_center(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn bottom_center(&self) -> Point {
                                    let result = self.0.bottom_center();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_bottom_center(&self, value: Point) -> () {
                                    let result = self.0.set_bottom_center(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_to_string()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn bottom_right(&self) -> Point {
                                    let result = self.0.bottom_right();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_bottom_right(&self, value: Point) -> () {
                                    let result = self.0.set_bottom_right(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set(
                                    &self,
                                    values: &[JsValue],
                                ) -> std::result::Result<Rectangle, JsValue>
                                {
                                    let result = std::result::Result::Ok(self.0.__TSB_set(values)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn intersects(
                                    &self,
                                    rect: Rectangle,
                                    epsilon: f64,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_intersects(rect, epsilon)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn right(&self) -> f64 {
                                    let result = self.0.right();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_right(&self, value: f64) -> () {
                                    let result = self.0.set_right(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn right_center(&self) -> Point {
                                    let result = self.0.right_center();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_right_center(&self, value: Point) -> () {
                                    let result = self.0.set_right_center(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn point(&self) -> Point {
                                    let result = self.0.point();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_point(&self, value: Point) -> () {
                                    let result = self.0.set_point(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn y(&self) -> f64 {
                                    let result = self.0.y();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_y(&self, value: f64) -> () {
                                    let result = self.0.set_y(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn expand(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                ) -> std::result::Result<Rectangle, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_expand(hor, ver)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn contains(
                                    &self,
                                    rect: Rectangle,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_contains(rect)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn equals(
                                    &self,
                                    rect: Rectangle,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_equals(rect)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn center(&self) -> Point {
                                    let result = self.0.center();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_center(&self, value: Point) -> () {
                                    let result = self.0.set_center(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn intersect(
                                    &self,
                                    rect: Rectangle,
                                ) -> std::result::Result<Rectangle, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_intersect(rect)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn top_right(&self) -> Point {
                                    let result = self.0.top_right();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_top_right(&self, value: Point) -> () {
                                    let result = self.0.set_top_right(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn selected(&self) -> bool {
                                    let result = self.0.selected();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_selected(&self, value: bool) -> () {
                                    let result = self.0.set_selected(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn area(&self) -> f64 {
                                    let result = self.0.area();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_area(&self, value: f64) -> () {
                                    let result = self.0.set_area(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn height(&self) -> f64 {
                                    let result = self.0.height();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_height(&self, value: f64) -> () {
                                    let result = self.0.set_height(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn bottom_left(&self) -> Point {
                                    let result = self.0.bottom_left();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_bottom_left(&self, value: Point) -> () {
                                    let result = self.0.set_bottom_left(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn new(
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> Rectangle {
                                    let result = Rectangle_Class::new(object);
                                    let result =
                                        ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result)
                                            .unwrap();
                                    Rectangle(result)
                                }
                                #[allow(dead_code)]
                                pub fn is_empty(&self) -> std::result::Result<bool, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_is_empty()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn scale(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                ) -> std::result::Result<Rectangle, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_scale(hor, ver)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn size(&self) -> Size {
                                    let result = self.0.size();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_size(&self, value: Size) -> () {
                                    let result = self.0.set_size(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn unite(
                                    &self,
                                    rect: Rectangle,
                                ) -> std::result::Result<Rectangle, JsValue>
                                {
                                    let result = std::result::Result::Ok(self.0.__TSB_unite(rect)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn left(&self) -> f64 {
                                    let result = self.0.left();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_left(&self, value: f64) -> () {
                                    let result = self.0.set_left(value);
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for Rectangle {
                                fn describe() {
                                    < Rectangle_Class as wasm_bindgen :: describe :: WasmDescribe > :: describe ()
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for Rectangle {
                                type Abi =
                                    <Rectangle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Rectangle {
                                type Abi = < & 'a Rectangle_Class as wasm_bindgen :: convert :: IntoWasmAbi > :: Abi ;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for Rectangle {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Rectangle {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal: Rectangle_Class =
                                        <Rectangle_Class as serde::de::Deserialize>::deserialize(
                                            deserializer,
                                        )?;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait Rectangle_Trait {
                                fn width(&self) -> f64;
                                fn set_width(&mut self, value: f64) -> ();
                                fn x(&self) -> f64;
                                fn set_x(&mut self, value: f64) -> ();
                                fn include(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Rectangle, JsValue>;
                                fn left_center(&self) -> Point;
                                fn set_left_center(&mut self, value: Point) -> ();
                                fn top(&self) -> f64;
                                fn set_top(&mut self, value: f64) -> ();
                                fn top_left(&self) -> Point;
                                fn set_top_left(&mut self, value: Point) -> ();
                                fn clone(&self) -> std::result::Result<Rectangle, JsValue>;
                                fn bottom(&self) -> f64;
                                fn set_bottom(&mut self, value: f64) -> ();
                                fn top_center(&self) -> Point;
                                fn set_top_center(&mut self, value: Point) -> ();
                                fn bottom_center(&self) -> Point;
                                fn set_bottom_center(&mut self, value: Point) -> ();
                                fn to_string(&self) -> std::result::Result<String, JsValue>;
                                fn bottom_right(&self) -> Point;
                                fn set_bottom_right(&mut self, value: Point) -> ();
                                fn set(
                                    &self,
                                    values: &[JsValue],
                                ) -> std::result::Result<Rectangle, JsValue>;
                                fn intersects(
                                    &self,
                                    rect: Rectangle,
                                    epsilon: f64,
                                ) -> std::result::Result<bool, JsValue>;
                                fn right(&self) -> f64;
                                fn set_right(&mut self, value: f64) -> ();
                                fn right_center(&self) -> Point;
                                fn set_right_center(&mut self, value: Point) -> ();
                                fn point(&self) -> Point;
                                fn set_point(&mut self, value: Point) -> ();
                                fn y(&self) -> f64;
                                fn set_y(&mut self, value: f64) -> ();
                                fn expand(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                ) -> std::result::Result<Rectangle, JsValue>;
                                fn contains(
                                    &self,
                                    rect: Rectangle,
                                ) -> std::result::Result<bool, JsValue>;
                                fn equals(
                                    &self,
                                    rect: Rectangle,
                                ) -> std::result::Result<bool, JsValue>;
                                fn center(&self) -> Point;
                                fn set_center(&mut self, value: Point) -> ();
                                fn intersect(
                                    &self,
                                    rect: Rectangle,
                                ) -> std::result::Result<Rectangle, JsValue>;
                                fn top_right(&self) -> Point;
                                fn set_top_right(&mut self, value: Point) -> ();
                                fn selected(&self) -> bool;
                                fn set_selected(&mut self, value: bool) -> ();
                                fn area(&self) -> f64;
                                fn set_area(&mut self, value: f64) -> ();
                                fn height(&self) -> f64;
                                fn set_height(&mut self, value: f64) -> ();
                                fn bottom_left(&self) -> Point;
                                fn set_bottom_left(&mut self, value: Point) -> ();
                                fn new(
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> Rectangle;
                                fn is_empty(&self) -> std::result::Result<bool, JsValue>;
                                fn scale(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                ) -> std::result::Result<Rectangle, JsValue>;
                                fn size(&self) -> Size;
                                fn set_size(&mut self, value: Size) -> ();
                                fn unite(
                                    &self,
                                    rect: Rectangle,
                                ) -> std::result::Result<Rectangle, JsValue>;
                                fn left(&self) -> f64;
                                fn set_left(&mut self, value: f64) -> ();
                            }
                            impl std::clone::Clone for Rectangle_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for Rectangle_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Rectangle_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                #[wasm_bindgen(js_name = "Key")]
                                type Key_Class;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isDown , method , js_class = "Key" , catch)]
                                fn __TSB_is_down(
                                    this: &Key_Class,
                                    key: String,
                                ) -> std::result::Result<bool, JsValue>;
                                # [wasm_bindgen (method , structural , getter = modifiers , js_class = "Key")]
                                fn modifiers(this: &Key_Class) -> JsValue;
                                # [wasm_bindgen (method , structural , setter = modifiers , js_class = "Key")]
                                fn set_modifiers(this: &Key_Class, value: JsValue);
                            }
                            #[derive(std :: clone :: Clone)]
                            struct Key(pub Key_Class);
                            impl Key {
                                #[allow(dead_code)]
                                pub fn is_down(
                                    &self,
                                    key: String,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_is_down(key)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn modifiers(&self) -> JsValue {
                                    let result = self.0.modifiers();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_modifiers(&self, value: JsValue) -> () {
                                    let result = self.0.set_modifiers(value);
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for Key {
                                fn describe() {
                                    <Key_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for Key {
                                type Abi = <Key_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Key {
                                type Abi =
                                    <&'a Key_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for Key {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Key {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal: Key_Class =
                                        <Key_Class as serde::de::Deserialize>::deserialize(
                                            deserializer,
                                        )?;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait Key_Trait {
                                fn is_down(
                                    &self,
                                    key: String,
                                ) -> std::result::Result<bool, JsValue>;
                                fn modifiers(&self) -> JsValue;
                                fn set_modifiers(&mut self, value: JsValue) -> ();
                            }
                            impl std::clone::Clone for Key_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for Key_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Key_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                # [wasm_bindgen (js_name = "Shape" , extends = Item_Class)]
                                type Shape_Class;
                                # [wasm_bindgen (method , structural , getter = type , js_class = "Shape")]
                                fn type_(this: &Shape_Class) -> String;
                                # [wasm_bindgen (method , structural , setter = type , js_class = "Shape")]
                                fn set_type_(this: &Shape_Class, value: String);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = toPath , method , js_class = "Shape" , catch)]
                                fn __TSB_to_path(
                                    this: &Shape_Class,
                                    insert: bool,
                                ) -> std::result::Result<Path, JsValue>;
                                # [wasm_bindgen (method , structural , getter = size , js_class = "Shape")]
                                fn size(this: &Shape_Class) -> Size;
                                # [wasm_bindgen (method , structural , setter = size , js_class = "Shape")]
                                fn set_size(this: &Shape_Class, value: Size);
                                # [wasm_bindgen (method , structural , getter = radius , js_class = "Shape")]
                                fn radius(this: &Shape_Class) -> ShapeRadius;
                                # [wasm_bindgen (method , structural , setter = radius , js_class = "Shape")]
                                fn set_radius(this: &Shape_Class, value: ShapeRadius);
                            }
                            #[derive(std :: clone :: Clone)]
                            struct Shape(pub Shape_Class);
                            impl std::convert::From<&Shape> for Item {
                                fn from(src: &Shape) -> Item {
                                    let src: &Item_Class = src.0.as_ref();
                                    Item(src.clone())
                                }
                            }
                            impl std::convert::From<&mut Shape> for Item {
                                fn from(src: &mut Shape) -> Item {
                                    let src: &Item_Class = src.0.as_ref();
                                    Item(src.clone())
                                }
                            }
                            impl Shape {
                                #[allow(dead_code)]
                                pub fn type_(&self) -> String {
                                    let result = self.0.type_();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_type_(&self, value: String) -> () {
                                    let result = self.0.set_type_(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn to_path(
                                    &self,
                                    insert: bool,
                                ) -> std::result::Result<Path, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_to_path(insert)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn size(&self) -> Size {
                                    let result = self.0.size();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_size(&self, value: Size) -> () {
                                    let result = self.0.set_size(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn radius(&self) -> ShapeRadius {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.radius()).unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_radius(&self, value: ShapeRadius) -> () {
                                    let result = self.0.set_radius(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for Shape {
                                fn describe() {
                                    <Shape_Class as wasm_bindgen::describe::WasmDescribe>::describe(
                                    )
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for Shape {
                                type Abi = <Shape_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Shape {
                                type Abi =
                                    <&'a Shape_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for Shape {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Shape {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal: Shape_Class =
                                        <Shape_Class as serde::de::Deserialize>::deserialize(
                                            deserializer,
                                        )?;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait Shape_Trait: Item_Trait {
                                fn type_(&self) -> String;
                                fn set_type(&mut self, value: String) -> ();
                                fn to_path(
                                    &self,
                                    insert: bool,
                                ) -> std::result::Result<Path, JsValue>;
                                fn size(&self) -> Size;
                                fn set_size(&mut self, value: Size) -> ();
                                fn radius(&self) -> ShapeRadius;
                                fn set_radius(&mut self, value: ShapeRadius) -> ();
                            }
                            impl Item_Trait for Shape {
                                fn insert_below(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_below(&target, item)
                                }
                                fn on_double_click(&self) -> ItemOnDoubleClick {
                                    let target: Item = self.into();
                                    Item::on_double_click(&target)
                                }
                                fn set_on_double_click(&mut self, value: ItemOnDoubleClick) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_double_click(&mut target, value)
                                }
                                fn view(&self) -> View {
                                    let target: Item = self.into();
                                    Item::view(&target)
                                }
                                fn set_view(&mut self, value: View) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_view(&mut target, value)
                                }
                                fn blend_mode(&self) -> String {
                                    let target: Item = self.into();
                                    Item::blend_mode(&target)
                                }
                                fn set_blend_mode(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_blend_mode(&mut target, value)
                                }
                                fn name(&self) -> String {
                                    let target: Item = self.into();
                                    Item::name(&target)
                                }
                                fn set_name(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_name(&mut target, value)
                                }
                                fn project(&self) -> Project {
                                    let target: Item = self.into();
                                    Item::project(&target)
                                }
                                fn set_project(&mut self, value: Project) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_project(&mut target, value)
                                }
                                fn is_child(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_child(&target, item)
                                }
                                fn global_matrix(&self) -> Matrix {
                                    let target: Item = self.into();
                                    Item::global_matrix(&target)
                                }
                                fn set_global_matrix(&mut self, value: Matrix) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_global_matrix(&mut target, value)
                                }
                                fn on_mouse_leave(&self) -> ItemOnMouseLeave {
                                    let target: Item = self.into();
                                    Item::on_mouse_leave(&target)
                                }
                                fn set_on_mouse_leave(&mut self, value: ItemOnMouseLeave) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_leave(&mut target, value)
                                }
                                fn has_children(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_children(&target)
                                }
                                fn selected(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::selected(&target)
                                }
                                fn set_selected(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_selected(&mut target, value)
                                }
                                fn global_to_local(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::global_to_local(&target, point)
                                }
                                fn shadow_blur(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::shadow_blur(&target)
                                }
                                fn set_shadow_blur(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_shadow_blur(&mut target, value)
                                }
                                fn children(&self) -> Vec<Item> {
                                    let target: Item = self.into();
                                    Item::children(&target)
                                }
                                fn set_children(&mut self, value: Vec<Item>) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_children(&mut target, value)
                                }
                                fn replace_with(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::replace_with(&target, item)
                                }
                                fn import_json(
                                    &self,
                                    json: String,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::import_json(&target, json)
                                }
                                fn insert_child(
                                    &self,
                                    index: f64,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_child(&target, index, item)
                                }
                                fn stroke_join(&self) -> String {
                                    let target: Item = self.into();
                                    Item::stroke_join(&target)
                                }
                                fn set_stroke_join(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_join(&mut target, value)
                                }
                                fn rotation(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::rotation(&target)
                                }
                                fn set_rotation(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_rotation(&mut target, value)
                                }
                                fn scaling(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::scaling(&target)
                                }
                                fn set_scaling(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_scaling(&mut target, value)
                                }
                                fn is_ancestor(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_ancestor(&target, item)
                                }
                                fn emit(
                                    &self,
                                    type_: String,
                                    event: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::emit(&target, type_, event)
                                }
                                fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_up(&target)
                                }
                                fn add_to(
                                    &self,
                                    owner: ItemAddToParamsOwnerParam,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::add_to(&target, owner)
                                }
                                fn stroke_cap(&self) -> String {
                                    let target: Item = self.into();
                                    Item::stroke_cap(&target)
                                }
                                fn set_stroke_cap(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_cap(&mut target, value)
                                }
                                fn on_mouse_drag(&self) -> ItemOnMouseDrag {
                                    let target: Item = self.into();
                                    Item::on_mouse_drag(&target)
                                }
                                fn set_on_mouse_drag(&mut self, value: ItemOnMouseDrag) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_drag(&mut target, value)
                                }
                                fn set(
                                    &self,
                                    props: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::set(&target, props)
                                }
                                fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::reverse_children(&target)
                                }
                                fn matches(
                                    &self,
                                    name: String,
                                    compare: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::matches(&target, name, compare)
                                }
                                fn on_mouse_enter(&self) -> ItemOnMouseEnter {
                                    let target: Item = self.into();
                                    Item::on_mouse_enter(&target)
                                }
                                fn set_on_mouse_enter(&mut self, value: ItemOnMouseEnter) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_enter(&mut target, value)
                                }
                                fn shadow_offset(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::shadow_offset(&target)
                                }
                                fn set_shadow_offset(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_shadow_offset(&mut target, value)
                                }
                                fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_stroke(&target)
                                }
                                fn view_matrix(&self) -> Matrix {
                                    let target: Item = self.into();
                                    Item::view_matrix(&target)
                                }
                                fn set_view_matrix(&mut self, value: Matrix) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_view_matrix(&mut target, value)
                                }
                                fn on_frame(&self) -> ItemOnFrame {
                                    let target: Item = self.into();
                                    Item::on_frame(&target)
                                }
                                fn set_on_frame(&mut self, value: ItemOnFrame) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_frame(&mut target, value)
                                }
                                fn on_mouse_down(&self) -> ItemOnMouseDown {
                                    let target: Item = self.into();
                                    Item::on_mouse_down(&target)
                                }
                                fn set_on_mouse_down(&mut self, value: ItemOnMouseDown) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_down(&mut target, value)
                                }
                                fn is_sibling(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_sibling(&target, item)
                                }
                                fn local_to_global(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::local_to_global(&target, point)
                                }
                                fn first_child(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::first_child(&target)
                                }
                                fn set_first_child(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_first_child(&mut target, value)
                                }
                                fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::send_to_back(&target)
                                }
                                fn clip_mask(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::clip_mask(&target)
                                }
                                fn set_clip_mask(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_clip_mask(&mut target, value)
                                }
                                fn next_sibling(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::next_sibling(&target)
                                }
                                fn set_next_sibling(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_next_sibling(&mut target, value)
                                }
                                fn off(
                                    &self,
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::off(&target, object)
                                }
                                fn rotate(
                                    &self,
                                    angle: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::rotate(&target, angle, center)
                                }
                                fn add_child(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::add_child(&target, item)
                                }
                                fn is_grouped_with(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_grouped_with(&target, item)
                                }
                                fn scale(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::scale(&target, hor, ver, center)
                                }
                                fn hit_test_all(
                                    &self,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Vec<HitResult>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::hit_test_all(&target, point, options)
                                }
                                fn insert_children(
                                    &self,
                                    index: f64,
                                    items: Vec<Item>,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_children(&target, index, items)
                                }
                                fn style(&self) -> Style {
                                    let target: Item = self.into();
                                    Item::style(&target)
                                }
                                fn set_style(&mut self, value: Style) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_style(&mut target, value)
                                }
                                fn position(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::position(&target)
                                }
                                fn set_position(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_position(&mut target, value)
                                }
                                fn transform(
                                    &self,
                                    matrix: Matrix,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::transform(&target, matrix)
                                }
                                fn fill_color(&self) -> ItemFillColor {
                                    let target: Item = self.into();
                                    Item::fill_color(&target)
                                }
                                fn set_fill_color(&mut self, value: ItemFillColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_fill_color(&mut target, value)
                                }
                                fn matrix(&self) -> Matrix {
                                    let target: Item = self.into();
                                    Item::matrix(&target)
                                }
                                fn set_matrix(&mut self, value: Matrix) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_matrix(&mut target, value)
                                }
                                fn id(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::id(&target)
                                }
                                fn set_id(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_id(&mut target, value)
                                }
                                fn tween(
                                    &self,
                                    options: ItemTweenParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::tween(&target, options)
                                }
                                fn reduce(
                                    &self,
                                    options: JsValue,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::reduce(&target, options)
                                }
                                fn internal_bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::internal_bounds(&target)
                                }
                                fn set_internal_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_internal_bounds(&mut target, value)
                                }
                                fn fill_rule(&self) -> String {
                                    let target: Item = self.into();
                                    Item::fill_rule(&target)
                                }
                                fn set_fill_rule(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_fill_rule(&mut target, value)
                                }
                                fn shadow_color(&self) -> ItemShadowColor {
                                    let target: Item = self.into();
                                    Item::shadow_color(&target)
                                }
                                fn set_shadow_color(&mut self, value: ItemShadowColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_shadow_color(&mut target, value)
                                }
                                fn insert_above(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_above(&target, item)
                                }
                                fn responds(
                                    &self,
                                    type_: String,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::responds(&target, type_)
                                }
                                fn handle_bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::handle_bounds(&target)
                                }
                                fn set_handle_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_handle_bounds(&mut target, value)
                                }
                                fn skew(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::skew(&target, hor, ver, center)
                                }
                                fn on_click(&self) -> ItemOnClick {
                                    let target: Item = self.into();
                                    Item::on_click(&target)
                                }
                                fn set_on_click(&mut self, value: ItemOnClick) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_click(&mut target, value)
                                }
                                fn get_items(
                                    &self,
                                    options: ItemGetItemsParamsOptionsParam,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::get_items(&target, options)
                                }
                                fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::is_inserted(&target)
                                }
                                fn get_item(
                                    &self,
                                    options: ItemGetItemParamsOptionsParam,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::get_item(&target, options)
                                }
                                fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_fill(&target)
                                }
                                fn shear(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::shear(&target, hor, ver, center)
                                }
                                fn visible(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::visible(&target)
                                }
                                fn set_visible(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_visible(&mut target, value)
                                }
                                fn previous_sibling(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::previous_sibling(&target)
                                }
                                fn set_previous_sibling(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_previous_sibling(&mut target, value)
                                }
                                fn hit_test(
                                    &self,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<HitResult, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::hit_test(&target, point, options)
                                }
                                fn is_descendant(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_descendant(&target, item)
                                }
                                fn locked(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::locked(&target)
                                }
                                fn set_locked(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_locked(&mut target, value)
                                }
                                fn is_parent(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_parent(&target, item)
                                }
                                fn copy_attributes(
                                    &self,
                                    source: Item,
                                    exclude_matrix: bool,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::copy_attributes(&target, source, exclude_matrix)
                                }
                                fn last_child(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::last_child(&target)
                                }
                                fn set_last_child(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_last_child(&mut target, value)
                                }
                                fn stroke_width(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::stroke_width(&target)
                                }
                                fn set_stroke_width(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_width(&mut target, value)
                                }
                                fn parent(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::parent(&target)
                                }
                                fn set_parent(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_parent(&mut target, value)
                                }
                                fn stroke_bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::stroke_bounds(&target)
                                }
                                fn set_stroke_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_bounds(&mut target, value)
                                }
                                fn translate(
                                    &self,
                                    delta: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::translate(&target, delta)
                                }
                                fn remove(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::remove(&target)
                                }
                                fn parent_to_local(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::parent_to_local(&target, point)
                                }
                                fn bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::bounds(&target)
                                }
                                fn set_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_bounds(&mut target, value)
                                }
                                fn add_children(
                                    &self,
                                    items: Vec<Item>,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::add_children(&target, items)
                                }
                                fn dash_array(&self) -> Vec<f64> {
                                    let target: Item = self.into();
                                    Item::dash_array(&target)
                                }
                                fn set_dash_array(&mut self, value: Vec<f64>) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_dash_array(&mut target, value)
                                }
                                fn on_mouse_up(&self) -> ItemOnMouseUp {
                                    let target: Item = self.into();
                                    Item::on_mouse_up(&target)
                                }
                                fn set_on_mouse_up(&mut self, value: ItemOnMouseUp) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_up(&mut target, value)
                                }
                                fn on(
                                    &self,
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::on(&target, object)
                                }
                                fn remove_on(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::remove_on(&target, options)
                                }
                                fn is_below(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_below(&target, item)
                                }
                                fn apply_matrix(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::apply_matrix(&target)
                                }
                                fn set_apply_matrix(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_apply_matrix(&mut target, value)
                                }
                                fn clone(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::clone(&target, options)
                                }
                                fn contains(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::contains(&target, point)
                                }
                                fn export_json(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<String, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::export_json(&target, options)
                                }
                                fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::bring_to_front(&target)
                                }
                                fn is_above(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_above(&target, item)
                                }
                                fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_drag(&target)
                                }
                                fn data(&self) -> JsValue {
                                    let target: Item = self.into();
                                    Item::data(&target)
                                }
                                fn set_data(&mut self, value: JsValue) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_data(&mut target, value)
                                }
                                fn import_svg(
                                    &self,
                                    svg: ItemImportSvgParamsSvgParam,
                                    on_load: JsValue,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::import_svg(&target, svg, on_load)
                                }
                                fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_shadow(&target)
                                }
                                fn selected_color(&self) -> ItemSelectedColor {
                                    let target: Item = self.into();
                                    Item::selected_color(&target)
                                }
                                fn set_selected_color(&mut self, value: ItemSelectedColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_selected_color(&mut target, value)
                                }
                                fn class_name(&self) -> String {
                                    let target: Item = self.into();
                                    Item::class_name(&target)
                                }
                                fn set_class_name(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_class_name(&mut target, value)
                                }
                                fn export_svg(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<ItemExportSvgReturn, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::export_svg(&target, options)
                                }
                                fn tween_to(
                                    &self,
                                    to: std::collections::HashMap<String, JsValue>,
                                    options: ItemTweenToParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::tween_to(&target, to, options)
                                }
                                fn is_inside(
                                    &self,
                                    rect: Rectangle,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_inside(&target, rect)
                                }
                                fn is_empty(
                                    &self,
                                    recursively: bool,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_empty(&target, recursively)
                                }
                                fn copy_content(
                                    &self,
                                    source: Item,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::copy_content(&target, source)
                                }
                                fn rasterize(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Raster, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::rasterize(&target, options)
                                }
                                fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_move(&target)
                                }
                                fn tween_from(
                                    &self,
                                    from: std::collections::HashMap<String, JsValue>,
                                    options: ItemTweenFromParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::tween_from(&target, from, options)
                                }
                                fn opacity(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::opacity(&target)
                                }
                                fn set_opacity(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_opacity(&mut target, value)
                                }
                                fn dash_offset(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::dash_offset(&target)
                                }
                                fn set_dash_offset(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_dash_offset(&mut target, value)
                                }
                                fn remove_children(
                                    &self,
                                    start: f64,
                                    end: f64,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::remove_children(&target, start, end)
                                }
                                fn on_mouse_move(&self) -> ItemOnMouseMove {
                                    let target: Item = self.into();
                                    Item::on_mouse_move(&target)
                                }
                                fn set_on_mouse_move(&mut self, value: ItemOnMouseMove) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_move(&mut target, value)
                                }
                                fn intersects(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::intersects(&target, item)
                                }
                                fn pivot(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::pivot(&target)
                                }
                                fn set_pivot(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_pivot(&mut target, value)
                                }
                                fn copy_to(
                                    &self,
                                    owner: ItemCopyToParamsOwnerParam,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::copy_to(&target, owner)
                                }
                                fn index(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::index(&target)
                                }
                                fn set_index(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_index(&mut target, value)
                                }
                                fn local_to_parent(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::local_to_parent(&target, point)
                                }
                                fn stroke_color(&self) -> ItemStrokeColor {
                                    let target: Item = self.into();
                                    Item::stroke_color(&target)
                                }
                                fn set_stroke_color(&mut self, value: ItemStrokeColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_color(&mut target, value)
                                }
                                fn layer(&self) -> Layer {
                                    let target: Item = self.into();
                                    Item::layer(&target)
                                }
                                fn set_layer(&mut self, value: Layer) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_layer(&mut target, value)
                                }
                                fn stroke_scaling(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::stroke_scaling(&target)
                                }
                                fn set_stroke_scaling(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_scaling(&mut target, value)
                                }
                                fn fit_bounds(
                                    &self,
                                    rectangle: Rectangle,
                                    fill: bool,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::fit_bounds(&target, rectangle, fill)
                                }
                                fn miter_limit(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::miter_limit(&target)
                                }
                                fn set_miter_limit(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_miter_limit(&mut target, value)
                                }
                                fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_down(&target)
                                }
                            }
                            impl Shape_Trait for Shape {}
                            impl std::clone::Clone for Shape_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for Shape_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Shape_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                # [wasm_bindgen (js_name = "SymbolItem" , extends = Item_Class)]
                                type SymbolItem_Class;
                                # [wasm_bindgen (method , structural , getter = definition , js_class = "SymbolItem")]
                                fn definition(this: &SymbolItem_Class) -> SymbolDefinition;
                                # [wasm_bindgen (method , structural , setter = definition , js_class = "SymbolItem")]
                                fn set_definition(this: &SymbolItem_Class, value: SymbolDefinition);
                                #[wasm_bindgen(constructor, js_class = "SymbolItem")]
                                pub fn new(
                                    definition: SymbolItemConstructorDefinitionParam,
                                    point: Point,
                                ) -> SymbolItem_Class;
                            }
                            #[derive(std :: clone :: Clone)]
                            struct SymbolItem(pub SymbolItem_Class);
                            impl std::convert::From<&SymbolItem> for Item {
                                fn from(src: &SymbolItem) -> Item {
                                    let src: &Item_Class = src.0.as_ref();
                                    Item(src.clone())
                                }
                            }
                            impl std::convert::From<&mut SymbolItem> for Item {
                                fn from(src: &mut SymbolItem) -> Item {
                                    let src: &Item_Class = src.0.as_ref();
                                    Item(src.clone())
                                }
                            }
                            impl SymbolItem {
                                #[allow(dead_code)]
                                pub fn definition(&self) -> SymbolDefinition {
                                    let result = self.0.definition();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_definition(&self, value: SymbolDefinition) -> () {
                                    let result = self.0.set_definition(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn new(
                                    definition: SymbolItemConstructorDefinitionParam,
                                    point: Point,
                                ) -> SymbolItem {
                                    let result = SymbolItem_Class::new(
                                        ts_bindgen_rt::to_jsvalue(&definition)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                        point,
                                    );
                                    let result =
                                        ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result)
                                            .unwrap();
                                    SymbolItem(result)
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for SymbolItem {
                                fn describe() {
                                    < SymbolItem_Class as wasm_bindgen :: describe :: WasmDescribe > :: describe ()
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for SymbolItem {
                                type Abi =
                                    <SymbolItem_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a SymbolItem {
                                type Abi = < & 'a SymbolItem_Class as wasm_bindgen :: convert :: IntoWasmAbi > :: Abi ;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for SymbolItem {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for SymbolItem {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal: SymbolItem_Class =
                                        <SymbolItem_Class as serde::de::Deserialize>::deserialize(
                                            deserializer,
                                        )?;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait SymbolItem_Trait: Item_Trait {
                                fn definition(&self) -> SymbolDefinition;
                                fn set_definition(&mut self, value: SymbolDefinition) -> ();
                                fn new(
                                    definition: SymbolItemConstructorDefinitionParam,
                                    point: Point,
                                ) -> SymbolItem;
                            }
                            impl Item_Trait for SymbolItem {
                                fn insert_below(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_below(&target, item)
                                }
                                fn on_double_click(&self) -> ItemOnDoubleClick {
                                    let target: Item = self.into();
                                    Item::on_double_click(&target)
                                }
                                fn set_on_double_click(&mut self, value: ItemOnDoubleClick) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_double_click(&mut target, value)
                                }
                                fn view(&self) -> View {
                                    let target: Item = self.into();
                                    Item::view(&target)
                                }
                                fn set_view(&mut self, value: View) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_view(&mut target, value)
                                }
                                fn blend_mode(&self) -> String {
                                    let target: Item = self.into();
                                    Item::blend_mode(&target)
                                }
                                fn set_blend_mode(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_blend_mode(&mut target, value)
                                }
                                fn name(&self) -> String {
                                    let target: Item = self.into();
                                    Item::name(&target)
                                }
                                fn set_name(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_name(&mut target, value)
                                }
                                fn project(&self) -> Project {
                                    let target: Item = self.into();
                                    Item::project(&target)
                                }
                                fn set_project(&mut self, value: Project) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_project(&mut target, value)
                                }
                                fn is_child(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_child(&target, item)
                                }
                                fn global_matrix(&self) -> Matrix {
                                    let target: Item = self.into();
                                    Item::global_matrix(&target)
                                }
                                fn set_global_matrix(&mut self, value: Matrix) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_global_matrix(&mut target, value)
                                }
                                fn on_mouse_leave(&self) -> ItemOnMouseLeave {
                                    let target: Item = self.into();
                                    Item::on_mouse_leave(&target)
                                }
                                fn set_on_mouse_leave(&mut self, value: ItemOnMouseLeave) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_leave(&mut target, value)
                                }
                                fn has_children(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_children(&target)
                                }
                                fn selected(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::selected(&target)
                                }
                                fn set_selected(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_selected(&mut target, value)
                                }
                                fn global_to_local(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::global_to_local(&target, point)
                                }
                                fn shadow_blur(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::shadow_blur(&target)
                                }
                                fn set_shadow_blur(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_shadow_blur(&mut target, value)
                                }
                                fn children(&self) -> Vec<Item> {
                                    let target: Item = self.into();
                                    Item::children(&target)
                                }
                                fn set_children(&mut self, value: Vec<Item>) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_children(&mut target, value)
                                }
                                fn replace_with(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::replace_with(&target, item)
                                }
                                fn import_json(
                                    &self,
                                    json: String,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::import_json(&target, json)
                                }
                                fn insert_child(
                                    &self,
                                    index: f64,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_child(&target, index, item)
                                }
                                fn stroke_join(&self) -> String {
                                    let target: Item = self.into();
                                    Item::stroke_join(&target)
                                }
                                fn set_stroke_join(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_join(&mut target, value)
                                }
                                fn rotation(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::rotation(&target)
                                }
                                fn set_rotation(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_rotation(&mut target, value)
                                }
                                fn scaling(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::scaling(&target)
                                }
                                fn set_scaling(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_scaling(&mut target, value)
                                }
                                fn is_ancestor(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_ancestor(&target, item)
                                }
                                fn emit(
                                    &self,
                                    type_: String,
                                    event: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::emit(&target, type_, event)
                                }
                                fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_up(&target)
                                }
                                fn add_to(
                                    &self,
                                    owner: ItemAddToParamsOwnerParam,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::add_to(&target, owner)
                                }
                                fn stroke_cap(&self) -> String {
                                    let target: Item = self.into();
                                    Item::stroke_cap(&target)
                                }
                                fn set_stroke_cap(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_cap(&mut target, value)
                                }
                                fn on_mouse_drag(&self) -> ItemOnMouseDrag {
                                    let target: Item = self.into();
                                    Item::on_mouse_drag(&target)
                                }
                                fn set_on_mouse_drag(&mut self, value: ItemOnMouseDrag) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_drag(&mut target, value)
                                }
                                fn set(
                                    &self,
                                    props: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::set(&target, props)
                                }
                                fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::reverse_children(&target)
                                }
                                fn matches(
                                    &self,
                                    name: String,
                                    compare: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::matches(&target, name, compare)
                                }
                                fn on_mouse_enter(&self) -> ItemOnMouseEnter {
                                    let target: Item = self.into();
                                    Item::on_mouse_enter(&target)
                                }
                                fn set_on_mouse_enter(&mut self, value: ItemOnMouseEnter) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_enter(&mut target, value)
                                }
                                fn shadow_offset(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::shadow_offset(&target)
                                }
                                fn set_shadow_offset(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_shadow_offset(&mut target, value)
                                }
                                fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_stroke(&target)
                                }
                                fn view_matrix(&self) -> Matrix {
                                    let target: Item = self.into();
                                    Item::view_matrix(&target)
                                }
                                fn set_view_matrix(&mut self, value: Matrix) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_view_matrix(&mut target, value)
                                }
                                fn on_frame(&self) -> ItemOnFrame {
                                    let target: Item = self.into();
                                    Item::on_frame(&target)
                                }
                                fn set_on_frame(&mut self, value: ItemOnFrame) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_frame(&mut target, value)
                                }
                                fn on_mouse_down(&self) -> ItemOnMouseDown {
                                    let target: Item = self.into();
                                    Item::on_mouse_down(&target)
                                }
                                fn set_on_mouse_down(&mut self, value: ItemOnMouseDown) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_down(&mut target, value)
                                }
                                fn is_sibling(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_sibling(&target, item)
                                }
                                fn local_to_global(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::local_to_global(&target, point)
                                }
                                fn first_child(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::first_child(&target)
                                }
                                fn set_first_child(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_first_child(&mut target, value)
                                }
                                fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::send_to_back(&target)
                                }
                                fn clip_mask(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::clip_mask(&target)
                                }
                                fn set_clip_mask(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_clip_mask(&mut target, value)
                                }
                                fn next_sibling(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::next_sibling(&target)
                                }
                                fn set_next_sibling(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_next_sibling(&mut target, value)
                                }
                                fn off(
                                    &self,
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::off(&target, object)
                                }
                                fn rotate(
                                    &self,
                                    angle: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::rotate(&target, angle, center)
                                }
                                fn add_child(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::add_child(&target, item)
                                }
                                fn is_grouped_with(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_grouped_with(&target, item)
                                }
                                fn scale(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::scale(&target, hor, ver, center)
                                }
                                fn hit_test_all(
                                    &self,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Vec<HitResult>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::hit_test_all(&target, point, options)
                                }
                                fn insert_children(
                                    &self,
                                    index: f64,
                                    items: Vec<Item>,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_children(&target, index, items)
                                }
                                fn style(&self) -> Style {
                                    let target: Item = self.into();
                                    Item::style(&target)
                                }
                                fn set_style(&mut self, value: Style) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_style(&mut target, value)
                                }
                                fn position(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::position(&target)
                                }
                                fn set_position(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_position(&mut target, value)
                                }
                                fn transform(
                                    &self,
                                    matrix: Matrix,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::transform(&target, matrix)
                                }
                                fn fill_color(&self) -> ItemFillColor {
                                    let target: Item = self.into();
                                    Item::fill_color(&target)
                                }
                                fn set_fill_color(&mut self, value: ItemFillColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_fill_color(&mut target, value)
                                }
                                fn matrix(&self) -> Matrix {
                                    let target: Item = self.into();
                                    Item::matrix(&target)
                                }
                                fn set_matrix(&mut self, value: Matrix) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_matrix(&mut target, value)
                                }
                                fn id(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::id(&target)
                                }
                                fn set_id(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_id(&mut target, value)
                                }
                                fn tween(
                                    &self,
                                    options: ItemTweenParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::tween(&target, options)
                                }
                                fn reduce(
                                    &self,
                                    options: JsValue,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::reduce(&target, options)
                                }
                                fn internal_bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::internal_bounds(&target)
                                }
                                fn set_internal_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_internal_bounds(&mut target, value)
                                }
                                fn fill_rule(&self) -> String {
                                    let target: Item = self.into();
                                    Item::fill_rule(&target)
                                }
                                fn set_fill_rule(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_fill_rule(&mut target, value)
                                }
                                fn shadow_color(&self) -> ItemShadowColor {
                                    let target: Item = self.into();
                                    Item::shadow_color(&target)
                                }
                                fn set_shadow_color(&mut self, value: ItemShadowColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_shadow_color(&mut target, value)
                                }
                                fn insert_above(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::insert_above(&target, item)
                                }
                                fn responds(
                                    &self,
                                    type_: String,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::responds(&target, type_)
                                }
                                fn handle_bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::handle_bounds(&target)
                                }
                                fn set_handle_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_handle_bounds(&mut target, value)
                                }
                                fn skew(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::skew(&target, hor, ver, center)
                                }
                                fn on_click(&self) -> ItemOnClick {
                                    let target: Item = self.into();
                                    Item::on_click(&target)
                                }
                                fn set_on_click(&mut self, value: ItemOnClick) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_click(&mut target, value)
                                }
                                fn get_items(
                                    &self,
                                    options: ItemGetItemsParamsOptionsParam,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::get_items(&target, options)
                                }
                                fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::is_inserted(&target)
                                }
                                fn get_item(
                                    &self,
                                    options: ItemGetItemParamsOptionsParam,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::get_item(&target, options)
                                }
                                fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_fill(&target)
                                }
                                fn shear(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::shear(&target, hor, ver, center)
                                }
                                fn visible(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::visible(&target)
                                }
                                fn set_visible(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_visible(&mut target, value)
                                }
                                fn previous_sibling(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::previous_sibling(&target)
                                }
                                fn set_previous_sibling(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_previous_sibling(&mut target, value)
                                }
                                fn hit_test(
                                    &self,
                                    point: Point,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<HitResult, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::hit_test(&target, point, options)
                                }
                                fn is_descendant(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_descendant(&target, item)
                                }
                                fn locked(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::locked(&target)
                                }
                                fn set_locked(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_locked(&mut target, value)
                                }
                                fn is_parent(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_parent(&target, item)
                                }
                                fn copy_attributes(
                                    &self,
                                    source: Item,
                                    exclude_matrix: bool,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::copy_attributes(&target, source, exclude_matrix)
                                }
                                fn last_child(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::last_child(&target)
                                }
                                fn set_last_child(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_last_child(&mut target, value)
                                }
                                fn stroke_width(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::stroke_width(&target)
                                }
                                fn set_stroke_width(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_width(&mut target, value)
                                }
                                fn parent(&self) -> Item {
                                    let target: Item = self.into();
                                    Item::parent(&target)
                                }
                                fn set_parent(&mut self, value: Item) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_parent(&mut target, value)
                                }
                                fn stroke_bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::stroke_bounds(&target)
                                }
                                fn set_stroke_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_bounds(&mut target, value)
                                }
                                fn translate(
                                    &self,
                                    delta: Point,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::translate(&target, delta)
                                }
                                fn remove(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::remove(&target)
                                }
                                fn parent_to_local(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::parent_to_local(&target, point)
                                }
                                fn bounds(&self) -> Rectangle {
                                    let target: Item = self.into();
                                    Item::bounds(&target)
                                }
                                fn set_bounds(&mut self, value: Rectangle) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_bounds(&mut target, value)
                                }
                                fn add_children(
                                    &self,
                                    items: Vec<Item>,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::add_children(&target, items)
                                }
                                fn dash_array(&self) -> Vec<f64> {
                                    let target: Item = self.into();
                                    Item::dash_array(&target)
                                }
                                fn set_dash_array(&mut self, value: Vec<f64>) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_dash_array(&mut target, value)
                                }
                                fn on_mouse_up(&self) -> ItemOnMouseUp {
                                    let target: Item = self.into();
                                    Item::on_mouse_up(&target)
                                }
                                fn set_on_mouse_up(&mut self, value: ItemOnMouseUp) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_up(&mut target, value)
                                }
                                fn on(
                                    &self,
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::on(&target, object)
                                }
                                fn remove_on(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::remove_on(&target, options)
                                }
                                fn is_below(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_below(&target, item)
                                }
                                fn apply_matrix(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::apply_matrix(&target)
                                }
                                fn set_apply_matrix(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_apply_matrix(&mut target, value)
                                }
                                fn clone(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::clone(&target, options)
                                }
                                fn contains(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::contains(&target, point)
                                }
                                fn export_json(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<String, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::export_json(&target, options)
                                }
                                fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::bring_to_front(&target)
                                }
                                fn is_above(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_above(&target, item)
                                }
                                fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_drag(&target)
                                }
                                fn data(&self) -> JsValue {
                                    let target: Item = self.into();
                                    Item::data(&target)
                                }
                                fn set_data(&mut self, value: JsValue) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_data(&mut target, value)
                                }
                                fn import_svg(
                                    &self,
                                    svg: ItemImportSvgParamsSvgParam,
                                    on_load: JsValue,
                                ) -> std::result::Result<Item, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::import_svg(&target, svg, on_load)
                                }
                                fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                                    let target: Item = self.into();
                                    Item::has_shadow(&target)
                                }
                                fn selected_color(&self) -> ItemSelectedColor {
                                    let target: Item = self.into();
                                    Item::selected_color(&target)
                                }
                                fn set_selected_color(&mut self, value: ItemSelectedColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_selected_color(&mut target, value)
                                }
                                fn class_name(&self) -> String {
                                    let target: Item = self.into();
                                    Item::class_name(&target)
                                }
                                fn set_class_name(&mut self, value: String) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_class_name(&mut target, value)
                                }
                                fn export_svg(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<ItemExportSvgReturn, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::export_svg(&target, options)
                                }
                                fn tween_to(
                                    &self,
                                    to: std::collections::HashMap<String, JsValue>,
                                    options: ItemTweenToParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::tween_to(&target, to, options)
                                }
                                fn is_inside(
                                    &self,
                                    rect: Rectangle,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_inside(&target, rect)
                                }
                                fn is_empty(
                                    &self,
                                    recursively: bool,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::is_empty(&target, recursively)
                                }
                                fn copy_content(
                                    &self,
                                    source: Item,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::copy_content(&target, source)
                                }
                                fn rasterize(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<Raster, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::rasterize(&target, options)
                                }
                                fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_move(&target)
                                }
                                fn tween_from(
                                    &self,
                                    from: std::collections::HashMap<String, JsValue>,
                                    options: ItemTweenFromParamsOptionsParam,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::tween_from(&target, from, options)
                                }
                                fn opacity(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::opacity(&target)
                                }
                                fn set_opacity(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_opacity(&mut target, value)
                                }
                                fn dash_offset(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::dash_offset(&target)
                                }
                                fn set_dash_offset(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_dash_offset(&mut target, value)
                                }
                                fn remove_children(
                                    &self,
                                    start: f64,
                                    end: f64,
                                ) -> std::result::Result<Vec<Item>, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::remove_children(&target, start, end)
                                }
                                fn on_mouse_move(&self) -> ItemOnMouseMove {
                                    let target: Item = self.into();
                                    Item::on_mouse_move(&target)
                                }
                                fn set_on_mouse_move(&mut self, value: ItemOnMouseMove) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_on_mouse_move(&mut target, value)
                                }
                                fn intersects(
                                    &self,
                                    item: Item,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::intersects(&target, item)
                                }
                                fn pivot(&self) -> Point {
                                    let target: Item = self.into();
                                    Item::pivot(&target)
                                }
                                fn set_pivot(&mut self, value: Point) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_pivot(&mut target, value)
                                }
                                fn copy_to(
                                    &self,
                                    owner: ItemCopyToParamsOwnerParam,
                                ) -> std::result::Result<JsValue, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::copy_to(&target, owner)
                                }
                                fn index(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::index(&target)
                                }
                                fn set_index(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_index(&mut target, value)
                                }
                                fn local_to_parent(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::local_to_parent(&target, point)
                                }
                                fn stroke_color(&self) -> ItemStrokeColor {
                                    let target: Item = self.into();
                                    Item::stroke_color(&target)
                                }
                                fn set_stroke_color(&mut self, value: ItemStrokeColor) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_color(&mut target, value)
                                }
                                fn layer(&self) -> Layer {
                                    let target: Item = self.into();
                                    Item::layer(&target)
                                }
                                fn set_layer(&mut self, value: Layer) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_layer(&mut target, value)
                                }
                                fn stroke_scaling(&self) -> bool {
                                    let target: Item = self.into();
                                    Item::stroke_scaling(&target)
                                }
                                fn set_stroke_scaling(&mut self, value: bool) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_stroke_scaling(&mut target, value)
                                }
                                fn fit_bounds(
                                    &self,
                                    rectangle: Rectangle,
                                    fill: bool,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let target: Item = self.into();
                                    Item::fit_bounds(&target, rectangle, fill)
                                }
                                fn miter_limit(&self) -> f64 {
                                    let target: Item = self.into();
                                    Item::miter_limit(&target)
                                }
                                fn set_miter_limit(&mut self, value: f64) -> () {
                                    let mut target: Item = self.into();
                                    Item::set_miter_limit(&mut target, value)
                                }
                                fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                                    let target: Item = self.into();
                                    Item::remove_on_down(&target)
                                }
                            }
                            impl SymbolItem_Trait for SymbolItem {}
                            impl std::clone::Clone for SymbolItem_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for SymbolItem_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for SymbolItem_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                #[wasm_bindgen(js_name = "Matrix")]
                                type Matrix_Class;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = appended , method , js_class = "Matrix" , catch)]
                                fn __TSB_appended(
                                    this: &Matrix_Class,
                                    matrix: Matrix,
                                ) -> std::result::Result<Matrix, JsValue>;
                                # [wasm_bindgen (method , structural , getter = values , js_class = "Matrix")]
                                fn values(this: &Matrix_Class) -> Vec<f64>;
                                # [wasm_bindgen (method , structural , setter = values , js_class = "Matrix")]
                                fn set_values(this: &Matrix_Class, value: Vec<f64>);
                                # [wasm_bindgen (method , structural , getter = translation , js_class = "Matrix")]
                                fn translation(this: &Matrix_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = translation , js_class = "Matrix")]
                                fn set_translation(this: &Matrix_Class, value: Point);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = decompose , method , js_class = "Matrix" , catch)]
                                fn __TSB_decompose(
                                    this: &Matrix_Class,
                                ) -> std::result::Result<
                                    std::collections::HashMap<String, JsValue>,
                                    JsValue,
                                >;
                                # [wasm_bindgen (method , structural , getter = ty , js_class = "Matrix")]
                                fn ty(this: &Matrix_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = ty , js_class = "Matrix")]
                                fn set_ty(this: &Matrix_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = clone , method , js_class = "Matrix" , catch)]
                                fn __TSB_clone(
                                    this: &Matrix_Class,
                                ) -> std::result::Result<Matrix, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isInvertible , method , js_class = "Matrix" , catch)]
                                fn __TSB_is_invertible(
                                    this: &Matrix_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isSingular , method , js_class = "Matrix" , catch)]
                                fn __TSB_is_singular(
                                    this: &Matrix_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                # [wasm_bindgen (method , structural , getter = b , js_class = "Matrix")]
                                fn b(this: &Matrix_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = b , js_class = "Matrix")]
                                fn set_b(this: &Matrix_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = append , method , js_class = "Matrix" , catch)]
                                fn __TSB_append(
                                    this: &Matrix_Class,
                                    matrix: Matrix,
                                ) -> std::result::Result<Matrix, JsValue>;
                                # [wasm_bindgen (method , structural , getter = c , js_class = "Matrix")]
                                fn c(this: &Matrix_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = c , js_class = "Matrix")]
                                fn set_c(this: &Matrix_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = transform , method , js_class = "Matrix" , catch)]
                                fn __TSB_transform(
                                    this: &Matrix_Class,
                                    src: Vec<f64>,
                                    dst: Vec<f64>,
                                    count: f64,
                                ) -> std::result::Result<Vec<f64>, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = invert , method , js_class = "Matrix" , catch)]
                                fn __TSB_invert(
                                    this: &Matrix_Class,
                                ) -> std::result::Result<Matrix, JsValue>;
                                #[wasm_bindgen(constructor, js_class = "Matrix")]
                                pub fn new(matrix: Matrix) -> Matrix_Class;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = rotate , method , js_class = "Matrix" , catch)]
                                fn __TSB_rotate(
                                    this: &Matrix_Class,
                                    angle: f64,
                                    x: f64,
                                    y: f64,
                                ) -> std::result::Result<Matrix, JsValue>;
                                # [wasm_bindgen (method , structural , getter = d , js_class = "Matrix")]
                                fn d(this: &Matrix_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = d , js_class = "Matrix")]
                                fn set_d(this: &Matrix_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = translate , method , js_class = "Matrix" , catch)]
                                fn __TSB_translate(
                                    this: &Matrix_Class,
                                    dx: f64,
                                    dy: f64,
                                ) -> std::result::Result<Matrix, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = inverted , method , js_class = "Matrix" , catch)]
                                fn __TSB_inverted(
                                    this: &Matrix_Class,
                                ) -> std::result::Result<Matrix, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = applyToContext , method , js_class = "Matrix" , catch)]
                                fn __TSB_apply_to_context(
                                    this: &Matrix_Class,
                                    ctx: JsValue,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = scale , method , js_class = "Matrix" , catch)]
                                fn __TSB_scale(
                                    this: &Matrix_Class,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<Matrix, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = skew , method , js_class = "Matrix" , catch)]
                                fn __TSB_skew(
                                    this: &Matrix_Class,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<Matrix, JsValue>;
                                # [wasm_bindgen (method , structural , getter = scaling , js_class = "Matrix")]
                                fn scaling(this: &Matrix_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = scaling , js_class = "Matrix")]
                                fn set_scaling(this: &Matrix_Class, value: Point);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = prepend , method , js_class = "Matrix" , catch)]
                                fn __TSB_prepend(
                                    this: &Matrix_Class,
                                    matrix: Matrix,
                                ) -> std::result::Result<Matrix, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isIdentity , method , js_class = "Matrix" , catch)]
                                fn __TSB_is_identity(
                                    this: &Matrix_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = toString , method , js_class = "Matrix" , catch)]
                                fn __TSB_to_string(
                                    this: &Matrix_Class,
                                ) -> std::result::Result<String, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = set , method , js_class = "Matrix" , catch , variadic)]
                                fn __TSB_set(
                                    this: &Matrix_Class,
                                    values: &[JsValue],
                                ) -> std::result::Result<Point, JsValue>;
                                # [wasm_bindgen (method , structural , getter = rotation , js_class = "Matrix")]
                                fn rotation(this: &Matrix_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = rotation , js_class = "Matrix")]
                                fn set_rotation(this: &Matrix_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = tx , js_class = "Matrix")]
                                fn tx(this: &Matrix_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = tx , js_class = "Matrix")]
                                fn set_tx(this: &Matrix_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = reset , method , js_class = "Matrix" , catch)]
                                fn __TSB_reset(
                                    this: &Matrix_Class,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = equals , method , js_class = "Matrix" , catch)]
                                fn __TSB_equals(
                                    this: &Matrix_Class,
                                    matrix: Matrix,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = inverseTransform , method , js_class = "Matrix" , catch)]
                                fn __TSB_inverse_transform(
                                    this: &Matrix_Class,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = apply , method , js_class = "Matrix" , catch)]
                                fn __TSB_apply(
                                    this: &Matrix_Class,
                                    recursively: bool,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = prepended , method , js_class = "Matrix" , catch)]
                                fn __TSB_prepended(
                                    this: &Matrix_Class,
                                    matrix: Matrix,
                                ) -> std::result::Result<Matrix, JsValue>;
                                # [wasm_bindgen (method , structural , getter = a , js_class = "Matrix")]
                                fn a(this: &Matrix_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = a , js_class = "Matrix")]
                                fn set_a(this: &Matrix_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = shear , method , js_class = "Matrix" , catch)]
                                fn __TSB_shear(
                                    this: &Matrix_Class,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<Matrix, JsValue>;
                            }
                            #[derive(std :: clone :: Clone)]
                            struct Matrix(pub Matrix_Class);
                            impl Matrix {
                                #[allow(dead_code)]
                                pub fn appended(
                                    &self,
                                    matrix: Matrix,
                                ) -> std::result::Result<Matrix, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_appended(matrix)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn values(&self) -> Vec<f64> {
                                    let result = self.0.values();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_values(&self, value: Vec<f64>) -> () {
                                    let result = self.0.set_values(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn translation(&self) -> Point {
                                    let result = self.0.translation();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_translation(&self, value: Point) -> () {
                                    let result = self.0.set_translation(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn decompose(
                                    &self,
                                ) -> std::result::Result<
                                    std::collections::HashMap<String, JsValue>,
                                    JsValue,
                                > {
                                    let result = std::result::Result::Ok(self.0.__TSB_decompose()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn ty(&self) -> f64 {
                                    let result = self.0.ty();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_ty(&self, value: f64) -> () {
                                    let result = self.0.set_ty(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn clone(&self) -> std::result::Result<Matrix, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_clone()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_invertible(&self) -> std::result::Result<bool, JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_is_invertible()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_singular(&self) -> std::result::Result<bool, JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_is_singular()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn b(&self) -> f64 {
                                    let result = self.0.b();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_b(&self, value: f64) -> () {
                                    let result = self.0.set_b(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn append(
                                    &self,
                                    matrix: Matrix,
                                ) -> std::result::Result<Matrix, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_append(matrix)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn c(&self) -> f64 {
                                    let result = self.0.c();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_c(&self, value: f64) -> () {
                                    let result = self.0.set_c(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn transform(
                                    &self,
                                    src: Vec<f64>,
                                    dst: Vec<f64>,
                                    count: f64,
                                ) -> std::result::Result<Vec<f64>, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_transform(src, dst, count)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn invert(&self) -> std::result::Result<Matrix, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_invert()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn new(matrix: Matrix) -> Matrix {
                                    let result = Matrix_Class::new(matrix);
                                    let result =
                                        ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result)
                                            .unwrap();
                                    Matrix(result)
                                }
                                #[allow(dead_code)]
                                pub fn rotate(
                                    &self,
                                    angle: f64,
                                    x: f64,
                                    y: f64,
                                ) -> std::result::Result<Matrix, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_rotate(angle, x, y)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn d(&self) -> f64 {
                                    let result = self.0.d();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_d(&self, value: f64) -> () {
                                    let result = self.0.set_d(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn translate(
                                    &self,
                                    dx: f64,
                                    dy: f64,
                                ) -> std::result::Result<Matrix, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_translate(dx, dy)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn inverted(&self) -> std::result::Result<Matrix, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_inverted()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn apply_to_context(
                                    &self,
                                    ctx: JsValue,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_apply_to_context(ctx)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn scale(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<Matrix, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_scale(hor, ver, center)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn skew(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<Matrix, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_skew(hor, ver, center)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn scaling(&self) -> Point {
                                    let result = self.0.scaling();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_scaling(&self, value: Point) -> () {
                                    let result = self.0.set_scaling(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn prepend(
                                    &self,
                                    matrix: Matrix,
                                ) -> std::result::Result<Matrix, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_prepend(matrix)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_identity(&self) -> std::result::Result<bool, JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_is_identity()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_to_string()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set(
                                    &self,
                                    values: &[JsValue],
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result = std::result::Result::Ok(self.0.__TSB_set(values)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn rotation(&self) -> f64 {
                                    let result = self.0.rotation();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_rotation(&self, value: f64) -> () {
                                    let result = self.0.set_rotation(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn tx(&self) -> f64 {
                                    let result = self.0.tx();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_tx(&self, value: f64) -> () {
                                    let result = self.0.set_tx(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn reset(&self) -> std::result::Result<(), JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_reset()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn equals(
                                    &self,
                                    matrix: Matrix,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_equals(matrix)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn inverse_transform(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_inverse_transform(point)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn apply(
                                    &self,
                                    recursively: bool,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_apply(recursively)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn prepended(
                                    &self,
                                    matrix: Matrix,
                                ) -> std::result::Result<Matrix, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_prepended(matrix)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn a(&self) -> f64 {
                                    let result = self.0.a();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_a(&self, value: f64) -> () {
                                    let result = self.0.set_a(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn shear(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<Matrix, JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_shear(hor, ver, center)?,
                                    );
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for Matrix {
                                fn describe() {
                                    <Matrix_Class as wasm_bindgen::describe::WasmDescribe>::describe(
                                    )
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for Matrix {
                                type Abi =
                                    <Matrix_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Matrix {
                                type Abi =
                                    <&'a Matrix_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for Matrix {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Matrix {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal: Matrix_Class =
                                        <Matrix_Class as serde::de::Deserialize>::deserialize(
                                            deserializer,
                                        )?;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait Matrix_Trait {
                                fn appended(
                                    &self,
                                    matrix: Matrix,
                                ) -> std::result::Result<Matrix, JsValue>;
                                fn values(&self) -> Vec<f64>;
                                fn set_values(&mut self, value: Vec<f64>) -> ();
                                fn translation(&self) -> Point;
                                fn set_translation(&mut self, value: Point) -> ();
                                fn decompose(
                                    &self,
                                ) -> std::result::Result<
                                    std::collections::HashMap<String, JsValue>,
                                    JsValue,
                                >;
                                fn ty(&self) -> f64;
                                fn set_ty(&mut self, value: f64) -> ();
                                fn clone(&self) -> std::result::Result<Matrix, JsValue>;
                                fn is_invertible(&self) -> std::result::Result<bool, JsValue>;
                                fn is_singular(&self) -> std::result::Result<bool, JsValue>;
                                fn b(&self) -> f64;
                                fn set_b(&mut self, value: f64) -> ();
                                fn append(
                                    &self,
                                    matrix: Matrix,
                                ) -> std::result::Result<Matrix, JsValue>;
                                fn c(&self) -> f64;
                                fn set_c(&mut self, value: f64) -> ();
                                fn transform(
                                    &self,
                                    src: Vec<f64>,
                                    dst: Vec<f64>,
                                    count: f64,
                                ) -> std::result::Result<Vec<f64>, JsValue>;
                                fn invert(&self) -> std::result::Result<Matrix, JsValue>;
                                fn new(matrix: Matrix) -> Matrix;
                                fn rotate(
                                    &self,
                                    angle: f64,
                                    x: f64,
                                    y: f64,
                                ) -> std::result::Result<Matrix, JsValue>;
                                fn d(&self) -> f64;
                                fn set_d(&mut self, value: f64) -> ();
                                fn translate(
                                    &self,
                                    dx: f64,
                                    dy: f64,
                                ) -> std::result::Result<Matrix, JsValue>;
                                fn inverted(&self) -> std::result::Result<Matrix, JsValue>;
                                fn apply_to_context(
                                    &self,
                                    ctx: JsValue,
                                ) -> std::result::Result<(), JsValue>;
                                fn scale(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<Matrix, JsValue>;
                                fn skew(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<Matrix, JsValue>;
                                fn scaling(&self) -> Point;
                                fn set_scaling(&mut self, value: Point) -> ();
                                fn prepend(
                                    &self,
                                    matrix: Matrix,
                                ) -> std::result::Result<Matrix, JsValue>;
                                fn is_identity(&self) -> std::result::Result<bool, JsValue>;
                                fn to_string(&self) -> std::result::Result<String, JsValue>;
                                fn set(
                                    &self,
                                    values: &[JsValue],
                                ) -> std::result::Result<Point, JsValue>;
                                fn rotation(&self) -> f64;
                                fn set_rotation(&mut self, value: f64) -> ();
                                fn tx(&self) -> f64;
                                fn set_tx(&mut self, value: f64) -> ();
                                fn reset(&self) -> std::result::Result<(), JsValue>;
                                fn equals(
                                    &self,
                                    matrix: Matrix,
                                ) -> std::result::Result<bool, JsValue>;
                                fn inverse_transform(
                                    &self,
                                    point: Point,
                                ) -> std::result::Result<Point, JsValue>;
                                fn apply(
                                    &self,
                                    recursively: bool,
                                ) -> std::result::Result<bool, JsValue>;
                                fn prepended(
                                    &self,
                                    matrix: Matrix,
                                ) -> std::result::Result<Matrix, JsValue>;
                                fn a(&self) -> f64;
                                fn set_a(&mut self, value: f64) -> ();
                                fn shear(
                                    &self,
                                    hor: f64,
                                    ver: f64,
                                    center: Point,
                                ) -> std::result::Result<Matrix, JsValue>;
                            }
                            impl std::clone::Clone for Matrix_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for Matrix_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Matrix_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                #[wasm_bindgen(js_name = "SymbolDefinition")]
                                type SymbolDefinition_Class;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = clone , method , js_class = "SymbolDefinition" , catch)]
                                fn __TSB_clone(
                                    this: &SymbolDefinition_Class,
                                ) -> std::result::Result<SymbolDefinition, JsValue>;
                                #[wasm_bindgen(constructor, js_class = "SymbolDefinition")]
                                pub fn new(item: Item, dont_center: bool)
                                    -> SymbolDefinition_Class;
                                # [wasm_bindgen (method , structural , getter = item , js_class = "SymbolDefinition")]
                                fn item(this: &SymbolDefinition_Class) -> Item;
                                # [wasm_bindgen (method , structural , setter = item , js_class = "SymbolDefinition")]
                                fn set_item(this: &SymbolDefinition_Class, value: Item);
                                # [wasm_bindgen (method , structural , getter = project , js_class = "SymbolDefinition")]
                                fn project(this: &SymbolDefinition_Class) -> Project;
                                # [wasm_bindgen (method , structural , setter = project , js_class = "SymbolDefinition")]
                                fn set_project(this: &SymbolDefinition_Class, value: Project);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = equals , method , js_class = "SymbolDefinition" , catch)]
                                fn __TSB_equals(
                                    this: &SymbolDefinition_Class,
                                    symbol: SymbolDefinition,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = place , method , js_class = "SymbolDefinition" , catch)]
                                fn __TSB_place(
                                    this: &SymbolDefinition_Class,
                                    position: Point,
                                ) -> std::result::Result<SymbolItem, JsValue>;
                            }
                            #[derive(std :: clone :: Clone)]
                            struct SymbolDefinition(pub SymbolDefinition_Class);
                            impl SymbolDefinition {
                                #[allow(dead_code)]
                                pub fn clone(
                                    &self,
                                ) -> std::result::Result<SymbolDefinition, JsValue>
                                {
                                    let result = std::result::Result::Ok(self.0.__TSB_clone()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn new(item: Item, dont_center: bool) -> SymbolDefinition {
                                    let result = SymbolDefinition_Class::new(item, dont_center);
                                    let result =
                                        ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result)
                                            .unwrap();
                                    SymbolDefinition(result)
                                }
                                #[allow(dead_code)]
                                pub fn item(&self) -> Item {
                                    let result = self.0.item();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_item(&self, value: Item) -> () {
                                    let result = self.0.set_item(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn project(&self) -> Project {
                                    let result = self.0.project();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_project(&self, value: Project) -> () {
                                    let result = self.0.set_project(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn equals(
                                    &self,
                                    symbol: SymbolDefinition,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_equals(symbol)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn place(
                                    &self,
                                    position: Point,
                                ) -> std::result::Result<SymbolItem, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_place(position)?);
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for SymbolDefinition {
                                fn describe() {
                                    < SymbolDefinition_Class as wasm_bindgen :: describe :: WasmDescribe > :: describe ()
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for SymbolDefinition {
                                type Abi = < SymbolDefinition_Class as wasm_bindgen :: convert :: IntoWasmAbi > :: Abi ;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a SymbolDefinition {
                                type Abi = < & 'a SymbolDefinition_Class as wasm_bindgen :: convert :: IntoWasmAbi > :: Abi ;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for SymbolDefinition {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for SymbolDefinition {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal : SymbolDefinition_Class = < SymbolDefinition_Class as serde :: de :: Deserialize > :: deserialize (deserializer) ? ;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait SymbolDefinition_Trait {
                                fn clone(&self) -> std::result::Result<SymbolDefinition, JsValue>;
                                fn new(item: Item, dont_center: bool) -> SymbolDefinition;
                                fn item(&self) -> Item;
                                fn set_item(&mut self, value: Item) -> ();
                                fn project(&self) -> Project;
                                fn set_project(&mut self, value: Project) -> ();
                                fn equals(
                                    &self,
                                    symbol: SymbolDefinition,
                                ) -> std::result::Result<bool, JsValue>;
                                fn place(
                                    &self,
                                    position: Point,
                                ) -> std::result::Result<SymbolItem, JsValue>;
                            }
                            impl std::clone::Clone for SymbolDefinition_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for SymbolDefinition_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for SymbolDefinition_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                #[wasm_bindgen(js_name = "GradientStop")]
                                type GradientStop_Class;
                                # [wasm_bindgen (method , structural , getter = color , js_class = "GradientStop")]
                                fn color(this: &GradientStop_Class) -> Color;
                                # [wasm_bindgen (method , structural , setter = color , js_class = "GradientStop")]
                                fn set_color(this: &GradientStop_Class, value: Color);
                                # [wasm_bindgen (method , structural , getter = offset , js_class = "GradientStop")]
                                fn offset(this: &GradientStop_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = offset , js_class = "GradientStop")]
                                fn set_offset(this: &GradientStop_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = clone , method , js_class = "GradientStop" , catch)]
                                fn __TSB_clone(
                                    this: &GradientStop_Class,
                                ) -> std::result::Result<GradientStop, JsValue>;
                                #[wasm_bindgen(constructor, js_class = "GradientStop")]
                                pub fn new(color: Color, offset: f64) -> GradientStop_Class;
                            }
                            #[derive(std :: clone :: Clone)]
                            struct GradientStop(pub GradientStop_Class);
                            impl GradientStop {
                                #[allow(dead_code)]
                                pub fn color(&self) -> Color {
                                    let result = self.0.color();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_color(&self, value: Color) -> () {
                                    let result = self.0.set_color(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn offset(&self) -> f64 {
                                    let result = self.0.offset();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_offset(&self, value: f64) -> () {
                                    let result = self.0.set_offset(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn clone(&self) -> std::result::Result<GradientStop, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_clone()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn new(color: Color, offset: f64) -> GradientStop {
                                    let result = GradientStop_Class::new(color, offset);
                                    let result =
                                        ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result)
                                            .unwrap();
                                    GradientStop(result)
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for GradientStop {
                                fn describe() {
                                    < GradientStop_Class as wasm_bindgen :: describe :: WasmDescribe > :: describe ()
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for GradientStop {
                                type Abi =
                                    <GradientStop_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a GradientStop {
                                type Abi = < & 'a GradientStop_Class as wasm_bindgen :: convert :: IntoWasmAbi > :: Abi ;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for GradientStop {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for GradientStop {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal : GradientStop_Class = < GradientStop_Class as serde :: de :: Deserialize > :: deserialize (deserializer) ? ;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait GradientStop_Trait {
                                fn color(&self) -> Color;
                                fn set_color(&mut self, value: Color) -> ();
                                fn offset(&self) -> f64;
                                fn set_offset(&mut self, value: f64) -> ();
                                fn clone(&self) -> std::result::Result<GradientStop, JsValue>;
                                fn new(color: Color, offset: f64) -> GradientStop;
                            }
                            impl std::clone::Clone for GradientStop_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for GradientStop_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for GradientStop_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                #[wasm_bindgen(js_name = "Style")]
                                type Style_Class;
                                # [wasm_bindgen (method , structural , getter = strokeScaling , js_class = "Style")]
                                fn stroke_scaling(this: &Style_Class) -> bool;
                                # [wasm_bindgen (method , structural , setter = strokeScaling , js_class = "Style")]
                                fn set_stroke_scaling(this: &Style_Class, value: bool);
                                # [wasm_bindgen (method , structural , getter = strokeWidth , js_class = "Style")]
                                fn stroke_width(this: &Style_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = strokeWidth , js_class = "Style")]
                                fn set_stroke_width(this: &Style_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = dashOffset , js_class = "Style")]
                                fn dash_offset(this: &Style_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = dashOffset , js_class = "Style")]
                                fn set_dash_offset(this: &Style_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = shadowColor , js_class = "Style")]
                                fn shadow_color(this: &Style_Class) -> StyleShadowColor;
                                # [wasm_bindgen (method , structural , setter = shadowColor , js_class = "Style")]
                                fn set_shadow_color(this: &Style_Class, value: StyleShadowColor);
                                # [wasm_bindgen (method , structural , getter = fillColor , js_class = "Style")]
                                fn fill_color(this: &Style_Class) -> StyleFillColor;
                                # [wasm_bindgen (method , structural , setter = fillColor , js_class = "Style")]
                                fn set_fill_color(this: &Style_Class, value: StyleFillColor);
                                # [wasm_bindgen (method , structural , getter = dashArray , js_class = "Style")]
                                fn dash_array(this: &Style_Class) -> Vec<f64>;
                                # [wasm_bindgen (method , structural , setter = dashArray , js_class = "Style")]
                                fn set_dash_array(this: &Style_Class, value: Vec<f64>);
                                # [wasm_bindgen (method , structural , getter = strokeJoin , js_class = "Style")]
                                fn stroke_join(this: &Style_Class) -> String;
                                # [wasm_bindgen (method , structural , setter = strokeJoin , js_class = "Style")]
                                fn set_stroke_join(this: &Style_Class, value: String);
                                # [wasm_bindgen (method , structural , getter = leading , js_class = "Style")]
                                fn leading(this: &Style_Class) -> StyleLeading;
                                # [wasm_bindgen (method , structural , setter = leading , js_class = "Style")]
                                fn set_leading(this: &Style_Class, value: StyleLeading);
                                # [wasm_bindgen (method , structural , getter = fillRule , js_class = "Style")]
                                fn fill_rule(this: &Style_Class) -> String;
                                # [wasm_bindgen (method , structural , setter = fillRule , js_class = "Style")]
                                fn set_fill_rule(this: &Style_Class, value: String);
                                # [wasm_bindgen (method , structural , getter = fontSize , js_class = "Style")]
                                fn font_size(this: &Style_Class) -> StyleFontSize;
                                # [wasm_bindgen (method , structural , setter = fontSize , js_class = "Style")]
                                fn set_font_size(this: &Style_Class, value: StyleFontSize);
                                # [wasm_bindgen (method , structural , getter = strokeColor , js_class = "Style")]
                                fn stroke_color(this: &Style_Class) -> StyleStrokeColor;
                                # [wasm_bindgen (method , structural , setter = strokeColor , js_class = "Style")]
                                fn set_stroke_color(this: &Style_Class, value: StyleStrokeColor);
                                # [wasm_bindgen (method , structural , getter = shadowBlur , js_class = "Style")]
                                fn shadow_blur(this: &Style_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = shadowBlur , js_class = "Style")]
                                fn set_shadow_blur(this: &Style_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = justification , js_class = "Style")]
                                fn justification(this: &Style_Class) -> String;
                                # [wasm_bindgen (method , structural , setter = justification , js_class = "Style")]
                                fn set_justification(this: &Style_Class, value: String);
                                #[wasm_bindgen(constructor, js_class = "Style")]
                                pub fn new(
                                    style: std::collections::HashMap<String, JsValue>,
                                ) -> Style_Class;
                                # [wasm_bindgen (method , structural , getter = view , js_class = "Style")]
                                fn view(this: &Style_Class) -> View;
                                # [wasm_bindgen (method , structural , setter = view , js_class = "Style")]
                                fn set_view(this: &Style_Class, value: View);
                                # [wasm_bindgen (method , structural , getter = strokeCap , js_class = "Style")]
                                fn stroke_cap(this: &Style_Class) -> String;
                                # [wasm_bindgen (method , structural , setter = strokeCap , js_class = "Style")]
                                fn set_stroke_cap(this: &Style_Class, value: String);
                                # [wasm_bindgen (method , structural , getter = shadowOffset , js_class = "Style")]
                                fn shadow_offset(this: &Style_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = shadowOffset , js_class = "Style")]
                                fn set_shadow_offset(this: &Style_Class, value: Point);
                                # [wasm_bindgen (method , structural , getter = selectedColor , js_class = "Style")]
                                fn selected_color(this: &Style_Class) -> StyleSelectedColor;
                                # [wasm_bindgen (method , structural , setter = selectedColor , js_class = "Style")]
                                fn set_selected_color(
                                    this: &Style_Class,
                                    value: StyleSelectedColor,
                                );
                                # [wasm_bindgen (method , structural , getter = fontFamily , js_class = "Style")]
                                fn font_family(this: &Style_Class) -> String;
                                # [wasm_bindgen (method , structural , setter = fontFamily , js_class = "Style")]
                                fn set_font_family(this: &Style_Class, value: String);
                                # [wasm_bindgen (method , structural , getter = fontWeight , js_class = "Style")]
                                fn font_weight(this: &Style_Class) -> StyleFontWeight;
                                # [wasm_bindgen (method , structural , setter = fontWeight , js_class = "Style")]
                                fn set_font_weight(this: &Style_Class, value: StyleFontWeight);
                                # [wasm_bindgen (method , structural , getter = miterLimit , js_class = "Style")]
                                fn miter_limit(this: &Style_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = miterLimit , js_class = "Style")]
                                fn set_miter_limit(this: &Style_Class, value: f64);
                            }
                            #[derive(std :: clone :: Clone)]
                            struct Style(pub Style_Class);
                            impl Style {
                                #[allow(dead_code)]
                                pub fn stroke_scaling(&self) -> bool {
                                    let result = self.0.stroke_scaling();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_stroke_scaling(&self, value: bool) -> () {
                                    let result = self.0.set_stroke_scaling(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn stroke_width(&self) -> f64 {
                                    let result = self.0.stroke_width();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_stroke_width(&self, value: f64) -> () {
                                    let result = self.0.set_stroke_width(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn dash_offset(&self) -> f64 {
                                    let result = self.0.dash_offset();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_dash_offset(&self, value: f64) -> () {
                                    let result = self.0.set_dash_offset(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn shadow_color(&self) -> StyleShadowColor {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.shadow_color())
                                            .unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_shadow_color(&self, value: StyleShadowColor) -> () {
                                    let result = self.0.set_shadow_color(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn fill_color(&self) -> StyleFillColor {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.fill_color()).unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_fill_color(&self, value: StyleFillColor) -> () {
                                    let result = self.0.set_fill_color(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn dash_array(&self) -> Vec<f64> {
                                    let result = self.0.dash_array();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_dash_array(&self, value: Vec<f64>) -> () {
                                    let result = self.0.set_dash_array(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn stroke_join(&self) -> String {
                                    let result = self.0.stroke_join();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_stroke_join(&self, value: String) -> () {
                                    let result = self.0.set_stroke_join(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn leading(&self) -> StyleLeading {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.leading()).unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_leading(&self, value: StyleLeading) -> () {
                                    let result = self.0.set_leading(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn fill_rule(&self) -> String {
                                    let result = self.0.fill_rule();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_fill_rule(&self, value: String) -> () {
                                    let result = self.0.set_fill_rule(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn font_size(&self) -> StyleFontSize {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.font_size()).unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_font_size(&self, value: StyleFontSize) -> () {
                                    let result = self.0.set_font_size(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn stroke_color(&self) -> StyleStrokeColor {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.stroke_color())
                                            .unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_stroke_color(&self, value: StyleStrokeColor) -> () {
                                    let result = self.0.set_stroke_color(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn shadow_blur(&self) -> f64 {
                                    let result = self.0.shadow_blur();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_shadow_blur(&self, value: f64) -> () {
                                    let result = self.0.set_shadow_blur(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn justification(&self) -> String {
                                    let result = self.0.justification();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_justification(&self, value: String) -> () {
                                    let result = self.0.set_justification(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn new(
                                    style: std::collections::HashMap<String, JsValue>,
                                ) -> Style {
                                    let result = Style_Class::new(style);
                                    let result =
                                        ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result)
                                            .unwrap();
                                    Style(result)
                                }
                                #[allow(dead_code)]
                                pub fn view(&self) -> View {
                                    let result = self.0.view();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_view(&self, value: View) -> () {
                                    let result = self.0.set_view(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn stroke_cap(&self) -> String {
                                    let result = self.0.stroke_cap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_stroke_cap(&self, value: String) -> () {
                                    let result = self.0.set_stroke_cap(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn shadow_offset(&self) -> Point {
                                    let result = self.0.shadow_offset();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_shadow_offset(&self, value: Point) -> () {
                                    let result = self.0.set_shadow_offset(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn selected_color(&self) -> StyleSelectedColor {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.selected_color())
                                            .unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_selected_color(&self, value: StyleSelectedColor) -> () {
                                    let result = self.0.set_selected_color(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn font_family(&self) -> String {
                                    let result = self.0.font_family();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_font_family(&self, value: String) -> () {
                                    let result = self.0.set_font_family(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn font_weight(&self) -> StyleFontWeight {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.font_weight()).unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_font_weight(&self, value: StyleFontWeight) -> () {
                                    let result = self.0.set_font_weight(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn miter_limit(&self) -> f64 {
                                    let result = self.0.miter_limit();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_miter_limit(&self, value: f64) -> () {
                                    let result = self.0.set_miter_limit(value);
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for Style {
                                fn describe() {
                                    <Style_Class as wasm_bindgen::describe::WasmDescribe>::describe(
                                    )
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for Style {
                                type Abi = <Style_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Style {
                                type Abi =
                                    <&'a Style_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for Style {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Style {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal: Style_Class =
                                        <Style_Class as serde::de::Deserialize>::deserialize(
                                            deserializer,
                                        )?;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait Style_Trait {
                                fn stroke_scaling(&self) -> bool;
                                fn set_stroke_scaling(&mut self, value: bool) -> ();
                                fn stroke_width(&self) -> f64;
                                fn set_stroke_width(&mut self, value: f64) -> ();
                                fn dash_offset(&self) -> f64;
                                fn set_dash_offset(&mut self, value: f64) -> ();
                                fn shadow_color(&self) -> StyleShadowColor;
                                fn set_shadow_color(&mut self, value: StyleShadowColor) -> ();
                                fn fill_color(&self) -> StyleFillColor;
                                fn set_fill_color(&mut self, value: StyleFillColor) -> ();
                                fn dash_array(&self) -> Vec<f64>;
                                fn set_dash_array(&mut self, value: Vec<f64>) -> ();
                                fn stroke_join(&self) -> String;
                                fn set_stroke_join(&mut self, value: String) -> ();
                                fn leading(&self) -> StyleLeading;
                                fn set_leading(&mut self, value: StyleLeading) -> ();
                                fn fill_rule(&self) -> String;
                                fn set_fill_rule(&mut self, value: String) -> ();
                                fn font_size(&self) -> StyleFontSize;
                                fn set_font_size(&mut self, value: StyleFontSize) -> ();
                                fn stroke_color(&self) -> StyleStrokeColor;
                                fn set_stroke_color(&mut self, value: StyleStrokeColor) -> ();
                                fn shadow_blur(&self) -> f64;
                                fn set_shadow_blur(&mut self, value: f64) -> ();
                                fn justification(&self) -> String;
                                fn set_justification(&mut self, value: String) -> ();
                                fn new(style: std::collections::HashMap<String, JsValue>) -> Style;
                                fn view(&self) -> View;
                                fn set_view(&mut self, value: View) -> ();
                                fn stroke_cap(&self) -> String;
                                fn set_stroke_cap(&mut self, value: String) -> ();
                                fn shadow_offset(&self) -> Point;
                                fn set_shadow_offset(&mut self, value: Point) -> ();
                                fn selected_color(&self) -> StyleSelectedColor;
                                fn set_selected_color(&mut self, value: StyleSelectedColor) -> ();
                                fn font_family(&self) -> String;
                                fn set_font_family(&mut self, value: String) -> ();
                                fn font_weight(&self) -> StyleFontWeight;
                                fn set_font_weight(&mut self, value: StyleFontWeight) -> ();
                                fn miter_limit(&self) -> f64;
                                fn set_miter_limit(&mut self, value: f64) -> ();
                            }
                            impl std::clone::Clone for Style_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for Style_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Style_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                #[wasm_bindgen(js_name = "Gradient")]
                                type Gradient_Class;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = equals , method , js_class = "Gradient" , catch)]
                                fn __TSB_equals(
                                    this: &Gradient_Class,
                                    gradient: Gradient,
                                ) -> std::result::Result<bool, JsValue>;
                                # [wasm_bindgen (method , structural , getter = radial , js_class = "Gradient")]
                                fn radial(this: &Gradient_Class) -> bool;
                                # [wasm_bindgen (method , structural , setter = radial , js_class = "Gradient")]
                                fn set_radial(this: &Gradient_Class, value: bool);
                                # [wasm_bindgen (method , structural , getter = stops , js_class = "Gradient")]
                                fn stops(this: &Gradient_Class) -> Vec<GradientStop>;
                                # [wasm_bindgen (method , structural , setter = stops , js_class = "Gradient")]
                                fn set_stops(this: &Gradient_Class, value: Vec<GradientStop>);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = clone , method , js_class = "Gradient" , catch)]
                                fn __TSB_clone(
                                    this: &Gradient_Class,
                                ) -> std::result::Result<Gradient, JsValue>;
                            }
                            #[derive(std :: clone :: Clone)]
                            struct Gradient(pub Gradient_Class);
                            impl Gradient {
                                #[allow(dead_code)]
                                pub fn equals(
                                    &self,
                                    gradient: Gradient,
                                ) -> std::result::Result<bool, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_equals(gradient)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn radial(&self) -> bool {
                                    let result = self.0.radial();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_radial(&self, value: bool) -> () {
                                    let result = self.0.set_radial(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn stops(&self) -> Vec<GradientStop> {
                                    let result = self.0.stops();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_stops(&self, value: Vec<GradientStop>) -> () {
                                    let result = self.0.set_stops(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn clone(&self) -> std::result::Result<Gradient, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_clone()?);
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for Gradient {
                                fn describe() {
                                    < Gradient_Class as wasm_bindgen :: describe :: WasmDescribe > :: describe ()
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for Gradient {
                                type Abi =
                                    <Gradient_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Gradient {
                                type Abi =
                                    <&'a Gradient_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for Gradient {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Gradient {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal: Gradient_Class =
                                        <Gradient_Class as serde::de::Deserialize>::deserialize(
                                            deserializer,
                                        )?;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait Gradient_Trait {
                                fn equals(
                                    &self,
                                    gradient: Gradient,
                                ) -> std::result::Result<bool, JsValue>;
                                fn radial(&self) -> bool;
                                fn set_radial(&mut self, value: bool) -> ();
                                fn stops(&self) -> Vec<GradientStop>;
                                fn set_stops(&mut self, value: Vec<GradientStop>) -> ();
                                fn clone(&self) -> std::result::Result<Gradient, JsValue>;
                            }
                            impl std::clone::Clone for Gradient_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for Gradient_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Gradient_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                # [wasm_bindgen (js_name = "MouseEvent" , extends = Event_Class)]
                                type MouseEvent_Class;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = toString , method , js_class = "MouseEvent" , catch)]
                                fn __TSB_to_string(
                                    this: &MouseEvent_Class,
                                ) -> std::result::Result<String, JsValue>;
                                # [wasm_bindgen (method , structural , getter = delta , js_class = "MouseEvent")]
                                fn delta(this: &MouseEvent_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = delta , js_class = "MouseEvent")]
                                fn set_delta(this: &MouseEvent_Class, value: Point);
                                # [wasm_bindgen (method , structural , getter = target , js_class = "MouseEvent")]
                                fn target(this: &MouseEvent_Class) -> Item;
                                # [wasm_bindgen (method , structural , setter = target , js_class = "MouseEvent")]
                                fn set_target(this: &MouseEvent_Class, value: Item);
                                # [wasm_bindgen (method , structural , getter = type , js_class = "MouseEvent")]
                                fn type_(this: &MouseEvent_Class) -> String;
                                # [wasm_bindgen (method , structural , setter = type , js_class = "MouseEvent")]
                                fn set_type_(this: &MouseEvent_Class, value: String);
                                # [wasm_bindgen (method , structural , getter = currentTarget , js_class = "MouseEvent")]
                                fn current_target(this: &MouseEvent_Class) -> Item;
                                # [wasm_bindgen (method , structural , setter = currentTarget , js_class = "MouseEvent")]
                                fn set_current_target(this: &MouseEvent_Class, value: Item);
                                # [wasm_bindgen (method , structural , getter = point , js_class = "MouseEvent")]
                                fn point(this: &MouseEvent_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = point , js_class = "MouseEvent")]
                                fn set_point(this: &MouseEvent_Class, value: Point);
                            }
                            #[derive(std :: clone :: Clone)]
                            struct MouseEvent(pub MouseEvent_Class);
                            impl std::convert::From<&MouseEvent> for Event {
                                fn from(src: &MouseEvent) -> Event {
                                    let src: &Event_Class = src.0.as_ref();
                                    Event(src.clone())
                                }
                            }
                            impl std::convert::From<&mut MouseEvent> for Event {
                                fn from(src: &mut MouseEvent) -> Event {
                                    let src: &Event_Class = src.0.as_ref();
                                    Event(src.clone())
                                }
                            }
                            impl MouseEvent {
                                #[allow(dead_code)]
                                pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_to_string()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn delta(&self) -> Point {
                                    let result = self.0.delta();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_delta(&self, value: Point) -> () {
                                    let result = self.0.set_delta(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn target(&self) -> Item {
                                    let result = self.0.target();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_target(&self, value: Item) -> () {
                                    let result = self.0.set_target(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn type_(&self) -> String {
                                    let result = self.0.type_();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_type_(&self, value: String) -> () {
                                    let result = self.0.set_type_(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn current_target(&self) -> Item {
                                    let result = self.0.current_target();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_current_target(&self, value: Item) -> () {
                                    let result = self.0.set_current_target(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn point(&self) -> Point {
                                    let result = self.0.point();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_point(&self, value: Point) -> () {
                                    let result = self.0.set_point(value);
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for MouseEvent {
                                fn describe() {
                                    < MouseEvent_Class as wasm_bindgen :: describe :: WasmDescribe > :: describe ()
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for MouseEvent {
                                type Abi =
                                    <MouseEvent_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a MouseEvent {
                                type Abi = < & 'a MouseEvent_Class as wasm_bindgen :: convert :: IntoWasmAbi > :: Abi ;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for MouseEvent {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for MouseEvent {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal: MouseEvent_Class =
                                        <MouseEvent_Class as serde::de::Deserialize>::deserialize(
                                            deserializer,
                                        )?;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait MouseEvent_Trait: Event_Trait {
                                fn to_string(&self) -> std::result::Result<String, JsValue>;
                                fn delta(&self) -> Point;
                                fn set_delta(&mut self, value: Point) -> ();
                                fn target(&self) -> Item;
                                fn set_target(&mut self, value: Item) -> ();
                                fn type_(&self) -> String;
                                fn set_type(&mut self, value: String) -> ();
                                fn current_target(&self) -> Item;
                                fn set_current_target(&mut self, value: Item) -> ();
                                fn point(&self) -> Point;
                                fn set_point(&mut self, value: Point) -> ();
                            }
                            impl Event_Trait for MouseEvent {
                                fn prevent_default(&self) -> std::result::Result<(), JsValue> {
                                    let target: Event = self.into();
                                    Event::prevent_default(&target)
                                }
                                fn time_stamp(&self) -> f64 {
                                    let target: Event = self.into();
                                    Event::time_stamp(&target)
                                }
                                fn set_time_stamp(&mut self, value: f64) -> () {
                                    let mut target: Event = self.into();
                                    Event::set_time_stamp(&mut target, value)
                                }
                                fn stop(&self) -> std::result::Result<(), JsValue> {
                                    let target: Event = self.into();
                                    Event::stop(&target)
                                }
                                fn modifiers(&self) -> JsValue {
                                    let target: Event = self.into();
                                    Event::modifiers(&target)
                                }
                                fn set_modifiers(&mut self, value: JsValue) -> () {
                                    let mut target: Event = self.into();
                                    Event::set_modifiers(&mut target, value)
                                }
                                fn stop_propagation(&self) -> std::result::Result<(), JsValue> {
                                    let target: Event = self.into();
                                    Event::stop_propagation(&target)
                                }
                            }
                            impl MouseEvent_Trait for MouseEvent {}
                            impl std::clone::Clone for MouseEvent_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for MouseEvent_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for MouseEvent_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                #[wasm_bindgen(js_name = "Segment")]
                                type Segment_Class;
                                #[wasm_bindgen(constructor, js_class = "Segment")]
                                pub fn new(
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> Segment_Class;
                                # [wasm_bindgen (method , structural , getter = curve , js_class = "Segment")]
                                fn curve(this: &Segment_Class) -> Curve;
                                # [wasm_bindgen (method , structural , setter = curve , js_class = "Segment")]
                                fn set_curve(this: &Segment_Class, value: Curve);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isSmooth , method , js_class = "Segment" , catch)]
                                fn __TSB_is_smooth(
                                    this: &Segment_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                # [wasm_bindgen (method , structural , getter = location , js_class = "Segment")]
                                fn location(this: &Segment_Class) -> CurveLocation;
                                # [wasm_bindgen (method , structural , setter = location , js_class = "Segment")]
                                fn set_location(this: &Segment_Class, value: CurveLocation);
                                # [wasm_bindgen (method , structural , getter = path , js_class = "Segment")]
                                fn path(this: &Segment_Class) -> Path;
                                # [wasm_bindgen (method , structural , setter = path , js_class = "Segment")]
                                fn set_path(this: &Segment_Class, value: Path);
                                # [wasm_bindgen (method , structural , getter = handleOut , js_class = "Segment")]
                                fn handle_out(this: &Segment_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = handleOut , js_class = "Segment")]
                                fn set_handle_out(this: &Segment_Class, value: Point);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = reversed , method , js_class = "Segment" , catch)]
                                fn __TSB_reversed(
                                    this: &Segment_Class,
                                ) -> std::result::Result<Segment, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = remove , method , js_class = "Segment" , catch)]
                                fn __TSB_remove(
                                    this: &Segment_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isLast , method , js_class = "Segment" , catch)]
                                fn __TSB_is_last(
                                    this: &Segment_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = reverse , method , js_class = "Segment" , catch)]
                                fn __TSB_reverse(
                                    this: &Segment_Class,
                                ) -> std::result::Result<Segment, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = transform , method , js_class = "Segment" , catch)]
                                fn __TSB_transform(
                                    this: &Segment_Class,
                                    matrix: Matrix,
                                ) -> std::result::Result<(), JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = clone , method , js_class = "Segment" , catch)]
                                fn __TSB_clone(
                                    this: &Segment_Class,
                                ) -> std::result::Result<Segment, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = toString , method , js_class = "Segment" , catch)]
                                fn __TSB_to_string(
                                    this: &Segment_Class,
                                ) -> std::result::Result<String, JsValue>;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = isFirst , method , js_class = "Segment" , catch)]
                                fn __TSB_is_first(
                                    this: &Segment_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                # [wasm_bindgen (method , structural , getter = handleIn , js_class = "Segment")]
                                fn handle_in(this: &Segment_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = handleIn , js_class = "Segment")]
                                fn set_handle_in(this: &Segment_Class, value: Point);
                                # [wasm_bindgen (method , structural , getter = previous , js_class = "Segment")]
                                fn previous(this: &Segment_Class) -> Segment;
                                # [wasm_bindgen (method , structural , setter = previous , js_class = "Segment")]
                                fn set_previous(this: &Segment_Class, value: Segment);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = clearHandles , method , js_class = "Segment" , catch)]
                                fn __TSB_clear_handles(
                                    this: &Segment_Class,
                                ) -> std::result::Result<(), JsValue>;
                                # [wasm_bindgen (method , structural , getter = selected , js_class = "Segment")]
                                fn selected(this: &Segment_Class) -> bool;
                                # [wasm_bindgen (method , structural , setter = selected , js_class = "Segment")]
                                fn set_selected(this: &Segment_Class, value: bool);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = hasHandles , method , js_class = "Segment" , catch)]
                                fn __TSB_has_handles(
                                    this: &Segment_Class,
                                ) -> std::result::Result<bool, JsValue>;
                                # [wasm_bindgen (method , structural , getter = next , js_class = "Segment")]
                                fn next(this: &Segment_Class) -> Segment;
                                # [wasm_bindgen (method , structural , setter = next , js_class = "Segment")]
                                fn set_next(this: &Segment_Class, value: Segment);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = interpolate , method , js_class = "Segment" , catch)]
                                fn __TSB_interpolate(
                                    this: &Segment_Class,
                                    from: Segment,
                                    to: Segment,
                                    factor: f64,
                                ) -> std::result::Result<(), JsValue>;
                                # [wasm_bindgen (method , structural , getter = index , js_class = "Segment")]
                                fn index(this: &Segment_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = index , js_class = "Segment")]
                                fn set_index(this: &Segment_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = point , js_class = "Segment")]
                                fn point(this: &Segment_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = point , js_class = "Segment")]
                                fn set_point(this: &Segment_Class, value: Point);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = smooth , method , js_class = "Segment" , catch)]
                                fn __TSB_smooth(
                                    this: &Segment_Class,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<(), JsValue>;
                            }
                            #[derive(std :: clone :: Clone)]
                            struct Segment(pub Segment_Class);
                            impl Segment {
                                #[allow(dead_code)]
                                pub fn new(
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> Segment {
                                    let result = Segment_Class::new(object);
                                    let result =
                                        ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result)
                                            .unwrap();
                                    Segment(result)
                                }
                                #[allow(dead_code)]
                                pub fn curve(&self) -> Curve {
                                    let result = self.0.curve();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_curve(&self, value: Curve) -> () {
                                    let result = self.0.set_curve(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_smooth(&self) -> std::result::Result<bool, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_is_smooth()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn location(&self) -> CurveLocation {
                                    let result = self.0.location();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_location(&self, value: CurveLocation) -> () {
                                    let result = self.0.set_location(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn path(&self) -> Path {
                                    let result = self.0.path();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_path(&self, value: Path) -> () {
                                    let result = self.0.set_path(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn handle_out(&self) -> Point {
                                    let result = self.0.handle_out();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_handle_out(&self, value: Point) -> () {
                                    let result = self.0.set_handle_out(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn reversed(&self) -> std::result::Result<Segment, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_reversed()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn remove(&self) -> std::result::Result<bool, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_remove()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_last(&self) -> std::result::Result<bool, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_is_last()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn reverse(&self) -> std::result::Result<Segment, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_reverse()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn transform(
                                    &self,
                                    matrix: Matrix,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_transform(matrix)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn clone(&self) -> std::result::Result<Segment, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_clone()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_to_string()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn is_first(&self) -> std::result::Result<bool, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_is_first()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn handle_in(&self) -> Point {
                                    let result = self.0.handle_in();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_handle_in(&self, value: Point) -> () {
                                    let result = self.0.set_handle_in(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn previous(&self) -> Segment {
                                    let result = self.0.previous();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_previous(&self, value: Segment) -> () {
                                    let result = self.0.set_previous(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_clear_handles()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn selected(&self) -> bool {
                                    let result = self.0.selected();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_selected(&self, value: bool) -> () {
                                    let result = self.0.set_selected(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_has_handles()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn next(&self) -> Segment {
                                    let result = self.0.next();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_next(&self, value: Segment) -> () {
                                    let result = self.0.set_next(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn interpolate(
                                    &self,
                                    from: Segment,
                                    to: Segment,
                                    factor: f64,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result = std::result::Result::Ok(
                                        self.0.__TSB_interpolate(from, to, factor)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn index(&self) -> f64 {
                                    let result = self.0.index();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_index(&self, value: f64) -> () {
                                    let result = self.0.set_index(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn point(&self) -> Point {
                                    let result = self.0.point();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_point(&self, value: Point) -> () {
                                    let result = self.0.set_point(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn smooth(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<(), JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_smooth(options)?);
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for Segment {
                                fn describe() {
                                    < Segment_Class as wasm_bindgen :: describe :: WasmDescribe > :: describe ()
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for Segment {
                                type Abi =
                                    <Segment_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Segment {
                                type Abi =
                                    <&'a Segment_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for Segment {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Segment {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal: Segment_Class =
                                        <Segment_Class as serde::de::Deserialize>::deserialize(
                                            deserializer,
                                        )?;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait Segment_Trait {
                                fn new(
                                    object: std::collections::HashMap<String, JsValue>,
                                ) -> Segment;
                                fn curve(&self) -> Curve;
                                fn set_curve(&mut self, value: Curve) -> ();
                                fn is_smooth(&self) -> std::result::Result<bool, JsValue>;
                                fn location(&self) -> CurveLocation;
                                fn set_location(&mut self, value: CurveLocation) -> ();
                                fn path(&self) -> Path;
                                fn set_path(&mut self, value: Path) -> ();
                                fn handle_out(&self) -> Point;
                                fn set_handle_out(&mut self, value: Point) -> ();
                                fn reversed(&self) -> std::result::Result<Segment, JsValue>;
                                fn remove(&self) -> std::result::Result<bool, JsValue>;
                                fn is_last(&self) -> std::result::Result<bool, JsValue>;
                                fn reverse(&self) -> std::result::Result<Segment, JsValue>;
                                fn transform(
                                    &self,
                                    matrix: Matrix,
                                ) -> std::result::Result<(), JsValue>;
                                fn clone(&self) -> std::result::Result<Segment, JsValue>;
                                fn to_string(&self) -> std::result::Result<String, JsValue>;
                                fn is_first(&self) -> std::result::Result<bool, JsValue>;
                                fn handle_in(&self) -> Point;
                                fn set_handle_in(&mut self, value: Point) -> ();
                                fn previous(&self) -> Segment;
                                fn set_previous(&mut self, value: Segment) -> ();
                                fn clear_handles(&self) -> std::result::Result<(), JsValue>;
                                fn selected(&self) -> bool;
                                fn set_selected(&mut self, value: bool) -> ();
                                fn has_handles(&self) -> std::result::Result<bool, JsValue>;
                                fn next(&self) -> Segment;
                                fn set_next(&mut self, value: Segment) -> ();
                                fn interpolate(
                                    &self,
                                    from: Segment,
                                    to: Segment,
                                    factor: f64,
                                ) -> std::result::Result<(), JsValue>;
                                fn index(&self) -> f64;
                                fn set_index(&mut self, value: f64) -> ();
                                fn point(&self) -> Point;
                                fn set_point(&mut self, value: Point) -> ();
                                fn smooth(
                                    &self,
                                    options: std::collections::HashMap<String, JsValue>,
                                ) -> std::result::Result<(), JsValue>;
                            }
                            impl std::clone::Clone for Segment_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for Segment_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Segment_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                #[wasm_bindgen(js_name = "Tween")]
                                type Tween_Class;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = start , method , js_class = "Tween" , catch)]
                                fn __TSB_start(
                                    this: &Tween_Class,
                                ) -> std::result::Result<Tween, JsValue>;
                                # [wasm_bindgen (method , structural , getter = onUpdate , js_class = "Tween")]
                                fn on_update(this: &Tween_Class) -> TweenOnUpdate;
                                # [wasm_bindgen (method , structural , setter = onUpdate , js_class = "Tween")]
                                fn set_on_update(this: &Tween_Class, value: TweenOnUpdate);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = then , method , js_class = "Tween" , catch)]
                                fn __TSB_then(
                                    this: &Tween_Class,
                                    callback: JsValue,
                                ) -> std::result::Result<Tween, JsValue>;
                                #[wasm_bindgen(constructor, js_class = "Tween")]
                                pub fn new(
                                    object: std::collections::HashMap<String, JsValue>,
                                    from: std::collections::HashMap<String, JsValue>,
                                    to: std::collections::HashMap<String, JsValue>,
                                    duration: f64,
                                    easing: TweenConstructorEasingParam,
                                    start: bool,
                                ) -> Tween_Class;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = stop , method , js_class = "Tween" , catch)]
                                fn __TSB_stop(
                                    this: &Tween_Class,
                                ) -> std::result::Result<Tween, JsValue>;
                            }
                            #[derive(std :: clone :: Clone)]
                            struct Tween(pub Tween_Class);
                            impl Tween {
                                #[allow(dead_code)]
                                pub fn start(&self) -> std::result::Result<Tween, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_start()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn on_update(&self) -> TweenOnUpdate {
                                    let result =
                                        ts_bindgen_rt::from_jsvalue(&self.0.on_update()).unwrap();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_on_update(&self, value: TweenOnUpdate) -> () {
                                    let result = self.0.set_on_update(
                                        ts_bindgen_rt::to_jsvalue(&value)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                    );
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn then(
                                    &self,
                                    callback: JsValue,
                                ) -> std::result::Result<Tween, JsValue>
                                {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_then(callback)?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn new(
                                    object: std::collections::HashMap<String, JsValue>,
                                    from: std::collections::HashMap<String, JsValue>,
                                    to: std::collections::HashMap<String, JsValue>,
                                    duration: f64,
                                    easing: TweenConstructorEasingParam,
                                    start: bool,
                                ) -> Tween {
                                    let result = Tween_Class::new(
                                        object,
                                        from,
                                        to,
                                        duration,
                                        ts_bindgen_rt::to_jsvalue(&easing)
                                            .map_err(ts_bindgen_rt::Error::from)?,
                                        start,
                                    );
                                    let result =
                                        ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result)
                                            .unwrap();
                                    Tween(result)
                                }
                                #[allow(dead_code)]
                                pub fn stop(&self) -> std::result::Result<Tween, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_stop()?);
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for Tween {
                                fn describe() {
                                    <Tween_Class as wasm_bindgen::describe::WasmDescribe>::describe(
                                    )
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for Tween {
                                type Abi = <Tween_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Tween {
                                type Abi =
                                    <&'a Tween_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for Tween {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Tween {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal: Tween_Class =
                                        <Tween_Class as serde::de::Deserialize>::deserialize(
                                            deserializer,
                                        )?;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait Tween_Trait {
                                fn start(&self) -> std::result::Result<Tween, JsValue>;
                                fn on_update(&self) -> TweenOnUpdate;
                                fn set_on_update(&mut self, value: TweenOnUpdate) -> ();
                                fn then(
                                    &self,
                                    callback: JsValue,
                                ) -> std::result::Result<Tween, JsValue>;
                                fn new(
                                    object: std::collections::HashMap<String, JsValue>,
                                    from: std::collections::HashMap<String, JsValue>,
                                    to: std::collections::HashMap<String, JsValue>,
                                    duration: f64,
                                    easing: TweenConstructorEasingParam,
                                    start: bool,
                                ) -> Tween;
                                fn stop(&self) -> std::result::Result<Tween, JsValue>;
                            }
                            impl std::clone::Clone for Tween_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for Tween_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Tween_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                #[wasm_bindgen(js_name = "Event")]
                                type Event_Class;
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = preventDefault , method , js_class = "Event" , catch)]
                                fn __TSB_prevent_default(
                                    this: &Event_Class,
                                ) -> std::result::Result<(), JsValue>;
                                # [wasm_bindgen (method , structural , getter = timeStamp , js_class = "Event")]
                                fn time_stamp(this: &Event_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = timeStamp , js_class = "Event")]
                                fn set_time_stamp(this: &Event_Class, value: f64);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = stop , method , js_class = "Event" , catch)]
                                fn __TSB_stop(
                                    this: &Event_Class,
                                ) -> std::result::Result<(), JsValue>;
                                # [wasm_bindgen (method , structural , getter = modifiers , js_class = "Event")]
                                fn modifiers(this: &Event_Class) -> JsValue;
                                # [wasm_bindgen (method , structural , setter = modifiers , js_class = "Event")]
                                fn set_modifiers(this: &Event_Class, value: JsValue);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = stopPropagation , method , js_class = "Event" , catch)]
                                fn __TSB_stop_propagation(
                                    this: &Event_Class,
                                ) -> std::result::Result<(), JsValue>;
                            }
                            #[derive(std :: clone :: Clone)]
                            struct Event(pub Event_Class);
                            impl Event {
                                #[allow(dead_code)]
                                pub fn prevent_default(&self) -> std::result::Result<(), JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_prevent_default()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn time_stamp(&self) -> f64 {
                                    let result = self.0.time_stamp();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_time_stamp(&self, value: f64) -> () {
                                    let result = self.0.set_time_stamp(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn stop(&self) -> std::result::Result<(), JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_stop()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn modifiers(&self) -> JsValue {
                                    let result = self.0.modifiers();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_modifiers(&self, value: JsValue) -> () {
                                    let result = self.0.set_modifiers(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn stop_propagation(&self) -> std::result::Result<(), JsValue> {
                                    let result =
                                        std::result::Result::Ok(self.0.__TSB_stop_propagation()?);
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for Event {
                                fn describe() {
                                    <Event_Class as wasm_bindgen::describe::WasmDescribe>::describe(
                                    )
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for Event {
                                type Abi = <Event_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Event {
                                type Abi =
                                    <&'a Event_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for Event {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Event {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal: Event_Class =
                                        <Event_Class as serde::de::Deserialize>::deserialize(
                                            deserializer,
                                        )?;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait Event_Trait {
                                fn prevent_default(&self) -> std::result::Result<(), JsValue>;
                                fn time_stamp(&self) -> f64;
                                fn set_time_stamp(&mut self, value: f64) -> ();
                                fn stop(&self) -> std::result::Result<(), JsValue>;
                                fn modifiers(&self) -> JsValue;
                                fn set_modifiers(&mut self, value: JsValue) -> ();
                                fn stop_propagation(&self) -> std::result::Result<(), JsValue>;
                            }
                            impl std::clone::Clone for Event_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for Event_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for Event_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                            extern "C" {
                                # [wasm_bindgen (js_name = "ToolEvent" , extends = Event_Class)]
                                type ToolEvent_Class;
                                # [wasm_bindgen (method , structural , getter = middlePoint , js_class = "ToolEvent")]
                                fn middle_point(this: &ToolEvent_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = middlePoint , js_class = "ToolEvent")]
                                fn set_middle_point(this: &ToolEvent_Class, value: Point);
                                # [wasm_bindgen (method , structural , getter = type , js_class = "ToolEvent")]
                                fn type_(this: &ToolEvent_Class) -> String;
                                # [wasm_bindgen (method , structural , setter = type , js_class = "ToolEvent")]
                                fn set_type_(this: &ToolEvent_Class, value: String);
                                #[allow(non_snake_case)]
                                # [wasm_bindgen (js_name = toString , method , js_class = "ToolEvent" , catch)]
                                fn __TSB_to_string(
                                    this: &ToolEvent_Class,
                                ) -> std::result::Result<String, JsValue>;
                                # [wasm_bindgen (method , structural , getter = delta , js_class = "ToolEvent")]
                                fn delta(this: &ToolEvent_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = delta , js_class = "ToolEvent")]
                                fn set_delta(this: &ToolEvent_Class, value: Point);
                                # [wasm_bindgen (method , structural , getter = item , js_class = "ToolEvent")]
                                fn item(this: &ToolEvent_Class) -> Item;
                                # [wasm_bindgen (method , structural , setter = item , js_class = "ToolEvent")]
                                fn set_item(this: &ToolEvent_Class, value: Item);
                                # [wasm_bindgen (method , structural , getter = downPoint , js_class = "ToolEvent")]
                                fn down_point(this: &ToolEvent_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = downPoint , js_class = "ToolEvent")]
                                fn set_down_point(this: &ToolEvent_Class, value: Point);
                                # [wasm_bindgen (method , structural , getter = lastPoint , js_class = "ToolEvent")]
                                fn last_point(this: &ToolEvent_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = lastPoint , js_class = "ToolEvent")]
                                fn set_last_point(this: &ToolEvent_Class, value: Point);
                                # [wasm_bindgen (method , structural , getter = count , js_class = "ToolEvent")]
                                fn count(this: &ToolEvent_Class) -> f64;
                                # [wasm_bindgen (method , structural , setter = count , js_class = "ToolEvent")]
                                fn set_count(this: &ToolEvent_Class, value: f64);
                                # [wasm_bindgen (method , structural , getter = point , js_class = "ToolEvent")]
                                fn point(this: &ToolEvent_Class) -> Point;
                                # [wasm_bindgen (method , structural , setter = point , js_class = "ToolEvent")]
                                fn set_point(this: &ToolEvent_Class, value: Point);
                            }
                            #[derive(std :: clone :: Clone)]
                            struct ToolEvent(pub ToolEvent_Class);
                            impl std::convert::From<&ToolEvent> for Event {
                                fn from(src: &ToolEvent) -> Event {
                                    let src: &Event_Class = src.0.as_ref();
                                    Event(src.clone())
                                }
                            }
                            impl std::convert::From<&mut ToolEvent> for Event {
                                fn from(src: &mut ToolEvent) -> Event {
                                    let src: &Event_Class = src.0.as_ref();
                                    Event(src.clone())
                                }
                            }
                            impl ToolEvent {
                                #[allow(dead_code)]
                                pub fn middle_point(&self) -> Point {
                                    let result = self.0.middle_point();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_middle_point(&self, value: Point) -> () {
                                    let result = self.0.set_middle_point(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn type_(&self) -> String {
                                    let result = self.0.type_();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_type_(&self, value: String) -> () {
                                    let result = self.0.set_type_(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                                    let result = std::result::Result::Ok(self.0.__TSB_to_string()?);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn delta(&self) -> Point {
                                    let result = self.0.delta();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_delta(&self, value: Point) -> () {
                                    let result = self.0.set_delta(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn item(&self) -> Item {
                                    let result = self.0.item();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_item(&self, value: Item) -> () {
                                    let result = self.0.set_item(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn down_point(&self) -> Point {
                                    let result = self.0.down_point();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_down_point(&self, value: Point) -> () {
                                    let result = self.0.set_down_point(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn last_point(&self) -> Point {
                                    let result = self.0.last_point();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_last_point(&self, value: Point) -> () {
                                    let result = self.0.set_last_point(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn count(&self) -> f64 {
                                    let result = self.0.count();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_count(&self, value: f64) -> () {
                                    let result = self.0.set_count(value);
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn point(&self) -> Point {
                                    let result = self.0.point();
                                    result
                                }
                                #[allow(dead_code)]
                                pub fn set_point(&self, value: Point) -> () {
                                    let result = self.0.set_point(value);
                                    result
                                }
                            }
                            impl wasm_bindgen::describe::WasmDescribe for ToolEvent {
                                fn describe() {
                                    < ToolEvent_Class as wasm_bindgen :: describe :: WasmDescribe > :: describe ()
                                }
                            }
                            impl wasm_bindgen::convert::IntoWasmAbi for ToolEvent {
                                type Abi =
                                    <ToolEvent_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                }
                            }
                            impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a ToolEvent {
                                type Abi = < & 'a ToolEvent_Class as wasm_bindgen :: convert :: IntoWasmAbi > :: Abi ;
                                fn into_abi(self) -> Self::Abi {
                                    wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                }
                            }
                            impl serde::ser::Serialize for ToolEvent {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde::ser::Serialize::serialize(&self.0, serializer)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for ToolEvent {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    let internal: ToolEvent_Class =
                                        <ToolEvent_Class as serde::de::Deserialize>::deserialize(
                                            deserializer,
                                        )?;
                                    std::result::Result::Ok(Self(internal))
                                }
                            }
                            #[allow(non_camel_case_types)]
                            trait ToolEvent_Trait: Event_Trait {
                                fn middle_point(&self) -> Point;
                                fn set_middle_point(&mut self, value: Point) -> ();
                                fn type_(&self) -> String;
                                fn set_type(&mut self, value: String) -> ();
                                fn to_string(&self) -> std::result::Result<String, JsValue>;
                                fn delta(&self) -> Point;
                                fn set_delta(&mut self, value: Point) -> ();
                                fn item(&self) -> Item;
                                fn set_item(&mut self, value: Item) -> ();
                                fn down_point(&self) -> Point;
                                fn set_down_point(&mut self, value: Point) -> ();
                                fn last_point(&self) -> Point;
                                fn set_last_point(&mut self, value: Point) -> ();
                                fn count(&self) -> f64;
                                fn set_count(&mut self, value: f64) -> ();
                                fn point(&self) -> Point;
                                fn set_point(&mut self, value: Point) -> ();
                            }
                            impl Event_Trait for ToolEvent {
                                fn prevent_default(&self) -> std::result::Result<(), JsValue> {
                                    let target: Event = self.into();
                                    Event::prevent_default(&target)
                                }
                                fn time_stamp(&self) -> f64 {
                                    let target: Event = self.into();
                                    Event::time_stamp(&target)
                                }
                                fn set_time_stamp(&mut self, value: f64) -> () {
                                    let mut target: Event = self.into();
                                    Event::set_time_stamp(&mut target, value)
                                }
                                fn stop(&self) -> std::result::Result<(), JsValue> {
                                    let target: Event = self.into();
                                    Event::stop(&target)
                                }
                                fn modifiers(&self) -> JsValue {
                                    let target: Event = self.into();
                                    Event::modifiers(&target)
                                }
                                fn set_modifiers(&mut self, value: JsValue) -> () {
                                    let mut target: Event = self.into();
                                    Event::set_modifiers(&mut target, value)
                                }
                                fn stop_propagation(&self) -> std::result::Result<(), JsValue> {
                                    let target: Event = self.into();
                                    Event::stop_propagation(&target)
                                }
                            }
                            impl ToolEvent_Trait for ToolEvent {}
                            impl std::clone::Clone for ToolEvent_Class {
                                fn clone(&self) -> Self {
                                    Self {
                                        obj: std::clone::Clone::clone(&self.obj),
                                    }
                                }
                            }
                            impl serde::ser::Serialize for ToolEvent_Class {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                }
                            }
                            impl<'de> serde::de::Deserialize<'de> for ToolEvent_Class {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                }
                            }
                            #[cfg(target_family = "wasm")]
                            pub mod path {
                                #[allow(unused)]
                                use wasm_bindgen::prelude::*;
                                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                                extern "C" {
                                    # [wasm_bindgen (js_name = "Ellipse" , extends = Path_Class)]
                                    type Ellipse_Class;
                                    #[wasm_bindgen(constructor, js_class = "Ellipse")]
                                    pub fn new(
                                        object: std::collections::HashMap<String, JsValue>,
                                    ) -> Ellipse_Class;
                                }
                                #[derive(std :: clone :: Clone)]
                                struct Ellipse(pub Ellipse_Class);
                                impl std::convert::From<&Ellipse> for Path {
                                    fn from(src: &Ellipse) -> Path {
                                        let src: &Path_Class = src.0.as_ref();
                                        Path(src.clone())
                                    }
                                }
                                impl std::convert::From<&mut Ellipse> for Path {
                                    fn from(src: &mut Ellipse) -> Path {
                                        let src: &Path_Class = src.0.as_ref();
                                        Path(src.clone())
                                    }
                                }
                                impl Ellipse {
                                    #[allow(dead_code)]
                                    pub fn new(
                                        object: std::collections::HashMap<String, JsValue>,
                                    ) -> Ellipse {
                                        let result = Ellipse_Class::new(object);
                                        let result =
                                            ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result)
                                                .unwrap();
                                        Ellipse(result)
                                    }
                                }
                                impl wasm_bindgen::describe::WasmDescribe for Ellipse {
                                    fn describe() {
                                        < Ellipse_Class as wasm_bindgen :: describe :: WasmDescribe > :: describe ()
                                    }
                                }
                                impl wasm_bindgen::convert::IntoWasmAbi for Ellipse {
                                    type Abi =
                                        <Ellipse_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                    fn into_abi(self) -> Self::Abi {
                                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                    }
                                }
                                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Ellipse {
                                    type Abi = < & 'a Ellipse_Class as wasm_bindgen :: convert :: IntoWasmAbi > :: Abi ;
                                    fn into_abi(self) -> Self::Abi {
                                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                    }
                                }
                                impl serde::ser::Serialize for Ellipse {
                                    fn serialize<S>(
                                        &self,
                                        serializer: S,
                                    ) -> std::result::Result<S::Ok, S::Error>
                                    where
                                        S: serde::ser::Serializer,
                                    {
                                        serde::ser::Serialize::serialize(&self.0, serializer)
                                    }
                                }
                                impl<'de> serde::de::Deserialize<'de> for Ellipse {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        let internal: Ellipse_Class =
                                            <Ellipse_Class as serde::de::Deserialize>::deserialize(
                                                deserializer,
                                            )?;
                                        std::result::Result::Ok(Self(internal))
                                    }
                                }
                                #[allow(non_camel_case_types)]
                                trait Ellipse_Trait: Path_Trait {
                                    fn new(
                                        object: std::collections::HashMap<String, JsValue>,
                                    ) -> Ellipse;
                                }
                                impl Path_Trait for Ellipse {}
                                impl Ellipse_Trait for Ellipse {}
                                impl std::clone::Clone for Ellipse_Class {
                                    fn clone(&self) -> Self {
                                        Self {
                                            obj: std::clone::Clone::clone(&self.obj),
                                        }
                                    }
                                }
                                impl serde::ser::Serialize for Ellipse_Class {
                                    fn serialize<S>(
                                        &self,
                                        serializer: S,
                                    ) -> std::result::Result<S::Ok, S::Error>
                                    where
                                        S: serde::ser::Serializer,
                                    {
                                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                    }
                                }
                                impl<'de> serde::de::Deserialize<'de> for Ellipse_Class {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                    }
                                }
                                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                                extern "C" {
                                    # [wasm_bindgen (js_name = "Arc" , extends = Path_Class)]
                                    type Arc_Class;
                                    #[wasm_bindgen(constructor, js_class = "Arc")]
                                    pub fn new(
                                        object: std::collections::HashMap<String, JsValue>,
                                    ) -> Arc_Class;
                                }
                                #[derive(std :: clone :: Clone)]
                                struct Arc(pub Arc_Class);
                                impl std::convert::From<&Arc> for Path {
                                    fn from(src: &Arc) -> Path {
                                        let src: &Path_Class = src.0.as_ref();
                                        Path(src.clone())
                                    }
                                }
                                impl std::convert::From<&mut Arc> for Path {
                                    fn from(src: &mut Arc) -> Path {
                                        let src: &Path_Class = src.0.as_ref();
                                        Path(src.clone())
                                    }
                                }
                                impl Arc {
                                    #[allow(dead_code)]
                                    pub fn new(
                                        object: std::collections::HashMap<String, JsValue>,
                                    ) -> Arc {
                                        let result = Arc_Class::new(object);
                                        let result =
                                            ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result)
                                                .unwrap();
                                        Arc(result)
                                    }
                                }
                                impl wasm_bindgen::describe::WasmDescribe for Arc {
                                    fn describe() {
                                        < Arc_Class as wasm_bindgen :: describe :: WasmDescribe > :: describe ()
                                    }
                                }
                                impl wasm_bindgen::convert::IntoWasmAbi for Arc {
                                    type Abi =
                                        <Arc_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                    fn into_abi(self) -> Self::Abi {
                                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                    }
                                }
                                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Arc {
                                    type Abi =
                                        <&'a Arc_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                    fn into_abi(self) -> Self::Abi {
                                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                    }
                                }
                                impl serde::ser::Serialize for Arc {
                                    fn serialize<S>(
                                        &self,
                                        serializer: S,
                                    ) -> std::result::Result<S::Ok, S::Error>
                                    where
                                        S: serde::ser::Serializer,
                                    {
                                        serde::ser::Serialize::serialize(&self.0, serializer)
                                    }
                                }
                                impl<'de> serde::de::Deserialize<'de> for Arc {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        let internal: Arc_Class =
                                            <Arc_Class as serde::de::Deserialize>::deserialize(
                                                deserializer,
                                            )?;
                                        std::result::Result::Ok(Self(internal))
                                    }
                                }
                                #[allow(non_camel_case_types)]
                                trait Arc_Trait: Path_Trait {
                                    fn new(
                                        object: std::collections::HashMap<String, JsValue>,
                                    ) -> Arc;
                                }
                                impl Path_Trait for Arc {}
                                impl Arc_Trait for Arc {}
                                impl std::clone::Clone for Arc_Class {
                                    fn clone(&self) -> Self {
                                        Self {
                                            obj: std::clone::Clone::clone(&self.obj),
                                        }
                                    }
                                }
                                impl serde::ser::Serialize for Arc_Class {
                                    fn serialize<S>(
                                        &self,
                                        serializer: S,
                                    ) -> std::result::Result<S::Ok, S::Error>
                                    where
                                        S: serde::ser::Serializer,
                                    {
                                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                    }
                                }
                                impl<'de> serde::de::Deserialize<'de> for Arc_Class {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                    }
                                }
                                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                                extern "C" {
                                    # [wasm_bindgen (js_name = "Line" , extends = Path_Class)]
                                    type Line_Class;
                                    #[wasm_bindgen(constructor, js_class = "Line")]
                                    pub fn new(
                                        object: std::collections::HashMap<String, JsValue>,
                                    ) -> Line_Class;
                                }
                                #[derive(std :: clone :: Clone)]
                                struct Line(pub Line_Class);
                                impl std::convert::From<&Line> for Path {
                                    fn from(src: &Line) -> Path {
                                        let src: &Path_Class = src.0.as_ref();
                                        Path(src.clone())
                                    }
                                }
                                impl std::convert::From<&mut Line> for Path {
                                    fn from(src: &mut Line) -> Path {
                                        let src: &Path_Class = src.0.as_ref();
                                        Path(src.clone())
                                    }
                                }
                                impl Line {
                                    #[allow(dead_code)]
                                    pub fn new(
                                        object: std::collections::HashMap<String, JsValue>,
                                    ) -> Line {
                                        let result = Line_Class::new(object);
                                        let result =
                                            ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result)
                                                .unwrap();
                                        Line(result)
                                    }
                                }
                                impl wasm_bindgen::describe::WasmDescribe for Line {
                                    fn describe() {
                                        < Line_Class as wasm_bindgen :: describe :: WasmDescribe > :: describe ()
                                    }
                                }
                                impl wasm_bindgen::convert::IntoWasmAbi for Line {
                                    type Abi =
                                        <Line_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                    fn into_abi(self) -> Self::Abi {
                                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                    }
                                }
                                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Line {
                                    type Abi =
                                        <&'a Line_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                    fn into_abi(self) -> Self::Abi {
                                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                    }
                                }
                                impl serde::ser::Serialize for Line {
                                    fn serialize<S>(
                                        &self,
                                        serializer: S,
                                    ) -> std::result::Result<S::Ok, S::Error>
                                    where
                                        S: serde::ser::Serializer,
                                    {
                                        serde::ser::Serialize::serialize(&self.0, serializer)
                                    }
                                }
                                impl<'de> serde::de::Deserialize<'de> for Line {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        let internal: Line_Class =
                                            <Line_Class as serde::de::Deserialize>::deserialize(
                                                deserializer,
                                            )?;
                                        std::result::Result::Ok(Self(internal))
                                    }
                                }
                                #[allow(non_camel_case_types)]
                                trait Line_Trait: Path_Trait {
                                    fn new(
                                        object: std::collections::HashMap<String, JsValue>,
                                    ) -> Line;
                                }
                                impl Path_Trait for Line {}
                                impl Line_Trait for Line {}
                                impl std::clone::Clone for Line_Class {
                                    fn clone(&self) -> Self {
                                        Self {
                                            obj: std::clone::Clone::clone(&self.obj),
                                        }
                                    }
                                }
                                impl serde::ser::Serialize for Line_Class {
                                    fn serialize<S>(
                                        &self,
                                        serializer: S,
                                    ) -> std::result::Result<S::Ok, S::Error>
                                    where
                                        S: serde::ser::Serializer,
                                    {
                                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                    }
                                }
                                impl<'de> serde::de::Deserialize<'de> for Line_Class {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                    }
                                }
                                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                                extern "C" {
                                    # [wasm_bindgen (js_name = "Circle" , extends = Path_Class)]
                                    type Circle_Class;
                                    #[wasm_bindgen(constructor, js_class = "Circle")]
                                    pub fn new(
                                        object: std::collections::HashMap<String, JsValue>,
                                    ) -> Circle_Class;
                                }
                                #[derive(std :: clone :: Clone)]
                                struct Circle(pub Circle_Class);
                                impl std::convert::From<&Circle> for Path {
                                    fn from(src: &Circle) -> Path {
                                        let src: &Path_Class = src.0.as_ref();
                                        Path(src.clone())
                                    }
                                }
                                impl std::convert::From<&mut Circle> for Path {
                                    fn from(src: &mut Circle) -> Path {
                                        let src: &Path_Class = src.0.as_ref();
                                        Path(src.clone())
                                    }
                                }
                                impl Circle {
                                    #[allow(dead_code)]
                                    pub fn new(
                                        object: std::collections::HashMap<String, JsValue>,
                                    ) -> Circle {
                                        let result = Circle_Class::new(object);
                                        let result =
                                            ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result)
                                                .unwrap();
                                        Circle(result)
                                    }
                                }
                                impl wasm_bindgen::describe::WasmDescribe for Circle {
                                    fn describe() {
                                        < Circle_Class as wasm_bindgen :: describe :: WasmDescribe > :: describe ()
                                    }
                                }
                                impl wasm_bindgen::convert::IntoWasmAbi for Circle {
                                    type Abi =
                                        <Circle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                    fn into_abi(self) -> Self::Abi {
                                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                    }
                                }
                                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Circle {
                                    type Abi = < & 'a Circle_Class as wasm_bindgen :: convert :: IntoWasmAbi > :: Abi ;
                                    fn into_abi(self) -> Self::Abi {
                                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                    }
                                }
                                impl serde::ser::Serialize for Circle {
                                    fn serialize<S>(
                                        &self,
                                        serializer: S,
                                    ) -> std::result::Result<S::Ok, S::Error>
                                    where
                                        S: serde::ser::Serializer,
                                    {
                                        serde::ser::Serialize::serialize(&self.0, serializer)
                                    }
                                }
                                impl<'de> serde::de::Deserialize<'de> for Circle {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        let internal: Circle_Class =
                                            <Circle_Class as serde::de::Deserialize>::deserialize(
                                                deserializer,
                                            )?;
                                        std::result::Result::Ok(Self(internal))
                                    }
                                }
                                #[allow(non_camel_case_types)]
                                trait Circle_Trait: Path_Trait {
                                    fn new(
                                        object: std::collections::HashMap<String, JsValue>,
                                    ) -> Circle;
                                }
                                impl Path_Trait for Circle {}
                                impl Circle_Trait for Circle {}
                                impl std::clone::Clone for Circle_Class {
                                    fn clone(&self) -> Self {
                                        Self {
                                            obj: std::clone::Clone::clone(&self.obj),
                                        }
                                    }
                                }
                                impl serde::ser::Serialize for Circle_Class {
                                    fn serialize<S>(
                                        &self,
                                        serializer: S,
                                    ) -> std::result::Result<S::Ok, S::Error>
                                    where
                                        S: serde::ser::Serializer,
                                    {
                                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                    }
                                }
                                impl<'de> serde::de::Deserialize<'de> for Circle_Class {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                    }
                                }
                                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                                extern "C" {
                                    # [wasm_bindgen (js_name = "Star" , extends = Path_Class)]
                                    type Star_Class;
                                    #[wasm_bindgen(constructor, js_class = "Star")]
                                    pub fn new(
                                        object: std::collections::HashMap<String, JsValue>,
                                    ) -> Star_Class;
                                }
                                #[derive(std :: clone :: Clone)]
                                struct Star(pub Star_Class);
                                impl std::convert::From<&Star> for Path {
                                    fn from(src: &Star) -> Path {
                                        let src: &Path_Class = src.0.as_ref();
                                        Path(src.clone())
                                    }
                                }
                                impl std::convert::From<&mut Star> for Path {
                                    fn from(src: &mut Star) -> Path {
                                        let src: &Path_Class = src.0.as_ref();
                                        Path(src.clone())
                                    }
                                }
                                impl Star {
                                    #[allow(dead_code)]
                                    pub fn new(
                                        object: std::collections::HashMap<String, JsValue>,
                                    ) -> Star {
                                        let result = Star_Class::new(object);
                                        let result =
                                            ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result)
                                                .unwrap();
                                        Star(result)
                                    }
                                }
                                impl wasm_bindgen::describe::WasmDescribe for Star {
                                    fn describe() {
                                        < Star_Class as wasm_bindgen :: describe :: WasmDescribe > :: describe ()
                                    }
                                }
                                impl wasm_bindgen::convert::IntoWasmAbi for Star {
                                    type Abi =
                                        <Star_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                    fn into_abi(self) -> Self::Abi {
                                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                    }
                                }
                                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Star {
                                    type Abi =
                                        <&'a Star_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                    fn into_abi(self) -> Self::Abi {
                                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                    }
                                }
                                impl serde::ser::Serialize for Star {
                                    fn serialize<S>(
                                        &self,
                                        serializer: S,
                                    ) -> std::result::Result<S::Ok, S::Error>
                                    where
                                        S: serde::ser::Serializer,
                                    {
                                        serde::ser::Serialize::serialize(&self.0, serializer)
                                    }
                                }
                                impl<'de> serde::de::Deserialize<'de> for Star {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        let internal: Star_Class =
                                            <Star_Class as serde::de::Deserialize>::deserialize(
                                                deserializer,
                                            )?;
                                        std::result::Result::Ok(Self(internal))
                                    }
                                }
                                #[allow(non_camel_case_types)]
                                trait Star_Trait: Path_Trait {
                                    fn new(
                                        object: std::collections::HashMap<String, JsValue>,
                                    ) -> Star;
                                }
                                impl Path_Trait for Star {}
                                impl Star_Trait for Star {}
                                impl std::clone::Clone for Star_Class {
                                    fn clone(&self) -> Self {
                                        Self {
                                            obj: std::clone::Clone::clone(&self.obj),
                                        }
                                    }
                                }
                                impl serde::ser::Serialize for Star_Class {
                                    fn serialize<S>(
                                        &self,
                                        serializer: S,
                                    ) -> std::result::Result<S::Ok, S::Error>
                                    where
                                        S: serde::ser::Serializer,
                                    {
                                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                    }
                                }
                                impl<'de> serde::de::Deserialize<'de> for Star_Class {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                    }
                                }
                                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                                extern "C" {
                                    # [wasm_bindgen (js_name = "RegularPolygon" , extends = Path_Class)]
                                    type RegularPolygon_Class;
                                    #[wasm_bindgen(constructor, js_class = "RegularPolygon")]
                                    pub fn new(
                                        object: std::collections::HashMap<String, JsValue>,
                                    ) -> RegularPolygon_Class;
                                }
                                #[derive(std :: clone :: Clone)]
                                struct RegularPolygon(pub RegularPolygon_Class);
                                impl std::convert::From<&RegularPolygon> for Path {
                                    fn from(src: &RegularPolygon) -> Path {
                                        let src: &Path_Class = src.0.as_ref();
                                        Path(src.clone())
                                    }
                                }
                                impl std::convert::From<&mut RegularPolygon> for Path {
                                    fn from(src: &mut RegularPolygon) -> Path {
                                        let src: &Path_Class = src.0.as_ref();
                                        Path(src.clone())
                                    }
                                }
                                impl RegularPolygon {
                                    #[allow(dead_code)]
                                    pub fn new(
                                        object: std::collections::HashMap<String, JsValue>,
                                    ) -> RegularPolygon {
                                        let result = RegularPolygon_Class::new(object);
                                        let result =
                                            ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result)
                                                .unwrap();
                                        RegularPolygon(result)
                                    }
                                }
                                impl wasm_bindgen::describe::WasmDescribe for RegularPolygon {
                                    fn describe() {
                                        < RegularPolygon_Class as wasm_bindgen :: describe :: WasmDescribe > :: describe ()
                                    }
                                }
                                impl wasm_bindgen::convert::IntoWasmAbi for RegularPolygon {
                                    type Abi = < RegularPolygon_Class as wasm_bindgen :: convert :: IntoWasmAbi > :: Abi ;
                                    fn into_abi(self) -> Self::Abi {
                                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                    }
                                }
                                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a RegularPolygon {
                                    type Abi = < & 'a RegularPolygon_Class as wasm_bindgen :: convert :: IntoWasmAbi > :: Abi ;
                                    fn into_abi(self) -> Self::Abi {
                                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                    }
                                }
                                impl serde::ser::Serialize for RegularPolygon {
                                    fn serialize<S>(
                                        &self,
                                        serializer: S,
                                    ) -> std::result::Result<S::Ok, S::Error>
                                    where
                                        S: serde::ser::Serializer,
                                    {
                                        serde::ser::Serialize::serialize(&self.0, serializer)
                                    }
                                }
                                impl<'de> serde::de::Deserialize<'de> for RegularPolygon {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        let internal : RegularPolygon_Class = < RegularPolygon_Class as serde :: de :: Deserialize > :: deserialize (deserializer) ? ;
                                        std::result::Result::Ok(Self(internal))
                                    }
                                }
                                #[allow(non_camel_case_types)]
                                trait RegularPolygon_Trait: Path_Trait {
                                    fn new(
                                        object: std::collections::HashMap<String, JsValue>,
                                    ) -> RegularPolygon;
                                }
                                impl Path_Trait for RegularPolygon {}
                                impl RegularPolygon_Trait for RegularPolygon {}
                                impl std::clone::Clone for RegularPolygon_Class {
                                    fn clone(&self) -> Self {
                                        Self {
                                            obj: std::clone::Clone::clone(&self.obj),
                                        }
                                    }
                                }
                                impl serde::ser::Serialize for RegularPolygon_Class {
                                    fn serialize<S>(
                                        &self,
                                        serializer: S,
                                    ) -> std::result::Result<S::Ok, S::Error>
                                    where
                                        S: serde::ser::Serializer,
                                    {
                                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                    }
                                }
                                impl<'de> serde::de::Deserialize<'de> for RegularPolygon_Class {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                    }
                                }
                                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                                extern "C" {
                                    # [wasm_bindgen (js_name = "Rectangle" , extends = Path_Class)]
                                    type Rectangle_Class;
                                    #[wasm_bindgen(constructor, js_class = "Rectangle")]
                                    pub fn new(
                                        object: std::collections::HashMap<String, JsValue>,
                                    ) -> Rectangle_Class;
                                }
                                #[derive(std :: clone :: Clone)]
                                struct Rectangle(pub Rectangle_Class);
                                impl std::convert::From<&Rectangle> for Path {
                                    fn from(src: &Rectangle) -> Path {
                                        let src: &Path_Class = src.0.as_ref();
                                        Path(src.clone())
                                    }
                                }
                                impl std::convert::From<&mut Rectangle> for Path {
                                    fn from(src: &mut Rectangle) -> Path {
                                        let src: &Path_Class = src.0.as_ref();
                                        Path(src.clone())
                                    }
                                }
                                impl Rectangle {
                                    #[allow(dead_code)]
                                    pub fn new(
                                        object: std::collections::HashMap<String, JsValue>,
                                    ) -> Rectangle {
                                        let result = Rectangle_Class::new(object);
                                        let result =
                                            ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result)
                                                .unwrap();
                                        Rectangle(result)
                                    }
                                }
                                impl wasm_bindgen::describe::WasmDescribe for Rectangle {
                                    fn describe() {
                                        < Rectangle_Class as wasm_bindgen :: describe :: WasmDescribe > :: describe ()
                                    }
                                }
                                impl wasm_bindgen::convert::IntoWasmAbi for Rectangle {
                                    type Abi = < Rectangle_Class as wasm_bindgen :: convert :: IntoWasmAbi > :: Abi ;
                                    fn into_abi(self) -> Self::Abi {
                                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                    }
                                }
                                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Rectangle {
                                    type Abi = < & 'a Rectangle_Class as wasm_bindgen :: convert :: IntoWasmAbi > :: Abi ;
                                    fn into_abi(self) -> Self::Abi {
                                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                    }
                                }
                                impl serde::ser::Serialize for Rectangle {
                                    fn serialize<S>(
                                        &self,
                                        serializer: S,
                                    ) -> std::result::Result<S::Ok, S::Error>
                                    where
                                        S: serde::ser::Serializer,
                                    {
                                        serde::ser::Serialize::serialize(&self.0, serializer)
                                    }
                                }
                                impl<'de> serde::de::Deserialize<'de> for Rectangle {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        let internal : Rectangle_Class = < Rectangle_Class as serde :: de :: Deserialize > :: deserialize (deserializer) ? ;
                                        std::result::Result::Ok(Self(internal))
                                    }
                                }
                                #[allow(non_camel_case_types)]
                                trait Rectangle_Trait: Path_Trait {
                                    fn new(
                                        object: std::collections::HashMap<String, JsValue>,
                                    ) -> Rectangle;
                                }
                                impl Path_Trait for Rectangle {}
                                impl Rectangle_Trait for Rectangle {}
                                impl std::clone::Clone for Rectangle_Class {
                                    fn clone(&self) -> Self {
                                        Self {
                                            obj: std::clone::Clone::clone(&self.obj),
                                        }
                                    }
                                }
                                impl serde::ser::Serialize for Rectangle_Class {
                                    fn serialize<S>(
                                        &self,
                                        serializer: S,
                                    ) -> std::result::Result<S::Ok, S::Error>
                                    where
                                        S: serde::ser::Serializer,
                                    {
                                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                    }
                                }
                                impl<'de> serde::de::Deserialize<'de> for Rectangle_Class {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                    }
                                }
                            }
                            #[cfg(target_family = "wasm")]
                            pub mod shape {
                                #[allow(unused)]
                                use wasm_bindgen::prelude::*;
                                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                                extern "C" {
                                    # [wasm_bindgen (js_name = "Ellipse" , extends = Shape_Class)]
                                    type Ellipse_Class;
                                    #[wasm_bindgen(constructor, js_class = "Ellipse")]
                                    pub fn new(
                                        object: std::collections::HashMap<String, JsValue>,
                                    ) -> Ellipse_Class;
                                }
                                #[derive(std :: clone :: Clone)]
                                struct Ellipse(pub Ellipse_Class);
                                impl std::convert::From<&Ellipse> for Shape {
                                    fn from(src: &Ellipse) -> Shape {
                                        let src: &Shape_Class = src.0.as_ref();
                                        Shape(src.clone())
                                    }
                                }
                                impl std::convert::From<&mut Ellipse> for Shape {
                                    fn from(src: &mut Ellipse) -> Shape {
                                        let src: &Shape_Class = src.0.as_ref();
                                        Shape(src.clone())
                                    }
                                }
                                impl Ellipse {
                                    #[allow(dead_code)]
                                    pub fn new(
                                        object: std::collections::HashMap<String, JsValue>,
                                    ) -> Ellipse {
                                        let result = Ellipse_Class::new(object);
                                        let result =
                                            ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result)
                                                .unwrap();
                                        Ellipse(result)
                                    }
                                }
                                impl wasm_bindgen::describe::WasmDescribe for Ellipse {
                                    fn describe() {
                                        < Ellipse_Class as wasm_bindgen :: describe :: WasmDescribe > :: describe ()
                                    }
                                }
                                impl wasm_bindgen::convert::IntoWasmAbi for Ellipse {
                                    type Abi =
                                        <Ellipse_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                    fn into_abi(self) -> Self::Abi {
                                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                    }
                                }
                                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Ellipse {
                                    type Abi = < & 'a Ellipse_Class as wasm_bindgen :: convert :: IntoWasmAbi > :: Abi ;
                                    fn into_abi(self) -> Self::Abi {
                                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                    }
                                }
                                impl serde::ser::Serialize for Ellipse {
                                    fn serialize<S>(
                                        &self,
                                        serializer: S,
                                    ) -> std::result::Result<S::Ok, S::Error>
                                    where
                                        S: serde::ser::Serializer,
                                    {
                                        serde::ser::Serialize::serialize(&self.0, serializer)
                                    }
                                }
                                impl<'de> serde::de::Deserialize<'de> for Ellipse {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        let internal: Ellipse_Class =
                                            <Ellipse_Class as serde::de::Deserialize>::deserialize(
                                                deserializer,
                                            )?;
                                        std::result::Result::Ok(Self(internal))
                                    }
                                }
                                #[allow(non_camel_case_types)]
                                trait Ellipse_Trait: Shape_Trait {
                                    fn new(
                                        object: std::collections::HashMap<String, JsValue>,
                                    ) -> Ellipse;
                                }
                                impl Shape_Trait for Ellipse {}
                                impl Ellipse_Trait for Ellipse {}
                                impl std::clone::Clone for Ellipse_Class {
                                    fn clone(&self) -> Self {
                                        Self {
                                            obj: std::clone::Clone::clone(&self.obj),
                                        }
                                    }
                                }
                                impl serde::ser::Serialize for Ellipse_Class {
                                    fn serialize<S>(
                                        &self,
                                        serializer: S,
                                    ) -> std::result::Result<S::Ok, S::Error>
                                    where
                                        S: serde::ser::Serializer,
                                    {
                                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                    }
                                }
                                impl<'de> serde::de::Deserialize<'de> for Ellipse_Class {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                    }
                                }
                                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                                extern "C" {
                                    # [wasm_bindgen (js_name = "Circle" , extends = Shape_Class)]
                                    type Circle_Class;
                                    #[wasm_bindgen(constructor, js_class = "Circle")]
                                    pub fn new(
                                        object: std::collections::HashMap<String, JsValue>,
                                    ) -> Circle_Class;
                                }
                                #[derive(std :: clone :: Clone)]
                                struct Circle(pub Circle_Class);
                                impl std::convert::From<&Circle> for Shape {
                                    fn from(src: &Circle) -> Shape {
                                        let src: &Shape_Class = src.0.as_ref();
                                        Shape(src.clone())
                                    }
                                }
                                impl std::convert::From<&mut Circle> for Shape {
                                    fn from(src: &mut Circle) -> Shape {
                                        let src: &Shape_Class = src.0.as_ref();
                                        Shape(src.clone())
                                    }
                                }
                                impl Circle {
                                    #[allow(dead_code)]
                                    pub fn new(
                                        object: std::collections::HashMap<String, JsValue>,
                                    ) -> Circle {
                                        let result = Circle_Class::new(object);
                                        let result =
                                            ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result)
                                                .unwrap();
                                        Circle(result)
                                    }
                                }
                                impl wasm_bindgen::describe::WasmDescribe for Circle {
                                    fn describe() {
                                        < Circle_Class as wasm_bindgen :: describe :: WasmDescribe > :: describe ()
                                    }
                                }
                                impl wasm_bindgen::convert::IntoWasmAbi for Circle {
                                    type Abi =
                                        <Circle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                                    fn into_abi(self) -> Self::Abi {
                                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                    }
                                }
                                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Circle {
                                    type Abi = < & 'a Circle_Class as wasm_bindgen :: convert :: IntoWasmAbi > :: Abi ;
                                    fn into_abi(self) -> Self::Abi {
                                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                    }
                                }
                                impl serde::ser::Serialize for Circle {
                                    fn serialize<S>(
                                        &self,
                                        serializer: S,
                                    ) -> std::result::Result<S::Ok, S::Error>
                                    where
                                        S: serde::ser::Serializer,
                                    {
                                        serde::ser::Serialize::serialize(&self.0, serializer)
                                    }
                                }
                                impl<'de> serde::de::Deserialize<'de> for Circle {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        let internal: Circle_Class =
                                            <Circle_Class as serde::de::Deserialize>::deserialize(
                                                deserializer,
                                            )?;
                                        std::result::Result::Ok(Self(internal))
                                    }
                                }
                                #[allow(non_camel_case_types)]
                                trait Circle_Trait: Shape_Trait {
                                    fn new(
                                        object: std::collections::HashMap<String, JsValue>,
                                    ) -> Circle;
                                }
                                impl Shape_Trait for Circle {}
                                impl Circle_Trait for Circle {}
                                impl std::clone::Clone for Circle_Class {
                                    fn clone(&self) -> Self {
                                        Self {
                                            obj: std::clone::Clone::clone(&self.obj),
                                        }
                                    }
                                }
                                impl serde::ser::Serialize for Circle_Class {
                                    fn serialize<S>(
                                        &self,
                                        serializer: S,
                                    ) -> std::result::Result<S::Ok, S::Error>
                                    where
                                        S: serde::ser::Serializer,
                                    {
                                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                    }
                                }
                                impl<'de> serde::de::Deserialize<'de> for Circle_Class {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                    }
                                }
                                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                                extern "C" {
                                    # [wasm_bindgen (js_name = "Rectangle" , extends = Shape_Class)]
                                    type Rectangle_Class;
                                    #[wasm_bindgen(constructor, js_class = "Rectangle")]
                                    pub fn new(
                                        object: std::collections::HashMap<String, JsValue>,
                                    ) -> Rectangle_Class;
                                }
                                #[derive(std :: clone :: Clone)]
                                struct Rectangle(pub Rectangle_Class);
                                impl std::convert::From<&Rectangle> for Shape {
                                    fn from(src: &Rectangle) -> Shape {
                                        let src: &Shape_Class = src.0.as_ref();
                                        Shape(src.clone())
                                    }
                                }
                                impl std::convert::From<&mut Rectangle> for Shape {
                                    fn from(src: &mut Rectangle) -> Shape {
                                        let src: &Shape_Class = src.0.as_ref();
                                        Shape(src.clone())
                                    }
                                }
                                impl Rectangle {
                                    #[allow(dead_code)]
                                    pub fn new(
                                        object: std::collections::HashMap<String, JsValue>,
                                    ) -> Rectangle {
                                        let result = Rectangle_Class::new(object);
                                        let result =
                                            ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result)
                                                .unwrap();
                                        Rectangle(result)
                                    }
                                }
                                impl wasm_bindgen::describe::WasmDescribe for Rectangle {
                                    fn describe() {
                                        < Rectangle_Class as wasm_bindgen :: describe :: WasmDescribe > :: describe ()
                                    }
                                }
                                impl wasm_bindgen::convert::IntoWasmAbi for Rectangle {
                                    type Abi = < Rectangle_Class as wasm_bindgen :: convert :: IntoWasmAbi > :: Abi ;
                                    fn into_abi(self) -> Self::Abi {
                                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                                    }
                                }
                                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Rectangle {
                                    type Abi = < & 'a Rectangle_Class as wasm_bindgen :: convert :: IntoWasmAbi > :: Abi ;
                                    fn into_abi(self) -> Self::Abi {
                                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                                    }
                                }
                                impl serde::ser::Serialize for Rectangle {
                                    fn serialize<S>(
                                        &self,
                                        serializer: S,
                                    ) -> std::result::Result<S::Ok, S::Error>
                                    where
                                        S: serde::ser::Serializer,
                                    {
                                        serde::ser::Serialize::serialize(&self.0, serializer)
                                    }
                                }
                                impl<'de> serde::de::Deserialize<'de> for Rectangle {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        let internal : Rectangle_Class = < Rectangle_Class as serde :: de :: Deserialize > :: deserialize (deserializer) ? ;
                                        std::result::Result::Ok(Self(internal))
                                    }
                                }
                                #[allow(non_camel_case_types)]
                                trait Rectangle_Trait: Shape_Trait {
                                    fn new(
                                        object: std::collections::HashMap<String, JsValue>,
                                    ) -> Rectangle;
                                }
                                impl Shape_Trait for Rectangle {}
                                impl Rectangle_Trait for Rectangle {}
                                impl std::clone::Clone for Rectangle_Class {
                                    fn clone(&self) -> Self {
                                        Self {
                                            obj: std::clone::Clone::clone(&self.obj),
                                        }
                                    }
                                }
                                impl serde::ser::Serialize for Rectangle_Class {
                                    fn serialize<S>(
                                        &self,
                                        serializer: S,
                                    ) -> std::result::Result<S::Ok, S::Error>
                                    where
                                        S: serde::ser::Serializer,
                                    {
                                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                                    }
                                }
                                impl<'de> serde::de::Deserialize<'de> for Rectangle_Class {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
