#[cfg(target_family = "wasm")]
pub mod paper {
    #[cfg(target_family = "wasm")]
    pub mod dist {
        #[cfg(target_family = "wasm")]
        pub mod paper {
            #[allow(unused)]
            use super::*;
            #[allow(unused)]
            use wasm_bindgen::prelude::*;
            #[cfg(target_family = "wasm")]
            pub mod paper {
                #[allow(unused)]
                use super::*;
                #[allow(unused)]
                use wasm_bindgen::prelude::*;
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum RasterGetAverageColorParamsObjectParam {
                    PathCase(Path),
                    PointCase(Point),
                    RectangleCase(Rectangle),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ProjectGetItemsParamsOptionsParam {
                    #[serde(
                        serialize_with = "ProjectGetItemsParamsOptionsParam::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "ProjectGetItemsParamsOptionsParam::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    JsValueCase(JsValue),
                }
                impl ProjectGetItemsParamsOptionsParam {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    # [wasm_bindgen (js_name = "KeyEvent" , extends = Event_Class)]
                    pub type KeyEvent_Class;
                    # [wasm_bindgen (method , structural , catch , getter = key , js_class = "KeyEvent")]
                    fn key(this: &KeyEvent_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = key , js_class = "KeyEvent")]
                    fn set_key(
                        this: &KeyEvent_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = type , js_class = "KeyEvent")]
                    fn type_(this: &KeyEvent_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = type , js_class = "KeyEvent")]
                    fn set_type_(
                        this: &KeyEvent_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = toString , method , js_class = "KeyEvent" , catch)]
                    fn __TSB_to_string(
                        this: &KeyEvent_Class,
                    ) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = character , js_class = "KeyEvent")]
                    fn character(this: &KeyEvent_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = character , js_class = "KeyEvent")]
                    fn set_character(
                        this: &KeyEvent_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct KeyEvent(pub KeyEvent_Class);
                impl std::convert::From<&KeyEvent> for Event {
                    fn from(src: &KeyEvent) -> Event {
                        let src: &Event_Class = src.0.as_ref();
                        Event(src.clone())
                    }
                }
                impl std::convert::From<&mut KeyEvent> for Event {
                    fn from(src: &mut KeyEvent) -> Event {
                        let src: &Event_Class = src.0.as_ref();
                        Event(src.clone())
                    }
                }
                impl KeyEvent {
                    #[allow(dead_code)]
                    pub fn key(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.key();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_key(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_key(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn type_(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.type_();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_type_(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_type_(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.__TSB_to_string();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn character(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.character();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_character(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_character(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for KeyEvent {
                    fn describe() {
                        <KeyEvent_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for KeyEvent {
                    type Abi = <KeyEvent_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for KeyEvent {
                    type Abi = <KeyEvent_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        KeyEvent(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a KeyEvent {
                    type Abi = <&'a KeyEvent_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for KeyEvent {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for KeyEvent {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: KeyEvent_Class =
                            <KeyEvent_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait KeyEvent_Trait: Event_Trait {
                    fn set_key(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn key(&self) -> std::result::Result<String, JsValue>;
                    fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn type_(&self) -> std::result::Result<String, JsValue>;
                    fn to_string(&self) -> std::result::Result<String, JsValue>;
                    fn set_character(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn character(&self) -> std::result::Result<String, JsValue>;
                }
                impl Event_Trait for KeyEvent {
                    fn set_modifiers(
                        &mut self,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Event = self.into();
                        Event::set_modifiers(&mut target, value)
                    }
                    fn modifiers(&self) -> std::result::Result<JsValue, JsValue> {
                        let target: Event = self.into();
                        Event::modifiers(&target)
                    }
                    fn stop_propagation(&self) -> std::result::Result<(), JsValue> {
                        let target: Event = self.into();
                        Event::stop_propagation(&target)
                    }
                    fn set_time_stamp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Event = self.into();
                        Event::set_time_stamp(&mut target, value)
                    }
                    fn time_stamp(&self) -> std::result::Result<f64, JsValue> {
                        let target: Event = self.into();
                        Event::time_stamp(&target)
                    }
                    fn prevent_default(&self) -> std::result::Result<(), JsValue> {
                        let target: Event = self.into();
                        Event::prevent_default(&target)
                    }
                    fn stop(&self) -> std::result::Result<(), JsValue> {
                        let target: Event = self.into();
                        Event::stop(&target)
                    }
                }
                impl KeyEvent_Trait for KeyEvent
                where
                    KeyEvent: Event_Trait,
                {
                    fn set_key(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        KeyEvent::set_key(&mut target, value)
                    }
                    fn key(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        KeyEvent::key(&target)
                    }
                    fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        KeyEvent::set_type_(&mut target, value)
                    }
                    fn type_(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        KeyEvent::type_(&target)
                    }
                    fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        KeyEvent::to_string(&target)
                    }
                    fn set_character(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        KeyEvent::set_character(&mut target, value)
                    }
                    fn character(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        KeyEvent::character(&target)
                    }
                }
                impl std::clone::Clone for KeyEvent_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for KeyEvent_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for KeyEvent_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemTweenParamsOptionsParam {
                    F64Case(f64),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    JsValueCase(JsValue),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ShapeRadius {
                    SizeCase(Size),
                    F64Case(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum RasterSource {
                    StringCase(String),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    WebSysHtmlCanvasElementCase(web_sys::HtmlCanvasElement),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    WebSysHtmlImageElementCase(web_sys::HtmlImageElement),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum StyleStrokeColor {
                    ColorCase(Color),
                    TsBindgenRtNullCase,
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[wasm_bindgen(js_name = "Color")]
                    pub type Color_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clone , method , js_class = "Color" , catch)]
                    fn __TSB_clone(this: &Color_Class) -> std::result::Result<Color, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = green , js_class = "Color")]
                    fn green(this: &Color_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = green , js_class = "Color")]
                    fn set_green(
                        this: &Color_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = divide , method , js_class = "Color" , catch)]
                    fn __TSB_divide(
                        this: &Color_Class,
                        color: Color,
                    ) -> std::result::Result<Color, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = blue , js_class = "Color")]
                    fn blue(this: &Color_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = blue , js_class = "Color")]
                    fn set_blue(this: &Color_Class, value: f64)
                        -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = hasAlpha , method , js_class = "Color" , catch)]
                    fn __TSB_has_alpha(this: &Color_Class) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = random , method , js_class = "Color" , catch)]
                    fn __TSB_random(this: &Color_Class) -> std::result::Result<Color, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = gradient , js_class = "Color")]
                    fn gradient(this: &Color_Class) -> std::result::Result<Gradient, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = gradient , js_class = "Color")]
                    fn set_gradient(
                        this: &Color_Class,
                        value: Gradient,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = toString , method , js_class = "Color" , catch)]
                    fn __TSB_to_string(this: &Color_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = components , js_class = "Color")]
                    fn __TSB_components(
                        this: &Color_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = components , js_class = "Color")]
                    fn __TSB_set_components(
                        this: &Color_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = gray , js_class = "Color")]
                    fn gray(this: &Color_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = gray , js_class = "Color")]
                    fn set_gray(this: &Color_Class, value: f64)
                        -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = convert , method , js_class = "Color" , catch)]
                    fn __TSB_convert(
                        this: &Color_Class,
                        type_: String,
                    ) -> std::result::Result<Color, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = add , method , js_class = "Color" , catch)]
                    fn __TSB_add(
                        this: &Color_Class,
                        color: Color,
                    ) -> std::result::Result<Color, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = highlight , js_class = "Color")]
                    fn highlight(this: &Color_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = highlight , js_class = "Color")]
                    fn set_highlight(
                        this: &Color_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = toCSS , method , js_class = "Color" , catch)]
                    fn __TSB_to_css(
                        this: &Color_Class,
                        hex: bool,
                    ) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = hue , js_class = "Color")]
                    fn hue(this: &Color_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = hue , js_class = "Color")]
                    fn set_hue(this: &Color_Class, value: f64) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = multiply , method , js_class = "Color" , catch)]
                    fn __TSB_multiply(
                        this: &Color_Class,
                        color: Color,
                    ) -> std::result::Result<Color, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = type , js_class = "Color")]
                    fn type_(this: &Color_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = type , js_class = "Color")]
                    fn set_type_(
                        this: &Color_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = equals , method , js_class = "Color" , catch)]
                    fn __TSB_equals(
                        this: &Color_Class,
                        color: Color,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = brightness , js_class = "Color")]
                    fn brightness(this: &Color_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = brightness , js_class = "Color")]
                    fn set_brightness(
                        this: &Color_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = lightness , js_class = "Color")]
                    fn lightness(this: &Color_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = lightness , js_class = "Color")]
                    fn set_lightness(
                        this: &Color_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = red , js_class = "Color")]
                    fn red(this: &Color_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = red , js_class = "Color")]
                    fn set_red(this: &Color_Class, value: f64) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = subtract , method , js_class = "Color" , catch)]
                    fn __TSB_subtract(
                        this: &Color_Class,
                        color: Color,
                    ) -> std::result::Result<Color, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = alpha , js_class = "Color")]
                    fn alpha(this: &Color_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = alpha , js_class = "Color")]
                    fn set_alpha(
                        this: &Color_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = transform , method , js_class = "Color" , catch)]
                    fn __TSB_transform(
                        this: &Color_Class,
                        matrix: Matrix,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = saturation , js_class = "Color")]
                    fn saturation(this: &Color_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = saturation , js_class = "Color")]
                    fn set_saturation(
                        this: &Color_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = set , method , js_class = "Color" , catch , variadic)]
                    fn __TSB_set(
                        this: &Color_Class,
                        values: Box<[JsValue]>,
                    ) -> std::result::Result<Color, JsValue>;
                    #[wasm_bindgen(constructor, js_class = "Color")]
                    pub fn new(object: JsValue) -> Color_Class;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Color(pub Color_Class);
                impl Color {
                    #[allow(dead_code)]
                    pub fn clone(&self) -> std::result::Result<Color, JsValue> {
                        let result = self.0.__TSB_clone();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn green(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.green();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_green(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_green(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn divide(&self, color: Color) -> std::result::Result<Color, JsValue> {
                        let result = self.0.__TSB_divide(color);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn blue(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.blue();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_blue(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_blue(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn has_alpha(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_has_alpha();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn random(&self) -> std::result::Result<Color, JsValue> {
                        let result = self.0.__TSB_random();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn gradient(&self) -> std::result::Result<Gradient, JsValue> {
                        let result = self.0.gradient();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_gradient(
                        &self,
                        value: Gradient,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_gradient(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.__TSB_to_string();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn components(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_components()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_components(
                        &self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_components(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn gray(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.gray();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_gray(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_gray(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn convert(&self, type_: String) -> std::result::Result<Color, JsValue> {
                        let result = self.0.__TSB_convert(type_);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn add(&self, color: Color) -> std::result::Result<Color, JsValue> {
                        let result = self.0.__TSB_add(color);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn highlight(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.highlight();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_highlight(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_highlight(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn to_css(&self, hex: bool) -> std::result::Result<String, JsValue> {
                        let result = self.0.__TSB_to_css(hex);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn hue(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.hue();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_hue(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_hue(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn multiply(&self, color: Color) -> std::result::Result<Color, JsValue> {
                        let result = self.0.__TSB_multiply(color);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn type_(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.type_();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_type_(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_type_(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn equals(&self, color: Color) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_equals(color);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn brightness(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.brightness();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_brightness(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_brightness(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn lightness(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.lightness();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_lightness(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_lightness(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn red(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.red();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_red(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_red(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn subtract(&self, color: Color) -> std::result::Result<Color, JsValue> {
                        let result = self.0.__TSB_subtract(color);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn alpha(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.alpha();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_alpha(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_alpha(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_transform(matrix);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn saturation(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.saturation();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_saturation(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_saturation(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set(
                        &self,
                        values: Box<[JsValue]>,
                    ) -> std::result::Result<Color, JsValue> {
                        let result = self.0.__TSB_set(values);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn new(object: JsValue) -> Color {
                        let result = Color_Class::new(object);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Color(result)
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Color {
                    fn describe() {
                        <Color_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Color {
                    type Abi = <Color_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Color {
                    type Abi = <Color_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Color(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Color {
                    type Abi = <&'a Color_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Color {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Color {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Color_Class =
                            <Color_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait Color_Trait {
                    fn clone(&self) -> std::result::Result<Color, JsValue>;
                    fn set_green(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn green(&self) -> std::result::Result<f64, JsValue>;
                    fn divide(&self, color: Color) -> std::result::Result<Color, JsValue>;
                    fn set_blue(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn blue(&self) -> std::result::Result<f64, JsValue>;
                    fn has_alpha(&self) -> std::result::Result<bool, JsValue>;
                    fn random(&self) -> std::result::Result<Color, JsValue>;
                    fn set_gradient(&mut self, value: Gradient)
                        -> std::result::Result<(), JsValue>;
                    fn gradient(&self) -> std::result::Result<Gradient, JsValue>;
                    fn to_string(&self) -> std::result::Result<String, JsValue>;
                    fn set_components(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue>;
                    fn components(&self) -> std::result::Result<Vec<f64>, JsValue>;
                    fn set_gray(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn gray(&self) -> std::result::Result<f64, JsValue>;
                    fn convert(&self, type_: String) -> std::result::Result<Color, JsValue>;
                    fn add(&self, color: Color) -> std::result::Result<Color, JsValue>;
                    fn set_highlight(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn highlight(&self) -> std::result::Result<Point, JsValue>;
                    fn to_css(&self, hex: bool) -> std::result::Result<String, JsValue>;
                    fn set_hue(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn hue(&self) -> std::result::Result<f64, JsValue>;
                    fn multiply(&self, color: Color) -> std::result::Result<Color, JsValue>;
                    fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn type_(&self) -> std::result::Result<String, JsValue>;
                    fn equals(&self, color: Color) -> std::result::Result<bool, JsValue>;
                    fn set_brightness(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn brightness(&self) -> std::result::Result<f64, JsValue>;
                    fn set_lightness(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn lightness(&self) -> std::result::Result<f64, JsValue>;
                    fn set_red(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn red(&self) -> std::result::Result<f64, JsValue>;
                    fn subtract(&self, color: Color) -> std::result::Result<Color, JsValue>;
                    fn set_alpha(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn alpha(&self) -> std::result::Result<f64, JsValue>;
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue>;
                    fn set_saturation(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn saturation(&self) -> std::result::Result<f64, JsValue>;
                    fn set(&self, values: Box<[JsValue]>) -> std::result::Result<Color, JsValue>;
                }
                impl Color_Trait for Color {
                    fn clone(&self) -> std::result::Result<Color, JsValue> {
                        let target = self;
                        Color::clone(&target)
                    }
                    fn set_green(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Color::set_green(&mut target, value)
                    }
                    fn green(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Color::green(&target)
                    }
                    fn divide(&self, color: Color) -> std::result::Result<Color, JsValue> {
                        let target = self;
                        Color::divide(&target, color)
                    }
                    fn set_blue(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Color::set_blue(&mut target, value)
                    }
                    fn blue(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Color::blue(&target)
                    }
                    fn has_alpha(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Color::has_alpha(&target)
                    }
                    fn random(&self) -> std::result::Result<Color, JsValue> {
                        let target = self;
                        Color::random(&target)
                    }
                    fn set_gradient(
                        &mut self,
                        value: Gradient,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Color::set_gradient(&mut target, value)
                    }
                    fn gradient(&self) -> std::result::Result<Gradient, JsValue> {
                        let target = self;
                        Color::gradient(&target)
                    }
                    fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Color::to_string(&target)
                    }
                    fn set_components(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Color::set_components(&mut target, value)
                    }
                    fn components(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let target = self;
                        Color::components(&target)
                    }
                    fn set_gray(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Color::set_gray(&mut target, value)
                    }
                    fn gray(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Color::gray(&target)
                    }
                    fn convert(&self, type_: String) -> std::result::Result<Color, JsValue> {
                        let target = self;
                        Color::convert(&target, type_)
                    }
                    fn add(&self, color: Color) -> std::result::Result<Color, JsValue> {
                        let target = self;
                        Color::add(&target, color)
                    }
                    fn set_highlight(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Color::set_highlight(&mut target, value)
                    }
                    fn highlight(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Color::highlight(&target)
                    }
                    fn to_css(&self, hex: bool) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Color::to_css(&target, hex)
                    }
                    fn set_hue(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Color::set_hue(&mut target, value)
                    }
                    fn hue(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Color::hue(&target)
                    }
                    fn multiply(&self, color: Color) -> std::result::Result<Color, JsValue> {
                        let target = self;
                        Color::multiply(&target, color)
                    }
                    fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Color::set_type_(&mut target, value)
                    }
                    fn type_(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Color::type_(&target)
                    }
                    fn equals(&self, color: Color) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Color::equals(&target, color)
                    }
                    fn set_brightness(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Color::set_brightness(&mut target, value)
                    }
                    fn brightness(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Color::brightness(&target)
                    }
                    fn set_lightness(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Color::set_lightness(&mut target, value)
                    }
                    fn lightness(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Color::lightness(&target)
                    }
                    fn set_red(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Color::set_red(&mut target, value)
                    }
                    fn red(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Color::red(&target)
                    }
                    fn subtract(&self, color: Color) -> std::result::Result<Color, JsValue> {
                        let target = self;
                        Color::subtract(&target, color)
                    }
                    fn set_alpha(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Color::set_alpha(&mut target, value)
                    }
                    fn alpha(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Color::alpha(&target)
                    }
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Color::transform(&target, matrix)
                    }
                    fn set_saturation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Color::set_saturation(&mut target, value)
                    }
                    fn saturation(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Color::saturation(&target)
                    }
                    fn set(&self, values: Box<[JsValue]>) -> std::result::Result<Color, JsValue> {
                        let target = self;
                        Color::set(&target, values)
                    }
                }
                impl std::clone::Clone for Color_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Color_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Color_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[wasm_bindgen(js_name = "PaperScope")]
                    pub type PaperScope_Class;
                    # [wasm_bindgen (method , structural , catch , getter = tool , js_class = "PaperScope")]
                    fn tool(this: &PaperScope_Class) -> std::result::Result<Tool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = tool , js_class = "PaperScope")]
                    fn set_tool(
                        this: &PaperScope_Class,
                        value: Tool,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = project , js_class = "PaperScope")]
                    fn project(this: &PaperScope_Class) -> std::result::Result<Project, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = project , js_class = "PaperScope")]
                    fn set_project(
                        this: &PaperScope_Class,
                        value: Project,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = settings , js_class = "PaperScope")]
                    fn __TSB_settings(
                        this: &PaperScope_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = settings , js_class = "PaperScope")]
                    fn __TSB_set_settings(
                        this: &PaperScope_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = tools , js_class = "PaperScope")]
                    fn __TSB_tools(
                        this: &PaperScope_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = tools , js_class = "PaperScope")]
                    fn __TSB_set_tools(
                        this: &PaperScope_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = version , js_class = "PaperScope")]
                    fn version(this: &PaperScope_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = version , js_class = "PaperScope")]
                    fn set_version(
                        this: &PaperScope_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = setup , method , js_class = "PaperScope" , catch)]
                    fn __TSB_setup(
                        this: &PaperScope_Class,
                        element: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = install , method , js_class = "PaperScope" , catch)]
                    fn __TSB_install(
                        this: &PaperScope_Class,
                        scope: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = get , method , js_class = "PaperScope" , catch)]
                    fn __TSB_get(
                        this: &PaperScope_Class,
                        id: JsValue,
                    ) -> std::result::Result<PaperScope, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = activate , method , js_class = "PaperScope" , catch)]
                    fn __TSB_activate(this: &PaperScope_Class) -> std::result::Result<(), JsValue>;
                    #[wasm_bindgen(constructor, js_class = "PaperScope")]
                    pub fn new() -> PaperScope_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = execute , method , js_class = "PaperScope" , catch)]
                    fn __TSB_execute(
                        this: &PaperScope_Class,
                        code: String,
                        options: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = view , js_class = "PaperScope")]
                    fn view(this: &PaperScope_Class) -> std::result::Result<View, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = view , js_class = "PaperScope")]
                    fn set_view(
                        this: &PaperScope_Class,
                        value: View,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = projects , js_class = "PaperScope")]
                    fn __TSB_projects(
                        this: &PaperScope_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = projects , js_class = "PaperScope")]
                    fn __TSB_set_projects(
                        this: &PaperScope_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct PaperScope(pub PaperScope_Class);
                impl PaperScope {
                    #[allow(dead_code)]
                    pub fn tool(&self) -> std::result::Result<Tool, JsValue> {
                        let result = self.0.tool();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_tool(&self, value: Tool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_tool(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn project(&self) -> std::result::Result<Project, JsValue> {
                        let result = self.0.project();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_project(&self, value: Project) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_project(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn settings(&self) -> std::result::Result<JsValue, JsValue> {
                        let result = self.0.__TSB_settings();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_settings(&self, value: JsValue) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_settings(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn tools(&self) -> std::result::Result<Vec<Tool>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_tools()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_tools(&self, value: Vec<Tool>) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_tools(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn version(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.version();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_version(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_version(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn setup(
                        &self,
                        element: PaperScopeSetupParamsElementParam,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_setup(
                            ts_bindgen_rt::to_jsvalue(&element)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn install(&self, scope: JsValue) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_install(scope);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get(&self, id: JsValue) -> std::result::Result<PaperScope, JsValue> {
                        let result = self.0.__TSB_get(id);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn activate(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_activate();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn new() -> PaperScope {
                        let result = PaperScope_Class::new();
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        PaperScope(result)
                    }
                    #[allow(dead_code)]
                    pub fn execute(
                        &self,
                        code: String,
                        options: JsValue,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_execute(code, options);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn view(&self) -> std::result::Result<View, JsValue> {
                        let result = self.0.view();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_view(&self, value: View) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_view(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn projects(&self) -> std::result::Result<Vec<Project>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_projects()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_projects(
                        &self,
                        value: Vec<Project>,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_projects(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for PaperScope {
                    fn describe() {
                        <PaperScope_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for PaperScope {
                    type Abi = <PaperScope_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for PaperScope {
                    type Abi = <PaperScope_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        PaperScope(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a PaperScope {
                    type Abi = <&'a PaperScope_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for PaperScope {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for PaperScope {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: PaperScope_Class =
                            <PaperScope_Class as serde::de::Deserialize>::deserialize(
                                deserializer,
                            )?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait PaperScope_Trait {
                    fn set_tool(&mut self, value: Tool) -> std::result::Result<(), JsValue>;
                    fn tool(&self) -> std::result::Result<Tool, JsValue>;
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue>;
                    fn project(&self) -> std::result::Result<Project, JsValue>;
                    fn set_settings(&mut self, value: JsValue) -> std::result::Result<(), JsValue>;
                    fn settings(&self) -> std::result::Result<JsValue, JsValue>;
                    fn set_tools(&mut self, value: Vec<Tool>) -> std::result::Result<(), JsValue>;
                    fn tools(&self) -> std::result::Result<Vec<Tool>, JsValue>;
                    fn set_version(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn version(&self) -> std::result::Result<String, JsValue>;
                    fn setup(
                        &self,
                        element: PaperScopeSetupParamsElementParam,
                    ) -> std::result::Result<(), JsValue>;
                    fn install(&self, scope: JsValue) -> std::result::Result<(), JsValue>;
                    fn get(&self, id: JsValue) -> std::result::Result<PaperScope, JsValue>;
                    fn activate(&self) -> std::result::Result<(), JsValue>;
                    fn execute(
                        &self,
                        code: String,
                        options: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue>;
                    fn view(&self) -> std::result::Result<View, JsValue>;
                    fn set_projects(
                        &mut self,
                        value: Vec<Project>,
                    ) -> std::result::Result<(), JsValue>;
                    fn projects(&self) -> std::result::Result<Vec<Project>, JsValue>;
                }
                impl PaperScope_Trait for PaperScope {
                    fn set_tool(&mut self, value: Tool) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        PaperScope::set_tool(&mut target, value)
                    }
                    fn tool(&self) -> std::result::Result<Tool, JsValue> {
                        let target = self;
                        PaperScope::tool(&target)
                    }
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        PaperScope::set_project(&mut target, value)
                    }
                    fn project(&self) -> std::result::Result<Project, JsValue> {
                        let target = self;
                        PaperScope::project(&target)
                    }
                    fn set_settings(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        PaperScope::set_settings(&mut target, value)
                    }
                    fn settings(&self) -> std::result::Result<JsValue, JsValue> {
                        let target = self;
                        PaperScope::settings(&target)
                    }
                    fn set_tools(&mut self, value: Vec<Tool>) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        PaperScope::set_tools(&mut target, value)
                    }
                    fn tools(&self) -> std::result::Result<Vec<Tool>, JsValue> {
                        let target = self;
                        PaperScope::tools(&target)
                    }
                    fn set_version(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        PaperScope::set_version(&mut target, value)
                    }
                    fn version(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        PaperScope::version(&target)
                    }
                    fn setup(
                        &self,
                        element: PaperScopeSetupParamsElementParam,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PaperScope::setup(&target, element)
                    }
                    fn install(&self, scope: JsValue) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PaperScope::install(&target, scope)
                    }
                    fn get(&self, id: JsValue) -> std::result::Result<PaperScope, JsValue> {
                        let target = self;
                        PaperScope::get(&target, id)
                    }
                    fn activate(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PaperScope::activate(&target)
                    }
                    fn execute(
                        &self,
                        code: String,
                        options: JsValue,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PaperScope::execute(&target, code, options)
                    }
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        PaperScope::set_view(&mut target, value)
                    }
                    fn view(&self) -> std::result::Result<View, JsValue> {
                        let target = self;
                        PaperScope::view(&target)
                    }
                    fn set_projects(
                        &mut self,
                        value: Vec<Project>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        PaperScope::set_projects(&mut target, value)
                    }
                    fn projects(&self) -> std::result::Result<Vec<Project>, JsValue> {
                        let target = self;
                        PaperScope::projects(&target)
                    }
                }
                impl std::clone::Clone for PaperScope_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for PaperScope_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for PaperScope_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewOnMouseEnter {
                    TsBindgenRtNullCase,
                    #[serde(
                        serialize_with = "ViewOnMouseEnter::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "ViewOnMouseEnter::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                }
                impl ViewOnMouseEnter {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    # [wasm_bindgen (js_name = "TextItem" , extends = Item_Class)]
                    pub type TextItem_Class;
                    # [wasm_bindgen (method , structural , catch , getter = fontWeight , js_class = "TextItem")]
                    fn __TSB_font_weight(
                        this: &TextItem_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = fontWeight , js_class = "TextItem")]
                    fn __TSB_set_font_weight(
                        this: &TextItem_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = fontSize , js_class = "TextItem")]
                    fn __TSB_font_size(
                        this: &TextItem_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = fontSize , js_class = "TextItem")]
                    fn __TSB_set_font_size(
                        this: &TextItem_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = content , js_class = "TextItem")]
                    fn content(this: &TextItem_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = content , js_class = "TextItem")]
                    fn set_content(
                        this: &TextItem_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = fontFamily , js_class = "TextItem")]
                    fn font_family(this: &TextItem_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = fontFamily , js_class = "TextItem")]
                    fn set_font_family(
                        this: &TextItem_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = leading , js_class = "TextItem")]
                    fn __TSB_leading(
                        this: &TextItem_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = leading , js_class = "TextItem")]
                    fn __TSB_set_leading(
                        this: &TextItem_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = justification , js_class = "TextItem")]
                    fn justification(this: &TextItem_Class)
                        -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = justification , js_class = "TextItem")]
                    fn set_justification(
                        this: &TextItem_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct TextItem(pub TextItem_Class);
                impl std::convert::From<&TextItem> for Item {
                    fn from(src: &TextItem) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl std::convert::From<&mut TextItem> for Item {
                    fn from(src: &mut TextItem) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl TextItem {
                    #[allow(dead_code)]
                    pub fn font_weight(&self) -> std::result::Result<TextItemFontWeight, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_font_weight()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_font_weight(
                        &self,
                        value: TextItemFontWeight,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_font_weight(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn font_size(&self) -> std::result::Result<TextItemFontSize, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_font_size()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_font_size(
                        &self,
                        value: TextItemFontSize,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_font_size(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn content(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.content();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_content(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_content(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn font_family(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.font_family();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_font_family(
                        &self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_font_family(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn leading(&self) -> std::result::Result<TextItemLeading, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_leading()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_leading(
                        &self,
                        value: TextItemLeading,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_leading(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn justification(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.justification();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_justification(
                        &self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_justification(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for TextItem {
                    fn describe() {
                        <TextItem_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for TextItem {
                    type Abi = <TextItem_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for TextItem {
                    type Abi = <TextItem_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        TextItem(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a TextItem {
                    type Abi = <&'a TextItem_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for TextItem {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for TextItem {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: TextItem_Class =
                            <TextItem_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait TextItem_Trait: Item_Trait {
                    fn set_font_weight(
                        &mut self,
                        value: TextItemFontWeight,
                    ) -> std::result::Result<(), JsValue>;
                    fn font_weight(&self) -> std::result::Result<TextItemFontWeight, JsValue>;
                    fn set_font_size(
                        &mut self,
                        value: TextItemFontSize,
                    ) -> std::result::Result<(), JsValue>;
                    fn font_size(&self) -> std::result::Result<TextItemFontSize, JsValue>;
                    fn set_content(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn content(&self) -> std::result::Result<String, JsValue>;
                    fn set_font_family(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    fn font_family(&self) -> std::result::Result<String, JsValue>;
                    fn set_leading(
                        &mut self,
                        value: TextItemLeading,
                    ) -> std::result::Result<(), JsValue>;
                    fn leading(&self) -> std::result::Result<TextItemLeading, JsValue>;
                    fn set_justification(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    fn justification(&self) -> std::result::Result<String, JsValue>;
                }
                impl Item_Trait for TextItem {
                    fn set_stroke_scaling(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_scaling(&mut target, value)
                    }
                    fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_scaling(&target)
                    }
                    fn set_apply_matrix(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_apply_matrix(&mut target, value)
                    }
                    fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::apply_matrix(&target)
                    }
                    fn set_view_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_view_matrix(&mut target, value)
                    }
                    fn view_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::view_matrix(&target)
                    }
                    fn set_dash_array(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_dash_array(&mut target, value)
                    }
                    fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let target: Item = self.into();
                        Item::dash_array(&target)
                    }
                    fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_ancestor(&target, item)
                    }
                    fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_descendant(&target, item)
                    }
                    fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_sibling(&target, item)
                    }
                    fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_parent(&target, point)
                    }
                    fn set_shadow_blur(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_shadow_blur(&mut target, value)
                    }
                    fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_blur(&target)
                    }
                    fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_empty(&target, recursively)
                    }
                    fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_parent(&target, item)
                    }
                    fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_below(&target, item)
                    }
                    fn set_matrix(&mut self, value: Matrix) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_matrix(&mut target, value)
                    }
                    fn matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::matrix(&target)
                    }
                    fn export_json(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::export_json(&target, options)
                    }
                    fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::global_to_local(&target, point)
                    }
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ItemOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_drag(&mut target, value)
                    }
                    fn on_mouse_drag(&self) -> std::result::Result<ItemOnMouseDrag, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_drag(&target)
                    }
                    fn get_item(
                        &self,
                        options: ItemGetItemParamsOptionsParam,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::get_item(&target, options)
                    }
                    fn remove_children(
                        &self,
                        start: f64,
                        end: f64,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::remove_children(&target, start, end)
                    }
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_project(&mut target, value)
                    }
                    fn project(&self) -> std::result::Result<Project, JsValue> {
                        let target: Item = self.into();
                        Item::project(&target)
                    }
                    fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_data(&mut target, value)
                    }
                    fn data(&self) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::data(&target)
                    }
                    fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_above(&target, item)
                    }
                    fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on(&target, options)
                    }
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::transform(&target, matrix)
                    }
                    fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inserted(&target)
                    }
                    fn set_on_mouse_down(
                        &mut self,
                        value: ItemOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_down(&mut target, value)
                    }
                    fn on_mouse_down(&self) -> std::result::Result<ItemOnMouseDown, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_down(&target)
                    }
                    fn set_last_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_last_child(&mut target, value)
                    }
                    fn last_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::last_child(&target)
                    }
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_selected(&mut target, value)
                    }
                    fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::selected(&target)
                    }
                    fn set_global_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_global_matrix(&mut target, value)
                    }
                    fn global_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::global_matrix(&target)
                    }
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::responds(&target, type_)
                    }
                    fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::rotate(&target, angle, center)
                    }
                    fn tween(
                        &self,
                        options: ItemTweenParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween(&target, options)
                    }
                    fn set_on_mouse_enter(
                        &mut self,
                        value: ItemOnMouseEnter,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_enter(&mut target, value)
                    }
                    fn on_mouse_enter(&self) -> std::result::Result<ItemOnMouseEnter, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_enter(&target)
                    }
                    fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_id(&mut target, value)
                    }
                    fn id(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::id(&target)
                    }
                    fn on(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::on(&target, object)
                    }
                    fn tween_to(
                        &self,
                        to: JsValue,
                        options: ItemTweenToParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_to(&target, to, options)
                    }
                    fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_locked(&mut target, value)
                    }
                    fn locked(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::locked(&target)
                    }
                    fn set_children(
                        &mut self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_children(&mut target, value)
                    }
                    fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::children(&target)
                    }
                    fn copy_attributes(
                        &self,
                        source: Item,
                        exclude_matrix: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_attributes(&target, source, exclude_matrix)
                    }
                    fn off(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::off(&target, object)
                    }
                    fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::contains(&target, point)
                    }
                    fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_stroke(&target)
                    }
                    fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_move(&target)
                    }
                    fn add_children(
                        &self,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::add_children(&target, items)
                    }
                    fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::reverse_children(&target)
                    }
                    fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_shadow(&target)
                    }
                    fn set_dash_offset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_dash_offset(&mut target, value)
                    }
                    fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::dash_offset(&target)
                    }
                    fn set_on_mouse_leave(
                        &mut self,
                        value: ItemOnMouseLeave,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_leave(&mut target, value)
                    }
                    fn on_mouse_leave(&self) -> std::result::Result<ItemOnMouseLeave, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_leave(&target)
                    }
                    fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test_all(&target, point, options)
                    }
                    fn set_stroke_cap(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_cap(&mut target, value)
                    }
                    fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_cap(&target)
                    }
                    fn set_internal_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_internal_bounds(&mut target, value)
                    }
                    fn internal_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::internal_bounds(&target)
                    }
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_index(&mut target, value)
                    }
                    fn index(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::index(&target)
                    }
                    fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::reduce(&target, options)
                    }
                    fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_grouped_with(&target, item)
                    }
                    fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_global(&target, point)
                    }
                    fn set_first_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_first_child(&mut target, value)
                    }
                    fn first_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::first_child(&target)
                    }
                    fn set_position(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_position(&mut target, value)
                    }
                    fn position(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::position(&target)
                    }
                    fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_opacity(&mut target, value)
                    }
                    fn opacity(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::opacity(&target)
                    }
                    fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_down(&target)
                    }
                    fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_drag(&target)
                    }
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_bounds(&mut target, value)
                    }
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::bounds(&target)
                    }
                    fn set_parent(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_parent(&mut target, value)
                    }
                    fn parent(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::parent(&target)
                    }
                    fn get_items(
                        &self,
                        options: ItemGetItemsParamsOptionsParam,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::get_items(&target, options)
                    }
                    fn copy_to(
                        &self,
                        owner: ItemCopyToParamsOwnerParam,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::copy_to(&target, owner)
                    }
                    fn set_on_double_click(
                        &mut self,
                        value: ItemOnDoubleClick,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_double_click(&mut target, value)
                    }
                    fn on_double_click(&self) -> std::result::Result<ItemOnDoubleClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_double_click(&target)
                    }
                    fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::set(&target, props)
                    }
                    fn scale(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::scale(&target, hor, ver, center)
                    }
                    fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_below(&target, item)
                    }
                    fn set_next_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_next_sibling(&mut target, value)
                    }
                    fn next_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::next_sibling(&target)
                    }
                    fn rasterize(&self, options: JsValue) -> std::result::Result<Raster, JsValue> {
                        let target: Item = self.into();
                        Item::rasterize(&target, options)
                    }
                    fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::bring_to_front(&target)
                    }
                    fn matches(
                        &self,
                        name: String,
                        compare: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::matches(&target, name, compare)
                    }
                    fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_fill(&target)
                    }
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_view(&mut target, value)
                    }
                    fn view(&self) -> std::result::Result<View, JsValue> {
                        let target: Item = self.into();
                        Item::view(&target)
                    }
                    fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::clone(&target, options)
                    }
                    fn set_handle_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_handle_bounds(&mut target, value)
                    }
                    fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::handle_bounds(&target)
                    }
                    fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inside(&target, rect)
                    }
                    fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_above(&target, item)
                    }
                    fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::remove(&target)
                    }
                    fn set_stroke_join(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_join(&mut target, value)
                    }
                    fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_join(&target)
                    }
                    fn set_on_click(
                        &mut self,
                        value: ItemOnClick,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_click(&mut target, value)
                    }
                    fn on_click(&self) -> std::result::Result<ItemOnClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_click(&target)
                    }
                    fn fit_bounds(
                        &self,
                        rectangle: Rectangle,
                        fill: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::fit_bounds(&target, rectangle, fill)
                    }
                    fn set_blend_mode(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_blend_mode(&mut target, value)
                    }
                    fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::blend_mode(&target)
                    }
                    fn set_stroke_width(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_width(&mut target, value)
                    }
                    fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_width(&target)
                    }
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_rotation(&mut target, value)
                    }
                    fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::rotation(&target)
                    }
                    fn set_selected_color(
                        &mut self,
                        value: ItemSelectedColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_selected_color(&mut target, value)
                    }
                    fn selected_color(&self) -> std::result::Result<ItemSelectedColor, JsValue> {
                        let target: Item = self.into();
                        Item::selected_color(&target)
                    }
                    fn skew(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::skew(&target, hor, ver, center)
                    }
                    fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_name(&mut target, value)
                    }
                    fn name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::name(&target)
                    }
                    fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_json(&target, json)
                    }
                    fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::add_child(&target, item)
                    }
                    fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_visible(&mut target, value)
                    }
                    fn visible(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::visible(&target)
                    }
                    fn set_fill_rule(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_fill_rule(&mut target, value)
                    }
                    fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::fill_rule(&target)
                    }
                    fn set_layer(&mut self, value: Layer) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_layer(&mut target, value)
                    }
                    fn layer(&self) -> std::result::Result<Layer, JsValue> {
                        let target: Item = self.into();
                        Item::layer(&target)
                    }
                    fn tween_from(
                        &self,
                        from: JsValue,
                        options: ItemTweenFromParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_from(&target, from, options)
                    }
                    fn insert_child(
                        &self,
                        index: f64,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_child(&target, index, item)
                    }
                    fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_up(&target)
                    }
                    fn set_pivot(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_pivot(&mut target, value)
                    }
                    fn pivot(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::pivot(&target)
                    }
                    fn set_miter_limit(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_miter_limit(&mut target, value)
                    }
                    fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::miter_limit(&target)
                    }
                    fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_content(&target, source)
                    }
                    fn import_svg(
                        &self,
                        svg: ItemImportSvgParamsSvgParam,
                        on_load: &'static dyn Fn(
                            Box<[JsValue]>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_svg(&target, svg, on_load)
                    }
                    fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::send_to_back(&target)
                    }
                    fn set_stroke_color(
                        &mut self,
                        value: ItemStrokeColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_color(&mut target, value)
                    }
                    fn stroke_color(&self) -> std::result::Result<ItemStrokeColor, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_color(&target)
                    }
                    fn set_on_mouse_move(
                        &mut self,
                        value: ItemOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_move(&mut target, value)
                    }
                    fn on_mouse_move(&self) -> std::result::Result<ItemOnMouseMove, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_move(&target)
                    }
                    fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::replace_with(&target, item)
                    }
                    fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test(&target, point, options)
                    }
                    fn shear(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::shear(&target, hor, ver, center)
                    }
                    fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::translate(&target, delta)
                    }
                    fn set_stroke_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_bounds(&mut target, value)
                    }
                    fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_bounds(&target)
                    }
                    fn insert_children(
                        &self,
                        index: f64,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::insert_children(&target, index, items)
                    }
                    fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_child(&target, item)
                    }
                    fn set_shadow_offset(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_shadow_offset(&mut target, value)
                    }
                    fn shadow_offset(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_offset(&target)
                    }
                    fn set_fill_color(
                        &mut self,
                        value: ItemFillColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_fill_color(&mut target, value)
                    }
                    fn fill_color(&self) -> std::result::Result<ItemFillColor, JsValue> {
                        let target: Item = self.into();
                        Item::fill_color(&target)
                    }
                    fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                        let target: Item = self.into();
                        Item::export_svg(&target, options)
                    }
                    fn set_style(&mut self, value: Style) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_style(&mut target, value)
                    }
                    fn style(&self) -> std::result::Result<Style, JsValue> {
                        let target: Item = self.into();
                        Item::style(&target)
                    }
                    fn set_clip_mask(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_clip_mask(&mut target, value)
                    }
                    fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::clip_mask(&target)
                    }
                    fn set_class_name(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_class_name(&mut target, value)
                    }
                    fn class_name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::class_name(&target)
                    }
                    fn set_on_mouse_up(
                        &mut self,
                        value: ItemOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_up(&mut target, value)
                    }
                    fn on_mouse_up(&self) -> std::result::Result<ItemOnMouseUp, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_up(&target)
                    }
                    fn set_on_frame(
                        &mut self,
                        value: ItemOnFrame,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_frame(&mut target, value)
                    }
                    fn on_frame(&self) -> std::result::Result<ItemOnFrame, JsValue> {
                        let target: Item = self.into();
                        Item::on_frame(&target)
                    }
                    fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::parent_to_local(&target, point)
                    }
                    fn set_previous_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_previous_sibling(&mut target, value)
                    }
                    fn previous_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::previous_sibling(&target)
                    }
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::emit(&target, type_, event)
                    }
                    fn add_to(
                        &self,
                        owner: ItemAddToParamsOwnerParam,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::add_to(&target, owner)
                    }
                    fn has_children(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_children(&target)
                    }
                    fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::intersects(&target, item)
                    }
                    fn set_shadow_color(
                        &mut self,
                        value: ItemShadowColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_shadow_color(&mut target, value)
                    }
                    fn shadow_color(&self) -> std::result::Result<ItemShadowColor, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_color(&target)
                    }
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_scaling(&mut target, value)
                    }
                    fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::scaling(&target)
                    }
                }
                impl TextItem_Trait for TextItem
                where
                    TextItem: Item_Trait,
                {
                    fn set_font_weight(
                        &mut self,
                        value: TextItemFontWeight,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        TextItem::set_font_weight(&mut target, value)
                    }
                    fn font_weight(&self) -> std::result::Result<TextItemFontWeight, JsValue> {
                        let target = self;
                        TextItem::font_weight(&target)
                    }
                    fn set_font_size(
                        &mut self,
                        value: TextItemFontSize,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        TextItem::set_font_size(&mut target, value)
                    }
                    fn font_size(&self) -> std::result::Result<TextItemFontSize, JsValue> {
                        let target = self;
                        TextItem::font_size(&target)
                    }
                    fn set_content(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        TextItem::set_content(&mut target, value)
                    }
                    fn content(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        TextItem::content(&target)
                    }
                    fn set_font_family(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        TextItem::set_font_family(&mut target, value)
                    }
                    fn font_family(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        TextItem::font_family(&target)
                    }
                    fn set_leading(
                        &mut self,
                        value: TextItemLeading,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        TextItem::set_leading(&mut target, value)
                    }
                    fn leading(&self) -> std::result::Result<TextItemLeading, JsValue> {
                        let target = self;
                        TextItem::leading(&target)
                    }
                    fn set_justification(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        TextItem::set_justification(&mut target, value)
                    }
                    fn justification(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        TextItem::justification(&target)
                    }
                }
                impl std::clone::Clone for TextItem_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for TextItem_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for TextItem_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ToolOnKeyDown {
                    TsBindgenRtNullCase,
                    #[serde(
                        serialize_with = "ToolOnKeyDown::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "ToolOnKeyDown::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                }
                impl ToolOnKeyDown {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[wasm_bindgen(js_name = "Matrix")]
                    pub type Matrix_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clone , method , js_class = "Matrix" , catch)]
                    fn __TSB_clone(this: &Matrix_Class) -> std::result::Result<Matrix, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = prepended , method , js_class = "Matrix" , catch)]
                    fn __TSB_prepended(
                        this: &Matrix_Class,
                        matrix: Matrix,
                    ) -> std::result::Result<Matrix, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isInvertible , method , js_class = "Matrix" , catch)]
                    fn __TSB_is_invertible(
                        this: &Matrix_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = set , method , js_class = "Matrix" , catch , variadic)]
                    fn __TSB_set(
                        this: &Matrix_Class,
                        values: Box<[JsValue]>,
                    ) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = b , js_class = "Matrix")]
                    fn b(this: &Matrix_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = b , js_class = "Matrix")]
                    fn set_b(this: &Matrix_Class, value: f64) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = applyToContext , method , js_class = "Matrix" , catch)]
                    fn __TSB_apply_to_context(
                        this: &Matrix_Class,
                        ctx: web_sys::CanvasRenderingContext2d,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = invert , method , js_class = "Matrix" , catch)]
                    fn __TSB_invert(this: &Matrix_Class) -> std::result::Result<Matrix, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = scale , method , js_class = "Matrix" , catch)]
                    fn __TSB_scale(
                        this: &Matrix_Class,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = c , js_class = "Matrix")]
                    fn c(this: &Matrix_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = c , js_class = "Matrix")]
                    fn set_c(this: &Matrix_Class, value: f64) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = appended , method , js_class = "Matrix" , catch)]
                    fn __TSB_appended(
                        this: &Matrix_Class,
                        matrix: Matrix,
                    ) -> std::result::Result<Matrix, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = toString , method , js_class = "Matrix" , catch)]
                    fn __TSB_to_string(this: &Matrix_Class)
                        -> std::result::Result<String, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = rotate , method , js_class = "Matrix" , catch)]
                    fn __TSB_rotate(
                        this: &Matrix_Class,
                        angle: f64,
                        x: f64,
                        y: f64,
                    ) -> std::result::Result<Matrix, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = apply , method , js_class = "Matrix" , catch)]
                    fn __TSB_apply(
                        this: &Matrix_Class,
                        recursively: bool,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = skew , method , js_class = "Matrix" , catch)]
                    fn __TSB_skew(
                        this: &Matrix_Class,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = translate , method , js_class = "Matrix" , catch)]
                    fn __TSB_translate(
                        this: &Matrix_Class,
                        dx: f64,
                        dy: f64,
                    ) -> std::result::Result<Matrix, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = inverted , method , js_class = "Matrix" , catch)]
                    fn __TSB_inverted(this: &Matrix_Class) -> std::result::Result<Matrix, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = values , js_class = "Matrix")]
                    fn __TSB_values(this: &Matrix_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = values , js_class = "Matrix")]
                    fn __TSB_set_values(
                        this: &Matrix_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = scaling , js_class = "Matrix")]
                    fn scaling(this: &Matrix_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = scaling , js_class = "Matrix")]
                    fn set_scaling(
                        this: &Matrix_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = tx , js_class = "Matrix")]
                    fn tx(this: &Matrix_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = tx , js_class = "Matrix")]
                    fn set_tx(this: &Matrix_Class, value: f64) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isIdentity , method , js_class = "Matrix" , catch)]
                    fn __TSB_is_identity(this: &Matrix_Class)
                        -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = prepend , method , js_class = "Matrix" , catch)]
                    fn __TSB_prepend(
                        this: &Matrix_Class,
                        matrix: Matrix,
                    ) -> std::result::Result<Matrix, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = a , js_class = "Matrix")]
                    fn a(this: &Matrix_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = a , js_class = "Matrix")]
                    fn set_a(this: &Matrix_Class, value: f64) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = translation , js_class = "Matrix")]
                    fn translation(this: &Matrix_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = translation , js_class = "Matrix")]
                    fn set_translation(
                        this: &Matrix_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = transform , method , js_class = "Matrix" , catch)]
                    fn __TSB_transform(
                        this: &Matrix_Class,
                        src: JsValue,
                        dst: JsValue,
                        count: f64,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isSingular , method , js_class = "Matrix" , catch)]
                    fn __TSB_is_singular(this: &Matrix_Class)
                        -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = equals , method , js_class = "Matrix" , catch)]
                    fn __TSB_equals(
                        this: &Matrix_Class,
                        matrix: Matrix,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = shear , method , js_class = "Matrix" , catch)]
                    fn __TSB_shear(
                        this: &Matrix_Class,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = decompose , method , js_class = "Matrix" , catch)]
                    fn __TSB_decompose(
                        this: &Matrix_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = rotation , js_class = "Matrix")]
                    fn rotation(this: &Matrix_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = rotation , js_class = "Matrix")]
                    fn set_rotation(
                        this: &Matrix_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = reset , method , js_class = "Matrix" , catch)]
                    fn __TSB_reset(this: &Matrix_Class) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = inverseTransform , method , js_class = "Matrix" , catch)]
                    fn __TSB_inverse_transform(
                        this: &Matrix_Class,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    #[wasm_bindgen(constructor, js_class = "Matrix")]
                    pub fn new(matrix: Matrix) -> Matrix_Class;
                    # [wasm_bindgen (method , structural , catch , getter = ty , js_class = "Matrix")]
                    fn ty(this: &Matrix_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = ty , js_class = "Matrix")]
                    fn set_ty(this: &Matrix_Class, value: f64) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = d , js_class = "Matrix")]
                    fn d(this: &Matrix_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = d , js_class = "Matrix")]
                    fn set_d(this: &Matrix_Class, value: f64) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = append , method , js_class = "Matrix" , catch)]
                    fn __TSB_append(
                        this: &Matrix_Class,
                        matrix: Matrix,
                    ) -> std::result::Result<Matrix, JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Matrix(pub Matrix_Class);
                impl Matrix {
                    #[allow(dead_code)]
                    pub fn clone(&self) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.__TSB_clone();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn prepended(
                        &self,
                        matrix: Matrix,
                    ) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.__TSB_prepended(matrix);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_invertible(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_invertible();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set(
                        &self,
                        values: Box<[JsValue]>,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_set(values);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn b(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.b();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_b(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_b(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn apply_to_context(
                        &self,
                        ctx: web_sys::CanvasRenderingContext2d,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_apply_to_context(ctx);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn invert(&self) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.__TSB_invert();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn scale(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.__TSB_scale(hor, ver, center);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn c(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.c();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_c(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_c(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn appended(&self, matrix: Matrix) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.__TSB_appended(matrix);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.__TSB_to_string();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn rotate(
                        &self,
                        angle: f64,
                        x: f64,
                        y: f64,
                    ) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.__TSB_rotate(angle, x, y);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn apply(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_apply(recursively);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn skew(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.__TSB_skew(hor, ver, center);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn translate(
                        &self,
                        dx: f64,
                        dy: f64,
                    ) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.__TSB_translate(dx, dy);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn inverted(&self) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.__TSB_inverted();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn values(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_values()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_values(&self, value: Vec<f64>) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_values(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.scaling();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_scaling(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_scaling(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn tx(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.tx();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_tx(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_tx(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_identity(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_identity();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn prepend(&self, matrix: Matrix) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.__TSB_prepend(matrix);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn a(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.a();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_a(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_a(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn translation(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.translation();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_translation(
                        &self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_translation(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn transform(
                        &self,
                        src: Vec<f64>,
                        dst: Vec<f64>,
                        count: f64,
                    ) -> std::result::Result<Vec<f64>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self.0.__TSB_transform(
                                ts_bindgen_rt::to_jsvalue(&src)
                                    .map_err(ts_bindgen_rt::Error::from)
                                    .map_err(JsValue::from)?,
                                ts_bindgen_rt::to_jsvalue(&dst)
                                    .map_err(ts_bindgen_rt::Error::from)
                                    .map_err(JsValue::from)?,
                                count,
                            )?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_singular(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_singular();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn equals(&self, matrix: Matrix) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_equals(matrix);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn shear(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.__TSB_shear(hor, ver, center);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn decompose(&self) -> std::result::Result<JsValue, JsValue> {
                        let result = self.0.__TSB_decompose();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.rotation();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_rotation(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_rotation(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn reset(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_reset();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn inverse_transform(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_inverse_transform(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn new(matrix: Matrix) -> Matrix {
                        let result = Matrix_Class::new(matrix);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Matrix(result)
                    }
                    #[allow(dead_code)]
                    pub fn ty(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.ty();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_ty(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_ty(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn d(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.d();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_d(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_d(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn append(&self, matrix: Matrix) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.__TSB_append(matrix);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Matrix {
                    fn describe() {
                        <Matrix_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Matrix {
                    type Abi = <Matrix_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Matrix {
                    type Abi = <Matrix_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Matrix(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Matrix {
                    type Abi = <&'a Matrix_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Matrix {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Matrix {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Matrix_Class =
                            <Matrix_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait Matrix_Trait {
                    fn clone(&self) -> std::result::Result<Matrix, JsValue>;
                    fn prepended(&self, matrix: Matrix) -> std::result::Result<Matrix, JsValue>;
                    fn is_invertible(&self) -> std::result::Result<bool, JsValue>;
                    fn set(&self, values: Box<[JsValue]>) -> std::result::Result<Point, JsValue>;
                    fn set_b(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn b(&self) -> std::result::Result<f64, JsValue>;
                    fn apply_to_context(
                        &self,
                        ctx: web_sys::CanvasRenderingContext2d,
                    ) -> std::result::Result<(), JsValue>;
                    fn invert(&self) -> std::result::Result<Matrix, JsValue>;
                    fn scale(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue>;
                    fn set_c(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn c(&self) -> std::result::Result<f64, JsValue>;
                    fn appended(&self, matrix: Matrix) -> std::result::Result<Matrix, JsValue>;
                    fn to_string(&self) -> std::result::Result<String, JsValue>;
                    fn rotate(
                        &self,
                        angle: f64,
                        x: f64,
                        y: f64,
                    ) -> std::result::Result<Matrix, JsValue>;
                    fn apply(&self, recursively: bool) -> std::result::Result<bool, JsValue>;
                    fn skew(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue>;
                    fn translate(&self, dx: f64, dy: f64) -> std::result::Result<Matrix, JsValue>;
                    fn inverted(&self) -> std::result::Result<Matrix, JsValue>;
                    fn set_values(&mut self, value: Vec<f64>) -> std::result::Result<(), JsValue>;
                    fn values(&self) -> std::result::Result<Vec<f64>, JsValue>;
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn scaling(&self) -> std::result::Result<Point, JsValue>;
                    fn set_tx(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn tx(&self) -> std::result::Result<f64, JsValue>;
                    fn is_identity(&self) -> std::result::Result<bool, JsValue>;
                    fn prepend(&self, matrix: Matrix) -> std::result::Result<Matrix, JsValue>;
                    fn set_a(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn a(&self) -> std::result::Result<f64, JsValue>;
                    fn set_translation(&mut self, value: Point)
                        -> std::result::Result<(), JsValue>;
                    fn translation(&self) -> std::result::Result<Point, JsValue>;
                    fn transform(
                        &self,
                        src: Vec<f64>,
                        dst: Vec<f64>,
                        count: f64,
                    ) -> std::result::Result<Vec<f64>, JsValue>;
                    fn is_singular(&self) -> std::result::Result<bool, JsValue>;
                    fn equals(&self, matrix: Matrix) -> std::result::Result<bool, JsValue>;
                    fn shear(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue>;
                    fn decompose(&self) -> std::result::Result<JsValue, JsValue>;
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn rotation(&self) -> std::result::Result<f64, JsValue>;
                    fn reset(&self) -> std::result::Result<(), JsValue>;
                    fn inverse_transform(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    fn set_ty(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn ty(&self) -> std::result::Result<f64, JsValue>;
                    fn set_d(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn d(&self) -> std::result::Result<f64, JsValue>;
                    fn append(&self, matrix: Matrix) -> std::result::Result<Matrix, JsValue>;
                }
                impl Matrix_Trait for Matrix {
                    fn clone(&self) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Matrix::clone(&target)
                    }
                    fn prepended(&self, matrix: Matrix) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Matrix::prepended(&target, matrix)
                    }
                    fn is_invertible(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Matrix::is_invertible(&target)
                    }
                    fn set(&self, values: Box<[JsValue]>) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Matrix::set(&target, values)
                    }
                    fn set_b(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Matrix::set_b(&mut target, value)
                    }
                    fn b(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Matrix::b(&target)
                    }
                    fn apply_to_context(
                        &self,
                        ctx: web_sys::CanvasRenderingContext2d,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Matrix::apply_to_context(&target, ctx)
                    }
                    fn invert(&self) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Matrix::invert(&target)
                    }
                    fn scale(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Matrix::scale(&target, hor, ver, center)
                    }
                    fn set_c(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Matrix::set_c(&mut target, value)
                    }
                    fn c(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Matrix::c(&target)
                    }
                    fn appended(&self, matrix: Matrix) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Matrix::appended(&target, matrix)
                    }
                    fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Matrix::to_string(&target)
                    }
                    fn rotate(
                        &self,
                        angle: f64,
                        x: f64,
                        y: f64,
                    ) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Matrix::rotate(&target, angle, x, y)
                    }
                    fn apply(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Matrix::apply(&target, recursively)
                    }
                    fn skew(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Matrix::skew(&target, hor, ver, center)
                    }
                    fn translate(&self, dx: f64, dy: f64) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Matrix::translate(&target, dx, dy)
                    }
                    fn inverted(&self) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Matrix::inverted(&target)
                    }
                    fn set_values(&mut self, value: Vec<f64>) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Matrix::set_values(&mut target, value)
                    }
                    fn values(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let target = self;
                        Matrix::values(&target)
                    }
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Matrix::set_scaling(&mut target, value)
                    }
                    fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Matrix::scaling(&target)
                    }
                    fn set_tx(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Matrix::set_tx(&mut target, value)
                    }
                    fn tx(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Matrix::tx(&target)
                    }
                    fn is_identity(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Matrix::is_identity(&target)
                    }
                    fn prepend(&self, matrix: Matrix) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Matrix::prepend(&target, matrix)
                    }
                    fn set_a(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Matrix::set_a(&mut target, value)
                    }
                    fn a(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Matrix::a(&target)
                    }
                    fn set_translation(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Matrix::set_translation(&mut target, value)
                    }
                    fn translation(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Matrix::translation(&target)
                    }
                    fn transform(
                        &self,
                        src: Vec<f64>,
                        dst: Vec<f64>,
                        count: f64,
                    ) -> std::result::Result<Vec<f64>, JsValue> {
                        let target = self;
                        Matrix::transform(&target, src, dst, count)
                    }
                    fn is_singular(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Matrix::is_singular(&target)
                    }
                    fn equals(&self, matrix: Matrix) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Matrix::equals(&target, matrix)
                    }
                    fn shear(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Matrix::shear(&target, hor, ver, center)
                    }
                    fn decompose(&self) -> std::result::Result<JsValue, JsValue> {
                        let target = self;
                        Matrix::decompose(&target)
                    }
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Matrix::set_rotation(&mut target, value)
                    }
                    fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Matrix::rotation(&target)
                    }
                    fn reset(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Matrix::reset(&target)
                    }
                    fn inverse_transform(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Matrix::inverse_transform(&target, point)
                    }
                    fn set_ty(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Matrix::set_ty(&mut target, value)
                    }
                    fn ty(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Matrix::ty(&target)
                    }
                    fn set_d(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Matrix::set_d(&mut target, value)
                    }
                    fn d(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Matrix::d(&target)
                    }
                    fn append(&self, matrix: Matrix) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Matrix::append(&target, matrix)
                    }
                }
                impl std::clone::Clone for Matrix_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Matrix_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Matrix_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum CurveGetCurvatureAtParamsLocationParam {
                    CurveLocationCase(CurveLocation),
                    F64Case(f64),
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[wasm_bindgen(js_name = "Key")]
                    pub type Key_Class;
                    # [wasm_bindgen (method , structural , catch , getter = modifiers , js_class = "Key")]
                    fn __TSB_modifiers(this: &Key_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = modifiers , js_class = "Key")]
                    fn __TSB_set_modifiers(
                        this: &Key_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isDown , method , js_class = "Key" , catch)]
                    fn __TSB_is_down(
                        this: &Key_Class,
                        key: String,
                    ) -> std::result::Result<bool, JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Key(pub Key_Class);
                impl Key {
                    #[allow(dead_code)]
                    pub fn modifiers(&self) -> std::result::Result<JsValue, JsValue> {
                        let result = self.0.__TSB_modifiers();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_modifiers(
                        &self,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_modifiers(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_down(&self, key: String) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_down(key);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Key {
                    fn describe() {
                        <Key_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Key {
                    type Abi = <Key_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Key {
                    type Abi = <Key_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Key(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Key {
                    type Abi = <&'a Key_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Key {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Key {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Key_Class =
                            <Key_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait Key_Trait {
                    fn set_modifiers(&mut self, value: JsValue)
                        -> std::result::Result<(), JsValue>;
                    fn modifiers(&self) -> std::result::Result<JsValue, JsValue>;
                    fn is_down(&self, key: String) -> std::result::Result<bool, JsValue>;
                }
                impl Key_Trait for Key {
                    fn set_modifiers(
                        &mut self,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Key::set_modifiers(&mut target, value)
                    }
                    fn modifiers(&self) -> std::result::Result<JsValue, JsValue> {
                        let target = self;
                        Key::modifiers(&target)
                    }
                    fn is_down(&self, key: String) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Key::is_down(&target, key)
                    }
                }
                impl std::clone::Clone for Key_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Key_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Key_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ProjectExportSvgReturn {
                    StringCase(String),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    WebSysSvgElementCase(web_sys::SvgElement),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemOnMouseEnter {
                    TsBindgenRtNullCase,
                    #[serde(
                        serialize_with = "ItemOnMouseEnter::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "ItemOnMouseEnter::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                }
                impl ItemOnMouseEnter {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[wasm_bindgen(js_name = "Tween")]
                    pub type Tween_Class;
                    # [wasm_bindgen (method , structural , catch , getter = onUpdate , js_class = "Tween")]
                    fn __TSB_on_update(this: &Tween_Class)
                        -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onUpdate , js_class = "Tween")]
                    fn __TSB_set_on_update(
                        this: &Tween_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = then , method , js_class = "Tween" , catch)]
                    fn __TSB_then(
                        this: &Tween_Class,
                        callback: &Closure<
                            dyn Fn(
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        >,
                    ) -> std::result::Result<Tween, JsValue>;
                    #[wasm_bindgen(constructor, js_class = "Tween")]
                    pub fn new(
                        object: JsValue,
                        from: JsValue,
                        to: JsValue,
                        duration: f64,
                        easing: JsValue,
                        start: bool,
                    ) -> Tween_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = start , method , js_class = "Tween" , catch)]
                    fn __TSB_start(this: &Tween_Class) -> std::result::Result<Tween, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = stop , method , js_class = "Tween" , catch)]
                    fn __TSB_stop(this: &Tween_Class) -> std::result::Result<Tween, JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Tween(pub Tween_Class);
                impl Tween {
                    #[allow(dead_code)]
                    pub fn on_update(&self) -> std::result::Result<TweenOnUpdate, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_update()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_on_update(
                        &self,
                        value: TweenOnUpdate,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_update(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn then(
                        &self,
                        callback: &'static dyn Fn(
                            Box<[JsValue]>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Tween, JsValue> {
                        # [allow (non_snake_case)] let __TSB_Local_callback = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 : Box < [JsValue] > = Box :: new ([_Variadic0_arg0 , _Variadic1_arg0 , _Variadic2_arg0 , _Variadic3_arg0 , _Variadic4_arg0 , _Variadic5_arg0 , _Variadic6_arg0]) ; let result = callback (arg0) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let result = self.0.__TSB_then(&__TSB_Local_callback);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn new(
                        object: JsValue,
                        from: JsValue,
                        to: JsValue,
                        duration: f64,
                        easing: TweenConstructorEasingParam,
                        start: bool,
                    ) -> Tween {
                        let result = Tween_Class::new(
                            object,
                            from,
                            to,
                            duration,
                            ts_bindgen_rt::to_jsvalue(&easing).unwrap(),
                            start,
                        );
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Tween(result)
                    }
                    #[allow(dead_code)]
                    pub fn start(&self) -> std::result::Result<Tween, JsValue> {
                        let result = self.0.__TSB_start();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn stop(&self) -> std::result::Result<Tween, JsValue> {
                        let result = self.0.__TSB_stop();
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Tween {
                    fn describe() {
                        <Tween_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Tween {
                    type Abi = <Tween_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Tween {
                    type Abi = <Tween_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Tween(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Tween {
                    type Abi = <&'a Tween_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Tween {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Tween {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Tween_Class =
                            <Tween_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait Tween_Trait {
                    fn set_on_update(
                        &mut self,
                        value: TweenOnUpdate,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_update(&self) -> std::result::Result<TweenOnUpdate, JsValue>;
                    fn then(
                        &self,
                        callback: &'static dyn Fn(
                            Box<[JsValue]>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Tween, JsValue>;
                    fn start(&self) -> std::result::Result<Tween, JsValue>;
                    fn stop(&self) -> std::result::Result<Tween, JsValue>;
                }
                impl Tween_Trait for Tween {
                    fn set_on_update(
                        &mut self,
                        value: TweenOnUpdate,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Tween::set_on_update(&mut target, value)
                    }
                    fn on_update(&self) -> std::result::Result<TweenOnUpdate, JsValue> {
                        let target = self;
                        Tween::on_update(&target)
                    }
                    fn then(
                        &self,
                        callback: &'static dyn Fn(
                            Box<[JsValue]>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target = self;
                        Tween::then(&target, callback)
                    }
                    fn start(&self) -> std::result::Result<Tween, JsValue> {
                        let target = self;
                        Tween::start(&target)
                    }
                    fn stop(&self) -> std::result::Result<Tween, JsValue> {
                        let target = self;
                        Tween::stop(&target)
                    }
                }
                impl std::clone::Clone for Tween_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Tween_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Tween_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemFillColor {
                    ColorCase(Color),
                    TsBindgenRtNullCase,
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PathItemCreateReturn {
                    PathCase(Path),
                    CompoundPathCase(CompoundPath),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemAddToParamsOwnerParam {
                    CompoundPathCase(CompoundPath),
                    LayerCase(Layer),
                    GroupCase(Group),
                    ProjectCase(Project),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemOnFrame {
                    TsBindgenRtNullCase,
                    #[serde(
                        serialize_with = "ItemOnFrame::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "ItemOnFrame::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                }
                impl ItemOnFrame {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ProjectConstructorElementParam {
                    SizeCase(Size),
                    StringCase(String),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    WebSysHtmlCanvasElementCase(web_sys::HtmlCanvasElement),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewOnFrame {
                    TsBindgenRtNullCase,
                    #[serde(
                        serialize_with = "ViewOnFrame::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "ViewOnFrame::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                }
                impl ViewOnFrame {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[wasm_bindgen(js_name = "SymbolDefinition")]
                    pub type SymbolDefinition_Class;
                    #[wasm_bindgen(constructor, js_class = "SymbolDefinition")]
                    pub fn new(item: Item, dont_center: bool) -> SymbolDefinition_Class;
                    # [wasm_bindgen (method , structural , catch , getter = item , js_class = "SymbolDefinition")]
                    fn item(this: &SymbolDefinition_Class) -> std::result::Result<Item, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = item , js_class = "SymbolDefinition")]
                    fn set_item(
                        this: &SymbolDefinition_Class,
                        value: Item,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = place , method , js_class = "SymbolDefinition" , catch)]
                    fn __TSB_place(
                        this: &SymbolDefinition_Class,
                        position: Point,
                    ) -> std::result::Result<SymbolItem, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = project , js_class = "SymbolDefinition")]
                    fn project(
                        this: &SymbolDefinition_Class,
                    ) -> std::result::Result<Project, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = project , js_class = "SymbolDefinition")]
                    fn set_project(
                        this: &SymbolDefinition_Class,
                        value: Project,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = equals , method , js_class = "SymbolDefinition" , catch)]
                    fn __TSB_equals(
                        this: &SymbolDefinition_Class,
                        symbol: SymbolDefinition,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clone , method , js_class = "SymbolDefinition" , catch)]
                    fn __TSB_clone(
                        this: &SymbolDefinition_Class,
                    ) -> std::result::Result<SymbolDefinition, JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct SymbolDefinition(pub SymbolDefinition_Class);
                impl SymbolDefinition {
                    #[allow(dead_code)]
                    pub fn new(item: Item, dont_center: bool) -> SymbolDefinition {
                        let result = SymbolDefinition_Class::new(item, dont_center);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        SymbolDefinition(result)
                    }
                    #[allow(dead_code)]
                    pub fn item(&self) -> std::result::Result<Item, JsValue> {
                        let result = self.0.item();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_item(&self, value: Item) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_item(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn place(
                        &self,
                        position: Point,
                    ) -> std::result::Result<SymbolItem, JsValue> {
                        let result = self.0.__TSB_place(position);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn project(&self) -> std::result::Result<Project, JsValue> {
                        let result = self.0.project();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_project(&self, value: Project) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_project(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn equals(
                        &self,
                        symbol: SymbolDefinition,
                    ) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_equals(symbol);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn clone(&self) -> std::result::Result<SymbolDefinition, JsValue> {
                        let result = self.0.__TSB_clone();
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for SymbolDefinition {
                    fn describe() {
                        <SymbolDefinition_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for SymbolDefinition {
                    type Abi = <SymbolDefinition_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for SymbolDefinition {
                    type Abi = <SymbolDefinition_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        SymbolDefinition(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a SymbolDefinition {
                    type Abi =
                        <&'a SymbolDefinition_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for SymbolDefinition {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for SymbolDefinition {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: SymbolDefinition_Class =
                            <SymbolDefinition_Class as serde::de::Deserialize>::deserialize(
                                deserializer,
                            )?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait SymbolDefinition_Trait {
                    fn set_item(&mut self, value: Item) -> std::result::Result<(), JsValue>;
                    fn item(&self) -> std::result::Result<Item, JsValue>;
                    fn place(&self, position: Point) -> std::result::Result<SymbolItem, JsValue>;
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue>;
                    fn project(&self) -> std::result::Result<Project, JsValue>;
                    fn equals(
                        &self,
                        symbol: SymbolDefinition,
                    ) -> std::result::Result<bool, JsValue>;
                    fn clone(&self) -> std::result::Result<SymbolDefinition, JsValue>;
                }
                impl SymbolDefinition_Trait for SymbolDefinition {
                    fn set_item(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        SymbolDefinition::set_item(&mut target, value)
                    }
                    fn item(&self) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        SymbolDefinition::item(&target)
                    }
                    fn place(&self, position: Point) -> std::result::Result<SymbolItem, JsValue> {
                        let target = self;
                        SymbolDefinition::place(&target, position)
                    }
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        SymbolDefinition::set_project(&mut target, value)
                    }
                    fn project(&self) -> std::result::Result<Project, JsValue> {
                        let target = self;
                        SymbolDefinition::project(&target)
                    }
                    fn equals(
                        &self,
                        symbol: SymbolDefinition,
                    ) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        SymbolDefinition::equals(&target, symbol)
                    }
                    fn clone(&self) -> std::result::Result<SymbolDefinition, JsValue> {
                        let target = self;
                        SymbolDefinition::clone(&target)
                    }
                }
                impl std::clone::Clone for SymbolDefinition_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for SymbolDefinition_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for SymbolDefinition_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    # [wasm_bindgen (js_name = "CompoundPath" , extends = PathItem_Class , extends = Item_Class)]
                    pub type CompoundPath_Class;
                    # [wasm_bindgen (method , structural , catch , getter = firstSegment , js_class = "CompoundPath")]
                    fn first_segment(
                        this: &CompoundPath_Class,
                    ) -> std::result::Result<Segment, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = firstSegment , js_class = "CompoundPath")]
                    fn set_first_segment(
                        this: &CompoundPath_Class,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = area , js_class = "CompoundPath")]
                    fn area(this: &CompoundPath_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = area , js_class = "CompoundPath")]
                    fn set_area(
                        this: &CompoundPath_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = closed , js_class = "CompoundPath")]
                    fn closed(this: &CompoundPath_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = closed , js_class = "CompoundPath")]
                    fn set_closed(
                        this: &CompoundPath_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = curves , js_class = "CompoundPath")]
                    fn __TSB_curves(
                        this: &CompoundPath_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = curves , js_class = "CompoundPath")]
                    fn __TSB_set_curves(
                        this: &CompoundPath_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = firstCurve , js_class = "CompoundPath")]
                    fn first_curve(
                        this: &CompoundPath_Class,
                    ) -> std::result::Result<Curve, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = firstCurve , js_class = "CompoundPath")]
                    fn set_first_curve(
                        this: &CompoundPath_Class,
                        value: Curve,
                    ) -> std::result::Result<(), JsValue>;
                    #[wasm_bindgen(constructor, js_class = "CompoundPath")]
                    pub fn new(object: JsValue) -> CompoundPath_Class;
                    # [wasm_bindgen (method , structural , catch , getter = length , js_class = "CompoundPath")]
                    fn length(this: &CompoundPath_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = length , js_class = "CompoundPath")]
                    fn set_length(
                        this: &CompoundPath_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = lastCurve , js_class = "CompoundPath")]
                    fn last_curve(this: &CompoundPath_Class)
                        -> std::result::Result<Curve, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = lastCurve , js_class = "CompoundPath")]
                    fn set_last_curve(
                        this: &CompoundPath_Class,
                        value: Curve,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = lastSegment , js_class = "CompoundPath")]
                    fn last_segment(
                        this: &CompoundPath_Class,
                    ) -> std::result::Result<Segment, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = lastSegment , js_class = "CompoundPath")]
                    fn set_last_segment(
                        this: &CompoundPath_Class,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct CompoundPath(pub CompoundPath_Class);
                impl std::convert::From<&CompoundPath> for PathItem {
                    fn from(src: &CompoundPath) -> PathItem {
                        let src: &PathItem_Class = src.0.as_ref();
                        PathItem(src.clone())
                    }
                }
                impl std::convert::From<&mut CompoundPath> for PathItem {
                    fn from(src: &mut CompoundPath) -> PathItem {
                        let src: &PathItem_Class = src.0.as_ref();
                        PathItem(src.clone())
                    }
                }
                impl std::convert::From<&CompoundPath> for Item {
                    fn from(src: &CompoundPath) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl std::convert::From<&mut CompoundPath> for Item {
                    fn from(src: &mut CompoundPath) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl CompoundPath {
                    #[allow(dead_code)]
                    pub fn first_segment(&self) -> std::result::Result<Segment, JsValue> {
                        let result = self.0.first_segment();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_first_segment(
                        &self,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_first_segment(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn area(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.area();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_area(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_area(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn closed(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.closed();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_closed(&self, value: bool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_closed(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn curves(&self) -> std::result::Result<Vec<Curve>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_curves()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_curves(
                        &self,
                        value: Vec<Curve>,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_curves(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn first_curve(&self) -> std::result::Result<Curve, JsValue> {
                        let result = self.0.first_curve();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_first_curve(
                        &self,
                        value: Curve,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_first_curve(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn new(object: JsValue) -> CompoundPath {
                        let result = CompoundPath_Class::new(object);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        CompoundPath(result)
                    }
                    #[allow(dead_code)]
                    pub fn length(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.length();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_length(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_length(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn last_curve(&self) -> std::result::Result<Curve, JsValue> {
                        let result = self.0.last_curve();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_last_curve(&self, value: Curve) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_last_curve(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn last_segment(&self) -> std::result::Result<Segment, JsValue> {
                        let result = self.0.last_segment();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_last_segment(
                        &self,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_last_segment(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for CompoundPath {
                    fn describe() {
                        <CompoundPath_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for CompoundPath {
                    type Abi = <CompoundPath_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for CompoundPath {
                    type Abi = <CompoundPath_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        CompoundPath(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a CompoundPath {
                    type Abi = <&'a CompoundPath_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for CompoundPath {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for CompoundPath {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: CompoundPath_Class =
                            <CompoundPath_Class as serde::de::Deserialize>::deserialize(
                                deserializer,
                            )?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait CompoundPath_Trait: PathItem_Trait {
                    fn set_first_segment(
                        &mut self,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue>;
                    fn first_segment(&self) -> std::result::Result<Segment, JsValue>;
                    fn set_area(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn area(&self) -> std::result::Result<f64, JsValue>;
                    fn set_closed(&mut self, value: bool) -> std::result::Result<(), JsValue>;
                    fn closed(&self) -> std::result::Result<bool, JsValue>;
                    fn set_curves(&mut self, value: Vec<Curve>)
                        -> std::result::Result<(), JsValue>;
                    fn curves(&self) -> std::result::Result<Vec<Curve>, JsValue>;
                    fn set_first_curve(&mut self, value: Curve)
                        -> std::result::Result<(), JsValue>;
                    fn first_curve(&self) -> std::result::Result<Curve, JsValue>;
                    fn set_length(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn length(&self) -> std::result::Result<f64, JsValue>;
                    fn set_last_curve(&mut self, value: Curve) -> std::result::Result<(), JsValue>;
                    fn last_curve(&self) -> std::result::Result<Curve, JsValue>;
                    fn set_last_segment(
                        &mut self,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue>;
                    fn last_segment(&self) -> std::result::Result<Segment, JsValue>;
                }
                impl PathItem_Trait for CompoundPath
                where
                    CompoundPath: Item_Trait,
                {
                    fn reverse(&self) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::reverse(&target)
                    }
                    fn get_nearest_location(
                        &self,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::get_nearest_location(&target, point)
                    }
                    fn smooth(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::smooth(&target, options)
                    }
                    fn arc_to(
                        &self,
                        to: Point,
                        clockwise: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::arc_to(&target, to, clockwise)
                    }
                    fn line_to(&self, point: Point) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::line_to(&target, point)
                    }
                    fn cubic_curve_by(
                        &self,
                        handle1: Point,
                        handle2: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::cubic_curve_by(&target, handle1, handle2, to)
                    }
                    fn divide(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::divide(&target, path, options)
                    }
                    fn quadratic_curve_by(
                        &self,
                        handle: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::quadratic_curve_by(&target, handle, to)
                    }
                    fn create(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<PathItemCreateReturn, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::create(&target, object)
                    }
                    fn interpolate(
                        &self,
                        from: PathItem,
                        to: PathItem,
                        factor: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::interpolate(&target, from, to, factor)
                    }
                    fn set_clockwise(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: PathItem = self.into();
                        PathItem::set_clockwise(&mut target, value)
                    }
                    fn clockwise(&self) -> std::result::Result<bool, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::clockwise(&target)
                    }
                    fn set_path_data(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target: PathItem = self.into();
                        PathItem::set_path_data(&mut target, value)
                    }
                    fn path_data(&self) -> std::result::Result<String, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::path_data(&target)
                    }
                    fn curve_to(
                        &self,
                        through: Point,
                        to: Point,
                        time: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::curve_to(&target, through, to, time)
                    }
                    fn move_to(&self, point: Point) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::move_to(&target, point)
                    }
                    fn get_crossings(
                        &self,
                        path: PathItem,
                    ) -> std::result::Result<Vec<CurveLocation>, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::get_crossings(&target, path)
                    }
                    fn close_path(&self) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::close_path(&target)
                    }
                    fn reorient(
                        &self,
                        non_zero: bool,
                        clockwise: bool,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::reorient(&target, non_zero, clockwise)
                    }
                    fn move_by(&self, to: Point) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::move_by(&target, to)
                    }
                    fn quadratic_curve_to(
                        &self,
                        handle: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::quadratic_curve_to(&target, handle, to)
                    }
                    fn cubic_curve_to(
                        &self,
                        handle1: Point,
                        handle2: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::cubic_curve_to(&target, handle1, handle2, to)
                    }
                    fn get_intersections(
                        &self,
                        path: PathItem,
                        include: &'static dyn Fn(
                            Box<[JsValue]>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Vec<CurveLocation>, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::get_intersections(&target, path, include)
                    }
                    fn compare(&self, path: PathItem) -> std::result::Result<bool, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::compare(&target, path)
                    }
                    fn set_interior_point(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: PathItem = self.into();
                        PathItem::set_interior_point(&mut target, value)
                    }
                    fn interior_point(&self) -> std::result::Result<Point, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::interior_point(&target)
                    }
                    fn simplify(&self, tolerance: f64) -> std::result::Result<bool, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::simplify(&target, tolerance)
                    }
                    fn arc_by(
                        &self,
                        to: Point,
                        clockwise: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::arc_by(&target, to, clockwise)
                    }
                    fn intersect(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::intersect(&target, path, options)
                    }
                    fn get_nearest_point(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::get_nearest_point(&target, point)
                    }
                    fn curve_by(
                        &self,
                        through: Point,
                        to: Point,
                        time: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::curve_by(&target, through, to, time)
                    }
                    fn exclude(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::exclude(&target, path, options)
                    }
                    fn line_by(&self, point: Point) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::line_by(&target, point)
                    }
                    fn unite(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::unite(&target, path, options)
                    }
                    fn subtract(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::subtract(&target, path, options)
                    }
                    fn flatten(&self, flatness: f64) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::flatten(&target, flatness)
                    }
                }
                impl Item_Trait for CompoundPath {
                    fn set_stroke_scaling(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_scaling(&mut target, value)
                    }
                    fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_scaling(&target)
                    }
                    fn set_apply_matrix(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_apply_matrix(&mut target, value)
                    }
                    fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::apply_matrix(&target)
                    }
                    fn set_view_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_view_matrix(&mut target, value)
                    }
                    fn view_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::view_matrix(&target)
                    }
                    fn set_dash_array(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_dash_array(&mut target, value)
                    }
                    fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let target: Item = self.into();
                        Item::dash_array(&target)
                    }
                    fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_ancestor(&target, item)
                    }
                    fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_descendant(&target, item)
                    }
                    fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_sibling(&target, item)
                    }
                    fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_parent(&target, point)
                    }
                    fn set_shadow_blur(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_shadow_blur(&mut target, value)
                    }
                    fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_blur(&target)
                    }
                    fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_empty(&target, recursively)
                    }
                    fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_parent(&target, item)
                    }
                    fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_below(&target, item)
                    }
                    fn set_matrix(&mut self, value: Matrix) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_matrix(&mut target, value)
                    }
                    fn matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::matrix(&target)
                    }
                    fn export_json(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::export_json(&target, options)
                    }
                    fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::global_to_local(&target, point)
                    }
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ItemOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_drag(&mut target, value)
                    }
                    fn on_mouse_drag(&self) -> std::result::Result<ItemOnMouseDrag, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_drag(&target)
                    }
                    fn get_item(
                        &self,
                        options: ItemGetItemParamsOptionsParam,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::get_item(&target, options)
                    }
                    fn remove_children(
                        &self,
                        start: f64,
                        end: f64,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::remove_children(&target, start, end)
                    }
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_project(&mut target, value)
                    }
                    fn project(&self) -> std::result::Result<Project, JsValue> {
                        let target: Item = self.into();
                        Item::project(&target)
                    }
                    fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_data(&mut target, value)
                    }
                    fn data(&self) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::data(&target)
                    }
                    fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_above(&target, item)
                    }
                    fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on(&target, options)
                    }
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::transform(&target, matrix)
                    }
                    fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inserted(&target)
                    }
                    fn set_on_mouse_down(
                        &mut self,
                        value: ItemOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_down(&mut target, value)
                    }
                    fn on_mouse_down(&self) -> std::result::Result<ItemOnMouseDown, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_down(&target)
                    }
                    fn set_last_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_last_child(&mut target, value)
                    }
                    fn last_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::last_child(&target)
                    }
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_selected(&mut target, value)
                    }
                    fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::selected(&target)
                    }
                    fn set_global_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_global_matrix(&mut target, value)
                    }
                    fn global_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::global_matrix(&target)
                    }
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::responds(&target, type_)
                    }
                    fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::rotate(&target, angle, center)
                    }
                    fn tween(
                        &self,
                        options: ItemTweenParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween(&target, options)
                    }
                    fn set_on_mouse_enter(
                        &mut self,
                        value: ItemOnMouseEnter,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_enter(&mut target, value)
                    }
                    fn on_mouse_enter(&self) -> std::result::Result<ItemOnMouseEnter, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_enter(&target)
                    }
                    fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_id(&mut target, value)
                    }
                    fn id(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::id(&target)
                    }
                    fn on(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::on(&target, object)
                    }
                    fn tween_to(
                        &self,
                        to: JsValue,
                        options: ItemTweenToParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_to(&target, to, options)
                    }
                    fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_locked(&mut target, value)
                    }
                    fn locked(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::locked(&target)
                    }
                    fn set_children(
                        &mut self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_children(&mut target, value)
                    }
                    fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::children(&target)
                    }
                    fn copy_attributes(
                        &self,
                        source: Item,
                        exclude_matrix: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_attributes(&target, source, exclude_matrix)
                    }
                    fn off(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::off(&target, object)
                    }
                    fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::contains(&target, point)
                    }
                    fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_stroke(&target)
                    }
                    fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_move(&target)
                    }
                    fn add_children(
                        &self,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::add_children(&target, items)
                    }
                    fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::reverse_children(&target)
                    }
                    fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_shadow(&target)
                    }
                    fn set_dash_offset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_dash_offset(&mut target, value)
                    }
                    fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::dash_offset(&target)
                    }
                    fn set_on_mouse_leave(
                        &mut self,
                        value: ItemOnMouseLeave,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_leave(&mut target, value)
                    }
                    fn on_mouse_leave(&self) -> std::result::Result<ItemOnMouseLeave, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_leave(&target)
                    }
                    fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test_all(&target, point, options)
                    }
                    fn set_stroke_cap(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_cap(&mut target, value)
                    }
                    fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_cap(&target)
                    }
                    fn set_internal_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_internal_bounds(&mut target, value)
                    }
                    fn internal_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::internal_bounds(&target)
                    }
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_index(&mut target, value)
                    }
                    fn index(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::index(&target)
                    }
                    fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::reduce(&target, options)
                    }
                    fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_grouped_with(&target, item)
                    }
                    fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_global(&target, point)
                    }
                    fn set_first_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_first_child(&mut target, value)
                    }
                    fn first_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::first_child(&target)
                    }
                    fn set_position(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_position(&mut target, value)
                    }
                    fn position(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::position(&target)
                    }
                    fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_opacity(&mut target, value)
                    }
                    fn opacity(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::opacity(&target)
                    }
                    fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_down(&target)
                    }
                    fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_drag(&target)
                    }
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_bounds(&mut target, value)
                    }
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::bounds(&target)
                    }
                    fn set_parent(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_parent(&mut target, value)
                    }
                    fn parent(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::parent(&target)
                    }
                    fn get_items(
                        &self,
                        options: ItemGetItemsParamsOptionsParam,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::get_items(&target, options)
                    }
                    fn copy_to(
                        &self,
                        owner: ItemCopyToParamsOwnerParam,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::copy_to(&target, owner)
                    }
                    fn set_on_double_click(
                        &mut self,
                        value: ItemOnDoubleClick,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_double_click(&mut target, value)
                    }
                    fn on_double_click(&self) -> std::result::Result<ItemOnDoubleClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_double_click(&target)
                    }
                    fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::set(&target, props)
                    }
                    fn scale(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::scale(&target, hor, ver, center)
                    }
                    fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_below(&target, item)
                    }
                    fn set_next_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_next_sibling(&mut target, value)
                    }
                    fn next_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::next_sibling(&target)
                    }
                    fn rasterize(&self, options: JsValue) -> std::result::Result<Raster, JsValue> {
                        let target: Item = self.into();
                        Item::rasterize(&target, options)
                    }
                    fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::bring_to_front(&target)
                    }
                    fn matches(
                        &self,
                        name: String,
                        compare: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::matches(&target, name, compare)
                    }
                    fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_fill(&target)
                    }
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_view(&mut target, value)
                    }
                    fn view(&self) -> std::result::Result<View, JsValue> {
                        let target: Item = self.into();
                        Item::view(&target)
                    }
                    fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::clone(&target, options)
                    }
                    fn set_handle_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_handle_bounds(&mut target, value)
                    }
                    fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::handle_bounds(&target)
                    }
                    fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inside(&target, rect)
                    }
                    fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_above(&target, item)
                    }
                    fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::remove(&target)
                    }
                    fn set_stroke_join(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_join(&mut target, value)
                    }
                    fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_join(&target)
                    }
                    fn set_on_click(
                        &mut self,
                        value: ItemOnClick,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_click(&mut target, value)
                    }
                    fn on_click(&self) -> std::result::Result<ItemOnClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_click(&target)
                    }
                    fn fit_bounds(
                        &self,
                        rectangle: Rectangle,
                        fill: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::fit_bounds(&target, rectangle, fill)
                    }
                    fn set_blend_mode(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_blend_mode(&mut target, value)
                    }
                    fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::blend_mode(&target)
                    }
                    fn set_stroke_width(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_width(&mut target, value)
                    }
                    fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_width(&target)
                    }
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_rotation(&mut target, value)
                    }
                    fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::rotation(&target)
                    }
                    fn set_selected_color(
                        &mut self,
                        value: ItemSelectedColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_selected_color(&mut target, value)
                    }
                    fn selected_color(&self) -> std::result::Result<ItemSelectedColor, JsValue> {
                        let target: Item = self.into();
                        Item::selected_color(&target)
                    }
                    fn skew(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::skew(&target, hor, ver, center)
                    }
                    fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_name(&mut target, value)
                    }
                    fn name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::name(&target)
                    }
                    fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_json(&target, json)
                    }
                    fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::add_child(&target, item)
                    }
                    fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_visible(&mut target, value)
                    }
                    fn visible(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::visible(&target)
                    }
                    fn set_fill_rule(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_fill_rule(&mut target, value)
                    }
                    fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::fill_rule(&target)
                    }
                    fn set_layer(&mut self, value: Layer) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_layer(&mut target, value)
                    }
                    fn layer(&self) -> std::result::Result<Layer, JsValue> {
                        let target: Item = self.into();
                        Item::layer(&target)
                    }
                    fn tween_from(
                        &self,
                        from: JsValue,
                        options: ItemTweenFromParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_from(&target, from, options)
                    }
                    fn insert_child(
                        &self,
                        index: f64,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_child(&target, index, item)
                    }
                    fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_up(&target)
                    }
                    fn set_pivot(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_pivot(&mut target, value)
                    }
                    fn pivot(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::pivot(&target)
                    }
                    fn set_miter_limit(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_miter_limit(&mut target, value)
                    }
                    fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::miter_limit(&target)
                    }
                    fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_content(&target, source)
                    }
                    fn import_svg(
                        &self,
                        svg: ItemImportSvgParamsSvgParam,
                        on_load: &'static dyn Fn(
                            Box<[JsValue]>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_svg(&target, svg, on_load)
                    }
                    fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::send_to_back(&target)
                    }
                    fn set_stroke_color(
                        &mut self,
                        value: ItemStrokeColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_color(&mut target, value)
                    }
                    fn stroke_color(&self) -> std::result::Result<ItemStrokeColor, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_color(&target)
                    }
                    fn set_on_mouse_move(
                        &mut self,
                        value: ItemOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_move(&mut target, value)
                    }
                    fn on_mouse_move(&self) -> std::result::Result<ItemOnMouseMove, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_move(&target)
                    }
                    fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::replace_with(&target, item)
                    }
                    fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test(&target, point, options)
                    }
                    fn shear(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::shear(&target, hor, ver, center)
                    }
                    fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::translate(&target, delta)
                    }
                    fn set_stroke_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_bounds(&mut target, value)
                    }
                    fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_bounds(&target)
                    }
                    fn insert_children(
                        &self,
                        index: f64,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::insert_children(&target, index, items)
                    }
                    fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_child(&target, item)
                    }
                    fn set_shadow_offset(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_shadow_offset(&mut target, value)
                    }
                    fn shadow_offset(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_offset(&target)
                    }
                    fn set_fill_color(
                        &mut self,
                        value: ItemFillColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_fill_color(&mut target, value)
                    }
                    fn fill_color(&self) -> std::result::Result<ItemFillColor, JsValue> {
                        let target: Item = self.into();
                        Item::fill_color(&target)
                    }
                    fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                        let target: Item = self.into();
                        Item::export_svg(&target, options)
                    }
                    fn set_style(&mut self, value: Style) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_style(&mut target, value)
                    }
                    fn style(&self) -> std::result::Result<Style, JsValue> {
                        let target: Item = self.into();
                        Item::style(&target)
                    }
                    fn set_clip_mask(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_clip_mask(&mut target, value)
                    }
                    fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::clip_mask(&target)
                    }
                    fn set_class_name(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_class_name(&mut target, value)
                    }
                    fn class_name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::class_name(&target)
                    }
                    fn set_on_mouse_up(
                        &mut self,
                        value: ItemOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_up(&mut target, value)
                    }
                    fn on_mouse_up(&self) -> std::result::Result<ItemOnMouseUp, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_up(&target)
                    }
                    fn set_on_frame(
                        &mut self,
                        value: ItemOnFrame,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_frame(&mut target, value)
                    }
                    fn on_frame(&self) -> std::result::Result<ItemOnFrame, JsValue> {
                        let target: Item = self.into();
                        Item::on_frame(&target)
                    }
                    fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::parent_to_local(&target, point)
                    }
                    fn set_previous_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_previous_sibling(&mut target, value)
                    }
                    fn previous_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::previous_sibling(&target)
                    }
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::emit(&target, type_, event)
                    }
                    fn add_to(
                        &self,
                        owner: ItemAddToParamsOwnerParam,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::add_to(&target, owner)
                    }
                    fn has_children(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_children(&target)
                    }
                    fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::intersects(&target, item)
                    }
                    fn set_shadow_color(
                        &mut self,
                        value: ItemShadowColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_shadow_color(&mut target, value)
                    }
                    fn shadow_color(&self) -> std::result::Result<ItemShadowColor, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_color(&target)
                    }
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_scaling(&mut target, value)
                    }
                    fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::scaling(&target)
                    }
                }
                impl CompoundPath_Trait for CompoundPath
                where
                    CompoundPath: PathItem_Trait,
                {
                    fn set_first_segment(
                        &mut self,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        CompoundPath::set_first_segment(&mut target, value)
                    }
                    fn first_segment(&self) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        CompoundPath::first_segment(&target)
                    }
                    fn set_area(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        CompoundPath::set_area(&mut target, value)
                    }
                    fn area(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        CompoundPath::area(&target)
                    }
                    fn set_closed(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        CompoundPath::set_closed(&mut target, value)
                    }
                    fn closed(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        CompoundPath::closed(&target)
                    }
                    fn set_curves(
                        &mut self,
                        value: Vec<Curve>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        CompoundPath::set_curves(&mut target, value)
                    }
                    fn curves(&self) -> std::result::Result<Vec<Curve>, JsValue> {
                        let target = self;
                        CompoundPath::curves(&target)
                    }
                    fn set_first_curve(
                        &mut self,
                        value: Curve,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        CompoundPath::set_first_curve(&mut target, value)
                    }
                    fn first_curve(&self) -> std::result::Result<Curve, JsValue> {
                        let target = self;
                        CompoundPath::first_curve(&target)
                    }
                    fn set_length(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        CompoundPath::set_length(&mut target, value)
                    }
                    fn length(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        CompoundPath::length(&target)
                    }
                    fn set_last_curve(&mut self, value: Curve) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        CompoundPath::set_last_curve(&mut target, value)
                    }
                    fn last_curve(&self) -> std::result::Result<Curve, JsValue> {
                        let target = self;
                        CompoundPath::last_curve(&target)
                    }
                    fn set_last_segment(
                        &mut self,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        CompoundPath::set_last_segment(&mut target, value)
                    }
                    fn last_segment(&self) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        CompoundPath::last_segment(&target)
                    }
                }
                impl std::clone::Clone for CompoundPath_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for CompoundPath_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for CompoundPath_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewOnMouseUp {
                    TsBindgenRtNullCase,
                    #[serde(
                        serialize_with = "ViewOnMouseUp::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "ViewOnMouseUp::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                }
                impl ViewOnMouseUp {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[wasm_bindgen(js_name = "Curve")]
                    pub type Curve_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getWeightedNormalAtTime , method , js_class = "Curve" , catch)]
                    fn __TSB_get_weighted_normal_at_time(
                        this: &Curve_Class,
                        time: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getLocationAt , method , js_class = "Curve" , catch)]
                    fn __TSB_get_location_at(
                        this: &Curve_Class,
                        offset: f64,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getCurvatureAt , method , js_class = "Curve" , catch)]
                    fn __TSB_get_curvature_at(
                        this: &Curve_Class,
                        location: JsValue,
                    ) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = next , js_class = "Curve")]
                    fn next(this: &Curve_Class) -> std::result::Result<Curve, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = next , js_class = "Curve")]
                    fn set_next(
                        this: &Curve_Class,
                        value: Curve,
                    ) -> std::result::Result<(), JsValue>;
                    #[wasm_bindgen(constructor, js_class = "Curve")]
                    pub fn new(
                        point1: Point,
                        handle1: Point,
                        handle2: Point,
                        point2: Point,
                    ) -> Curve_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getTangentAt , method , js_class = "Curve" , catch)]
                    fn __TSB_get_tangent_at(
                        this: &Curve_Class,
                        location: JsValue,
                    ) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = values , js_class = "Curve")]
                    fn __TSB_values(this: &Curve_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = values , js_class = "Curve")]
                    fn __TSB_set_values(
                        this: &Curve_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = handle1 , js_class = "Curve")]
                    fn handle1(this: &Curve_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = handle1 , js_class = "Curve")]
                    fn set_handle1(
                        this: &Curve_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = index , js_class = "Curve")]
                    fn index(this: &Curve_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = index , js_class = "Curve")]
                    fn set_index(
                        this: &Curve_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = segment1 , js_class = "Curve")]
                    fn segment1(this: &Curve_Class) -> std::result::Result<Segment, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = segment1 , js_class = "Curve")]
                    fn set_segment1(
                        this: &Curve_Class,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = remove , method , js_class = "Curve" , catch)]
                    fn __TSB_remove(this: &Curve_Class) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getWeightedTangentAtTime , method , js_class = "Curve" , catch)]
                    fn __TSB_get_weighted_tangent_at_time(
                        this: &Curve_Class,
                        time: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getCurvatureAtTime , method , js_class = "Curve" , catch)]
                    fn __TSB_get_curvature_at_time(
                        this: &Curve_Class,
                        time: f64,
                    ) -> std::result::Result<f64, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getTimeOf , method , js_class = "Curve" , catch)]
                    fn __TSB_get_time_of(
                        this: &Curve_Class,
                        point: Point,
                    ) -> std::result::Result<f64, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getIntersections , method , js_class = "Curve" , catch)]
                    fn __TSB_get_intersections(
                        this: &Curve_Class,
                        curve: Curve,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getTimesWithTangent , method , js_class = "Curve" , catch)]
                    fn __TSB_get_times_with_tangent(
                        this: &Curve_Class,
                        tangent: Point,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getOffsetAtTime , method , js_class = "Curve" , catch)]
                    fn __TSB_get_offset_at_time(
                        this: &Curve_Class,
                        time: f64,
                    ) -> std::result::Result<f64, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isStraight , method , js_class = "Curve" , catch)]
                    fn __TSB_is_straight(this: &Curve_Class) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getOffsetOf , method , js_class = "Curve" , catch)]
                    fn __TSB_get_offset_of(
                        this: &Curve_Class,
                        point: Point,
                    ) -> std::result::Result<f64, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isLinear , method , js_class = "Curve" , catch)]
                    fn __TSB_is_linear(this: &Curve_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = path , js_class = "Curve")]
                    fn path(this: &Curve_Class) -> std::result::Result<Path, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = path , js_class = "Curve")]
                    fn set_path(
                        this: &Curve_Class,
                        value: Path,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = previous , js_class = "Curve")]
                    fn previous(this: &Curve_Class) -> std::result::Result<Curve, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = previous , js_class = "Curve")]
                    fn set_previous(
                        this: &Curve_Class,
                        value: Curve,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = hasHandles , method , js_class = "Curve" , catch)]
                    fn __TSB_has_handles(this: &Curve_Class) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = divideAt , method , js_class = "Curve" , catch)]
                    fn __TSB_divide_at(
                        this: &Curve_Class,
                        location: JsValue,
                    ) -> std::result::Result<Curve, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = strokeBounds , js_class = "Curve")]
                    fn stroke_bounds(this: &Curve_Class)
                        -> std::result::Result<Rectangle, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = strokeBounds , js_class = "Curve")]
                    fn set_stroke_bounds(
                        this: &Curve_Class,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = points , js_class = "Curve")]
                    fn __TSB_points(this: &Curve_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = points , js_class = "Curve")]
                    fn __TSB_set_points(
                        this: &Curve_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clearHandles , method , js_class = "Curve" , catch)]
                    fn __TSB_clear_handles(this: &Curve_Class) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = reversed , method , js_class = "Curve" , catch)]
                    fn __TSB_reversed(this: &Curve_Class) -> std::result::Result<Curve, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = splitAt , method , js_class = "Curve" , catch)]
                    fn __TSB_split_at(
                        this: &Curve_Class,
                        location: JsValue,
                    ) -> std::result::Result<Path, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isFirst , method , js_class = "Curve" , catch)]
                    fn __TSB_is_first(this: &Curve_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = point2 , js_class = "Curve")]
                    fn point2(this: &Curve_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = point2 , js_class = "Curve")]
                    fn set_point2(
                        this: &Curve_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getLocationOf , method , js_class = "Curve" , catch)]
                    fn __TSB_get_location_of(
                        this: &Curve_Class,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = bounds , js_class = "Curve")]
                    fn bounds(this: &Curve_Class) -> std::result::Result<Rectangle, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = bounds , js_class = "Curve")]
                    fn set_bounds(
                        this: &Curve_Class,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getWeightedTangentAt , method , js_class = "Curve" , catch)]
                    fn __TSB_get_weighted_tangent_at(
                        this: &Curve_Class,
                        location: JsValue,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getNormalAt , method , js_class = "Curve" , catch)]
                    fn __TSB_get_normal_at(
                        this: &Curve_Class,
                        location: JsValue,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getTimeAt , method , js_class = "Curve" , catch)]
                    fn __TSB_get_time_at(
                        this: &Curve_Class,
                        offset: f64,
                        start: f64,
                    ) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = area , js_class = "Curve")]
                    fn area(this: &Curve_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = area , js_class = "Curve")]
                    fn set_area(this: &Curve_Class, value: f64)
                        -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getNormalAtTime , method , js_class = "Curve" , catch)]
                    fn __TSB_get_normal_at_time(
                        this: &Curve_Class,
                        time: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = selected , js_class = "Curve")]
                    fn selected(this: &Curve_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = selected , js_class = "Curve")]
                    fn set_selected(
                        this: &Curve_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = toString , method , js_class = "Curve" , catch)]
                    fn __TSB_to_string(this: &Curve_Class) -> std::result::Result<String, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getWeightedNormalAt , method , js_class = "Curve" , catch)]
                    fn __TSB_get_weighted_normal_at(
                        this: &Curve_Class,
                        location: JsValue,
                    ) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = handleBounds , js_class = "Curve")]
                    fn handle_bounds(this: &Curve_Class)
                        -> std::result::Result<Rectangle, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = handleBounds , js_class = "Curve")]
                    fn set_handle_bounds(
                        this: &Curve_Class,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isCollinear , method , js_class = "Curve" , catch)]
                    fn __TSB_is_collinear(
                        this: &Curve_Class,
                        curve: Curve,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = segment2 , js_class = "Curve")]
                    fn segment2(this: &Curve_Class) -> std::result::Result<Segment, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = segment2 , js_class = "Curve")]
                    fn set_segment2(
                        this: &Curve_Class,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getPointAtTime , method , js_class = "Curve" , catch)]
                    fn __TSB_get_point_at_time(
                        this: &Curve_Class,
                        time: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getLocationAtTime , method , js_class = "Curve" , catch)]
                    fn __TSB_get_location_at_time(
                        this: &Curve_Class,
                        time: f64,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = point1 , js_class = "Curve")]
                    fn point1(this: &Curve_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = point1 , js_class = "Curve")]
                    fn set_point1(
                        this: &Curve_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = classify , method , js_class = "Curve" , catch)]
                    fn __TSB_classify(this: &Curve_Class) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isVertical , method , js_class = "Curve" , catch)]
                    fn __TSB_is_vertical(this: &Curve_Class) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isHorizontal , method , js_class = "Curve" , catch)]
                    fn __TSB_is_horizontal(
                        this: &Curve_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = length , js_class = "Curve")]
                    fn length(this: &Curve_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = length , js_class = "Curve")]
                    fn set_length(
                        this: &Curve_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getPointAt , method , js_class = "Curve" , catch)]
                    fn __TSB_get_point_at(
                        this: &Curve_Class,
                        location: JsValue,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = splitAtTime , method , js_class = "Curve" , catch)]
                    fn __TSB_split_at_time(
                        this: &Curve_Class,
                        time: f64,
                    ) -> std::result::Result<Path, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = divideAtTime , method , js_class = "Curve" , catch)]
                    fn __TSB_divide_at_time(
                        this: &Curve_Class,
                        time: f64,
                    ) -> std::result::Result<Curve, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clone , method , js_class = "Curve" , catch)]
                    fn __TSB_clone(this: &Curve_Class) -> std::result::Result<Curve, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isLast , method , js_class = "Curve" , catch)]
                    fn __TSB_is_last(this: &Curve_Class) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getPart , method , js_class = "Curve" , catch)]
                    fn __TSB_get_part(
                        this: &Curve_Class,
                        from: f64,
                        to: f64,
                    ) -> std::result::Result<Curve, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getNearestPoint , method , js_class = "Curve" , catch)]
                    fn __TSB_get_nearest_point(
                        this: &Curve_Class,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = hasLength , method , js_class = "Curve" , catch)]
                    fn __TSB_has_length(
                        this: &Curve_Class,
                        epsilon: f64,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getNearestLocation , method , js_class = "Curve" , catch)]
                    fn __TSB_get_nearest_location(
                        this: &Curve_Class,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = handle2 , js_class = "Curve")]
                    fn handle2(this: &Curve_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = handle2 , js_class = "Curve")]
                    fn set_handle2(
                        this: &Curve_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getTangentAtTime , method , js_class = "Curve" , catch)]
                    fn __TSB_get_tangent_at_time(
                        this: &Curve_Class,
                        time: f64,
                    ) -> std::result::Result<Point, JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Curve(pub Curve_Class);
                impl Curve {
                    #[allow(dead_code)]
                    pub fn get_weighted_normal_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_get_weighted_normal_at_time(time);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_location_at(
                        &self,
                        offset: f64,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let result = self.0.__TSB_get_location_at(offset);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_curvature_at(
                        &self,
                        location: CurveGetCurvatureAtParamsLocationParam,
                    ) -> std::result::Result<f64, JsValue> {
                        let result = self.0.__TSB_get_curvature_at(
                            ts_bindgen_rt::to_jsvalue(&location)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn next(&self) -> std::result::Result<Curve, JsValue> {
                        let result = self.0.next();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_next(&self, value: Curve) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_next(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn new(
                        point1: Point,
                        handle1: Point,
                        handle2: Point,
                        point2: Point,
                    ) -> Curve {
                        let result = Curve_Class::new(point1, handle1, handle2, point2);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Curve(result)
                    }
                    #[allow(dead_code)]
                    pub fn get_tangent_at(
                        &self,
                        location: CurveGetTangentAtParamsLocationParam,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_get_tangent_at(
                            ts_bindgen_rt::to_jsvalue(&location)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn values(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_values()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_values(&self, value: Vec<f64>) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_values(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn handle1(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.handle1();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_handle1(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_handle1(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn index(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.index();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_index(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_index(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn segment1(&self) -> std::result::Result<Segment, JsValue> {
                        let result = self.0.segment1();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_segment1(&self, value: Segment) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_segment1(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_remove();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_weighted_tangent_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_get_weighted_tangent_at_time(time);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_curvature_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<f64, JsValue> {
                        let result = self.0.__TSB_get_curvature_at_time(time);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_time_of(&self, point: Point) -> std::result::Result<f64, JsValue> {
                        let result = self.0.__TSB_get_time_of(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_intersections(
                        &self,
                        curve: Curve,
                    ) -> std::result::Result<Vec<CurveLocation>, JsValue> {
                        let result =
                            ts_bindgen_rt::from_jsvalue(&self.0.__TSB_get_intersections(curve)?)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_times_with_tangent(
                        &self,
                        tangent: Point,
                    ) -> std::result::Result<Vec<f64>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self.0.__TSB_get_times_with_tangent(tangent)?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_offset_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<f64, JsValue> {
                        let result = self.0.__TSB_get_offset_at_time(time);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_straight(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_straight();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_offset_of(&self, point: Point) -> std::result::Result<f64, JsValue> {
                        let result = self.0.__TSB_get_offset_of(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_linear(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_linear();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn path(&self) -> std::result::Result<Path, JsValue> {
                        let result = self.0.path();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_path(&self, value: Path) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_path(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn previous(&self) -> std::result::Result<Curve, JsValue> {
                        let result = self.0.previous();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_previous(&self, value: Curve) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_previous(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_has_handles();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn divide_at(
                        &self,
                        location: CurveDivideAtParamsLocationParam,
                    ) -> std::result::Result<Curve, JsValue> {
                        let result = self.0.__TSB_divide_at(
                            ts_bindgen_rt::to_jsvalue(&location)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let result = self.0.stroke_bounds();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_stroke_bounds(
                        &self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_stroke_bounds(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn points(&self) -> std::result::Result<Vec<Point>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_points()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_points(
                        &self,
                        value: Vec<Point>,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_points(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_clear_handles();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn reversed(&self) -> std::result::Result<Curve, JsValue> {
                        let result = self.0.__TSB_reversed();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn split_at(
                        &self,
                        location: CurveSplitAtParamsLocationParam,
                    ) -> std::result::Result<Path, JsValue> {
                        let result = self.0.__TSB_split_at(
                            ts_bindgen_rt::to_jsvalue(&location)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_first(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_first();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn point2(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.point2();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_point2(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_point2(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_location_of(
                        &self,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let result = self.0.__TSB_get_location_of(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let result = self.0.bounds();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_bounds(&self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_bounds(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_weighted_tangent_at(
                        &self,
                        location: CurveGetWeightedTangentAtParamsLocationParam,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_get_weighted_tangent_at(
                            ts_bindgen_rt::to_jsvalue(&location)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_normal_at(
                        &self,
                        location: CurveGetNormalAtParamsLocationParam,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_get_normal_at(
                            ts_bindgen_rt::to_jsvalue(&location)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_time_at(
                        &self,
                        offset: f64,
                        start: f64,
                    ) -> std::result::Result<f64, JsValue> {
                        let result = self.0.__TSB_get_time_at(offset, start);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn area(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.area();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_area(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_area(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_normal_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_get_normal_at_time(time);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.selected();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_selected(&self, value: bool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_selected(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.__TSB_to_string();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_weighted_normal_at(
                        &self,
                        location: CurveGetWeightedNormalAtParamsLocationParam,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_get_weighted_normal_at(
                            ts_bindgen_rt::to_jsvalue(&location)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let result = self.0.handle_bounds();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_handle_bounds(
                        &self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_handle_bounds(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_collinear(&self, curve: Curve) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_collinear(curve);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn segment2(&self) -> std::result::Result<Segment, JsValue> {
                        let result = self.0.segment2();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_segment2(&self, value: Segment) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_segment2(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_point_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_get_point_at_time(time);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_location_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let result = self.0.__TSB_get_location_at_time(time);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn point1(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.point1();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_point1(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_point1(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn classify(&self) -> std::result::Result<JsValue, JsValue> {
                        let result = self.0.__TSB_classify();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_vertical(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_vertical();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_horizontal(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_horizontal();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn length(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.length();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_length(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_length(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_point_at(
                        &self,
                        location: CurveGetPointAtParamsLocationParam,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_get_point_at(
                            ts_bindgen_rt::to_jsvalue(&location)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn split_at_time(&self, time: f64) -> std::result::Result<Path, JsValue> {
                        let result = self.0.__TSB_split_at_time(time);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn divide_at_time(&self, time: f64) -> std::result::Result<Curve, JsValue> {
                        let result = self.0.__TSB_divide_at_time(time);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn clone(&self) -> std::result::Result<Curve, JsValue> {
                        let result = self.0.__TSB_clone();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_last(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_last();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_part(
                        &self,
                        from: f64,
                        to: f64,
                    ) -> std::result::Result<Curve, JsValue> {
                        let result = self.0.__TSB_get_part(from, to);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_nearest_point(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_get_nearest_point(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn has_length(&self, epsilon: f64) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_has_length(epsilon);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_nearest_location(
                        &self,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let result = self.0.__TSB_get_nearest_location(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn handle2(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.handle2();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_handle2(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_handle2(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_tangent_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_get_tangent_at_time(time);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Curve {
                    fn describe() {
                        <Curve_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Curve {
                    type Abi = <Curve_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Curve {
                    type Abi = <Curve_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Curve(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Curve {
                    type Abi = <&'a Curve_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Curve {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Curve {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Curve_Class =
                            <Curve_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait Curve_Trait {
                    fn get_weighted_normal_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    fn get_location_at(
                        &self,
                        offset: f64,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    fn get_curvature_at(
                        &self,
                        location: CurveGetCurvatureAtParamsLocationParam,
                    ) -> std::result::Result<f64, JsValue>;
                    fn set_next(&mut self, value: Curve) -> std::result::Result<(), JsValue>;
                    fn next(&self) -> std::result::Result<Curve, JsValue>;
                    fn get_tangent_at(
                        &self,
                        location: CurveGetTangentAtParamsLocationParam,
                    ) -> std::result::Result<Point, JsValue>;
                    fn set_values(&mut self, value: Vec<f64>) -> std::result::Result<(), JsValue>;
                    fn values(&self) -> std::result::Result<Vec<f64>, JsValue>;
                    fn set_handle1(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn handle1(&self) -> std::result::Result<Point, JsValue>;
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn index(&self) -> std::result::Result<f64, JsValue>;
                    fn set_segment1(&mut self, value: Segment) -> std::result::Result<(), JsValue>;
                    fn segment1(&self) -> std::result::Result<Segment, JsValue>;
                    fn remove(&self) -> std::result::Result<bool, JsValue>;
                    fn get_weighted_tangent_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    fn get_curvature_at_time(&self, time: f64)
                        -> std::result::Result<f64, JsValue>;
                    fn get_time_of(&self, point: Point) -> std::result::Result<f64, JsValue>;
                    fn get_intersections(
                        &self,
                        curve: Curve,
                    ) -> std::result::Result<Vec<CurveLocation>, JsValue>;
                    fn get_times_with_tangent(
                        &self,
                        tangent: Point,
                    ) -> std::result::Result<Vec<f64>, JsValue>;
                    fn get_offset_at_time(&self, time: f64) -> std::result::Result<f64, JsValue>;
                    fn is_straight(&self) -> std::result::Result<bool, JsValue>;
                    fn get_offset_of(&self, point: Point) -> std::result::Result<f64, JsValue>;
                    fn is_linear(&self) -> std::result::Result<bool, JsValue>;
                    fn set_path(&mut self, value: Path) -> std::result::Result<(), JsValue>;
                    fn path(&self) -> std::result::Result<Path, JsValue>;
                    fn set_previous(&mut self, value: Curve) -> std::result::Result<(), JsValue>;
                    fn previous(&self) -> std::result::Result<Curve, JsValue>;
                    fn has_handles(&self) -> std::result::Result<bool, JsValue>;
                    fn divide_at(
                        &self,
                        location: CurveDivideAtParamsLocationParam,
                    ) -> std::result::Result<Curve, JsValue>;
                    fn set_stroke_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue>;
                    fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue>;
                    fn set_points(&mut self, value: Vec<Point>)
                        -> std::result::Result<(), JsValue>;
                    fn points(&self) -> std::result::Result<Vec<Point>, JsValue>;
                    fn clear_handles(&self) -> std::result::Result<(), JsValue>;
                    fn reversed(&self) -> std::result::Result<Curve, JsValue>;
                    fn split_at(
                        &self,
                        location: CurveSplitAtParamsLocationParam,
                    ) -> std::result::Result<Path, JsValue>;
                    fn is_first(&self) -> std::result::Result<bool, JsValue>;
                    fn set_point2(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn point2(&self) -> std::result::Result<Point, JsValue>;
                    fn get_location_of(
                        &self,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue>;
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue>;
                    fn get_weighted_tangent_at(
                        &self,
                        location: CurveGetWeightedTangentAtParamsLocationParam,
                    ) -> std::result::Result<Point, JsValue>;
                    fn get_normal_at(
                        &self,
                        location: CurveGetNormalAtParamsLocationParam,
                    ) -> std::result::Result<Point, JsValue>;
                    fn get_time_at(
                        &self,
                        offset: f64,
                        start: f64,
                    ) -> std::result::Result<f64, JsValue>;
                    fn set_area(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn area(&self) -> std::result::Result<f64, JsValue>;
                    fn get_normal_at_time(&self, time: f64) -> std::result::Result<Point, JsValue>;
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue>;
                    fn selected(&self) -> std::result::Result<bool, JsValue>;
                    fn to_string(&self) -> std::result::Result<String, JsValue>;
                    fn get_weighted_normal_at(
                        &self,
                        location: CurveGetWeightedNormalAtParamsLocationParam,
                    ) -> std::result::Result<Point, JsValue>;
                    fn set_handle_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue>;
                    fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue>;
                    fn is_collinear(&self, curve: Curve) -> std::result::Result<bool, JsValue>;
                    fn set_segment2(&mut self, value: Segment) -> std::result::Result<(), JsValue>;
                    fn segment2(&self) -> std::result::Result<Segment, JsValue>;
                    fn get_point_at_time(&self, time: f64) -> std::result::Result<Point, JsValue>;
                    fn get_location_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    fn set_point1(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn point1(&self) -> std::result::Result<Point, JsValue>;
                    fn classify(&self) -> std::result::Result<JsValue, JsValue>;
                    fn is_vertical(&self) -> std::result::Result<bool, JsValue>;
                    fn is_horizontal(&self) -> std::result::Result<bool, JsValue>;
                    fn set_length(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn length(&self) -> std::result::Result<f64, JsValue>;
                    fn get_point_at(
                        &self,
                        location: CurveGetPointAtParamsLocationParam,
                    ) -> std::result::Result<Point, JsValue>;
                    fn split_at_time(&self, time: f64) -> std::result::Result<Path, JsValue>;
                    fn divide_at_time(&self, time: f64) -> std::result::Result<Curve, JsValue>;
                    fn clone(&self) -> std::result::Result<Curve, JsValue>;
                    fn is_last(&self) -> std::result::Result<bool, JsValue>;
                    fn get_part(&self, from: f64, to: f64) -> std::result::Result<Curve, JsValue>;
                    fn get_nearest_point(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    fn has_length(&self, epsilon: f64) -> std::result::Result<bool, JsValue>;
                    fn get_nearest_location(
                        &self,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    fn set_handle2(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn handle2(&self) -> std::result::Result<Point, JsValue>;
                    fn get_tangent_at_time(&self, time: f64)
                        -> std::result::Result<Point, JsValue>;
                }
                impl Curve_Trait for Curve {
                    fn get_weighted_normal_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Curve::get_weighted_normal_at_time(&target, time)
                    }
                    fn get_location_at(
                        &self,
                        offset: f64,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let target = self;
                        Curve::get_location_at(&target, offset)
                    }
                    fn get_curvature_at(
                        &self,
                        location: CurveGetCurvatureAtParamsLocationParam,
                    ) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Curve::get_curvature_at(&target, location)
                    }
                    fn set_next(&mut self, value: Curve) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Curve::set_next(&mut target, value)
                    }
                    fn next(&self) -> std::result::Result<Curve, JsValue> {
                        let target = self;
                        Curve::next(&target)
                    }
                    fn get_tangent_at(
                        &self,
                        location: CurveGetTangentAtParamsLocationParam,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Curve::get_tangent_at(&target, location)
                    }
                    fn set_values(&mut self, value: Vec<f64>) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Curve::set_values(&mut target, value)
                    }
                    fn values(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let target = self;
                        Curve::values(&target)
                    }
                    fn set_handle1(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Curve::set_handle1(&mut target, value)
                    }
                    fn handle1(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Curve::handle1(&target)
                    }
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Curve::set_index(&mut target, value)
                    }
                    fn index(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Curve::index(&target)
                    }
                    fn set_segment1(&mut self, value: Segment) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Curve::set_segment1(&mut target, value)
                    }
                    fn segment1(&self) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        Curve::segment1(&target)
                    }
                    fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Curve::remove(&target)
                    }
                    fn get_weighted_tangent_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Curve::get_weighted_tangent_at_time(&target, time)
                    }
                    fn get_curvature_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Curve::get_curvature_at_time(&target, time)
                    }
                    fn get_time_of(&self, point: Point) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Curve::get_time_of(&target, point)
                    }
                    fn get_intersections(
                        &self,
                        curve: Curve,
                    ) -> std::result::Result<Vec<CurveLocation>, JsValue> {
                        let target = self;
                        Curve::get_intersections(&target, curve)
                    }
                    fn get_times_with_tangent(
                        &self,
                        tangent: Point,
                    ) -> std::result::Result<Vec<f64>, JsValue> {
                        let target = self;
                        Curve::get_times_with_tangent(&target, tangent)
                    }
                    fn get_offset_at_time(&self, time: f64) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Curve::get_offset_at_time(&target, time)
                    }
                    fn is_straight(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Curve::is_straight(&target)
                    }
                    fn get_offset_of(&self, point: Point) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Curve::get_offset_of(&target, point)
                    }
                    fn is_linear(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Curve::is_linear(&target)
                    }
                    fn set_path(&mut self, value: Path) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Curve::set_path(&mut target, value)
                    }
                    fn path(&self) -> std::result::Result<Path, JsValue> {
                        let target = self;
                        Curve::path(&target)
                    }
                    fn set_previous(&mut self, value: Curve) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Curve::set_previous(&mut target, value)
                    }
                    fn previous(&self) -> std::result::Result<Curve, JsValue> {
                        let target = self;
                        Curve::previous(&target)
                    }
                    fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Curve::has_handles(&target)
                    }
                    fn divide_at(
                        &self,
                        location: CurveDivideAtParamsLocationParam,
                    ) -> std::result::Result<Curve, JsValue> {
                        let target = self;
                        Curve::divide_at(&target, location)
                    }
                    fn set_stroke_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Curve::set_stroke_bounds(&mut target, value)
                    }
                    fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        Curve::stroke_bounds(&target)
                    }
                    fn set_points(
                        &mut self,
                        value: Vec<Point>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Curve::set_points(&mut target, value)
                    }
                    fn points(&self) -> std::result::Result<Vec<Point>, JsValue> {
                        let target = self;
                        Curve::points(&target)
                    }
                    fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Curve::clear_handles(&target)
                    }
                    fn reversed(&self) -> std::result::Result<Curve, JsValue> {
                        let target = self;
                        Curve::reversed(&target)
                    }
                    fn split_at(
                        &self,
                        location: CurveSplitAtParamsLocationParam,
                    ) -> std::result::Result<Path, JsValue> {
                        let target = self;
                        Curve::split_at(&target, location)
                    }
                    fn is_first(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Curve::is_first(&target)
                    }
                    fn set_point2(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Curve::set_point2(&mut target, value)
                    }
                    fn point2(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Curve::point2(&target)
                    }
                    fn get_location_of(
                        &self,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let target = self;
                        Curve::get_location_of(&target, point)
                    }
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Curve::set_bounds(&mut target, value)
                    }
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        Curve::bounds(&target)
                    }
                    fn get_weighted_tangent_at(
                        &self,
                        location: CurveGetWeightedTangentAtParamsLocationParam,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Curve::get_weighted_tangent_at(&target, location)
                    }
                    fn get_normal_at(
                        &self,
                        location: CurveGetNormalAtParamsLocationParam,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Curve::get_normal_at(&target, location)
                    }
                    fn get_time_at(
                        &self,
                        offset: f64,
                        start: f64,
                    ) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Curve::get_time_at(&target, offset, start)
                    }
                    fn set_area(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Curve::set_area(&mut target, value)
                    }
                    fn area(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Curve::area(&target)
                    }
                    fn get_normal_at_time(&self, time: f64) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Curve::get_normal_at_time(&target, time)
                    }
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Curve::set_selected(&mut target, value)
                    }
                    fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Curve::selected(&target)
                    }
                    fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Curve::to_string(&target)
                    }
                    fn get_weighted_normal_at(
                        &self,
                        location: CurveGetWeightedNormalAtParamsLocationParam,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Curve::get_weighted_normal_at(&target, location)
                    }
                    fn set_handle_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Curve::set_handle_bounds(&mut target, value)
                    }
                    fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        Curve::handle_bounds(&target)
                    }
                    fn is_collinear(&self, curve: Curve) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Curve::is_collinear(&target, curve)
                    }
                    fn set_segment2(&mut self, value: Segment) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Curve::set_segment2(&mut target, value)
                    }
                    fn segment2(&self) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        Curve::segment2(&target)
                    }
                    fn get_point_at_time(&self, time: f64) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Curve::get_point_at_time(&target, time)
                    }
                    fn get_location_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let target = self;
                        Curve::get_location_at_time(&target, time)
                    }
                    fn set_point1(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Curve::set_point1(&mut target, value)
                    }
                    fn point1(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Curve::point1(&target)
                    }
                    fn classify(&self) -> std::result::Result<JsValue, JsValue> {
                        let target = self;
                        Curve::classify(&target)
                    }
                    fn is_vertical(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Curve::is_vertical(&target)
                    }
                    fn is_horizontal(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Curve::is_horizontal(&target)
                    }
                    fn set_length(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Curve::set_length(&mut target, value)
                    }
                    fn length(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Curve::length(&target)
                    }
                    fn get_point_at(
                        &self,
                        location: CurveGetPointAtParamsLocationParam,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Curve::get_point_at(&target, location)
                    }
                    fn split_at_time(&self, time: f64) -> std::result::Result<Path, JsValue> {
                        let target = self;
                        Curve::split_at_time(&target, time)
                    }
                    fn divide_at_time(&self, time: f64) -> std::result::Result<Curve, JsValue> {
                        let target = self;
                        Curve::divide_at_time(&target, time)
                    }
                    fn clone(&self) -> std::result::Result<Curve, JsValue> {
                        let target = self;
                        Curve::clone(&target)
                    }
                    fn is_last(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Curve::is_last(&target)
                    }
                    fn get_part(&self, from: f64, to: f64) -> std::result::Result<Curve, JsValue> {
                        let target = self;
                        Curve::get_part(&target, from, to)
                    }
                    fn get_nearest_point(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Curve::get_nearest_point(&target, point)
                    }
                    fn has_length(&self, epsilon: f64) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Curve::has_length(&target, epsilon)
                    }
                    fn get_nearest_location(
                        &self,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let target = self;
                        Curve::get_nearest_location(&target, point)
                    }
                    fn set_handle2(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Curve::set_handle2(&mut target, value)
                    }
                    fn handle2(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Curve::handle2(&target)
                    }
                    fn get_tangent_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Curve::get_tangent_at_time(&target, time)
                    }
                }
                impl std::clone::Clone for Curve_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Curve_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Curve_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum RasterOnError {
                    TsBindgenRtNullCase,
                    #[serde(
                        serialize_with = "RasterOnError::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "RasterOnError::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                }
                impl RasterOnError {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[wasm_bindgen(js_name = "HitResult")]
                    pub type HitResult_Class;
                    # [wasm_bindgen (method , structural , catch , getter = item , js_class = "HitResult")]
                    fn item(this: &HitResult_Class) -> std::result::Result<Item, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = item , js_class = "HitResult")]
                    fn set_item(
                        this: &HitResult_Class,
                        value: Item,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = name , js_class = "HitResult")]
                    fn name(this: &HitResult_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = name , js_class = "HitResult")]
                    fn set_name(
                        this: &HitResult_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = type , js_class = "HitResult")]
                    fn type_(this: &HitResult_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = type , js_class = "HitResult")]
                    fn set_type_(
                        this: &HitResult_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = segment , js_class = "HitResult")]
                    fn segment(this: &HitResult_Class) -> std::result::Result<Segment, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = segment , js_class = "HitResult")]
                    fn set_segment(
                        this: &HitResult_Class,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = location , js_class = "HitResult")]
                    fn location(
                        this: &HitResult_Class,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = location , js_class = "HitResult")]
                    fn set_location(
                        this: &HitResult_Class,
                        value: CurveLocation,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = point , js_class = "HitResult")]
                    fn point(this: &HitResult_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = point , js_class = "HitResult")]
                    fn set_point(
                        this: &HitResult_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = color , js_class = "HitResult")]
                    fn __TSB_color(this: &HitResult_Class)
                        -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = color , js_class = "HitResult")]
                    fn __TSB_set_color(
                        this: &HitResult_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct HitResult(pub HitResult_Class);
                impl HitResult {
                    #[allow(dead_code)]
                    pub fn item(&self) -> std::result::Result<Item, JsValue> {
                        let result = self.0.item();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_item(&self, value: Item) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_item(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn name(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.name();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_name(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_name(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn type_(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.type_();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_type_(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_type_(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn segment(&self) -> std::result::Result<Segment, JsValue> {
                        let result = self.0.segment();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_segment(&self, value: Segment) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_segment(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn location(&self) -> std::result::Result<CurveLocation, JsValue> {
                        let result = self.0.location();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_location(
                        &self,
                        value: CurveLocation,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_location(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn point(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.point();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_point(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_point(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn color(&self) -> std::result::Result<HitResultColor, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_color()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_color(
                        &self,
                        value: HitResultColor,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_color(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for HitResult {
                    fn describe() {
                        <HitResult_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for HitResult {
                    type Abi = <HitResult_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for HitResult {
                    type Abi = <HitResult_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        HitResult(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a HitResult {
                    type Abi = <&'a HitResult_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for HitResult {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for HitResult {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: HitResult_Class =
                            <HitResult_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait HitResult_Trait {
                    fn set_item(&mut self, value: Item) -> std::result::Result<(), JsValue>;
                    fn item(&self) -> std::result::Result<Item, JsValue>;
                    fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn name(&self) -> std::result::Result<String, JsValue>;
                    fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn type_(&self) -> std::result::Result<String, JsValue>;
                    fn set_segment(&mut self, value: Segment) -> std::result::Result<(), JsValue>;
                    fn segment(&self) -> std::result::Result<Segment, JsValue>;
                    fn set_location(
                        &mut self,
                        value: CurveLocation,
                    ) -> std::result::Result<(), JsValue>;
                    fn location(&self) -> std::result::Result<CurveLocation, JsValue>;
                    fn set_point(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn point(&self) -> std::result::Result<Point, JsValue>;
                    fn set_color(
                        &mut self,
                        value: HitResultColor,
                    ) -> std::result::Result<(), JsValue>;
                    fn color(&self) -> std::result::Result<HitResultColor, JsValue>;
                }
                impl HitResult_Trait for HitResult {
                    fn set_item(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        HitResult::set_item(&mut target, value)
                    }
                    fn item(&self) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        HitResult::item(&target)
                    }
                    fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        HitResult::set_name(&mut target, value)
                    }
                    fn name(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        HitResult::name(&target)
                    }
                    fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        HitResult::set_type_(&mut target, value)
                    }
                    fn type_(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        HitResult::type_(&target)
                    }
                    fn set_segment(&mut self, value: Segment) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        HitResult::set_segment(&mut target, value)
                    }
                    fn segment(&self) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        HitResult::segment(&target)
                    }
                    fn set_location(
                        &mut self,
                        value: CurveLocation,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        HitResult::set_location(&mut target, value)
                    }
                    fn location(&self) -> std::result::Result<CurveLocation, JsValue> {
                        let target = self;
                        HitResult::location(&target)
                    }
                    fn set_point(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        HitResult::set_point(&mut target, value)
                    }
                    fn point(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        HitResult::point(&target)
                    }
                    fn set_color(
                        &mut self,
                        value: HitResultColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        HitResult::set_color(&mut target, value)
                    }
                    fn color(&self) -> std::result::Result<HitResultColor, JsValue> {
                        let target = self;
                        HitResult::color(&target)
                    }
                }
                impl std::clone::Clone for HitResult_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for HitResult_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for HitResult_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PathDivideAtParamsLocationParam {
                    CurveLocationCase(CurveLocation),
                    F64Case(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemExportSvgReturn {
                    StringCase(String),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    WebSysSvgElementCase(web_sys::SvgElement),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum CurveGetWeightedTangentAtParamsLocationParam {
                    CurveLocationCase(CurveLocation),
                    F64Case(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum CurveSplitAtParamsLocationParam {
                    CurveLocationCase(CurveLocation),
                    F64Case(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum CurveDivideAtParamsLocationParam {
                    CurveLocationCase(CurveLocation),
                    F64Case(f64),
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    # [wasm_bindgen (js_name = "SymbolItem" , extends = Item_Class)]
                    pub type SymbolItem_Class;
                    #[wasm_bindgen(constructor, js_class = "SymbolItem")]
                    pub fn new(definition: JsValue, point: Point) -> SymbolItem_Class;
                    # [wasm_bindgen (method , structural , catch , getter = definition , js_class = "SymbolItem")]
                    fn definition(
                        this: &SymbolItem_Class,
                    ) -> std::result::Result<SymbolDefinition, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = definition , js_class = "SymbolItem")]
                    fn set_definition(
                        this: &SymbolItem_Class,
                        value: SymbolDefinition,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct SymbolItem(pub SymbolItem_Class);
                impl std::convert::From<&SymbolItem> for Item {
                    fn from(src: &SymbolItem) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl std::convert::From<&mut SymbolItem> for Item {
                    fn from(src: &mut SymbolItem) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl SymbolItem {
                    #[allow(dead_code)]
                    pub fn new(
                        definition: SymbolItemConstructorDefinitionParam,
                        point: Point,
                    ) -> SymbolItem {
                        let result = SymbolItem_Class::new(
                            ts_bindgen_rt::to_jsvalue(&definition).unwrap(),
                            point,
                        );
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        SymbolItem(result)
                    }
                    #[allow(dead_code)]
                    pub fn definition(&self) -> std::result::Result<SymbolDefinition, JsValue> {
                        let result = self.0.definition();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_definition(
                        &self,
                        value: SymbolDefinition,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_definition(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for SymbolItem {
                    fn describe() {
                        <SymbolItem_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for SymbolItem {
                    type Abi = <SymbolItem_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for SymbolItem {
                    type Abi = <SymbolItem_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        SymbolItem(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a SymbolItem {
                    type Abi = <&'a SymbolItem_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for SymbolItem {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for SymbolItem {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: SymbolItem_Class =
                            <SymbolItem_Class as serde::de::Deserialize>::deserialize(
                                deserializer,
                            )?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait SymbolItem_Trait: Item_Trait {
                    fn set_definition(
                        &mut self,
                        value: SymbolDefinition,
                    ) -> std::result::Result<(), JsValue>;
                    fn definition(&self) -> std::result::Result<SymbolDefinition, JsValue>;
                }
                impl Item_Trait for SymbolItem {
                    fn set_stroke_scaling(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_scaling(&mut target, value)
                    }
                    fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_scaling(&target)
                    }
                    fn set_apply_matrix(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_apply_matrix(&mut target, value)
                    }
                    fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::apply_matrix(&target)
                    }
                    fn set_view_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_view_matrix(&mut target, value)
                    }
                    fn view_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::view_matrix(&target)
                    }
                    fn set_dash_array(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_dash_array(&mut target, value)
                    }
                    fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let target: Item = self.into();
                        Item::dash_array(&target)
                    }
                    fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_ancestor(&target, item)
                    }
                    fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_descendant(&target, item)
                    }
                    fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_sibling(&target, item)
                    }
                    fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_parent(&target, point)
                    }
                    fn set_shadow_blur(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_shadow_blur(&mut target, value)
                    }
                    fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_blur(&target)
                    }
                    fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_empty(&target, recursively)
                    }
                    fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_parent(&target, item)
                    }
                    fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_below(&target, item)
                    }
                    fn set_matrix(&mut self, value: Matrix) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_matrix(&mut target, value)
                    }
                    fn matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::matrix(&target)
                    }
                    fn export_json(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::export_json(&target, options)
                    }
                    fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::global_to_local(&target, point)
                    }
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ItemOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_drag(&mut target, value)
                    }
                    fn on_mouse_drag(&self) -> std::result::Result<ItemOnMouseDrag, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_drag(&target)
                    }
                    fn get_item(
                        &self,
                        options: ItemGetItemParamsOptionsParam,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::get_item(&target, options)
                    }
                    fn remove_children(
                        &self,
                        start: f64,
                        end: f64,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::remove_children(&target, start, end)
                    }
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_project(&mut target, value)
                    }
                    fn project(&self) -> std::result::Result<Project, JsValue> {
                        let target: Item = self.into();
                        Item::project(&target)
                    }
                    fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_data(&mut target, value)
                    }
                    fn data(&self) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::data(&target)
                    }
                    fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_above(&target, item)
                    }
                    fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on(&target, options)
                    }
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::transform(&target, matrix)
                    }
                    fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inserted(&target)
                    }
                    fn set_on_mouse_down(
                        &mut self,
                        value: ItemOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_down(&mut target, value)
                    }
                    fn on_mouse_down(&self) -> std::result::Result<ItemOnMouseDown, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_down(&target)
                    }
                    fn set_last_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_last_child(&mut target, value)
                    }
                    fn last_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::last_child(&target)
                    }
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_selected(&mut target, value)
                    }
                    fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::selected(&target)
                    }
                    fn set_global_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_global_matrix(&mut target, value)
                    }
                    fn global_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::global_matrix(&target)
                    }
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::responds(&target, type_)
                    }
                    fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::rotate(&target, angle, center)
                    }
                    fn tween(
                        &self,
                        options: ItemTweenParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween(&target, options)
                    }
                    fn set_on_mouse_enter(
                        &mut self,
                        value: ItemOnMouseEnter,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_enter(&mut target, value)
                    }
                    fn on_mouse_enter(&self) -> std::result::Result<ItemOnMouseEnter, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_enter(&target)
                    }
                    fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_id(&mut target, value)
                    }
                    fn id(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::id(&target)
                    }
                    fn on(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::on(&target, object)
                    }
                    fn tween_to(
                        &self,
                        to: JsValue,
                        options: ItemTweenToParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_to(&target, to, options)
                    }
                    fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_locked(&mut target, value)
                    }
                    fn locked(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::locked(&target)
                    }
                    fn set_children(
                        &mut self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_children(&mut target, value)
                    }
                    fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::children(&target)
                    }
                    fn copy_attributes(
                        &self,
                        source: Item,
                        exclude_matrix: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_attributes(&target, source, exclude_matrix)
                    }
                    fn off(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::off(&target, object)
                    }
                    fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::contains(&target, point)
                    }
                    fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_stroke(&target)
                    }
                    fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_move(&target)
                    }
                    fn add_children(
                        &self,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::add_children(&target, items)
                    }
                    fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::reverse_children(&target)
                    }
                    fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_shadow(&target)
                    }
                    fn set_dash_offset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_dash_offset(&mut target, value)
                    }
                    fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::dash_offset(&target)
                    }
                    fn set_on_mouse_leave(
                        &mut self,
                        value: ItemOnMouseLeave,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_leave(&mut target, value)
                    }
                    fn on_mouse_leave(&self) -> std::result::Result<ItemOnMouseLeave, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_leave(&target)
                    }
                    fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test_all(&target, point, options)
                    }
                    fn set_stroke_cap(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_cap(&mut target, value)
                    }
                    fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_cap(&target)
                    }
                    fn set_internal_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_internal_bounds(&mut target, value)
                    }
                    fn internal_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::internal_bounds(&target)
                    }
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_index(&mut target, value)
                    }
                    fn index(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::index(&target)
                    }
                    fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::reduce(&target, options)
                    }
                    fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_grouped_with(&target, item)
                    }
                    fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_global(&target, point)
                    }
                    fn set_first_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_first_child(&mut target, value)
                    }
                    fn first_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::first_child(&target)
                    }
                    fn set_position(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_position(&mut target, value)
                    }
                    fn position(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::position(&target)
                    }
                    fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_opacity(&mut target, value)
                    }
                    fn opacity(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::opacity(&target)
                    }
                    fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_down(&target)
                    }
                    fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_drag(&target)
                    }
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_bounds(&mut target, value)
                    }
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::bounds(&target)
                    }
                    fn set_parent(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_parent(&mut target, value)
                    }
                    fn parent(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::parent(&target)
                    }
                    fn get_items(
                        &self,
                        options: ItemGetItemsParamsOptionsParam,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::get_items(&target, options)
                    }
                    fn copy_to(
                        &self,
                        owner: ItemCopyToParamsOwnerParam,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::copy_to(&target, owner)
                    }
                    fn set_on_double_click(
                        &mut self,
                        value: ItemOnDoubleClick,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_double_click(&mut target, value)
                    }
                    fn on_double_click(&self) -> std::result::Result<ItemOnDoubleClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_double_click(&target)
                    }
                    fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::set(&target, props)
                    }
                    fn scale(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::scale(&target, hor, ver, center)
                    }
                    fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_below(&target, item)
                    }
                    fn set_next_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_next_sibling(&mut target, value)
                    }
                    fn next_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::next_sibling(&target)
                    }
                    fn rasterize(&self, options: JsValue) -> std::result::Result<Raster, JsValue> {
                        let target: Item = self.into();
                        Item::rasterize(&target, options)
                    }
                    fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::bring_to_front(&target)
                    }
                    fn matches(
                        &self,
                        name: String,
                        compare: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::matches(&target, name, compare)
                    }
                    fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_fill(&target)
                    }
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_view(&mut target, value)
                    }
                    fn view(&self) -> std::result::Result<View, JsValue> {
                        let target: Item = self.into();
                        Item::view(&target)
                    }
                    fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::clone(&target, options)
                    }
                    fn set_handle_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_handle_bounds(&mut target, value)
                    }
                    fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::handle_bounds(&target)
                    }
                    fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inside(&target, rect)
                    }
                    fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_above(&target, item)
                    }
                    fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::remove(&target)
                    }
                    fn set_stroke_join(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_join(&mut target, value)
                    }
                    fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_join(&target)
                    }
                    fn set_on_click(
                        &mut self,
                        value: ItemOnClick,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_click(&mut target, value)
                    }
                    fn on_click(&self) -> std::result::Result<ItemOnClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_click(&target)
                    }
                    fn fit_bounds(
                        &self,
                        rectangle: Rectangle,
                        fill: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::fit_bounds(&target, rectangle, fill)
                    }
                    fn set_blend_mode(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_blend_mode(&mut target, value)
                    }
                    fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::blend_mode(&target)
                    }
                    fn set_stroke_width(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_width(&mut target, value)
                    }
                    fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_width(&target)
                    }
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_rotation(&mut target, value)
                    }
                    fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::rotation(&target)
                    }
                    fn set_selected_color(
                        &mut self,
                        value: ItemSelectedColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_selected_color(&mut target, value)
                    }
                    fn selected_color(&self) -> std::result::Result<ItemSelectedColor, JsValue> {
                        let target: Item = self.into();
                        Item::selected_color(&target)
                    }
                    fn skew(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::skew(&target, hor, ver, center)
                    }
                    fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_name(&mut target, value)
                    }
                    fn name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::name(&target)
                    }
                    fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_json(&target, json)
                    }
                    fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::add_child(&target, item)
                    }
                    fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_visible(&mut target, value)
                    }
                    fn visible(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::visible(&target)
                    }
                    fn set_fill_rule(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_fill_rule(&mut target, value)
                    }
                    fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::fill_rule(&target)
                    }
                    fn set_layer(&mut self, value: Layer) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_layer(&mut target, value)
                    }
                    fn layer(&self) -> std::result::Result<Layer, JsValue> {
                        let target: Item = self.into();
                        Item::layer(&target)
                    }
                    fn tween_from(
                        &self,
                        from: JsValue,
                        options: ItemTweenFromParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_from(&target, from, options)
                    }
                    fn insert_child(
                        &self,
                        index: f64,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_child(&target, index, item)
                    }
                    fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_up(&target)
                    }
                    fn set_pivot(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_pivot(&mut target, value)
                    }
                    fn pivot(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::pivot(&target)
                    }
                    fn set_miter_limit(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_miter_limit(&mut target, value)
                    }
                    fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::miter_limit(&target)
                    }
                    fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_content(&target, source)
                    }
                    fn import_svg(
                        &self,
                        svg: ItemImportSvgParamsSvgParam,
                        on_load: &'static dyn Fn(
                            Box<[JsValue]>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_svg(&target, svg, on_load)
                    }
                    fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::send_to_back(&target)
                    }
                    fn set_stroke_color(
                        &mut self,
                        value: ItemStrokeColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_color(&mut target, value)
                    }
                    fn stroke_color(&self) -> std::result::Result<ItemStrokeColor, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_color(&target)
                    }
                    fn set_on_mouse_move(
                        &mut self,
                        value: ItemOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_move(&mut target, value)
                    }
                    fn on_mouse_move(&self) -> std::result::Result<ItemOnMouseMove, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_move(&target)
                    }
                    fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::replace_with(&target, item)
                    }
                    fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test(&target, point, options)
                    }
                    fn shear(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::shear(&target, hor, ver, center)
                    }
                    fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::translate(&target, delta)
                    }
                    fn set_stroke_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_bounds(&mut target, value)
                    }
                    fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_bounds(&target)
                    }
                    fn insert_children(
                        &self,
                        index: f64,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::insert_children(&target, index, items)
                    }
                    fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_child(&target, item)
                    }
                    fn set_shadow_offset(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_shadow_offset(&mut target, value)
                    }
                    fn shadow_offset(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_offset(&target)
                    }
                    fn set_fill_color(
                        &mut self,
                        value: ItemFillColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_fill_color(&mut target, value)
                    }
                    fn fill_color(&self) -> std::result::Result<ItemFillColor, JsValue> {
                        let target: Item = self.into();
                        Item::fill_color(&target)
                    }
                    fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                        let target: Item = self.into();
                        Item::export_svg(&target, options)
                    }
                    fn set_style(&mut self, value: Style) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_style(&mut target, value)
                    }
                    fn style(&self) -> std::result::Result<Style, JsValue> {
                        let target: Item = self.into();
                        Item::style(&target)
                    }
                    fn set_clip_mask(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_clip_mask(&mut target, value)
                    }
                    fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::clip_mask(&target)
                    }
                    fn set_class_name(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_class_name(&mut target, value)
                    }
                    fn class_name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::class_name(&target)
                    }
                    fn set_on_mouse_up(
                        &mut self,
                        value: ItemOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_up(&mut target, value)
                    }
                    fn on_mouse_up(&self) -> std::result::Result<ItemOnMouseUp, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_up(&target)
                    }
                    fn set_on_frame(
                        &mut self,
                        value: ItemOnFrame,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_frame(&mut target, value)
                    }
                    fn on_frame(&self) -> std::result::Result<ItemOnFrame, JsValue> {
                        let target: Item = self.into();
                        Item::on_frame(&target)
                    }
                    fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::parent_to_local(&target, point)
                    }
                    fn set_previous_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_previous_sibling(&mut target, value)
                    }
                    fn previous_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::previous_sibling(&target)
                    }
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::emit(&target, type_, event)
                    }
                    fn add_to(
                        &self,
                        owner: ItemAddToParamsOwnerParam,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::add_to(&target, owner)
                    }
                    fn has_children(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_children(&target)
                    }
                    fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::intersects(&target, item)
                    }
                    fn set_shadow_color(
                        &mut self,
                        value: ItemShadowColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_shadow_color(&mut target, value)
                    }
                    fn shadow_color(&self) -> std::result::Result<ItemShadowColor, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_color(&target)
                    }
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_scaling(&mut target, value)
                    }
                    fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::scaling(&target)
                    }
                }
                impl SymbolItem_Trait for SymbolItem
                where
                    SymbolItem: Item_Trait,
                {
                    fn set_definition(
                        &mut self,
                        value: SymbolDefinition,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        SymbolItem::set_definition(&mut target, value)
                    }
                    fn definition(&self) -> std::result::Result<SymbolDefinition, JsValue> {
                        let target = self;
                        SymbolItem::definition(&target)
                    }
                }
                impl std::clone::Clone for SymbolItem_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for SymbolItem_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for SymbolItem_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum CurveGetTangentAtParamsLocationParam {
                    CurveLocationCase(CurveLocation),
                    F64Case(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PathAddReturn {
                    SegmentCase(Segment),
                    VecOfSegmentCase(Vec<Segment>),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewOnMouseLeave {
                    TsBindgenRtNullCase,
                    #[serde(
                        serialize_with = "ViewOnMouseLeave::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "ViewOnMouseLeave::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                }
                impl ViewOnMouseLeave {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ToolOnKeyUp {
                    TsBindgenRtNullCase,
                    #[serde(
                        serialize_with = "ToolOnKeyUp::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "ToolOnKeyUp::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                }
                impl ToolOnKeyUp {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[wasm_bindgen(js_name = "Size")]
                    pub type Size_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = subtract , method , js_class = "Size" , catch)]
                    fn __TSB_subtract(
                        this: &Size_Class,
                        size: Size,
                    ) -> std::result::Result<Size, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = equals , method , js_class = "Size" , catch)]
                    fn __TSB_equals(
                        this: &Size_Class,
                        size: Size,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = divide , method , js_class = "Size" , catch)]
                    fn __TSB_divide(
                        this: &Size_Class,
                        size: Size,
                    ) -> std::result::Result<Size, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = random , method , js_class = "Size" , catch)]
                    fn __TSB_random(this: &Size_Class) -> std::result::Result<Size, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clone , method , js_class = "Size" , catch)]
                    fn __TSB_clone(this: &Size_Class) -> std::result::Result<Size, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = min , method , js_class = "Size" , catch)]
                    fn __TSB_min(
                        this: &Size_Class,
                        size1: Size,
                        size2: Size,
                    ) -> std::result::Result<Size, JsValue>;
                    #[wasm_bindgen(constructor, js_class = "Size")]
                    pub fn new(object: JsValue) -> Size_Class;
                    # [wasm_bindgen (method , structural , catch , getter = width , js_class = "Size")]
                    fn width(this: &Size_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = width , js_class = "Size")]
                    fn set_width(this: &Size_Class, value: f64)
                        -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = multiply , method , js_class = "Size" , catch)]
                    fn __TSB_multiply(
                        this: &Size_Class,
                        size: Size,
                    ) -> std::result::Result<Size, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = abs , method , js_class = "Size" , catch)]
                    fn __TSB_abs(this: &Size_Class) -> std::result::Result<Size, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = add , method , js_class = "Size" , catch)]
                    fn __TSB_add(
                        this: &Size_Class,
                        size: Size,
                    ) -> std::result::Result<Size, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isNaN , method , js_class = "Size" , catch)]
                    fn __TSB_is_na_n(this: &Size_Class) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = toString , method , js_class = "Size" , catch)]
                    fn __TSB_to_string(this: &Size_Class) -> std::result::Result<String, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = round , method , js_class = "Size" , catch)]
                    fn __TSB_round(this: &Size_Class) -> std::result::Result<Size, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = ceil , method , js_class = "Size" , catch)]
                    fn __TSB_ceil(this: &Size_Class) -> std::result::Result<Size, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = floor , method , js_class = "Size" , catch)]
                    fn __TSB_floor(this: &Size_Class) -> std::result::Result<Size, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = max , method , js_class = "Size" , catch)]
                    fn __TSB_max(
                        this: &Size_Class,
                        size1: Size,
                        size2: Size,
                    ) -> std::result::Result<Size, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = set , method , js_class = "Size" , catch , variadic)]
                    fn __TSB_set(
                        this: &Size_Class,
                        values: Box<[JsValue]>,
                    ) -> std::result::Result<Size, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isZero , method , js_class = "Size" , catch)]
                    fn __TSB_is_zero(this: &Size_Class) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = modulo , method , js_class = "Size" , catch)]
                    fn __TSB_modulo(
                        this: &Size_Class,
                        size: Size,
                    ) -> std::result::Result<Size, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = height , js_class = "Size")]
                    fn height(this: &Size_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = height , js_class = "Size")]
                    fn set_height(
                        this: &Size_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Size(pub Size_Class);
                impl Size {
                    #[allow(dead_code)]
                    pub fn subtract(&self, size: Size) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_subtract(size);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn equals(&self, size: Size) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_equals(size);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn divide(&self, size: Size) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_divide(size);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn random(&self) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_random();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn clone(&self) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_clone();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn min(
                        &self,
                        size1: Size,
                        size2: Size,
                    ) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_min(size1, size2);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn new(object: JsValue) -> Size {
                        let result = Size_Class::new(object);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Size(result)
                    }
                    #[allow(dead_code)]
                    pub fn width(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.width();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_width(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_width(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn multiply(&self, size: Size) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_multiply(size);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn abs(&self) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_abs();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn add(&self, size: Size) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_add(size);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_na_n(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_na_n();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.__TSB_to_string();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn round(&self) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_round();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn ceil(&self) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_ceil();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn floor(&self) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_floor();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn max(
                        &self,
                        size1: Size,
                        size2: Size,
                    ) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_max(size1, size2);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set(
                        &self,
                        values: Box<[JsValue]>,
                    ) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_set(values);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_zero(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_zero();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn modulo(&self, size: Size) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_modulo(size);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn height(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.height();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_height(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_height(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Size {
                    fn describe() {
                        <Size_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Size {
                    type Abi = <Size_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Size {
                    type Abi = <Size_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Size(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Size {
                    type Abi = <&'a Size_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Size {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Size {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Size_Class =
                            <Size_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait Size_Trait {
                    fn subtract(&self, size: Size) -> std::result::Result<Size, JsValue>;
                    fn equals(&self, size: Size) -> std::result::Result<bool, JsValue>;
                    fn divide(&self, size: Size) -> std::result::Result<Size, JsValue>;
                    fn random(&self) -> std::result::Result<Size, JsValue>;
                    fn clone(&self) -> std::result::Result<Size, JsValue>;
                    fn min(&self, size1: Size, size2: Size) -> std::result::Result<Size, JsValue>;
                    fn set_width(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn width(&self) -> std::result::Result<f64, JsValue>;
                    fn multiply(&self, size: Size) -> std::result::Result<Size, JsValue>;
                    fn abs(&self) -> std::result::Result<Size, JsValue>;
                    fn add(&self, size: Size) -> std::result::Result<Size, JsValue>;
                    fn is_na_n(&self) -> std::result::Result<bool, JsValue>;
                    fn to_string(&self) -> std::result::Result<String, JsValue>;
                    fn round(&self) -> std::result::Result<Size, JsValue>;
                    fn ceil(&self) -> std::result::Result<Size, JsValue>;
                    fn floor(&self) -> std::result::Result<Size, JsValue>;
                    fn max(&self, size1: Size, size2: Size) -> std::result::Result<Size, JsValue>;
                    fn set(&self, values: Box<[JsValue]>) -> std::result::Result<Size, JsValue>;
                    fn is_zero(&self) -> std::result::Result<bool, JsValue>;
                    fn modulo(&self, size: Size) -> std::result::Result<Size, JsValue>;
                    fn set_height(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn height(&self) -> std::result::Result<f64, JsValue>;
                }
                impl Size_Trait for Size {
                    fn subtract(&self, size: Size) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::subtract(&target, size)
                    }
                    fn equals(&self, size: Size) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Size::equals(&target, size)
                    }
                    fn divide(&self, size: Size) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::divide(&target, size)
                    }
                    fn random(&self) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::random(&target)
                    }
                    fn clone(&self) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::clone(&target)
                    }
                    fn min(&self, size1: Size, size2: Size) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::min(&target, size1, size2)
                    }
                    fn set_width(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Size::set_width(&mut target, value)
                    }
                    fn width(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Size::width(&target)
                    }
                    fn multiply(&self, size: Size) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::multiply(&target, size)
                    }
                    fn abs(&self) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::abs(&target)
                    }
                    fn add(&self, size: Size) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::add(&target, size)
                    }
                    fn is_na_n(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Size::is_na_n(&target)
                    }
                    fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Size::to_string(&target)
                    }
                    fn round(&self) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::round(&target)
                    }
                    fn ceil(&self) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::ceil(&target)
                    }
                    fn floor(&self) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::floor(&target)
                    }
                    fn max(&self, size1: Size, size2: Size) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::max(&target, size1, size2)
                    }
                    fn set(&self, values: Box<[JsValue]>) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::set(&target, values)
                    }
                    fn is_zero(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Size::is_zero(&target)
                    }
                    fn modulo(&self, size: Size) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::modulo(&target, size)
                    }
                    fn set_height(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Size::set_height(&mut target, value)
                    }
                    fn height(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Size::height(&target)
                    }
                }
                impl std::clone::Clone for Size_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Size_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Size_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewOnResize {
                    TsBindgenRtNullCase,
                    #[serde(
                        serialize_with = "ViewOnResize::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "ViewOnResize::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                }
                impl ViewOnResize {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[wasm_bindgen(js_name = "Project")]
                    pub type Project_Class;
                    # [wasm_bindgen (method , structural , catch , getter = selectedItems , js_class = "Project")]
                    fn __TSB_selected_items(
                        this: &Project_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = selectedItems , js_class = "Project")]
                    fn __TSB_set_selected_items(
                        this: &Project_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clear , method , js_class = "Project" , catch)]
                    fn __TSB_clear(this: &Project_Class) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = exportJSON , method , js_class = "Project" , catch)]
                    fn __TSB_export_json(
                        this: &Project_Class,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = deselectAll , method , js_class = "Project" , catch)]
                    fn __TSB_deselect_all(this: &Project_Class)
                        -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = selectAll , method , js_class = "Project" , catch)]
                    fn __TSB_select_all(this: &Project_Class) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = symbolDefinitions , js_class = "Project")]
                    fn __TSB_symbol_definitions(
                        this: &Project_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = symbolDefinitions , js_class = "Project")]
                    fn __TSB_set_symbol_definitions(
                        this: &Project_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = importSVG , method , js_class = "Project" , catch)]
                    fn __TSB_import_svg(
                        this: &Project_Class,
                        svg: JsValue,
                        on_load: &Closure<
                            dyn Fn(
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        >,
                    ) -> std::result::Result<Item, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = remove , method , js_class = "Project" , catch)]
                    fn __TSB_remove(this: &Project_Class) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = layers , js_class = "Project")]
                    fn __TSB_layers(this: &Project_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = layers , js_class = "Project")]
                    fn __TSB_set_layers(
                        this: &Project_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = exportSVG , method , js_class = "Project" , catch)]
                    fn __TSB_export_svg(
                        this: &Project_Class,
                        options: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = activeLayer , js_class = "Project")]
                    fn active_layer(this: &Project_Class) -> std::result::Result<Layer, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = activeLayer , js_class = "Project")]
                    fn set_active_layer(
                        this: &Project_Class,
                        value: Layer,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = importJSON , method , js_class = "Project" , catch)]
                    fn __TSB_import_json(
                        this: &Project_Class,
                        json: String,
                    ) -> std::result::Result<Item, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = currentStyle , js_class = "Project")]
                    fn current_style(this: &Project_Class) -> std::result::Result<Style, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = currentStyle , js_class = "Project")]
                    fn set_current_style(
                        this: &Project_Class,
                        value: Style,
                    ) -> std::result::Result<(), JsValue>;
                    #[wasm_bindgen(constructor, js_class = "Project")]
                    pub fn new(element: JsValue) -> Project_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = hitTestAll , method , js_class = "Project" , catch)]
                    fn __TSB_hit_test_all(
                        this: &Project_Class,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = hitTest , method , js_class = "Project" , catch)]
                    fn __TSB_hit_test(
                        this: &Project_Class,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = activate , method , js_class = "Project" , catch)]
                    fn __TSB_activate(this: &Project_Class) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = view , js_class = "Project")]
                    fn view(this: &Project_Class) -> std::result::Result<View, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = view , js_class = "Project")]
                    fn set_view(
                        this: &Project_Class,
                        value: View,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = addLayer , method , js_class = "Project" , catch)]
                    fn __TSB_add_layer(
                        this: &Project_Class,
                        layer: Layer,
                    ) -> std::result::Result<Layer, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = insertLayer , method , js_class = "Project" , catch)]
                    fn __TSB_insert_layer(
                        this: &Project_Class,
                        index: f64,
                        layer: Layer,
                    ) -> std::result::Result<Layer, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isEmpty , method , js_class = "Project" , catch)]
                    fn __TSB_is_empty(this: &Project_Class) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getItem , method , js_class = "Project" , catch)]
                    fn __TSB_get_item(
                        this: &Project_Class,
                        options: JsValue,
                    ) -> std::result::Result<Item, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getItems , method , js_class = "Project" , catch)]
                    fn __TSB_get_items(
                        this: &Project_Class,
                        options: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = index , js_class = "Project")]
                    fn index(this: &Project_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = index , js_class = "Project")]
                    fn set_index(
                        this: &Project_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Project(pub Project_Class);
                impl Project {
                    #[allow(dead_code)]
                    pub fn selected_items(&self) -> std::result::Result<Vec<Item>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_selected_items()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_selected_items(
                        &self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_selected_items(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn clear(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_clear();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn export_json(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue> {
                        let result = self.0.__TSB_export_json(options);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn deselect_all(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_deselect_all();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn select_all(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_select_all();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn symbol_definitions(
                        &self,
                    ) -> std::result::Result<Vec<SymbolDefinition>, JsValue> {
                        let result =
                            ts_bindgen_rt::from_jsvalue(&self.0.__TSB_symbol_definitions()?)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_symbol_definitions(
                        &self,
                        value: Vec<SymbolDefinition>,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_symbol_definitions(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn import_svg(
                        &self,
                        svg: ProjectImportSvgParamsSvgParam,
                        on_load: &'static dyn Fn(
                            Box<[JsValue]>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue> {
                        # [allow (non_snake_case)] let __TSB_Local_on_load = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 : Box < [JsValue] > = Box :: new ([_Variadic0_arg0 , _Variadic1_arg0 , _Variadic2_arg0 , _Variadic3_arg0 , _Variadic4_arg0 , _Variadic5_arg0 , _Variadic6_arg0]) ; let result = on_load (arg0) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let result = self.0.__TSB_import_svg(
                            ts_bindgen_rt::to_jsvalue(&svg)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                            &__TSB_Local_on_load,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn remove(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_remove();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn layers(&self) -> std::result::Result<Vec<Layer>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_layers()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_layers(
                        &self,
                        value: Vec<Layer>,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_layers(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ProjectExportSvgReturn, JsValue> {
                        let result =
                            ts_bindgen_rt::from_jsvalue(&self.0.__TSB_export_svg(options)?)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn active_layer(&self) -> std::result::Result<Layer, JsValue> {
                        let result = self.0.active_layer();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_active_layer(
                        &self,
                        value: Layer,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_active_layer(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                        let result = self.0.__TSB_import_json(json);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn current_style(&self) -> std::result::Result<Style, JsValue> {
                        let result = self.0.current_style();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_current_style(
                        &self,
                        value: Style,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_current_style(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn new(element: ProjectConstructorElementParam) -> Project {
                        let result =
                            Project_Class::new(ts_bindgen_rt::to_jsvalue(&element).unwrap());
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Project(result)
                    }
                    #[allow(dead_code)]
                    pub fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self.0.__TSB_hit_test_all(point, options)?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue> {
                        let result = self.0.__TSB_hit_test(point, options);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn activate(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_activate();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn view(&self) -> std::result::Result<View, JsValue> {
                        let result = self.0.view();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_view(&self, value: View) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_view(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn add_layer(&self, layer: Layer) -> std::result::Result<Layer, JsValue> {
                        let result = self.0.__TSB_add_layer(layer);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn insert_layer(
                        &self,
                        index: f64,
                        layer: Layer,
                    ) -> std::result::Result<Layer, JsValue> {
                        let result = self.0.__TSB_insert_layer(index, layer);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_empty(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_empty();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_item(
                        &self,
                        options: ProjectGetItemParamsOptionsParam,
                    ) -> std::result::Result<Item, JsValue> {
                        let result = self.0.__TSB_get_item(
                            ts_bindgen_rt::to_jsvalue(&options)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_items(
                        &self,
                        options: ProjectGetItemsParamsOptionsParam,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self.0.__TSB_get_items(
                                ts_bindgen_rt::to_jsvalue(&options)
                                    .map_err(ts_bindgen_rt::Error::from)
                                    .map_err(JsValue::from)?,
                            )?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn index(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.index();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_index(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_index(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Project {
                    fn describe() {
                        <Project_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Project {
                    type Abi = <Project_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Project {
                    type Abi = <Project_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Project(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Project {
                    type Abi = <&'a Project_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Project {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Project {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Project_Class =
                            <Project_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait Project_Trait {
                    fn set_selected_items(
                        &mut self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue>;
                    fn selected_items(&self) -> std::result::Result<Vec<Item>, JsValue>;
                    fn clear(&self) -> std::result::Result<(), JsValue>;
                    fn export_json(&self, options: JsValue)
                        -> std::result::Result<String, JsValue>;
                    fn deselect_all(&self) -> std::result::Result<(), JsValue>;
                    fn select_all(&self) -> std::result::Result<(), JsValue>;
                    fn set_symbol_definitions(
                        &mut self,
                        value: Vec<SymbolDefinition>,
                    ) -> std::result::Result<(), JsValue>;
                    fn symbol_definitions(
                        &self,
                    ) -> std::result::Result<Vec<SymbolDefinition>, JsValue>;
                    fn import_svg(
                        &self,
                        svg: ProjectImportSvgParamsSvgParam,
                        on_load: &'static dyn Fn(
                            Box<[JsValue]>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue>;
                    fn remove(&self) -> std::result::Result<(), JsValue>;
                    fn set_layers(&mut self, value: Vec<Layer>)
                        -> std::result::Result<(), JsValue>;
                    fn layers(&self) -> std::result::Result<Vec<Layer>, JsValue>;
                    fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ProjectExportSvgReturn, JsValue>;
                    fn set_active_layer(
                        &mut self,
                        value: Layer,
                    ) -> std::result::Result<(), JsValue>;
                    fn active_layer(&self) -> std::result::Result<Layer, JsValue>;
                    fn import_json(&self, json: String) -> std::result::Result<Item, JsValue>;
                    fn set_current_style(
                        &mut self,
                        value: Style,
                    ) -> std::result::Result<(), JsValue>;
                    fn current_style(&self) -> std::result::Result<Style, JsValue>;
                    fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue>;
                    fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue>;
                    fn activate(&self) -> std::result::Result<(), JsValue>;
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue>;
                    fn view(&self) -> std::result::Result<View, JsValue>;
                    fn add_layer(&self, layer: Layer) -> std::result::Result<Layer, JsValue>;
                    fn insert_layer(
                        &self,
                        index: f64,
                        layer: Layer,
                    ) -> std::result::Result<Layer, JsValue>;
                    fn is_empty(&self) -> std::result::Result<bool, JsValue>;
                    fn get_item(
                        &self,
                        options: ProjectGetItemParamsOptionsParam,
                    ) -> std::result::Result<Item, JsValue>;
                    fn get_items(
                        &self,
                        options: ProjectGetItemsParamsOptionsParam,
                    ) -> std::result::Result<Vec<Item>, JsValue>;
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn index(&self) -> std::result::Result<f64, JsValue>;
                }
                impl Project_Trait for Project {
                    fn set_selected_items(
                        &mut self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Project::set_selected_items(&mut target, value)
                    }
                    fn selected_items(&self) -> std::result::Result<Vec<Item>, JsValue> {
                        let target = self;
                        Project::selected_items(&target)
                    }
                    fn clear(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Project::clear(&target)
                    }
                    fn export_json(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Project::export_json(&target, options)
                    }
                    fn deselect_all(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Project::deselect_all(&target)
                    }
                    fn select_all(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Project::select_all(&target)
                    }
                    fn set_symbol_definitions(
                        &mut self,
                        value: Vec<SymbolDefinition>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Project::set_symbol_definitions(&mut target, value)
                    }
                    fn symbol_definitions(
                        &self,
                    ) -> std::result::Result<Vec<SymbolDefinition>, JsValue> {
                        let target = self;
                        Project::symbol_definitions(&target)
                    }
                    fn import_svg(
                        &self,
                        svg: ProjectImportSvgParamsSvgParam,
                        on_load: &'static dyn Fn(
                            Box<[JsValue]>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Project::import_svg(&target, svg, on_load)
                    }
                    fn remove(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Project::remove(&target)
                    }
                    fn set_layers(
                        &mut self,
                        value: Vec<Layer>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Project::set_layers(&mut target, value)
                    }
                    fn layers(&self) -> std::result::Result<Vec<Layer>, JsValue> {
                        let target = self;
                        Project::layers(&target)
                    }
                    fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ProjectExportSvgReturn, JsValue> {
                        let target = self;
                        Project::export_svg(&target, options)
                    }
                    fn set_active_layer(
                        &mut self,
                        value: Layer,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Project::set_active_layer(&mut target, value)
                    }
                    fn active_layer(&self) -> std::result::Result<Layer, JsValue> {
                        let target = self;
                        Project::active_layer(&target)
                    }
                    fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Project::import_json(&target, json)
                    }
                    fn set_current_style(
                        &mut self,
                        value: Style,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Project::set_current_style(&mut target, value)
                    }
                    fn current_style(&self) -> std::result::Result<Style, JsValue> {
                        let target = self;
                        Project::current_style(&target)
                    }
                    fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue> {
                        let target = self;
                        Project::hit_test_all(&target, point, options)
                    }
                    fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue> {
                        let target = self;
                        Project::hit_test(&target, point, options)
                    }
                    fn activate(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Project::activate(&target)
                    }
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Project::set_view(&mut target, value)
                    }
                    fn view(&self) -> std::result::Result<View, JsValue> {
                        let target = self;
                        Project::view(&target)
                    }
                    fn add_layer(&self, layer: Layer) -> std::result::Result<Layer, JsValue> {
                        let target = self;
                        Project::add_layer(&target, layer)
                    }
                    fn insert_layer(
                        &self,
                        index: f64,
                        layer: Layer,
                    ) -> std::result::Result<Layer, JsValue> {
                        let target = self;
                        Project::insert_layer(&target, index, layer)
                    }
                    fn is_empty(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Project::is_empty(&target)
                    }
                    fn get_item(
                        &self,
                        options: ProjectGetItemParamsOptionsParam,
                    ) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Project::get_item(&target, options)
                    }
                    fn get_items(
                        &self,
                        options: ProjectGetItemsParamsOptionsParam,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target = self;
                        Project::get_items(&target, options)
                    }
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Project::set_index(&mut target, value)
                    }
                    fn index(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Project::index(&target)
                    }
                }
                impl std::clone::Clone for Project_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Project_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Project_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[wasm_bindgen(js_name = "Rectangle")]
                    pub type Rectangle_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = contains , method , js_class = "Rectangle" , catch)]
                    fn __TSB_contains(
                        this: &Rectangle_Class,
                        rect: Rectangle,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = intersects , method , js_class = "Rectangle" , catch)]
                    fn __TSB_intersects(
                        this: &Rectangle_Class,
                        rect: Rectangle,
                        epsilon: f64,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = leftCenter , js_class = "Rectangle")]
                    fn left_center(this: &Rectangle_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = leftCenter , js_class = "Rectangle")]
                    fn set_left_center(
                        this: &Rectangle_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = height , js_class = "Rectangle")]
                    fn height(this: &Rectangle_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = height , js_class = "Rectangle")]
                    fn set_height(
                        this: &Rectangle_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = bottomCenter , js_class = "Rectangle")]
                    fn bottom_center(this: &Rectangle_Class)
                        -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = bottomCenter , js_class = "Rectangle")]
                    fn set_bottom_center(
                        this: &Rectangle_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = include , method , js_class = "Rectangle" , catch)]
                    fn __TSB_include(
                        this: &Rectangle_Class,
                        point: Point,
                    ) -> std::result::Result<Rectangle, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = scale , method , js_class = "Rectangle" , catch)]
                    fn __TSB_scale(
                        this: &Rectangle_Class,
                        hor: f64,
                        ver: f64,
                    ) -> std::result::Result<Rectangle, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = selected , js_class = "Rectangle")]
                    fn selected(this: &Rectangle_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = selected , js_class = "Rectangle")]
                    fn set_selected(
                        this: &Rectangle_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isEmpty , method , js_class = "Rectangle" , catch)]
                    fn __TSB_is_empty(this: &Rectangle_Class)
                        -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = bottom , js_class = "Rectangle")]
                    fn bottom(this: &Rectangle_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = bottom , js_class = "Rectangle")]
                    fn set_bottom(
                        this: &Rectangle_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = point , js_class = "Rectangle")]
                    fn point(this: &Rectangle_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = point , js_class = "Rectangle")]
                    fn set_point(
                        this: &Rectangle_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = rightCenter , js_class = "Rectangle")]
                    fn right_center(this: &Rectangle_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = rightCenter , js_class = "Rectangle")]
                    fn set_right_center(
                        this: &Rectangle_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = size , js_class = "Rectangle")]
                    fn size(this: &Rectangle_Class) -> std::result::Result<Size, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = size , js_class = "Rectangle")]
                    fn set_size(
                        this: &Rectangle_Class,
                        value: Size,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = right , js_class = "Rectangle")]
                    fn right(this: &Rectangle_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = right , js_class = "Rectangle")]
                    fn set_right(
                        this: &Rectangle_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = intersect , method , js_class = "Rectangle" , catch)]
                    fn __TSB_intersect(
                        this: &Rectangle_Class,
                        rect: Rectangle,
                    ) -> std::result::Result<Rectangle, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = top , js_class = "Rectangle")]
                    fn top(this: &Rectangle_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = top , js_class = "Rectangle")]
                    fn set_top(
                        this: &Rectangle_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = left , js_class = "Rectangle")]
                    fn left(this: &Rectangle_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = left , js_class = "Rectangle")]
                    fn set_left(
                        this: &Rectangle_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clone , method , js_class = "Rectangle" , catch)]
                    fn __TSB_clone(
                        this: &Rectangle_Class,
                    ) -> std::result::Result<Rectangle, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = topLeft , js_class = "Rectangle")]
                    fn top_left(this: &Rectangle_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = topLeft , js_class = "Rectangle")]
                    fn set_top_left(
                        this: &Rectangle_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = width , js_class = "Rectangle")]
                    fn width(this: &Rectangle_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = width , js_class = "Rectangle")]
                    fn set_width(
                        this: &Rectangle_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = area , js_class = "Rectangle")]
                    fn area(this: &Rectangle_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = area , js_class = "Rectangle")]
                    fn set_area(
                        this: &Rectangle_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = expand , method , js_class = "Rectangle" , catch)]
                    fn __TSB_expand(
                        this: &Rectangle_Class,
                        hor: f64,
                        ver: f64,
                    ) -> std::result::Result<Rectangle, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = topRight , js_class = "Rectangle")]
                    fn top_right(this: &Rectangle_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = topRight , js_class = "Rectangle")]
                    fn set_top_right(
                        this: &Rectangle_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[wasm_bindgen(constructor, js_class = "Rectangle")]
                    pub fn new(object: JsValue) -> Rectangle_Class;
                    # [wasm_bindgen (method , structural , catch , getter = bottomRight , js_class = "Rectangle")]
                    fn bottom_right(this: &Rectangle_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = bottomRight , js_class = "Rectangle")]
                    fn set_bottom_right(
                        this: &Rectangle_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = equals , method , js_class = "Rectangle" , catch)]
                    fn __TSB_equals(
                        this: &Rectangle_Class,
                        rect: Rectangle,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = center , js_class = "Rectangle")]
                    fn center(this: &Rectangle_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = center , js_class = "Rectangle")]
                    fn set_center(
                        this: &Rectangle_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = y , js_class = "Rectangle")]
                    fn y(this: &Rectangle_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = y , js_class = "Rectangle")]
                    fn set_y(
                        this: &Rectangle_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = set , method , js_class = "Rectangle" , catch , variadic)]
                    fn __TSB_set(
                        this: &Rectangle_Class,
                        values: Box<[JsValue]>,
                    ) -> std::result::Result<Rectangle, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = bottomLeft , js_class = "Rectangle")]
                    fn bottom_left(this: &Rectangle_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = bottomLeft , js_class = "Rectangle")]
                    fn set_bottom_left(
                        this: &Rectangle_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = x , js_class = "Rectangle")]
                    fn x(this: &Rectangle_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = x , js_class = "Rectangle")]
                    fn set_x(
                        this: &Rectangle_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = toString , method , js_class = "Rectangle" , catch)]
                    fn __TSB_to_string(
                        this: &Rectangle_Class,
                    ) -> std::result::Result<String, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = unite , method , js_class = "Rectangle" , catch)]
                    fn __TSB_unite(
                        this: &Rectangle_Class,
                        rect: Rectangle,
                    ) -> std::result::Result<Rectangle, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = topCenter , js_class = "Rectangle")]
                    fn top_center(this: &Rectangle_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = topCenter , js_class = "Rectangle")]
                    fn set_top_center(
                        this: &Rectangle_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Rectangle(pub Rectangle_Class);
                impl Rectangle {
                    #[allow(dead_code)]
                    pub fn contains(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_contains(rect);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn intersects(
                        &self,
                        rect: Rectangle,
                        epsilon: f64,
                    ) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_intersects(rect, epsilon);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn left_center(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.left_center();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_left_center(
                        &self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_left_center(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn height(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.height();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_height(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_height(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn bottom_center(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.bottom_center();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_bottom_center(
                        &self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_bottom_center(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn include(&self, point: Point) -> std::result::Result<Rectangle, JsValue> {
                        let result = self.0.__TSB_include(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn scale(
                        &self,
                        hor: f64,
                        ver: f64,
                    ) -> std::result::Result<Rectangle, JsValue> {
                        let result = self.0.__TSB_scale(hor, ver);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.selected();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_selected(&self, value: bool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_selected(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_empty(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_empty();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn bottom(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.bottom();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_bottom(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_bottom(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn point(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.point();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_point(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_point(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn right_center(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.right_center();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_right_center(
                        &self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_right_center(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn size(&self) -> std::result::Result<Size, JsValue> {
                        let result = self.0.size();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_size(&self, value: Size) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_size(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn right(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.right();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_right(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_right(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn intersect(
                        &self,
                        rect: Rectangle,
                    ) -> std::result::Result<Rectangle, JsValue> {
                        let result = self.0.__TSB_intersect(rect);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn top(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.top();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_top(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_top(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn left(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.left();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_left(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_left(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn clone(&self) -> std::result::Result<Rectangle, JsValue> {
                        let result = self.0.__TSB_clone();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn top_left(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.top_left();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_top_left(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_top_left(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn width(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.width();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_width(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_width(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn area(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.area();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_area(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_area(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn expand(
                        &self,
                        hor: f64,
                        ver: f64,
                    ) -> std::result::Result<Rectangle, JsValue> {
                        let result = self.0.__TSB_expand(hor, ver);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn top_right(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.top_right();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_top_right(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_top_right(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn new(object: JsValue) -> Rectangle {
                        let result = Rectangle_Class::new(object);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Rectangle(result)
                    }
                    #[allow(dead_code)]
                    pub fn bottom_right(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.bottom_right();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_bottom_right(
                        &self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_bottom_right(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn equals(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_equals(rect);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn center(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.center();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_center(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_center(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn y(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.y();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_y(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_y(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set(
                        &self,
                        values: Box<[JsValue]>,
                    ) -> std::result::Result<Rectangle, JsValue> {
                        let result = self.0.__TSB_set(values);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn bottom_left(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.bottom_left();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_bottom_left(
                        &self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_bottom_left(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn x(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.x();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_x(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_x(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.__TSB_to_string();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn unite(
                        &self,
                        rect: Rectangle,
                    ) -> std::result::Result<Rectangle, JsValue> {
                        let result = self.0.__TSB_unite(rect);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn top_center(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.top_center();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_top_center(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_top_center(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Rectangle {
                    fn describe() {
                        <Rectangle_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Rectangle {
                    type Abi = <Rectangle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Rectangle {
                    type Abi = <Rectangle_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Rectangle(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Rectangle {
                    type Abi = <&'a Rectangle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Rectangle {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Rectangle {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Rectangle_Class =
                            <Rectangle_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait Rectangle_Trait {
                    fn contains(&self, rect: Rectangle) -> std::result::Result<bool, JsValue>;
                    fn intersects(
                        &self,
                        rect: Rectangle,
                        epsilon: f64,
                    ) -> std::result::Result<bool, JsValue>;
                    fn set_left_center(&mut self, value: Point)
                        -> std::result::Result<(), JsValue>;
                    fn left_center(&self) -> std::result::Result<Point, JsValue>;
                    fn set_height(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn height(&self) -> std::result::Result<f64, JsValue>;
                    fn set_bottom_center(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn bottom_center(&self) -> std::result::Result<Point, JsValue>;
                    fn include(&self, point: Point) -> std::result::Result<Rectangle, JsValue>;
                    fn scale(&self, hor: f64, ver: f64) -> std::result::Result<Rectangle, JsValue>;
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue>;
                    fn selected(&self) -> std::result::Result<bool, JsValue>;
                    fn is_empty(&self) -> std::result::Result<bool, JsValue>;
                    fn set_bottom(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn bottom(&self) -> std::result::Result<f64, JsValue>;
                    fn set_point(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn point(&self) -> std::result::Result<Point, JsValue>;
                    fn set_right_center(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn right_center(&self) -> std::result::Result<Point, JsValue>;
                    fn set_size(&mut self, value: Size) -> std::result::Result<(), JsValue>;
                    fn size(&self) -> std::result::Result<Size, JsValue>;
                    fn set_right(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn right(&self) -> std::result::Result<f64, JsValue>;
                    fn intersect(&self, rect: Rectangle)
                        -> std::result::Result<Rectangle, JsValue>;
                    fn set_top(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn top(&self) -> std::result::Result<f64, JsValue>;
                    fn set_left(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn left(&self) -> std::result::Result<f64, JsValue>;
                    fn clone(&self) -> std::result::Result<Rectangle, JsValue>;
                    fn set_top_left(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn top_left(&self) -> std::result::Result<Point, JsValue>;
                    fn set_width(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn width(&self) -> std::result::Result<f64, JsValue>;
                    fn set_area(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn area(&self) -> std::result::Result<f64, JsValue>;
                    fn expand(&self, hor: f64, ver: f64)
                        -> std::result::Result<Rectangle, JsValue>;
                    fn set_top_right(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn top_right(&self) -> std::result::Result<Point, JsValue>;
                    fn set_bottom_right(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn bottom_right(&self) -> std::result::Result<Point, JsValue>;
                    fn equals(&self, rect: Rectangle) -> std::result::Result<bool, JsValue>;
                    fn set_center(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn center(&self) -> std::result::Result<Point, JsValue>;
                    fn set_y(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn y(&self) -> std::result::Result<f64, JsValue>;
                    fn set(
                        &self,
                        values: Box<[JsValue]>,
                    ) -> std::result::Result<Rectangle, JsValue>;
                    fn set_bottom_left(&mut self, value: Point)
                        -> std::result::Result<(), JsValue>;
                    fn bottom_left(&self) -> std::result::Result<Point, JsValue>;
                    fn set_x(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn x(&self) -> std::result::Result<f64, JsValue>;
                    fn to_string(&self) -> std::result::Result<String, JsValue>;
                    fn unite(&self, rect: Rectangle) -> std::result::Result<Rectangle, JsValue>;
                    fn set_top_center(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn top_center(&self) -> std::result::Result<Point, JsValue>;
                }
                impl Rectangle_Trait for Rectangle {
                    fn contains(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Rectangle::contains(&target, rect)
                    }
                    fn intersects(
                        &self,
                        rect: Rectangle,
                        epsilon: f64,
                    ) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Rectangle::intersects(&target, rect, epsilon)
                    }
                    fn set_left_center(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Rectangle::set_left_center(&mut target, value)
                    }
                    fn left_center(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Rectangle::left_center(&target)
                    }
                    fn set_height(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Rectangle::set_height(&mut target, value)
                    }
                    fn height(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Rectangle::height(&target)
                    }
                    fn set_bottom_center(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Rectangle::set_bottom_center(&mut target, value)
                    }
                    fn bottom_center(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Rectangle::bottom_center(&target)
                    }
                    fn include(&self, point: Point) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        Rectangle::include(&target, point)
                    }
                    fn scale(&self, hor: f64, ver: f64) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        Rectangle::scale(&target, hor, ver)
                    }
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Rectangle::set_selected(&mut target, value)
                    }
                    fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Rectangle::selected(&target)
                    }
                    fn is_empty(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Rectangle::is_empty(&target)
                    }
                    fn set_bottom(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Rectangle::set_bottom(&mut target, value)
                    }
                    fn bottom(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Rectangle::bottom(&target)
                    }
                    fn set_point(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Rectangle::set_point(&mut target, value)
                    }
                    fn point(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Rectangle::point(&target)
                    }
                    fn set_right_center(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Rectangle::set_right_center(&mut target, value)
                    }
                    fn right_center(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Rectangle::right_center(&target)
                    }
                    fn set_size(&mut self, value: Size) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Rectangle::set_size(&mut target, value)
                    }
                    fn size(&self) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Rectangle::size(&target)
                    }
                    fn set_right(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Rectangle::set_right(&mut target, value)
                    }
                    fn right(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Rectangle::right(&target)
                    }
                    fn intersect(
                        &self,
                        rect: Rectangle,
                    ) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        Rectangle::intersect(&target, rect)
                    }
                    fn set_top(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Rectangle::set_top(&mut target, value)
                    }
                    fn top(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Rectangle::top(&target)
                    }
                    fn set_left(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Rectangle::set_left(&mut target, value)
                    }
                    fn left(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Rectangle::left(&target)
                    }
                    fn clone(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        Rectangle::clone(&target)
                    }
                    fn set_top_left(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Rectangle::set_top_left(&mut target, value)
                    }
                    fn top_left(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Rectangle::top_left(&target)
                    }
                    fn set_width(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Rectangle::set_width(&mut target, value)
                    }
                    fn width(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Rectangle::width(&target)
                    }
                    fn set_area(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Rectangle::set_area(&mut target, value)
                    }
                    fn area(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Rectangle::area(&target)
                    }
                    fn expand(
                        &self,
                        hor: f64,
                        ver: f64,
                    ) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        Rectangle::expand(&target, hor, ver)
                    }
                    fn set_top_right(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Rectangle::set_top_right(&mut target, value)
                    }
                    fn top_right(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Rectangle::top_right(&target)
                    }
                    fn set_bottom_right(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Rectangle::set_bottom_right(&mut target, value)
                    }
                    fn bottom_right(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Rectangle::bottom_right(&target)
                    }
                    fn equals(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Rectangle::equals(&target, rect)
                    }
                    fn set_center(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Rectangle::set_center(&mut target, value)
                    }
                    fn center(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Rectangle::center(&target)
                    }
                    fn set_y(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Rectangle::set_y(&mut target, value)
                    }
                    fn y(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Rectangle::y(&target)
                    }
                    fn set(
                        &self,
                        values: Box<[JsValue]>,
                    ) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        Rectangle::set(&target, values)
                    }
                    fn set_bottom_left(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Rectangle::set_bottom_left(&mut target, value)
                    }
                    fn bottom_left(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Rectangle::bottom_left(&target)
                    }
                    fn set_x(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Rectangle::set_x(&mut target, value)
                    }
                    fn x(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Rectangle::x(&target)
                    }
                    fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Rectangle::to_string(&target)
                    }
                    fn unite(&self, rect: Rectangle) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        Rectangle::unite(&target, rect)
                    }
                    fn set_top_center(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Rectangle::set_top_center(&mut target, value)
                    }
                    fn top_center(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Rectangle::top_center(&target)
                    }
                }
                impl std::clone::Clone for Rectangle_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Rectangle_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Rectangle_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[wasm_bindgen(js_name = "Point")]
                    pub type Point_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = multiply , method , js_class = "Point" , catch)]
                    fn __TSB_multiply(
                        this: &Point_Class,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = cross , method , js_class = "Point" , catch)]
                    fn __TSB_cross(
                        this: &Point_Class,
                        point: Point,
                    ) -> std::result::Result<f64, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getAngle , method , js_class = "Point" , catch)]
                    fn __TSB_get_angle(
                        this: &Point_Class,
                        point: Point,
                    ) -> std::result::Result<f64, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isOrthogonal , method , js_class = "Point" , catch)]
                    fn __TSB_is_orthogonal(
                        this: &Point_Class,
                        point: Point,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = add , method , js_class = "Point" , catch)]
                    fn __TSB_add(
                        this: &Point_Class,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isCollinear , method , js_class = "Point" , catch)]
                    fn __TSB_is_collinear(
                        this: &Point_Class,
                        point: Point,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = subtract , method , js_class = "Point" , catch)]
                    fn __TSB_subtract(
                        this: &Point_Class,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getDirectedAngle , method , js_class = "Point" , catch)]
                    fn __TSB_get_directed_angle(
                        this: &Point_Class,
                        point: Point,
                    ) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = y , js_class = "Point")]
                    fn y(this: &Point_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = y , js_class = "Point")]
                    fn set_y(this: &Point_Class, value: f64) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = angle , js_class = "Point")]
                    fn angle(this: &Point_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = angle , js_class = "Point")]
                    fn set_angle(
                        this: &Point_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = quadrant , js_class = "Point")]
                    fn quadrant(this: &Point_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = quadrant , js_class = "Point")]
                    fn set_quadrant(
                        this: &Point_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = x , js_class = "Point")]
                    fn x(this: &Point_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = x , js_class = "Point")]
                    fn set_x(this: &Point_Class, value: f64) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = toString , method , js_class = "Point" , catch)]
                    fn __TSB_to_string(this: &Point_Class) -> std::result::Result<String, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = project , method , js_class = "Point" , catch)]
                    fn __TSB_project(
                        this: &Point_Class,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = selected , js_class = "Point")]
                    fn selected(this: &Point_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = selected , js_class = "Point")]
                    fn set_selected(
                        this: &Point_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = length , js_class = "Point")]
                    fn length(this: &Point_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = length , js_class = "Point")]
                    fn set_length(
                        this: &Point_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = ceil , method , js_class = "Point" , catch)]
                    fn __TSB_ceil(this: &Point_Class) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = set , method , js_class = "Point" , catch , variadic)]
                    fn __TSB_set(
                        this: &Point_Class,
                        values: Box<[JsValue]>,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getAngleInRadians , method , js_class = "Point" , catch)]
                    fn __TSB_get_angle_in_radians(
                        this: &Point_Class,
                        point: Point,
                    ) -> std::result::Result<f64, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isInQuadrant , method , js_class = "Point" , catch)]
                    fn __TSB_is_in_quadrant(
                        this: &Point_Class,
                        quadrant: f64,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = divide , method , js_class = "Point" , catch)]
                    fn __TSB_divide(
                        this: &Point_Class,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = max , method , js_class = "Point" , catch)]
                    fn __TSB_max(
                        this: &Point_Class,
                        point1: Point,
                        point2: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = equals , method , js_class = "Point" , catch)]
                    fn __TSB_equals(
                        this: &Point_Class,
                        point: Point,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isClose , method , js_class = "Point" , catch)]
                    fn __TSB_is_close(
                        this: &Point_Class,
                        point: Point,
                        tolerance: f64,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = abs , method , js_class = "Point" , catch)]
                    fn __TSB_abs(this: &Point_Class) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getDistance , method , js_class = "Point" , catch)]
                    fn __TSB_get_distance(
                        this: &Point_Class,
                        point: Point,
                        squared: bool,
                    ) -> std::result::Result<f64, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clone , method , js_class = "Point" , catch)]
                    fn __TSB_clone(this: &Point_Class) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = floor , method , js_class = "Point" , catch)]
                    fn __TSB_floor(this: &Point_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = angleInRadians , js_class = "Point")]
                    fn angle_in_radians(this: &Point_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = angleInRadians , js_class = "Point")]
                    fn set_angle_in_radians(
                        this: &Point_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isInside , method , js_class = "Point" , catch)]
                    fn __TSB_is_inside(
                        this: &Point_Class,
                        rect: Rectangle,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isNaN , method , js_class = "Point" , catch)]
                    fn __TSB_is_na_n(this: &Point_Class) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = min , method , js_class = "Point" , catch)]
                    fn __TSB_min(
                        this: &Point_Class,
                        point1: Point,
                        point2: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    #[wasm_bindgen(constructor, js_class = "Point")]
                    pub fn new(object: JsValue) -> Point_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = modulo , method , js_class = "Point" , catch)]
                    fn __TSB_modulo(
                        this: &Point_Class,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = normalize , method , js_class = "Point" , catch)]
                    fn __TSB_normalize(
                        this: &Point_Class,
                        length: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = transform , method , js_class = "Point" , catch)]
                    fn __TSB_transform(
                        this: &Point_Class,
                        matrix: Matrix,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = round , method , js_class = "Point" , catch)]
                    fn __TSB_round(this: &Point_Class) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isZero , method , js_class = "Point" , catch)]
                    fn __TSB_is_zero(this: &Point_Class) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = random , method , js_class = "Point" , catch)]
                    fn __TSB_random(this: &Point_Class) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = dot , method , js_class = "Point" , catch)]
                    fn __TSB_dot(
                        this: &Point_Class,
                        point: Point,
                    ) -> std::result::Result<f64, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = rotate , method , js_class = "Point" , catch)]
                    fn __TSB_rotate(
                        this: &Point_Class,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<Point, JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Point(pub Point_Class);
                impl Point {
                    #[allow(dead_code)]
                    pub fn multiply(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_multiply(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn cross(&self, point: Point) -> std::result::Result<f64, JsValue> {
                        let result = self.0.__TSB_cross(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_angle(&self, point: Point) -> std::result::Result<f64, JsValue> {
                        let result = self.0.__TSB_get_angle(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_orthogonal(
                        &self,
                        point: Point,
                    ) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_orthogonal(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn add(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_add(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_collinear(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_collinear(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn subtract(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_subtract(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_directed_angle(
                        &self,
                        point: Point,
                    ) -> std::result::Result<f64, JsValue> {
                        let result = self.0.__TSB_get_directed_angle(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn y(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.y();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_y(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_y(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn angle(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.angle();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_angle(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_angle(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn quadrant(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.quadrant();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_quadrant(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_quadrant(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn x(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.x();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_x(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_x(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.__TSB_to_string();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn project(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_project(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.selected();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_selected(&self, value: bool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_selected(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn length(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.length();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_length(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_length(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn ceil(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_ceil();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set(
                        &self,
                        values: Box<[JsValue]>,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_set(values);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_angle_in_radians(
                        &self,
                        point: Point,
                    ) -> std::result::Result<f64, JsValue> {
                        let result = self.0.__TSB_get_angle_in_radians(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_in_quadrant(
                        &self,
                        quadrant: f64,
                    ) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_in_quadrant(quadrant);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn divide(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_divide(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn max(
                        &self,
                        point1: Point,
                        point2: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_max(point1, point2);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn equals(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_equals(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_close(
                        &self,
                        point: Point,
                        tolerance: f64,
                    ) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_close(point, tolerance);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn abs(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_abs();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_distance(
                        &self,
                        point: Point,
                        squared: bool,
                    ) -> std::result::Result<f64, JsValue> {
                        let result = self.0.__TSB_get_distance(point, squared);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn clone(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_clone();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn floor(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_floor();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn angle_in_radians(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.angle_in_radians();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_angle_in_radians(
                        &self,
                        value: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_angle_in_radians(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_inside(rect);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_na_n(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_na_n();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn min(
                        &self,
                        point1: Point,
                        point2: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_min(point1, point2);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn new(object: JsValue) -> Point {
                        let result = Point_Class::new(object);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Point(result)
                    }
                    #[allow(dead_code)]
                    pub fn modulo(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_modulo(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn normalize(&self, length: f64) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_normalize(length);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn transform(&self, matrix: Matrix) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_transform(matrix);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn round(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_round();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_zero(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_zero();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn random(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_random();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn dot(&self, point: Point) -> std::result::Result<f64, JsValue> {
                        let result = self.0.__TSB_dot(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_rotate(angle, center);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Point {
                    fn describe() {
                        <Point_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Point {
                    type Abi = <Point_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Point {
                    type Abi = <Point_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Point(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Point {
                    type Abi = <&'a Point_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Point {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Point {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Point_Class =
                            <Point_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait Point_Trait {
                    fn multiply(&self, point: Point) -> std::result::Result<Point, JsValue>;
                    fn cross(&self, point: Point) -> std::result::Result<f64, JsValue>;
                    fn get_angle(&self, point: Point) -> std::result::Result<f64, JsValue>;
                    fn is_orthogonal(&self, point: Point) -> std::result::Result<bool, JsValue>;
                    fn add(&self, point: Point) -> std::result::Result<Point, JsValue>;
                    fn is_collinear(&self, point: Point) -> std::result::Result<bool, JsValue>;
                    fn subtract(&self, point: Point) -> std::result::Result<Point, JsValue>;
                    fn get_directed_angle(&self, point: Point)
                        -> std::result::Result<f64, JsValue>;
                    fn set_y(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn y(&self) -> std::result::Result<f64, JsValue>;
                    fn set_angle(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn angle(&self) -> std::result::Result<f64, JsValue>;
                    fn set_quadrant(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn quadrant(&self) -> std::result::Result<f64, JsValue>;
                    fn set_x(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn x(&self) -> std::result::Result<f64, JsValue>;
                    fn to_string(&self) -> std::result::Result<String, JsValue>;
                    fn project(&self, point: Point) -> std::result::Result<Point, JsValue>;
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue>;
                    fn selected(&self) -> std::result::Result<bool, JsValue>;
                    fn set_length(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn length(&self) -> std::result::Result<f64, JsValue>;
                    fn ceil(&self) -> std::result::Result<Point, JsValue>;
                    fn set(&self, values: Box<[JsValue]>) -> std::result::Result<Point, JsValue>;
                    fn get_angle_in_radians(
                        &self,
                        point: Point,
                    ) -> std::result::Result<f64, JsValue>;
                    fn is_in_quadrant(&self, quadrant: f64) -> std::result::Result<bool, JsValue>;
                    fn divide(&self, point: Point) -> std::result::Result<Point, JsValue>;
                    fn max(
                        &self,
                        point1: Point,
                        point2: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    fn equals(&self, point: Point) -> std::result::Result<bool, JsValue>;
                    fn is_close(
                        &self,
                        point: Point,
                        tolerance: f64,
                    ) -> std::result::Result<bool, JsValue>;
                    fn abs(&self) -> std::result::Result<Point, JsValue>;
                    fn get_distance(
                        &self,
                        point: Point,
                        squared: bool,
                    ) -> std::result::Result<f64, JsValue>;
                    fn clone(&self) -> std::result::Result<Point, JsValue>;
                    fn floor(&self) -> std::result::Result<Point, JsValue>;
                    fn set_angle_in_radians(
                        &mut self,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    fn angle_in_radians(&self) -> std::result::Result<f64, JsValue>;
                    fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue>;
                    fn is_na_n(&self) -> std::result::Result<bool, JsValue>;
                    fn min(
                        &self,
                        point1: Point,
                        point2: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    fn modulo(&self, point: Point) -> std::result::Result<Point, JsValue>;
                    fn normalize(&self, length: f64) -> std::result::Result<Point, JsValue>;
                    fn transform(&self, matrix: Matrix) -> std::result::Result<Point, JsValue>;
                    fn round(&self) -> std::result::Result<Point, JsValue>;
                    fn is_zero(&self) -> std::result::Result<bool, JsValue>;
                    fn random(&self) -> std::result::Result<Point, JsValue>;
                    fn dot(&self, point: Point) -> std::result::Result<f64, JsValue>;
                    fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<Point, JsValue>;
                }
                impl Point_Trait for Point {
                    fn multiply(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::multiply(&target, point)
                    }
                    fn cross(&self, point: Point) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Point::cross(&target, point)
                    }
                    fn get_angle(&self, point: Point) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Point::get_angle(&target, point)
                    }
                    fn is_orthogonal(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Point::is_orthogonal(&target, point)
                    }
                    fn add(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::add(&target, point)
                    }
                    fn is_collinear(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Point::is_collinear(&target, point)
                    }
                    fn subtract(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::subtract(&target, point)
                    }
                    fn get_directed_angle(
                        &self,
                        point: Point,
                    ) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Point::get_directed_angle(&target, point)
                    }
                    fn set_y(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Point::set_y(&mut target, value)
                    }
                    fn y(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Point::y(&target)
                    }
                    fn set_angle(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Point::set_angle(&mut target, value)
                    }
                    fn angle(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Point::angle(&target)
                    }
                    fn set_quadrant(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Point::set_quadrant(&mut target, value)
                    }
                    fn quadrant(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Point::quadrant(&target)
                    }
                    fn set_x(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Point::set_x(&mut target, value)
                    }
                    fn x(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Point::x(&target)
                    }
                    fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Point::to_string(&target)
                    }
                    fn project(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::project(&target, point)
                    }
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Point::set_selected(&mut target, value)
                    }
                    fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Point::selected(&target)
                    }
                    fn set_length(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Point::set_length(&mut target, value)
                    }
                    fn length(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Point::length(&target)
                    }
                    fn ceil(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::ceil(&target)
                    }
                    fn set(&self, values: Box<[JsValue]>) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::set(&target, values)
                    }
                    fn get_angle_in_radians(
                        &self,
                        point: Point,
                    ) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Point::get_angle_in_radians(&target, point)
                    }
                    fn is_in_quadrant(&self, quadrant: f64) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Point::is_in_quadrant(&target, quadrant)
                    }
                    fn divide(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::divide(&target, point)
                    }
                    fn max(
                        &self,
                        point1: Point,
                        point2: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::max(&target, point1, point2)
                    }
                    fn equals(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Point::equals(&target, point)
                    }
                    fn is_close(
                        &self,
                        point: Point,
                        tolerance: f64,
                    ) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Point::is_close(&target, point, tolerance)
                    }
                    fn abs(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::abs(&target)
                    }
                    fn get_distance(
                        &self,
                        point: Point,
                        squared: bool,
                    ) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Point::get_distance(&target, point, squared)
                    }
                    fn clone(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::clone(&target)
                    }
                    fn floor(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::floor(&target)
                    }
                    fn set_angle_in_radians(
                        &mut self,
                        value: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Point::set_angle_in_radians(&mut target, value)
                    }
                    fn angle_in_radians(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Point::angle_in_radians(&target)
                    }
                    fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Point::is_inside(&target, rect)
                    }
                    fn is_na_n(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Point::is_na_n(&target)
                    }
                    fn min(
                        &self,
                        point1: Point,
                        point2: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::min(&target, point1, point2)
                    }
                    fn modulo(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::modulo(&target, point)
                    }
                    fn normalize(&self, length: f64) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::normalize(&target, length)
                    }
                    fn transform(&self, matrix: Matrix) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::transform(&target, matrix)
                    }
                    fn round(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::round(&target)
                    }
                    fn is_zero(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Point::is_zero(&target)
                    }
                    fn random(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::random(&target)
                    }
                    fn dot(&self, point: Point) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Point::dot(&target, point)
                    }
                    fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::rotate(&target, angle, center)
                    }
                }
                impl std::clone::Clone for Point_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Point_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Point_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    # [wasm_bindgen (js_name = "ToolEvent" , extends = Event_Class)]
                    pub type ToolEvent_Class;
                    # [wasm_bindgen (method , structural , catch , getter = downPoint , js_class = "ToolEvent")]
                    fn down_point(this: &ToolEvent_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = downPoint , js_class = "ToolEvent")]
                    fn set_down_point(
                        this: &ToolEvent_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = delta , js_class = "ToolEvent")]
                    fn delta(this: &ToolEvent_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = delta , js_class = "ToolEvent")]
                    fn set_delta(
                        this: &ToolEvent_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = point , js_class = "ToolEvent")]
                    fn point(this: &ToolEvent_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = point , js_class = "ToolEvent")]
                    fn set_point(
                        this: &ToolEvent_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = type , js_class = "ToolEvent")]
                    fn type_(this: &ToolEvent_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = type , js_class = "ToolEvent")]
                    fn set_type_(
                        this: &ToolEvent_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = item , js_class = "ToolEvent")]
                    fn item(this: &ToolEvent_Class) -> std::result::Result<Item, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = item , js_class = "ToolEvent")]
                    fn set_item(
                        this: &ToolEvent_Class,
                        value: Item,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = toString , method , js_class = "ToolEvent" , catch)]
                    fn __TSB_to_string(
                        this: &ToolEvent_Class,
                    ) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = middlePoint , js_class = "ToolEvent")]
                    fn middle_point(this: &ToolEvent_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = middlePoint , js_class = "ToolEvent")]
                    fn set_middle_point(
                        this: &ToolEvent_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = count , js_class = "ToolEvent")]
                    fn count(this: &ToolEvent_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = count , js_class = "ToolEvent")]
                    fn set_count(
                        this: &ToolEvent_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = lastPoint , js_class = "ToolEvent")]
                    fn last_point(this: &ToolEvent_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = lastPoint , js_class = "ToolEvent")]
                    fn set_last_point(
                        this: &ToolEvent_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct ToolEvent(pub ToolEvent_Class);
                impl std::convert::From<&ToolEvent> for Event {
                    fn from(src: &ToolEvent) -> Event {
                        let src: &Event_Class = src.0.as_ref();
                        Event(src.clone())
                    }
                }
                impl std::convert::From<&mut ToolEvent> for Event {
                    fn from(src: &mut ToolEvent) -> Event {
                        let src: &Event_Class = src.0.as_ref();
                        Event(src.clone())
                    }
                }
                impl ToolEvent {
                    #[allow(dead_code)]
                    pub fn down_point(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.down_point();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_down_point(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_down_point(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn delta(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.delta();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_delta(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_delta(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn point(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.point();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_point(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_point(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn type_(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.type_();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_type_(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_type_(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn item(&self) -> std::result::Result<Item, JsValue> {
                        let result = self.0.item();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_item(&self, value: Item) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_item(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.__TSB_to_string();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn middle_point(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.middle_point();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_middle_point(
                        &self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_middle_point(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn count(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.count();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_count(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_count(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn last_point(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.last_point();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_last_point(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_last_point(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for ToolEvent {
                    fn describe() {
                        <ToolEvent_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for ToolEvent {
                    type Abi = <ToolEvent_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for ToolEvent {
                    type Abi = <ToolEvent_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        ToolEvent(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a ToolEvent {
                    type Abi = <&'a ToolEvent_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for ToolEvent {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for ToolEvent {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: ToolEvent_Class =
                            <ToolEvent_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait ToolEvent_Trait: Event_Trait {
                    fn set_down_point(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn down_point(&self) -> std::result::Result<Point, JsValue>;
                    fn set_delta(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn delta(&self) -> std::result::Result<Point, JsValue>;
                    fn set_point(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn point(&self) -> std::result::Result<Point, JsValue>;
                    fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn type_(&self) -> std::result::Result<String, JsValue>;
                    fn set_item(&mut self, value: Item) -> std::result::Result<(), JsValue>;
                    fn item(&self) -> std::result::Result<Item, JsValue>;
                    fn to_string(&self) -> std::result::Result<String, JsValue>;
                    fn set_middle_point(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn middle_point(&self) -> std::result::Result<Point, JsValue>;
                    fn set_count(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn count(&self) -> std::result::Result<f64, JsValue>;
                    fn set_last_point(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn last_point(&self) -> std::result::Result<Point, JsValue>;
                }
                impl Event_Trait for ToolEvent {
                    fn set_modifiers(
                        &mut self,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Event = self.into();
                        Event::set_modifiers(&mut target, value)
                    }
                    fn modifiers(&self) -> std::result::Result<JsValue, JsValue> {
                        let target: Event = self.into();
                        Event::modifiers(&target)
                    }
                    fn stop_propagation(&self) -> std::result::Result<(), JsValue> {
                        let target: Event = self.into();
                        Event::stop_propagation(&target)
                    }
                    fn set_time_stamp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Event = self.into();
                        Event::set_time_stamp(&mut target, value)
                    }
                    fn time_stamp(&self) -> std::result::Result<f64, JsValue> {
                        let target: Event = self.into();
                        Event::time_stamp(&target)
                    }
                    fn prevent_default(&self) -> std::result::Result<(), JsValue> {
                        let target: Event = self.into();
                        Event::prevent_default(&target)
                    }
                    fn stop(&self) -> std::result::Result<(), JsValue> {
                        let target: Event = self.into();
                        Event::stop(&target)
                    }
                }
                impl ToolEvent_Trait for ToolEvent
                where
                    ToolEvent: Event_Trait,
                {
                    fn set_down_point(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        ToolEvent::set_down_point(&mut target, value)
                    }
                    fn down_point(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        ToolEvent::down_point(&target)
                    }
                    fn set_delta(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        ToolEvent::set_delta(&mut target, value)
                    }
                    fn delta(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        ToolEvent::delta(&target)
                    }
                    fn set_point(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        ToolEvent::set_point(&mut target, value)
                    }
                    fn point(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        ToolEvent::point(&target)
                    }
                    fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        ToolEvent::set_type_(&mut target, value)
                    }
                    fn type_(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        ToolEvent::type_(&target)
                    }
                    fn set_item(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        ToolEvent::set_item(&mut target, value)
                    }
                    fn item(&self) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        ToolEvent::item(&target)
                    }
                    fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        ToolEvent::to_string(&target)
                    }
                    fn set_middle_point(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        ToolEvent::set_middle_point(&mut target, value)
                    }
                    fn middle_point(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        ToolEvent::middle_point(&target)
                    }
                    fn set_count(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        ToolEvent::set_count(&mut target, value)
                    }
                    fn count(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        ToolEvent::count(&target)
                    }
                    fn set_last_point(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        ToolEvent::set_last_point(&mut target, value)
                    }
                    fn last_point(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        ToolEvent::last_point(&target)
                    }
                }
                impl std::clone::Clone for ToolEvent_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for ToolEvent_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for ToolEvent_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[wasm_bindgen(js_name = "Event")]
                    pub type Event_Class;
                    # [wasm_bindgen (method , structural , catch , getter = modifiers , js_class = "Event")]
                    fn __TSB_modifiers(this: &Event_Class)
                        -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = modifiers , js_class = "Event")]
                    fn __TSB_set_modifiers(
                        this: &Event_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = stopPropagation , method , js_class = "Event" , catch)]
                    fn __TSB_stop_propagation(
                        this: &Event_Class,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = timeStamp , js_class = "Event")]
                    fn time_stamp(this: &Event_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = timeStamp , js_class = "Event")]
                    fn set_time_stamp(
                        this: &Event_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = preventDefault , method , js_class = "Event" , catch)]
                    fn __TSB_prevent_default(
                        this: &Event_Class,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = stop , method , js_class = "Event" , catch)]
                    fn __TSB_stop(this: &Event_Class) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Event(pub Event_Class);
                impl Event {
                    #[allow(dead_code)]
                    pub fn modifiers(&self) -> std::result::Result<JsValue, JsValue> {
                        let result = self.0.__TSB_modifiers();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_modifiers(
                        &self,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_modifiers(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn stop_propagation(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_stop_propagation();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn time_stamp(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.time_stamp();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_time_stamp(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_time_stamp(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn prevent_default(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_prevent_default();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn stop(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_stop();
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Event {
                    fn describe() {
                        <Event_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Event {
                    type Abi = <Event_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Event {
                    type Abi = <Event_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Event(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Event {
                    type Abi = <&'a Event_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Event {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Event {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Event_Class =
                            <Event_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait Event_Trait {
                    fn set_modifiers(&mut self, value: JsValue)
                        -> std::result::Result<(), JsValue>;
                    fn modifiers(&self) -> std::result::Result<JsValue, JsValue>;
                    fn stop_propagation(&self) -> std::result::Result<(), JsValue>;
                    fn set_time_stamp(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn time_stamp(&self) -> std::result::Result<f64, JsValue>;
                    fn prevent_default(&self) -> std::result::Result<(), JsValue>;
                    fn stop(&self) -> std::result::Result<(), JsValue>;
                }
                impl Event_Trait for Event {
                    fn set_modifiers(
                        &mut self,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Event::set_modifiers(&mut target, value)
                    }
                    fn modifiers(&self) -> std::result::Result<JsValue, JsValue> {
                        let target = self;
                        Event::modifiers(&target)
                    }
                    fn stop_propagation(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Event::stop_propagation(&target)
                    }
                    fn set_time_stamp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Event::set_time_stamp(&mut target, value)
                    }
                    fn time_stamp(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Event::time_stamp(&target)
                    }
                    fn prevent_default(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Event::prevent_default(&target)
                    }
                    fn stop(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Event::stop(&target)
                    }
                }
                impl std::clone::Clone for Event_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Event_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Event_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemOnClick {
                    TsBindgenRtNullCase,
                    #[serde(
                        serialize_with = "ItemOnClick::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "ItemOnClick::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                }
                impl ItemOnClick {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    # [wasm_bindgen (js_name = "Layer" , extends = Item_Class , extends = Group_Class)]
                    pub type Layer_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = activate , method , js_class = "Layer" , catch)]
                    fn __TSB_activate(this: &Layer_Class) -> std::result::Result<(), JsValue>;
                    #[wasm_bindgen(constructor, js_class = "Layer")]
                    pub fn new(object: JsValue) -> Layer_Class;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Layer(pub Layer_Class);
                impl std::convert::From<&Layer> for Group {
                    fn from(src: &Layer) -> Group {
                        let src: &Group_Class = src.0.as_ref();
                        Group(src.clone())
                    }
                }
                impl std::convert::From<&mut Layer> for Group {
                    fn from(src: &mut Layer) -> Group {
                        let src: &Group_Class = src.0.as_ref();
                        Group(src.clone())
                    }
                }
                impl std::convert::From<&Layer> for Item {
                    fn from(src: &Layer) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl std::convert::From<&mut Layer> for Item {
                    fn from(src: &mut Layer) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl Layer {
                    #[allow(dead_code)]
                    pub fn activate(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_activate();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn new(object: JsValue) -> Layer {
                        let result = Layer_Class::new(object);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Layer(result)
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Layer {
                    fn describe() {
                        <Layer_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Layer {
                    type Abi = <Layer_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Layer {
                    type Abi = <Layer_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Layer(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Layer {
                    type Abi = <&'a Layer_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Layer {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Layer {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Layer_Class =
                            <Layer_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait Layer_Trait: Group_Trait {
                    fn activate(&self) -> std::result::Result<(), JsValue>;
                }
                impl Group_Trait for Layer
                where
                    Layer: Item_Trait,
                {
                    fn set_clipped(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Group = self.into();
                        Group::set_clipped(&mut target, value)
                    }
                    fn clipped(&self) -> std::result::Result<bool, JsValue> {
                        let target: Group = self.into();
                        Group::clipped(&target)
                    }
                }
                impl Item_Trait for Layer {
                    fn set_stroke_scaling(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_scaling(&mut target, value)
                    }
                    fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_scaling(&target)
                    }
                    fn set_apply_matrix(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_apply_matrix(&mut target, value)
                    }
                    fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::apply_matrix(&target)
                    }
                    fn set_view_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_view_matrix(&mut target, value)
                    }
                    fn view_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::view_matrix(&target)
                    }
                    fn set_dash_array(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_dash_array(&mut target, value)
                    }
                    fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let target: Item = self.into();
                        Item::dash_array(&target)
                    }
                    fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_ancestor(&target, item)
                    }
                    fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_descendant(&target, item)
                    }
                    fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_sibling(&target, item)
                    }
                    fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_parent(&target, point)
                    }
                    fn set_shadow_blur(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_shadow_blur(&mut target, value)
                    }
                    fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_blur(&target)
                    }
                    fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_empty(&target, recursively)
                    }
                    fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_parent(&target, item)
                    }
                    fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_below(&target, item)
                    }
                    fn set_matrix(&mut self, value: Matrix) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_matrix(&mut target, value)
                    }
                    fn matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::matrix(&target)
                    }
                    fn export_json(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::export_json(&target, options)
                    }
                    fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::global_to_local(&target, point)
                    }
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ItemOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_drag(&mut target, value)
                    }
                    fn on_mouse_drag(&self) -> std::result::Result<ItemOnMouseDrag, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_drag(&target)
                    }
                    fn get_item(
                        &self,
                        options: ItemGetItemParamsOptionsParam,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::get_item(&target, options)
                    }
                    fn remove_children(
                        &self,
                        start: f64,
                        end: f64,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::remove_children(&target, start, end)
                    }
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_project(&mut target, value)
                    }
                    fn project(&self) -> std::result::Result<Project, JsValue> {
                        let target: Item = self.into();
                        Item::project(&target)
                    }
                    fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_data(&mut target, value)
                    }
                    fn data(&self) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::data(&target)
                    }
                    fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_above(&target, item)
                    }
                    fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on(&target, options)
                    }
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::transform(&target, matrix)
                    }
                    fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inserted(&target)
                    }
                    fn set_on_mouse_down(
                        &mut self,
                        value: ItemOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_down(&mut target, value)
                    }
                    fn on_mouse_down(&self) -> std::result::Result<ItemOnMouseDown, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_down(&target)
                    }
                    fn set_last_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_last_child(&mut target, value)
                    }
                    fn last_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::last_child(&target)
                    }
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_selected(&mut target, value)
                    }
                    fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::selected(&target)
                    }
                    fn set_global_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_global_matrix(&mut target, value)
                    }
                    fn global_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::global_matrix(&target)
                    }
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::responds(&target, type_)
                    }
                    fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::rotate(&target, angle, center)
                    }
                    fn tween(
                        &self,
                        options: ItemTweenParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween(&target, options)
                    }
                    fn set_on_mouse_enter(
                        &mut self,
                        value: ItemOnMouseEnter,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_enter(&mut target, value)
                    }
                    fn on_mouse_enter(&self) -> std::result::Result<ItemOnMouseEnter, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_enter(&target)
                    }
                    fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_id(&mut target, value)
                    }
                    fn id(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::id(&target)
                    }
                    fn on(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::on(&target, object)
                    }
                    fn tween_to(
                        &self,
                        to: JsValue,
                        options: ItemTweenToParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_to(&target, to, options)
                    }
                    fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_locked(&mut target, value)
                    }
                    fn locked(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::locked(&target)
                    }
                    fn set_children(
                        &mut self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_children(&mut target, value)
                    }
                    fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::children(&target)
                    }
                    fn copy_attributes(
                        &self,
                        source: Item,
                        exclude_matrix: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_attributes(&target, source, exclude_matrix)
                    }
                    fn off(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::off(&target, object)
                    }
                    fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::contains(&target, point)
                    }
                    fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_stroke(&target)
                    }
                    fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_move(&target)
                    }
                    fn add_children(
                        &self,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::add_children(&target, items)
                    }
                    fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::reverse_children(&target)
                    }
                    fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_shadow(&target)
                    }
                    fn set_dash_offset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_dash_offset(&mut target, value)
                    }
                    fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::dash_offset(&target)
                    }
                    fn set_on_mouse_leave(
                        &mut self,
                        value: ItemOnMouseLeave,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_leave(&mut target, value)
                    }
                    fn on_mouse_leave(&self) -> std::result::Result<ItemOnMouseLeave, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_leave(&target)
                    }
                    fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test_all(&target, point, options)
                    }
                    fn set_stroke_cap(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_cap(&mut target, value)
                    }
                    fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_cap(&target)
                    }
                    fn set_internal_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_internal_bounds(&mut target, value)
                    }
                    fn internal_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::internal_bounds(&target)
                    }
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_index(&mut target, value)
                    }
                    fn index(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::index(&target)
                    }
                    fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::reduce(&target, options)
                    }
                    fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_grouped_with(&target, item)
                    }
                    fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_global(&target, point)
                    }
                    fn set_first_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_first_child(&mut target, value)
                    }
                    fn first_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::first_child(&target)
                    }
                    fn set_position(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_position(&mut target, value)
                    }
                    fn position(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::position(&target)
                    }
                    fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_opacity(&mut target, value)
                    }
                    fn opacity(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::opacity(&target)
                    }
                    fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_down(&target)
                    }
                    fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_drag(&target)
                    }
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_bounds(&mut target, value)
                    }
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::bounds(&target)
                    }
                    fn set_parent(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_parent(&mut target, value)
                    }
                    fn parent(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::parent(&target)
                    }
                    fn get_items(
                        &self,
                        options: ItemGetItemsParamsOptionsParam,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::get_items(&target, options)
                    }
                    fn copy_to(
                        &self,
                        owner: ItemCopyToParamsOwnerParam,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::copy_to(&target, owner)
                    }
                    fn set_on_double_click(
                        &mut self,
                        value: ItemOnDoubleClick,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_double_click(&mut target, value)
                    }
                    fn on_double_click(&self) -> std::result::Result<ItemOnDoubleClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_double_click(&target)
                    }
                    fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::set(&target, props)
                    }
                    fn scale(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::scale(&target, hor, ver, center)
                    }
                    fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_below(&target, item)
                    }
                    fn set_next_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_next_sibling(&mut target, value)
                    }
                    fn next_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::next_sibling(&target)
                    }
                    fn rasterize(&self, options: JsValue) -> std::result::Result<Raster, JsValue> {
                        let target: Item = self.into();
                        Item::rasterize(&target, options)
                    }
                    fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::bring_to_front(&target)
                    }
                    fn matches(
                        &self,
                        name: String,
                        compare: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::matches(&target, name, compare)
                    }
                    fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_fill(&target)
                    }
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_view(&mut target, value)
                    }
                    fn view(&self) -> std::result::Result<View, JsValue> {
                        let target: Item = self.into();
                        Item::view(&target)
                    }
                    fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::clone(&target, options)
                    }
                    fn set_handle_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_handle_bounds(&mut target, value)
                    }
                    fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::handle_bounds(&target)
                    }
                    fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inside(&target, rect)
                    }
                    fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_above(&target, item)
                    }
                    fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::remove(&target)
                    }
                    fn set_stroke_join(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_join(&mut target, value)
                    }
                    fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_join(&target)
                    }
                    fn set_on_click(
                        &mut self,
                        value: ItemOnClick,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_click(&mut target, value)
                    }
                    fn on_click(&self) -> std::result::Result<ItemOnClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_click(&target)
                    }
                    fn fit_bounds(
                        &self,
                        rectangle: Rectangle,
                        fill: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::fit_bounds(&target, rectangle, fill)
                    }
                    fn set_blend_mode(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_blend_mode(&mut target, value)
                    }
                    fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::blend_mode(&target)
                    }
                    fn set_stroke_width(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_width(&mut target, value)
                    }
                    fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_width(&target)
                    }
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_rotation(&mut target, value)
                    }
                    fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::rotation(&target)
                    }
                    fn set_selected_color(
                        &mut self,
                        value: ItemSelectedColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_selected_color(&mut target, value)
                    }
                    fn selected_color(&self) -> std::result::Result<ItemSelectedColor, JsValue> {
                        let target: Item = self.into();
                        Item::selected_color(&target)
                    }
                    fn skew(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::skew(&target, hor, ver, center)
                    }
                    fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_name(&mut target, value)
                    }
                    fn name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::name(&target)
                    }
                    fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_json(&target, json)
                    }
                    fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::add_child(&target, item)
                    }
                    fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_visible(&mut target, value)
                    }
                    fn visible(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::visible(&target)
                    }
                    fn set_fill_rule(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_fill_rule(&mut target, value)
                    }
                    fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::fill_rule(&target)
                    }
                    fn set_layer(&mut self, value: Layer) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_layer(&mut target, value)
                    }
                    fn layer(&self) -> std::result::Result<Layer, JsValue> {
                        let target: Item = self.into();
                        Item::layer(&target)
                    }
                    fn tween_from(
                        &self,
                        from: JsValue,
                        options: ItemTweenFromParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_from(&target, from, options)
                    }
                    fn insert_child(
                        &self,
                        index: f64,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_child(&target, index, item)
                    }
                    fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_up(&target)
                    }
                    fn set_pivot(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_pivot(&mut target, value)
                    }
                    fn pivot(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::pivot(&target)
                    }
                    fn set_miter_limit(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_miter_limit(&mut target, value)
                    }
                    fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::miter_limit(&target)
                    }
                    fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_content(&target, source)
                    }
                    fn import_svg(
                        &self,
                        svg: ItemImportSvgParamsSvgParam,
                        on_load: &'static dyn Fn(
                            Box<[JsValue]>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_svg(&target, svg, on_load)
                    }
                    fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::send_to_back(&target)
                    }
                    fn set_stroke_color(
                        &mut self,
                        value: ItemStrokeColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_color(&mut target, value)
                    }
                    fn stroke_color(&self) -> std::result::Result<ItemStrokeColor, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_color(&target)
                    }
                    fn set_on_mouse_move(
                        &mut self,
                        value: ItemOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_move(&mut target, value)
                    }
                    fn on_mouse_move(&self) -> std::result::Result<ItemOnMouseMove, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_move(&target)
                    }
                    fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::replace_with(&target, item)
                    }
                    fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test(&target, point, options)
                    }
                    fn shear(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::shear(&target, hor, ver, center)
                    }
                    fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::translate(&target, delta)
                    }
                    fn set_stroke_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_bounds(&mut target, value)
                    }
                    fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_bounds(&target)
                    }
                    fn insert_children(
                        &self,
                        index: f64,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::insert_children(&target, index, items)
                    }
                    fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_child(&target, item)
                    }
                    fn set_shadow_offset(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_shadow_offset(&mut target, value)
                    }
                    fn shadow_offset(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_offset(&target)
                    }
                    fn set_fill_color(
                        &mut self,
                        value: ItemFillColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_fill_color(&mut target, value)
                    }
                    fn fill_color(&self) -> std::result::Result<ItemFillColor, JsValue> {
                        let target: Item = self.into();
                        Item::fill_color(&target)
                    }
                    fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                        let target: Item = self.into();
                        Item::export_svg(&target, options)
                    }
                    fn set_style(&mut self, value: Style) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_style(&mut target, value)
                    }
                    fn style(&self) -> std::result::Result<Style, JsValue> {
                        let target: Item = self.into();
                        Item::style(&target)
                    }
                    fn set_clip_mask(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_clip_mask(&mut target, value)
                    }
                    fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::clip_mask(&target)
                    }
                    fn set_class_name(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_class_name(&mut target, value)
                    }
                    fn class_name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::class_name(&target)
                    }
                    fn set_on_mouse_up(
                        &mut self,
                        value: ItemOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_up(&mut target, value)
                    }
                    fn on_mouse_up(&self) -> std::result::Result<ItemOnMouseUp, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_up(&target)
                    }
                    fn set_on_frame(
                        &mut self,
                        value: ItemOnFrame,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_frame(&mut target, value)
                    }
                    fn on_frame(&self) -> std::result::Result<ItemOnFrame, JsValue> {
                        let target: Item = self.into();
                        Item::on_frame(&target)
                    }
                    fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::parent_to_local(&target, point)
                    }
                    fn set_previous_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_previous_sibling(&mut target, value)
                    }
                    fn previous_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::previous_sibling(&target)
                    }
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::emit(&target, type_, event)
                    }
                    fn add_to(
                        &self,
                        owner: ItemAddToParamsOwnerParam,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::add_to(&target, owner)
                    }
                    fn has_children(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_children(&target)
                    }
                    fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::intersects(&target, item)
                    }
                    fn set_shadow_color(
                        &mut self,
                        value: ItemShadowColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_shadow_color(&mut target, value)
                    }
                    fn shadow_color(&self) -> std::result::Result<ItemShadowColor, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_color(&target)
                    }
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_scaling(&mut target, value)
                    }
                    fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::scaling(&target)
                    }
                }
                impl Layer_Trait for Layer
                where
                    Layer: Group_Trait,
                {
                    fn activate(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Layer::activate(&target)
                    }
                }
                impl std::clone::Clone for Layer_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Layer_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Layer_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    # [wasm_bindgen (js_name = "Raster" , extends = Item_Class)]
                    pub type Raster_Class;
                    # [wasm_bindgen (method , structural , catch , getter = smoothing , js_class = "Raster")]
                    fn smoothing(this: &Raster_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = smoothing , js_class = "Raster")]
                    fn set_smoothing(
                        this: &Raster_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getAverageColor , method , js_class = "Raster" , catch)]
                    fn __TSB_get_average_color(
                        this: &Raster_Class,
                        object: JsValue,
                    ) -> std::result::Result<Color, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getPixel , method , js_class = "Raster" , catch)]
                    fn __TSB_get_pixel(
                        this: &Raster_Class,
                        point: Point,
                    ) -> std::result::Result<Color, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = height , js_class = "Raster")]
                    fn height(this: &Raster_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = height , js_class = "Raster")]
                    fn set_height(
                        this: &Raster_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = loaded , js_class = "Raster")]
                    fn loaded(this: &Raster_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = loaded , js_class = "Raster")]
                    fn set_loaded(
                        this: &Raster_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = crossOrigin , js_class = "Raster")]
                    fn cross_origin(this: &Raster_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = crossOrigin , js_class = "Raster")]
                    fn set_cross_origin(
                        this: &Raster_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = canvas , js_class = "Raster")]
                    fn __TSB_canvas(
                        this: &Raster_Class,
                    ) -> std::result::Result<web_sys::HtmlCanvasElement, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = canvas , js_class = "Raster")]
                    fn __TSB_set_canvas(
                        this: &Raster_Class,
                        value: web_sys::HtmlCanvasElement,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getSubRaster , method , js_class = "Raster" , catch)]
                    fn __TSB_get_sub_raster(
                        this: &Raster_Class,
                        rect: Rectangle,
                    ) -> std::result::Result<Raster, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = image , js_class = "Raster")]
                    fn __TSB_image(this: &Raster_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = image , js_class = "Raster")]
                    fn __TSB_set_image(
                        this: &Raster_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = drawImage , method , js_class = "Raster" , catch)]
                    fn __TSB_draw_image(
                        this: &Raster_Class,
                        image: JsValue,
                        point: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = resolution , js_class = "Raster")]
                    fn resolution(this: &Raster_Class) -> std::result::Result<Size, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = resolution , js_class = "Raster")]
                    fn set_resolution(
                        this: &Raster_Class,
                        value: Size,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = size , js_class = "Raster")]
                    fn size(this: &Raster_Class) -> std::result::Result<Size, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = size , js_class = "Raster")]
                    fn set_size(
                        this: &Raster_Class,
                        value: Size,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = toDataURL , method , js_class = "Raster" , catch)]
                    fn __TSB_to_data_url(
                        this: &Raster_Class,
                    ) -> std::result::Result<String, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clear , method , js_class = "Raster" , catch)]
                    fn __TSB_clear(this: &Raster_Class) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = setPixel , method , js_class = "Raster" , catch)]
                    fn __TSB_set_pixel(
                        this: &Raster_Class,
                        point: Point,
                        color: Color,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onError , js_class = "Raster")]
                    fn __TSB_on_error(this: &Raster_Class)
                        -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onError , js_class = "Raster")]
                    fn __TSB_set_on_error(
                        this: &Raster_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = source , js_class = "Raster")]
                    fn __TSB_source(this: &Raster_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = source , js_class = "Raster")]
                    fn __TSB_set_source(
                        this: &Raster_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = setImageData , method , js_class = "Raster" , catch)]
                    fn __TSB_set_image_data(
                        this: &Raster_Class,
                        data: web_sys::ImageData,
                        point: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = createImageData , method , js_class = "Raster" , catch)]
                    fn __TSB_create_image_data(
                        this: &Raster_Class,
                        size: Size,
                    ) -> std::result::Result<web_sys::ImageData, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = width , js_class = "Raster")]
                    fn width(this: &Raster_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = width , js_class = "Raster")]
                    fn set_width(
                        this: &Raster_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[wasm_bindgen(constructor, js_class = "Raster")]
                    pub fn new(object: JsValue) -> Raster_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getSubCanvas , method , js_class = "Raster" , catch)]
                    fn __TSB_get_sub_canvas(
                        this: &Raster_Class,
                        rect: Rectangle,
                    ) -> std::result::Result<web_sys::HtmlCanvasElement, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getImageData , method , js_class = "Raster" , catch)]
                    fn __TSB_get_image_data(
                        this: &Raster_Class,
                        rect: Rectangle,
                    ) -> std::result::Result<web_sys::ImageData, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onLoad , js_class = "Raster")]
                    fn __TSB_on_load(this: &Raster_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onLoad , js_class = "Raster")]
                    fn __TSB_set_on_load(
                        this: &Raster_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = context , js_class = "Raster")]
                    fn __TSB_context(
                        this: &Raster_Class,
                    ) -> std::result::Result<web_sys::CanvasRenderingContext2d, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = context , js_class = "Raster")]
                    fn __TSB_set_context(
                        this: &Raster_Class,
                        value: web_sys::CanvasRenderingContext2d,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Raster(pub Raster_Class);
                impl std::convert::From<&Raster> for Item {
                    fn from(src: &Raster) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl std::convert::From<&mut Raster> for Item {
                    fn from(src: &mut Raster) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl Raster {
                    #[allow(dead_code)]
                    pub fn smoothing(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.smoothing();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_smoothing(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_smoothing(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_average_color(
                        &self,
                        object: RasterGetAverageColorParamsObjectParam,
                    ) -> std::result::Result<Color, JsValue> {
                        let result = self.0.__TSB_get_average_color(
                            ts_bindgen_rt::to_jsvalue(&object)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_pixel(&self, point: Point) -> std::result::Result<Color, JsValue> {
                        let result = self.0.__TSB_get_pixel(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn height(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.height();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_height(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_height(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn loaded(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.loaded();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_loaded(&self, value: bool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_loaded(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn cross_origin(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.cross_origin();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_cross_origin(
                        &self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_cross_origin(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn canvas(
                        &self,
                    ) -> std::result::Result<web_sys::HtmlCanvasElement, JsValue>
                    {
                        let result = self.0.__TSB_canvas();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_canvas(
                        &self,
                        value: web_sys::HtmlCanvasElement,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_canvas(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_sub_raster(
                        &self,
                        rect: Rectangle,
                    ) -> std::result::Result<Raster, JsValue> {
                        let result = self.0.__TSB_get_sub_raster(rect);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn image(&self) -> std::result::Result<RasterImage, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_image()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_image(
                        &self,
                        value: RasterImage,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_image(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn draw_image(
                        &self,
                        image: JsValue,
                        point: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_draw_image(image, point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn resolution(&self) -> std::result::Result<Size, JsValue> {
                        let result = self.0.resolution();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_resolution(&self, value: Size) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_resolution(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn size(&self) -> std::result::Result<Size, JsValue> {
                        let result = self.0.size();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_size(&self, value: Size) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_size(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn to_data_url(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.__TSB_to_data_url();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn clear(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_clear();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_pixel(
                        &self,
                        point: Point,
                        color: Color,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_pixel(point, color);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn on_error(&self) -> std::result::Result<RasterOnError, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_error()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_on_error(
                        &self,
                        value: RasterOnError,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_error(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn source(&self) -> std::result::Result<RasterSource, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_source()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_source(
                        &self,
                        value: RasterSource,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_source(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_image_data(
                        &self,
                        data: web_sys::ImageData,
                        point: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_image_data(data, point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn create_image_data(
                        &self,
                        size: Size,
                    ) -> std::result::Result<web_sys::ImageData, JsValue> {
                        let result = self.0.__TSB_create_image_data(size);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn width(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.width();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_width(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_width(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn new(object: JsValue) -> Raster {
                        let result = Raster_Class::new(object);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Raster(result)
                    }
                    #[allow(dead_code)]
                    pub fn get_sub_canvas(
                        &self,
                        rect: Rectangle,
                    ) -> std::result::Result<web_sys::HtmlCanvasElement, JsValue>
                    {
                        let result = self.0.__TSB_get_sub_canvas(rect);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_image_data(
                        &self,
                        rect: Rectangle,
                    ) -> std::result::Result<web_sys::ImageData, JsValue> {
                        let result = self.0.__TSB_get_image_data(rect);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn on_load(&self) -> std::result::Result<RasterOnLoad, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_load()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_on_load(
                        &self,
                        value: RasterOnLoad,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_load(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn context(
                        &self,
                    ) -> std::result::Result<web_sys::CanvasRenderingContext2d, JsValue>
                    {
                        let result = self.0.__TSB_context();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_context(
                        &self,
                        value: web_sys::CanvasRenderingContext2d,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_context(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Raster {
                    fn describe() {
                        <Raster_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Raster {
                    type Abi = <Raster_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Raster {
                    type Abi = <Raster_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Raster(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Raster {
                    type Abi = <&'a Raster_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Raster {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Raster {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Raster_Class =
                            <Raster_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait Raster_Trait: Item_Trait {
                    fn set_smoothing(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn smoothing(&self) -> std::result::Result<String, JsValue>;
                    fn get_average_color(
                        &self,
                        object: RasterGetAverageColorParamsObjectParam,
                    ) -> std::result::Result<Color, JsValue>;
                    fn get_pixel(&self, point: Point) -> std::result::Result<Color, JsValue>;
                    fn set_height(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn height(&self) -> std::result::Result<f64, JsValue>;
                    fn set_loaded(&mut self, value: bool) -> std::result::Result<(), JsValue>;
                    fn loaded(&self) -> std::result::Result<bool, JsValue>;
                    fn set_cross_origin(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    fn cross_origin(&self) -> std::result::Result<String, JsValue>;
                    fn set_canvas(
                        &mut self,
                        value: web_sys::HtmlCanvasElement,
                    ) -> std::result::Result<(), JsValue>;
                    fn canvas(&self) -> std::result::Result<web_sys::HtmlCanvasElement, JsValue>;
                    fn get_sub_raster(
                        &self,
                        rect: Rectangle,
                    ) -> std::result::Result<Raster, JsValue>;
                    fn set_image(&mut self, value: RasterImage)
                        -> std::result::Result<(), JsValue>;
                    fn image(&self) -> std::result::Result<RasterImage, JsValue>;
                    fn draw_image(
                        &self,
                        image: JsValue,
                        point: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn set_resolution(&mut self, value: Size) -> std::result::Result<(), JsValue>;
                    fn resolution(&self) -> std::result::Result<Size, JsValue>;
                    fn set_size(&mut self, value: Size) -> std::result::Result<(), JsValue>;
                    fn size(&self) -> std::result::Result<Size, JsValue>;
                    fn to_data_url(&self) -> std::result::Result<String, JsValue>;
                    fn clear(&self) -> std::result::Result<(), JsValue>;
                    fn set_pixel(
                        &self,
                        point: Point,
                        color: Color,
                    ) -> std::result::Result<(), JsValue>;
                    fn set_on_error(
                        &mut self,
                        value: RasterOnError,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_error(&self) -> std::result::Result<RasterOnError, JsValue>;
                    fn set_source(
                        &mut self,
                        value: RasterSource,
                    ) -> std::result::Result<(), JsValue>;
                    fn source(&self) -> std::result::Result<RasterSource, JsValue>;
                    fn set_image_data(
                        &self,
                        data: web_sys::ImageData,
                        point: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn create_image_data(
                        &self,
                        size: Size,
                    ) -> std::result::Result<web_sys::ImageData, JsValue>;
                    fn set_width(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn width(&self) -> std::result::Result<f64, JsValue>;
                    fn get_sub_canvas(
                        &self,
                        rect: Rectangle,
                    ) -> std::result::Result<web_sys::HtmlCanvasElement, JsValue>;
                    fn get_image_data(
                        &self,
                        rect: Rectangle,
                    ) -> std::result::Result<web_sys::ImageData, JsValue>;
                    fn set_on_load(
                        &mut self,
                        value: RasterOnLoad,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_load(&self) -> std::result::Result<RasterOnLoad, JsValue>;
                    fn set_context(
                        &mut self,
                        value: web_sys::CanvasRenderingContext2d,
                    ) -> std::result::Result<(), JsValue>;
                    fn context(
                        &self,
                    ) -> std::result::Result<web_sys::CanvasRenderingContext2d, JsValue>;
                }
                impl Item_Trait for Raster {
                    fn set_stroke_scaling(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_scaling(&mut target, value)
                    }
                    fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_scaling(&target)
                    }
                    fn set_apply_matrix(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_apply_matrix(&mut target, value)
                    }
                    fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::apply_matrix(&target)
                    }
                    fn set_view_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_view_matrix(&mut target, value)
                    }
                    fn view_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::view_matrix(&target)
                    }
                    fn set_dash_array(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_dash_array(&mut target, value)
                    }
                    fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let target: Item = self.into();
                        Item::dash_array(&target)
                    }
                    fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_ancestor(&target, item)
                    }
                    fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_descendant(&target, item)
                    }
                    fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_sibling(&target, item)
                    }
                    fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_parent(&target, point)
                    }
                    fn set_shadow_blur(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_shadow_blur(&mut target, value)
                    }
                    fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_blur(&target)
                    }
                    fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_empty(&target, recursively)
                    }
                    fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_parent(&target, item)
                    }
                    fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_below(&target, item)
                    }
                    fn set_matrix(&mut self, value: Matrix) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_matrix(&mut target, value)
                    }
                    fn matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::matrix(&target)
                    }
                    fn export_json(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::export_json(&target, options)
                    }
                    fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::global_to_local(&target, point)
                    }
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ItemOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_drag(&mut target, value)
                    }
                    fn on_mouse_drag(&self) -> std::result::Result<ItemOnMouseDrag, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_drag(&target)
                    }
                    fn get_item(
                        &self,
                        options: ItemGetItemParamsOptionsParam,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::get_item(&target, options)
                    }
                    fn remove_children(
                        &self,
                        start: f64,
                        end: f64,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::remove_children(&target, start, end)
                    }
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_project(&mut target, value)
                    }
                    fn project(&self) -> std::result::Result<Project, JsValue> {
                        let target: Item = self.into();
                        Item::project(&target)
                    }
                    fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_data(&mut target, value)
                    }
                    fn data(&self) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::data(&target)
                    }
                    fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_above(&target, item)
                    }
                    fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on(&target, options)
                    }
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::transform(&target, matrix)
                    }
                    fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inserted(&target)
                    }
                    fn set_on_mouse_down(
                        &mut self,
                        value: ItemOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_down(&mut target, value)
                    }
                    fn on_mouse_down(&self) -> std::result::Result<ItemOnMouseDown, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_down(&target)
                    }
                    fn set_last_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_last_child(&mut target, value)
                    }
                    fn last_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::last_child(&target)
                    }
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_selected(&mut target, value)
                    }
                    fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::selected(&target)
                    }
                    fn set_global_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_global_matrix(&mut target, value)
                    }
                    fn global_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::global_matrix(&target)
                    }
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::responds(&target, type_)
                    }
                    fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::rotate(&target, angle, center)
                    }
                    fn tween(
                        &self,
                        options: ItemTweenParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween(&target, options)
                    }
                    fn set_on_mouse_enter(
                        &mut self,
                        value: ItemOnMouseEnter,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_enter(&mut target, value)
                    }
                    fn on_mouse_enter(&self) -> std::result::Result<ItemOnMouseEnter, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_enter(&target)
                    }
                    fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_id(&mut target, value)
                    }
                    fn id(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::id(&target)
                    }
                    fn on(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::on(&target, object)
                    }
                    fn tween_to(
                        &self,
                        to: JsValue,
                        options: ItemTweenToParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_to(&target, to, options)
                    }
                    fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_locked(&mut target, value)
                    }
                    fn locked(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::locked(&target)
                    }
                    fn set_children(
                        &mut self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_children(&mut target, value)
                    }
                    fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::children(&target)
                    }
                    fn copy_attributes(
                        &self,
                        source: Item,
                        exclude_matrix: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_attributes(&target, source, exclude_matrix)
                    }
                    fn off(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::off(&target, object)
                    }
                    fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::contains(&target, point)
                    }
                    fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_stroke(&target)
                    }
                    fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_move(&target)
                    }
                    fn add_children(
                        &self,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::add_children(&target, items)
                    }
                    fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::reverse_children(&target)
                    }
                    fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_shadow(&target)
                    }
                    fn set_dash_offset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_dash_offset(&mut target, value)
                    }
                    fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::dash_offset(&target)
                    }
                    fn set_on_mouse_leave(
                        &mut self,
                        value: ItemOnMouseLeave,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_leave(&mut target, value)
                    }
                    fn on_mouse_leave(&self) -> std::result::Result<ItemOnMouseLeave, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_leave(&target)
                    }
                    fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test_all(&target, point, options)
                    }
                    fn set_stroke_cap(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_cap(&mut target, value)
                    }
                    fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_cap(&target)
                    }
                    fn set_internal_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_internal_bounds(&mut target, value)
                    }
                    fn internal_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::internal_bounds(&target)
                    }
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_index(&mut target, value)
                    }
                    fn index(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::index(&target)
                    }
                    fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::reduce(&target, options)
                    }
                    fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_grouped_with(&target, item)
                    }
                    fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_global(&target, point)
                    }
                    fn set_first_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_first_child(&mut target, value)
                    }
                    fn first_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::first_child(&target)
                    }
                    fn set_position(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_position(&mut target, value)
                    }
                    fn position(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::position(&target)
                    }
                    fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_opacity(&mut target, value)
                    }
                    fn opacity(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::opacity(&target)
                    }
                    fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_down(&target)
                    }
                    fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_drag(&target)
                    }
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_bounds(&mut target, value)
                    }
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::bounds(&target)
                    }
                    fn set_parent(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_parent(&mut target, value)
                    }
                    fn parent(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::parent(&target)
                    }
                    fn get_items(
                        &self,
                        options: ItemGetItemsParamsOptionsParam,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::get_items(&target, options)
                    }
                    fn copy_to(
                        &self,
                        owner: ItemCopyToParamsOwnerParam,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::copy_to(&target, owner)
                    }
                    fn set_on_double_click(
                        &mut self,
                        value: ItemOnDoubleClick,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_double_click(&mut target, value)
                    }
                    fn on_double_click(&self) -> std::result::Result<ItemOnDoubleClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_double_click(&target)
                    }
                    fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::set(&target, props)
                    }
                    fn scale(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::scale(&target, hor, ver, center)
                    }
                    fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_below(&target, item)
                    }
                    fn set_next_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_next_sibling(&mut target, value)
                    }
                    fn next_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::next_sibling(&target)
                    }
                    fn rasterize(&self, options: JsValue) -> std::result::Result<Raster, JsValue> {
                        let target: Item = self.into();
                        Item::rasterize(&target, options)
                    }
                    fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::bring_to_front(&target)
                    }
                    fn matches(
                        &self,
                        name: String,
                        compare: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::matches(&target, name, compare)
                    }
                    fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_fill(&target)
                    }
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_view(&mut target, value)
                    }
                    fn view(&self) -> std::result::Result<View, JsValue> {
                        let target: Item = self.into();
                        Item::view(&target)
                    }
                    fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::clone(&target, options)
                    }
                    fn set_handle_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_handle_bounds(&mut target, value)
                    }
                    fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::handle_bounds(&target)
                    }
                    fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inside(&target, rect)
                    }
                    fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_above(&target, item)
                    }
                    fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::remove(&target)
                    }
                    fn set_stroke_join(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_join(&mut target, value)
                    }
                    fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_join(&target)
                    }
                    fn set_on_click(
                        &mut self,
                        value: ItemOnClick,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_click(&mut target, value)
                    }
                    fn on_click(&self) -> std::result::Result<ItemOnClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_click(&target)
                    }
                    fn fit_bounds(
                        &self,
                        rectangle: Rectangle,
                        fill: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::fit_bounds(&target, rectangle, fill)
                    }
                    fn set_blend_mode(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_blend_mode(&mut target, value)
                    }
                    fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::blend_mode(&target)
                    }
                    fn set_stroke_width(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_width(&mut target, value)
                    }
                    fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_width(&target)
                    }
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_rotation(&mut target, value)
                    }
                    fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::rotation(&target)
                    }
                    fn set_selected_color(
                        &mut self,
                        value: ItemSelectedColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_selected_color(&mut target, value)
                    }
                    fn selected_color(&self) -> std::result::Result<ItemSelectedColor, JsValue> {
                        let target: Item = self.into();
                        Item::selected_color(&target)
                    }
                    fn skew(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::skew(&target, hor, ver, center)
                    }
                    fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_name(&mut target, value)
                    }
                    fn name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::name(&target)
                    }
                    fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_json(&target, json)
                    }
                    fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::add_child(&target, item)
                    }
                    fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_visible(&mut target, value)
                    }
                    fn visible(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::visible(&target)
                    }
                    fn set_fill_rule(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_fill_rule(&mut target, value)
                    }
                    fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::fill_rule(&target)
                    }
                    fn set_layer(&mut self, value: Layer) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_layer(&mut target, value)
                    }
                    fn layer(&self) -> std::result::Result<Layer, JsValue> {
                        let target: Item = self.into();
                        Item::layer(&target)
                    }
                    fn tween_from(
                        &self,
                        from: JsValue,
                        options: ItemTweenFromParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_from(&target, from, options)
                    }
                    fn insert_child(
                        &self,
                        index: f64,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_child(&target, index, item)
                    }
                    fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_up(&target)
                    }
                    fn set_pivot(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_pivot(&mut target, value)
                    }
                    fn pivot(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::pivot(&target)
                    }
                    fn set_miter_limit(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_miter_limit(&mut target, value)
                    }
                    fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::miter_limit(&target)
                    }
                    fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_content(&target, source)
                    }
                    fn import_svg(
                        &self,
                        svg: ItemImportSvgParamsSvgParam,
                        on_load: &'static dyn Fn(
                            Box<[JsValue]>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_svg(&target, svg, on_load)
                    }
                    fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::send_to_back(&target)
                    }
                    fn set_stroke_color(
                        &mut self,
                        value: ItemStrokeColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_color(&mut target, value)
                    }
                    fn stroke_color(&self) -> std::result::Result<ItemStrokeColor, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_color(&target)
                    }
                    fn set_on_mouse_move(
                        &mut self,
                        value: ItemOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_move(&mut target, value)
                    }
                    fn on_mouse_move(&self) -> std::result::Result<ItemOnMouseMove, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_move(&target)
                    }
                    fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::replace_with(&target, item)
                    }
                    fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test(&target, point, options)
                    }
                    fn shear(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::shear(&target, hor, ver, center)
                    }
                    fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::translate(&target, delta)
                    }
                    fn set_stroke_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_bounds(&mut target, value)
                    }
                    fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_bounds(&target)
                    }
                    fn insert_children(
                        &self,
                        index: f64,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::insert_children(&target, index, items)
                    }
                    fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_child(&target, item)
                    }
                    fn set_shadow_offset(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_shadow_offset(&mut target, value)
                    }
                    fn shadow_offset(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_offset(&target)
                    }
                    fn set_fill_color(
                        &mut self,
                        value: ItemFillColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_fill_color(&mut target, value)
                    }
                    fn fill_color(&self) -> std::result::Result<ItemFillColor, JsValue> {
                        let target: Item = self.into();
                        Item::fill_color(&target)
                    }
                    fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                        let target: Item = self.into();
                        Item::export_svg(&target, options)
                    }
                    fn set_style(&mut self, value: Style) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_style(&mut target, value)
                    }
                    fn style(&self) -> std::result::Result<Style, JsValue> {
                        let target: Item = self.into();
                        Item::style(&target)
                    }
                    fn set_clip_mask(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_clip_mask(&mut target, value)
                    }
                    fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::clip_mask(&target)
                    }
                    fn set_class_name(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_class_name(&mut target, value)
                    }
                    fn class_name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::class_name(&target)
                    }
                    fn set_on_mouse_up(
                        &mut self,
                        value: ItemOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_up(&mut target, value)
                    }
                    fn on_mouse_up(&self) -> std::result::Result<ItemOnMouseUp, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_up(&target)
                    }
                    fn set_on_frame(
                        &mut self,
                        value: ItemOnFrame,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_frame(&mut target, value)
                    }
                    fn on_frame(&self) -> std::result::Result<ItemOnFrame, JsValue> {
                        let target: Item = self.into();
                        Item::on_frame(&target)
                    }
                    fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::parent_to_local(&target, point)
                    }
                    fn set_previous_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_previous_sibling(&mut target, value)
                    }
                    fn previous_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::previous_sibling(&target)
                    }
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::emit(&target, type_, event)
                    }
                    fn add_to(
                        &self,
                        owner: ItemAddToParamsOwnerParam,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::add_to(&target, owner)
                    }
                    fn has_children(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_children(&target)
                    }
                    fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::intersects(&target, item)
                    }
                    fn set_shadow_color(
                        &mut self,
                        value: ItemShadowColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_shadow_color(&mut target, value)
                    }
                    fn shadow_color(&self) -> std::result::Result<ItemShadowColor, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_color(&target)
                    }
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_scaling(&mut target, value)
                    }
                    fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::scaling(&target)
                    }
                }
                impl Raster_Trait for Raster
                where
                    Raster: Item_Trait,
                {
                    fn set_smoothing(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Raster::set_smoothing(&mut target, value)
                    }
                    fn smoothing(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Raster::smoothing(&target)
                    }
                    fn get_average_color(
                        &self,
                        object: RasterGetAverageColorParamsObjectParam,
                    ) -> std::result::Result<Color, JsValue> {
                        let target = self;
                        Raster::get_average_color(&target, object)
                    }
                    fn get_pixel(&self, point: Point) -> std::result::Result<Color, JsValue> {
                        let target = self;
                        Raster::get_pixel(&target, point)
                    }
                    fn set_height(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Raster::set_height(&mut target, value)
                    }
                    fn height(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Raster::height(&target)
                    }
                    fn set_loaded(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Raster::set_loaded(&mut target, value)
                    }
                    fn loaded(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Raster::loaded(&target)
                    }
                    fn set_cross_origin(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Raster::set_cross_origin(&mut target, value)
                    }
                    fn cross_origin(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Raster::cross_origin(&target)
                    }
                    fn set_canvas(
                        &mut self,
                        value: web_sys::HtmlCanvasElement,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Raster::set_canvas(&mut target, value)
                    }
                    fn canvas(&self) -> std::result::Result<web_sys::HtmlCanvasElement, JsValue> {
                        let target = self;
                        Raster::canvas(&target)
                    }
                    fn get_sub_raster(
                        &self,
                        rect: Rectangle,
                    ) -> std::result::Result<Raster, JsValue> {
                        let target = self;
                        Raster::get_sub_raster(&target, rect)
                    }
                    fn set_image(
                        &mut self,
                        value: RasterImage,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Raster::set_image(&mut target, value)
                    }
                    fn image(&self) -> std::result::Result<RasterImage, JsValue> {
                        let target = self;
                        Raster::image(&target)
                    }
                    fn draw_image(
                        &self,
                        image: JsValue,
                        point: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Raster::draw_image(&target, image, point)
                    }
                    fn set_resolution(&mut self, value: Size) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Raster::set_resolution(&mut target, value)
                    }
                    fn resolution(&self) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Raster::resolution(&target)
                    }
                    fn set_size(&mut self, value: Size) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Raster::set_size(&mut target, value)
                    }
                    fn size(&self) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Raster::size(&target)
                    }
                    fn to_data_url(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Raster::to_data_url(&target)
                    }
                    fn clear(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Raster::clear(&target)
                    }
                    fn set_pixel(
                        &self,
                        point: Point,
                        color: Color,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Raster::set_pixel(&target, point, color)
                    }
                    fn set_on_error(
                        &mut self,
                        value: RasterOnError,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Raster::set_on_error(&mut target, value)
                    }
                    fn on_error(&self) -> std::result::Result<RasterOnError, JsValue> {
                        let target = self;
                        Raster::on_error(&target)
                    }
                    fn set_source(
                        &mut self,
                        value: RasterSource,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Raster::set_source(&mut target, value)
                    }
                    fn source(&self) -> std::result::Result<RasterSource, JsValue> {
                        let target = self;
                        Raster::source(&target)
                    }
                    fn set_image_data(
                        &self,
                        data: web_sys::ImageData,
                        point: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Raster::set_image_data(&target, data, point)
                    }
                    fn create_image_data(
                        &self,
                        size: Size,
                    ) -> std::result::Result<web_sys::ImageData, JsValue> {
                        let target = self;
                        Raster::create_image_data(&target, size)
                    }
                    fn set_width(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Raster::set_width(&mut target, value)
                    }
                    fn width(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Raster::width(&target)
                    }
                    fn get_sub_canvas(
                        &self,
                        rect: Rectangle,
                    ) -> std::result::Result<web_sys::HtmlCanvasElement, JsValue>
                    {
                        let target = self;
                        Raster::get_sub_canvas(&target, rect)
                    }
                    fn get_image_data(
                        &self,
                        rect: Rectangle,
                    ) -> std::result::Result<web_sys::ImageData, JsValue> {
                        let target = self;
                        Raster::get_image_data(&target, rect)
                    }
                    fn set_on_load(
                        &mut self,
                        value: RasterOnLoad,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Raster::set_on_load(&mut target, value)
                    }
                    fn on_load(&self) -> std::result::Result<RasterOnLoad, JsValue> {
                        let target = self;
                        Raster::on_load(&target)
                    }
                    fn set_context(
                        &mut self,
                        value: web_sys::CanvasRenderingContext2d,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Raster::set_context(&mut target, value)
                    }
                    fn context(
                        &self,
                    ) -> std::result::Result<web_sys::CanvasRenderingContext2d, JsValue>
                    {
                        let target = self;
                        Raster::context(&target)
                    }
                }
                impl std::clone::Clone for Raster_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Raster_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Raster_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum StyleSelectedColor {
                    ColorCase(Color),
                    TsBindgenRtNullCase,
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    # [wasm_bindgen (js_name = "Shape" , extends = Item_Class)]
                    pub type Shape_Class;
                    # [wasm_bindgen (method , structural , catch , getter = size , js_class = "Shape")]
                    fn size(this: &Shape_Class) -> std::result::Result<Size, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = size , js_class = "Shape")]
                    fn set_size(
                        this: &Shape_Class,
                        value: Size,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = toPath , method , js_class = "Shape" , catch)]
                    fn __TSB_to_path(
                        this: &Shape_Class,
                        insert: bool,
                    ) -> std::result::Result<Path, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = radius , js_class = "Shape")]
                    fn __TSB_radius(this: &Shape_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = radius , js_class = "Shape")]
                    fn __TSB_set_radius(
                        this: &Shape_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = type , js_class = "Shape")]
                    fn type_(this: &Shape_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = type , js_class = "Shape")]
                    fn set_type_(
                        this: &Shape_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Shape(pub Shape_Class);
                impl std::convert::From<&Shape> for Item {
                    fn from(src: &Shape) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl std::convert::From<&mut Shape> for Item {
                    fn from(src: &mut Shape) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl Shape {
                    #[allow(dead_code)]
                    pub fn size(&self) -> std::result::Result<Size, JsValue> {
                        let result = self.0.size();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_size(&self, value: Size) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_size(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn to_path(&self, insert: bool) -> std::result::Result<Path, JsValue> {
                        let result = self.0.__TSB_to_path(insert);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn radius(&self) -> std::result::Result<ShapeRadius, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_radius()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_radius(
                        &self,
                        value: ShapeRadius,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_radius(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn type_(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.type_();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_type_(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_type_(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Shape {
                    fn describe() {
                        <Shape_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Shape {
                    type Abi = <Shape_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Shape {
                    type Abi = <Shape_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Shape(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Shape {
                    type Abi = <&'a Shape_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Shape {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Shape {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Shape_Class =
                            <Shape_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait Shape_Trait: Item_Trait {
                    fn set_size(&mut self, value: Size) -> std::result::Result<(), JsValue>;
                    fn size(&self) -> std::result::Result<Size, JsValue>;
                    fn to_path(&self, insert: bool) -> std::result::Result<Path, JsValue>;
                    fn set_radius(
                        &mut self,
                        value: ShapeRadius,
                    ) -> std::result::Result<(), JsValue>;
                    fn radius(&self) -> std::result::Result<ShapeRadius, JsValue>;
                    fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn type_(&self) -> std::result::Result<String, JsValue>;
                }
                impl Item_Trait for Shape {
                    fn set_stroke_scaling(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_scaling(&mut target, value)
                    }
                    fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_scaling(&target)
                    }
                    fn set_apply_matrix(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_apply_matrix(&mut target, value)
                    }
                    fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::apply_matrix(&target)
                    }
                    fn set_view_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_view_matrix(&mut target, value)
                    }
                    fn view_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::view_matrix(&target)
                    }
                    fn set_dash_array(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_dash_array(&mut target, value)
                    }
                    fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let target: Item = self.into();
                        Item::dash_array(&target)
                    }
                    fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_ancestor(&target, item)
                    }
                    fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_descendant(&target, item)
                    }
                    fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_sibling(&target, item)
                    }
                    fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_parent(&target, point)
                    }
                    fn set_shadow_blur(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_shadow_blur(&mut target, value)
                    }
                    fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_blur(&target)
                    }
                    fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_empty(&target, recursively)
                    }
                    fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_parent(&target, item)
                    }
                    fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_below(&target, item)
                    }
                    fn set_matrix(&mut self, value: Matrix) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_matrix(&mut target, value)
                    }
                    fn matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::matrix(&target)
                    }
                    fn export_json(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::export_json(&target, options)
                    }
                    fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::global_to_local(&target, point)
                    }
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ItemOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_drag(&mut target, value)
                    }
                    fn on_mouse_drag(&self) -> std::result::Result<ItemOnMouseDrag, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_drag(&target)
                    }
                    fn get_item(
                        &self,
                        options: ItemGetItemParamsOptionsParam,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::get_item(&target, options)
                    }
                    fn remove_children(
                        &self,
                        start: f64,
                        end: f64,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::remove_children(&target, start, end)
                    }
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_project(&mut target, value)
                    }
                    fn project(&self) -> std::result::Result<Project, JsValue> {
                        let target: Item = self.into();
                        Item::project(&target)
                    }
                    fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_data(&mut target, value)
                    }
                    fn data(&self) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::data(&target)
                    }
                    fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_above(&target, item)
                    }
                    fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on(&target, options)
                    }
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::transform(&target, matrix)
                    }
                    fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inserted(&target)
                    }
                    fn set_on_mouse_down(
                        &mut self,
                        value: ItemOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_down(&mut target, value)
                    }
                    fn on_mouse_down(&self) -> std::result::Result<ItemOnMouseDown, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_down(&target)
                    }
                    fn set_last_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_last_child(&mut target, value)
                    }
                    fn last_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::last_child(&target)
                    }
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_selected(&mut target, value)
                    }
                    fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::selected(&target)
                    }
                    fn set_global_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_global_matrix(&mut target, value)
                    }
                    fn global_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::global_matrix(&target)
                    }
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::responds(&target, type_)
                    }
                    fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::rotate(&target, angle, center)
                    }
                    fn tween(
                        &self,
                        options: ItemTweenParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween(&target, options)
                    }
                    fn set_on_mouse_enter(
                        &mut self,
                        value: ItemOnMouseEnter,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_enter(&mut target, value)
                    }
                    fn on_mouse_enter(&self) -> std::result::Result<ItemOnMouseEnter, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_enter(&target)
                    }
                    fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_id(&mut target, value)
                    }
                    fn id(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::id(&target)
                    }
                    fn on(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::on(&target, object)
                    }
                    fn tween_to(
                        &self,
                        to: JsValue,
                        options: ItemTweenToParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_to(&target, to, options)
                    }
                    fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_locked(&mut target, value)
                    }
                    fn locked(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::locked(&target)
                    }
                    fn set_children(
                        &mut self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_children(&mut target, value)
                    }
                    fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::children(&target)
                    }
                    fn copy_attributes(
                        &self,
                        source: Item,
                        exclude_matrix: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_attributes(&target, source, exclude_matrix)
                    }
                    fn off(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::off(&target, object)
                    }
                    fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::contains(&target, point)
                    }
                    fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_stroke(&target)
                    }
                    fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_move(&target)
                    }
                    fn add_children(
                        &self,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::add_children(&target, items)
                    }
                    fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::reverse_children(&target)
                    }
                    fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_shadow(&target)
                    }
                    fn set_dash_offset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_dash_offset(&mut target, value)
                    }
                    fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::dash_offset(&target)
                    }
                    fn set_on_mouse_leave(
                        &mut self,
                        value: ItemOnMouseLeave,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_leave(&mut target, value)
                    }
                    fn on_mouse_leave(&self) -> std::result::Result<ItemOnMouseLeave, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_leave(&target)
                    }
                    fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test_all(&target, point, options)
                    }
                    fn set_stroke_cap(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_cap(&mut target, value)
                    }
                    fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_cap(&target)
                    }
                    fn set_internal_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_internal_bounds(&mut target, value)
                    }
                    fn internal_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::internal_bounds(&target)
                    }
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_index(&mut target, value)
                    }
                    fn index(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::index(&target)
                    }
                    fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::reduce(&target, options)
                    }
                    fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_grouped_with(&target, item)
                    }
                    fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_global(&target, point)
                    }
                    fn set_first_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_first_child(&mut target, value)
                    }
                    fn first_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::first_child(&target)
                    }
                    fn set_position(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_position(&mut target, value)
                    }
                    fn position(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::position(&target)
                    }
                    fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_opacity(&mut target, value)
                    }
                    fn opacity(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::opacity(&target)
                    }
                    fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_down(&target)
                    }
                    fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_drag(&target)
                    }
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_bounds(&mut target, value)
                    }
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::bounds(&target)
                    }
                    fn set_parent(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_parent(&mut target, value)
                    }
                    fn parent(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::parent(&target)
                    }
                    fn get_items(
                        &self,
                        options: ItemGetItemsParamsOptionsParam,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::get_items(&target, options)
                    }
                    fn copy_to(
                        &self,
                        owner: ItemCopyToParamsOwnerParam,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::copy_to(&target, owner)
                    }
                    fn set_on_double_click(
                        &mut self,
                        value: ItemOnDoubleClick,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_double_click(&mut target, value)
                    }
                    fn on_double_click(&self) -> std::result::Result<ItemOnDoubleClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_double_click(&target)
                    }
                    fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::set(&target, props)
                    }
                    fn scale(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::scale(&target, hor, ver, center)
                    }
                    fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_below(&target, item)
                    }
                    fn set_next_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_next_sibling(&mut target, value)
                    }
                    fn next_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::next_sibling(&target)
                    }
                    fn rasterize(&self, options: JsValue) -> std::result::Result<Raster, JsValue> {
                        let target: Item = self.into();
                        Item::rasterize(&target, options)
                    }
                    fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::bring_to_front(&target)
                    }
                    fn matches(
                        &self,
                        name: String,
                        compare: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::matches(&target, name, compare)
                    }
                    fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_fill(&target)
                    }
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_view(&mut target, value)
                    }
                    fn view(&self) -> std::result::Result<View, JsValue> {
                        let target: Item = self.into();
                        Item::view(&target)
                    }
                    fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::clone(&target, options)
                    }
                    fn set_handle_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_handle_bounds(&mut target, value)
                    }
                    fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::handle_bounds(&target)
                    }
                    fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inside(&target, rect)
                    }
                    fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_above(&target, item)
                    }
                    fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::remove(&target)
                    }
                    fn set_stroke_join(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_join(&mut target, value)
                    }
                    fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_join(&target)
                    }
                    fn set_on_click(
                        &mut self,
                        value: ItemOnClick,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_click(&mut target, value)
                    }
                    fn on_click(&self) -> std::result::Result<ItemOnClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_click(&target)
                    }
                    fn fit_bounds(
                        &self,
                        rectangle: Rectangle,
                        fill: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::fit_bounds(&target, rectangle, fill)
                    }
                    fn set_blend_mode(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_blend_mode(&mut target, value)
                    }
                    fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::blend_mode(&target)
                    }
                    fn set_stroke_width(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_width(&mut target, value)
                    }
                    fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_width(&target)
                    }
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_rotation(&mut target, value)
                    }
                    fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::rotation(&target)
                    }
                    fn set_selected_color(
                        &mut self,
                        value: ItemSelectedColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_selected_color(&mut target, value)
                    }
                    fn selected_color(&self) -> std::result::Result<ItemSelectedColor, JsValue> {
                        let target: Item = self.into();
                        Item::selected_color(&target)
                    }
                    fn skew(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::skew(&target, hor, ver, center)
                    }
                    fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_name(&mut target, value)
                    }
                    fn name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::name(&target)
                    }
                    fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_json(&target, json)
                    }
                    fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::add_child(&target, item)
                    }
                    fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_visible(&mut target, value)
                    }
                    fn visible(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::visible(&target)
                    }
                    fn set_fill_rule(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_fill_rule(&mut target, value)
                    }
                    fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::fill_rule(&target)
                    }
                    fn set_layer(&mut self, value: Layer) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_layer(&mut target, value)
                    }
                    fn layer(&self) -> std::result::Result<Layer, JsValue> {
                        let target: Item = self.into();
                        Item::layer(&target)
                    }
                    fn tween_from(
                        &self,
                        from: JsValue,
                        options: ItemTweenFromParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_from(&target, from, options)
                    }
                    fn insert_child(
                        &self,
                        index: f64,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_child(&target, index, item)
                    }
                    fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_up(&target)
                    }
                    fn set_pivot(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_pivot(&mut target, value)
                    }
                    fn pivot(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::pivot(&target)
                    }
                    fn set_miter_limit(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_miter_limit(&mut target, value)
                    }
                    fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::miter_limit(&target)
                    }
                    fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_content(&target, source)
                    }
                    fn import_svg(
                        &self,
                        svg: ItemImportSvgParamsSvgParam,
                        on_load: &'static dyn Fn(
                            Box<[JsValue]>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_svg(&target, svg, on_load)
                    }
                    fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::send_to_back(&target)
                    }
                    fn set_stroke_color(
                        &mut self,
                        value: ItemStrokeColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_color(&mut target, value)
                    }
                    fn stroke_color(&self) -> std::result::Result<ItemStrokeColor, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_color(&target)
                    }
                    fn set_on_mouse_move(
                        &mut self,
                        value: ItemOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_move(&mut target, value)
                    }
                    fn on_mouse_move(&self) -> std::result::Result<ItemOnMouseMove, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_move(&target)
                    }
                    fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::replace_with(&target, item)
                    }
                    fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test(&target, point, options)
                    }
                    fn shear(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::shear(&target, hor, ver, center)
                    }
                    fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::translate(&target, delta)
                    }
                    fn set_stroke_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_bounds(&mut target, value)
                    }
                    fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_bounds(&target)
                    }
                    fn insert_children(
                        &self,
                        index: f64,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::insert_children(&target, index, items)
                    }
                    fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_child(&target, item)
                    }
                    fn set_shadow_offset(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_shadow_offset(&mut target, value)
                    }
                    fn shadow_offset(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_offset(&target)
                    }
                    fn set_fill_color(
                        &mut self,
                        value: ItemFillColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_fill_color(&mut target, value)
                    }
                    fn fill_color(&self) -> std::result::Result<ItemFillColor, JsValue> {
                        let target: Item = self.into();
                        Item::fill_color(&target)
                    }
                    fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                        let target: Item = self.into();
                        Item::export_svg(&target, options)
                    }
                    fn set_style(&mut self, value: Style) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_style(&mut target, value)
                    }
                    fn style(&self) -> std::result::Result<Style, JsValue> {
                        let target: Item = self.into();
                        Item::style(&target)
                    }
                    fn set_clip_mask(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_clip_mask(&mut target, value)
                    }
                    fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::clip_mask(&target)
                    }
                    fn set_class_name(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_class_name(&mut target, value)
                    }
                    fn class_name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::class_name(&target)
                    }
                    fn set_on_mouse_up(
                        &mut self,
                        value: ItemOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_up(&mut target, value)
                    }
                    fn on_mouse_up(&self) -> std::result::Result<ItemOnMouseUp, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_up(&target)
                    }
                    fn set_on_frame(
                        &mut self,
                        value: ItemOnFrame,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_frame(&mut target, value)
                    }
                    fn on_frame(&self) -> std::result::Result<ItemOnFrame, JsValue> {
                        let target: Item = self.into();
                        Item::on_frame(&target)
                    }
                    fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::parent_to_local(&target, point)
                    }
                    fn set_previous_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_previous_sibling(&mut target, value)
                    }
                    fn previous_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::previous_sibling(&target)
                    }
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::emit(&target, type_, event)
                    }
                    fn add_to(
                        &self,
                        owner: ItemAddToParamsOwnerParam,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::add_to(&target, owner)
                    }
                    fn has_children(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_children(&target)
                    }
                    fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::intersects(&target, item)
                    }
                    fn set_shadow_color(
                        &mut self,
                        value: ItemShadowColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_shadow_color(&mut target, value)
                    }
                    fn shadow_color(&self) -> std::result::Result<ItemShadowColor, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_color(&target)
                    }
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_scaling(&mut target, value)
                    }
                    fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::scaling(&target)
                    }
                }
                impl Shape_Trait for Shape
                where
                    Shape: Item_Trait,
                {
                    fn set_size(&mut self, value: Size) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Shape::set_size(&mut target, value)
                    }
                    fn size(&self) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Shape::size(&target)
                    }
                    fn to_path(&self, insert: bool) -> std::result::Result<Path, JsValue> {
                        let target = self;
                        Shape::to_path(&target, insert)
                    }
                    fn set_radius(
                        &mut self,
                        value: ShapeRadius,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Shape::set_radius(&mut target, value)
                    }
                    fn radius(&self) -> std::result::Result<ShapeRadius, JsValue> {
                        let target = self;
                        Shape::radius(&target)
                    }
                    fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Shape::set_type_(&mut target, value)
                    }
                    fn type_(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Shape::type_(&target)
                    }
                }
                impl std::clone::Clone for Shape_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Shape_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Shape_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PathSplitAtParamsLocationParam {
                    CurveLocationCase(CurveLocation),
                    F64Case(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PaperScopeSetupParamsElementParam {
                    SizeCase(Size),
                    StringCase(String),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    WebSysHtmlCanvasElementCase(web_sys::HtmlCanvasElement),
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[wasm_bindgen(js_name = "Item")]
                    pub type Item_Class;
                    # [wasm_bindgen (method , structural , catch , getter = strokeScaling , js_class = "Item")]
                    fn stroke_scaling(this: &Item_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = strokeScaling , js_class = "Item")]
                    fn set_stroke_scaling(
                        this: &Item_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = applyMatrix , js_class = "Item")]
                    fn apply_matrix(this: &Item_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = applyMatrix , js_class = "Item")]
                    fn set_apply_matrix(
                        this: &Item_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = viewMatrix , js_class = "Item")]
                    fn view_matrix(this: &Item_Class) -> std::result::Result<Matrix, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = viewMatrix , js_class = "Item")]
                    fn set_view_matrix(
                        this: &Item_Class,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = dashArray , js_class = "Item")]
                    fn __TSB_dash_array(this: &Item_Class)
                        -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = dashArray , js_class = "Item")]
                    fn __TSB_set_dash_array(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isAncestor , method , js_class = "Item" , catch)]
                    fn __TSB_is_ancestor(
                        this: &Item_Class,
                        item: Item,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isDescendant , method , js_class = "Item" , catch)]
                    fn __TSB_is_descendant(
                        this: &Item_Class,
                        item: Item,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isSibling , method , js_class = "Item" , catch)]
                    fn __TSB_is_sibling(
                        this: &Item_Class,
                        item: Item,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = localToParent , method , js_class = "Item" , catch)]
                    fn __TSB_local_to_parent(
                        this: &Item_Class,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = shadowBlur , js_class = "Item")]
                    fn shadow_blur(this: &Item_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = shadowBlur , js_class = "Item")]
                    fn set_shadow_blur(
                        this: &Item_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isEmpty , method , js_class = "Item" , catch)]
                    fn __TSB_is_empty(
                        this: &Item_Class,
                        recursively: bool,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isParent , method , js_class = "Item" , catch)]
                    fn __TSB_is_parent(
                        this: &Item_Class,
                        item: Item,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isBelow , method , js_class = "Item" , catch)]
                    fn __TSB_is_below(
                        this: &Item_Class,
                        item: Item,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = matrix , js_class = "Item")]
                    fn matrix(this: &Item_Class) -> std::result::Result<Matrix, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = matrix , js_class = "Item")]
                    fn set_matrix(
                        this: &Item_Class,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = exportJSON , method , js_class = "Item" , catch)]
                    fn __TSB_export_json(
                        this: &Item_Class,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = globalToLocal , method , js_class = "Item" , catch)]
                    fn __TSB_global_to_local(
                        this: &Item_Class,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseDrag , js_class = "Item")]
                    fn __TSB_on_mouse_drag(
                        this: &Item_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseDrag , js_class = "Item")]
                    fn __TSB_set_on_mouse_drag(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getItem , method , js_class = "Item" , catch)]
                    fn __TSB_get_item(
                        this: &Item_Class,
                        options: JsValue,
                    ) -> std::result::Result<Item, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = removeChildren , method , js_class = "Item" , catch)]
                    fn __TSB_remove_children(
                        this: &Item_Class,
                        start: f64,
                        end: f64,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = project , js_class = "Item")]
                    fn project(this: &Item_Class) -> std::result::Result<Project, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = project , js_class = "Item")]
                    fn set_project(
                        this: &Item_Class,
                        value: Project,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = data , js_class = "Item")]
                    fn __TSB_data(this: &Item_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = data , js_class = "Item")]
                    fn __TSB_set_data(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = insertAbove , method , js_class = "Item" , catch)]
                    fn __TSB_insert_above(
                        this: &Item_Class,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = removeOn , method , js_class = "Item" , catch)]
                    fn __TSB_remove_on(
                        this: &Item_Class,
                        options: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = transform , method , js_class = "Item" , catch)]
                    fn __TSB_transform(
                        this: &Item_Class,
                        matrix: Matrix,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isInserted , method , js_class = "Item" , catch)]
                    fn __TSB_is_inserted(this: &Item_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseDown , js_class = "Item")]
                    fn __TSB_on_mouse_down(
                        this: &Item_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseDown , js_class = "Item")]
                    fn __TSB_set_on_mouse_down(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = lastChild , js_class = "Item")]
                    fn last_child(this: &Item_Class) -> std::result::Result<Item, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = lastChild , js_class = "Item")]
                    fn set_last_child(
                        this: &Item_Class,
                        value: Item,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = selected , js_class = "Item")]
                    fn selected(this: &Item_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = selected , js_class = "Item")]
                    fn set_selected(
                        this: &Item_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = globalMatrix , js_class = "Item")]
                    fn global_matrix(this: &Item_Class) -> std::result::Result<Matrix, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = globalMatrix , js_class = "Item")]
                    fn set_global_matrix(
                        this: &Item_Class,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = responds , method , js_class = "Item" , catch)]
                    fn __TSB_responds(
                        this: &Item_Class,
                        type_: String,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = rotate , method , js_class = "Item" , catch)]
                    fn __TSB_rotate(
                        this: &Item_Class,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = tween , method , js_class = "Item" , catch)]
                    fn __TSB_tween(
                        this: &Item_Class,
                        options: JsValue,
                    ) -> std::result::Result<Tween, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseEnter , js_class = "Item")]
                    fn __TSB_on_mouse_enter(
                        this: &Item_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseEnter , js_class = "Item")]
                    fn __TSB_set_on_mouse_enter(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = id , js_class = "Item")]
                    fn id(this: &Item_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = id , js_class = "Item")]
                    fn set_id(this: &Item_Class, value: f64) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = on , method , js_class = "Item" , catch)]
                    fn __TSB_on(
                        this: &Item_Class,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = tweenTo , method , js_class = "Item" , catch)]
                    fn __TSB_tween_to(
                        this: &Item_Class,
                        to: JsValue,
                        options: JsValue,
                    ) -> std::result::Result<Tween, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = locked , js_class = "Item")]
                    fn locked(this: &Item_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = locked , js_class = "Item")]
                    fn set_locked(
                        this: &Item_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = children , js_class = "Item")]
                    fn __TSB_children(this: &Item_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = children , js_class = "Item")]
                    fn __TSB_set_children(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = copyAttributes , method , js_class = "Item" , catch)]
                    fn __TSB_copy_attributes(
                        this: &Item_Class,
                        source: Item,
                        exclude_matrix: bool,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = off , method , js_class = "Item" , catch)]
                    fn __TSB_off(
                        this: &Item_Class,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = contains , method , js_class = "Item" , catch)]
                    fn __TSB_contains(
                        this: &Item_Class,
                        point: Point,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = hasStroke , method , js_class = "Item" , catch)]
                    fn __TSB_has_stroke(this: &Item_Class) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = removeOnMove , method , js_class = "Item" , catch)]
                    fn __TSB_remove_on_move(this: &Item_Class) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = addChildren , method , js_class = "Item" , catch)]
                    fn __TSB_add_children(
                        this: &Item_Class,
                        items: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = reverseChildren , method , js_class = "Item" , catch)]
                    fn __TSB_reverse_children(
                        this: &Item_Class,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = hasShadow , method , js_class = "Item" , catch)]
                    fn __TSB_has_shadow(this: &Item_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = dashOffset , js_class = "Item")]
                    fn dash_offset(this: &Item_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = dashOffset , js_class = "Item")]
                    fn set_dash_offset(
                        this: &Item_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseLeave , js_class = "Item")]
                    fn __TSB_on_mouse_leave(
                        this: &Item_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseLeave , js_class = "Item")]
                    fn __TSB_set_on_mouse_leave(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = hitTestAll , method , js_class = "Item" , catch)]
                    fn __TSB_hit_test_all(
                        this: &Item_Class,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = strokeCap , js_class = "Item")]
                    fn stroke_cap(this: &Item_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = strokeCap , js_class = "Item")]
                    fn set_stroke_cap(
                        this: &Item_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = internalBounds , js_class = "Item")]
                    fn internal_bounds(
                        this: &Item_Class,
                    ) -> std::result::Result<Rectangle, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = internalBounds , js_class = "Item")]
                    fn set_internal_bounds(
                        this: &Item_Class,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = index , js_class = "Item")]
                    fn index(this: &Item_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = index , js_class = "Item")]
                    fn set_index(this: &Item_Class, value: f64)
                        -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = reduce , method , js_class = "Item" , catch)]
                    fn __TSB_reduce(
                        this: &Item_Class,
                        options: JsValue,
                    ) -> std::result::Result<Item, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isGroupedWith , method , js_class = "Item" , catch)]
                    fn __TSB_is_grouped_with(
                        this: &Item_Class,
                        item: Item,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = localToGlobal , method , js_class = "Item" , catch)]
                    fn __TSB_local_to_global(
                        this: &Item_Class,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = firstChild , js_class = "Item")]
                    fn first_child(this: &Item_Class) -> std::result::Result<Item, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = firstChild , js_class = "Item")]
                    fn set_first_child(
                        this: &Item_Class,
                        value: Item,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = position , js_class = "Item")]
                    fn position(this: &Item_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = position , js_class = "Item")]
                    fn set_position(
                        this: &Item_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = opacity , js_class = "Item")]
                    fn opacity(this: &Item_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = opacity , js_class = "Item")]
                    fn set_opacity(
                        this: &Item_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = removeOnDown , method , js_class = "Item" , catch)]
                    fn __TSB_remove_on_down(this: &Item_Class) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = removeOnDrag , method , js_class = "Item" , catch)]
                    fn __TSB_remove_on_drag(this: &Item_Class) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = bounds , js_class = "Item")]
                    fn bounds(this: &Item_Class) -> std::result::Result<Rectangle, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = bounds , js_class = "Item")]
                    fn set_bounds(
                        this: &Item_Class,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = parent , js_class = "Item")]
                    fn parent(this: &Item_Class) -> std::result::Result<Item, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = parent , js_class = "Item")]
                    fn set_parent(
                        this: &Item_Class,
                        value: Item,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getItems , method , js_class = "Item" , catch)]
                    fn __TSB_get_items(
                        this: &Item_Class,
                        options: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = copyTo , method , js_class = "Item" , catch)]
                    fn __TSB_copy_to(
                        this: &Item_Class,
                        owner: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onDoubleClick , js_class = "Item")]
                    fn __TSB_on_double_click(
                        this: &Item_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onDoubleClick , js_class = "Item")]
                    fn __TSB_set_on_double_click(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = set , method , js_class = "Item" , catch)]
                    fn __TSB_set(
                        this: &Item_Class,
                        props: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = scale , method , js_class = "Item" , catch)]
                    fn __TSB_scale(
                        this: &Item_Class,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = insertBelow , method , js_class = "Item" , catch)]
                    fn __TSB_insert_below(
                        this: &Item_Class,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = nextSibling , js_class = "Item")]
                    fn next_sibling(this: &Item_Class) -> std::result::Result<Item, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = nextSibling , js_class = "Item")]
                    fn set_next_sibling(
                        this: &Item_Class,
                        value: Item,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = rasterize , method , js_class = "Item" , catch)]
                    fn __TSB_rasterize(
                        this: &Item_Class,
                        options: JsValue,
                    ) -> std::result::Result<Raster, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = bringToFront , method , js_class = "Item" , catch)]
                    fn __TSB_bring_to_front(this: &Item_Class) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = matches , method , js_class = "Item" , catch)]
                    fn __TSB_matches(
                        this: &Item_Class,
                        name: String,
                        compare: JsValue,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = hasFill , method , js_class = "Item" , catch)]
                    fn __TSB_has_fill(this: &Item_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = view , js_class = "Item")]
                    fn view(this: &Item_Class) -> std::result::Result<View, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = view , js_class = "Item")]
                    fn set_view(this: &Item_Class, value: View)
                        -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clone , method , js_class = "Item" , catch)]
                    fn __TSB_clone(
                        this: &Item_Class,
                        options: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = handleBounds , js_class = "Item")]
                    fn handle_bounds(this: &Item_Class) -> std::result::Result<Rectangle, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = handleBounds , js_class = "Item")]
                    fn set_handle_bounds(
                        this: &Item_Class,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isInside , method , js_class = "Item" , catch)]
                    fn __TSB_is_inside(
                        this: &Item_Class,
                        rect: Rectangle,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isAbove , method , js_class = "Item" , catch)]
                    fn __TSB_is_above(
                        this: &Item_Class,
                        item: Item,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = remove , method , js_class = "Item" , catch)]
                    fn __TSB_remove(this: &Item_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = strokeJoin , js_class = "Item")]
                    fn stroke_join(this: &Item_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = strokeJoin , js_class = "Item")]
                    fn set_stroke_join(
                        this: &Item_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onClick , js_class = "Item")]
                    fn __TSB_on_click(this: &Item_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onClick , js_class = "Item")]
                    fn __TSB_set_on_click(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = fitBounds , method , js_class = "Item" , catch)]
                    fn __TSB_fit_bounds(
                        this: &Item_Class,
                        rectangle: Rectangle,
                        fill: bool,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = blendMode , js_class = "Item")]
                    fn blend_mode(this: &Item_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = blendMode , js_class = "Item")]
                    fn set_blend_mode(
                        this: &Item_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = strokeWidth , js_class = "Item")]
                    fn stroke_width(this: &Item_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = strokeWidth , js_class = "Item")]
                    fn set_stroke_width(
                        this: &Item_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = rotation , js_class = "Item")]
                    fn rotation(this: &Item_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = rotation , js_class = "Item")]
                    fn set_rotation(
                        this: &Item_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = selectedColor , js_class = "Item")]
                    fn __TSB_selected_color(
                        this: &Item_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = selectedColor , js_class = "Item")]
                    fn __TSB_set_selected_color(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = skew , method , js_class = "Item" , catch)]
                    fn __TSB_skew(
                        this: &Item_Class,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = name , js_class = "Item")]
                    fn name(this: &Item_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = name , js_class = "Item")]
                    fn set_name(
                        this: &Item_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = importJSON , method , js_class = "Item" , catch)]
                    fn __TSB_import_json(
                        this: &Item_Class,
                        json: String,
                    ) -> std::result::Result<Item, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = addChild , method , js_class = "Item" , catch)]
                    fn __TSB_add_child(
                        this: &Item_Class,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = visible , js_class = "Item")]
                    fn visible(this: &Item_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = visible , js_class = "Item")]
                    fn set_visible(
                        this: &Item_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = fillRule , js_class = "Item")]
                    fn fill_rule(this: &Item_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = fillRule , js_class = "Item")]
                    fn set_fill_rule(
                        this: &Item_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = layer , js_class = "Item")]
                    fn layer(this: &Item_Class) -> std::result::Result<Layer, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = layer , js_class = "Item")]
                    fn set_layer(
                        this: &Item_Class,
                        value: Layer,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = tweenFrom , method , js_class = "Item" , catch)]
                    fn __TSB_tween_from(
                        this: &Item_Class,
                        from: JsValue,
                        options: JsValue,
                    ) -> std::result::Result<Tween, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = insertChild , method , js_class = "Item" , catch)]
                    fn __TSB_insert_child(
                        this: &Item_Class,
                        index: f64,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = removeOnUp , method , js_class = "Item" , catch)]
                    fn __TSB_remove_on_up(this: &Item_Class) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = pivot , js_class = "Item")]
                    fn pivot(this: &Item_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = pivot , js_class = "Item")]
                    fn set_pivot(
                        this: &Item_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = miterLimit , js_class = "Item")]
                    fn miter_limit(this: &Item_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = miterLimit , js_class = "Item")]
                    fn set_miter_limit(
                        this: &Item_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = copyContent , method , js_class = "Item" , catch)]
                    fn __TSB_copy_content(
                        this: &Item_Class,
                        source: Item,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = importSVG , method , js_class = "Item" , catch)]
                    fn __TSB_import_svg(
                        this: &Item_Class,
                        svg: JsValue,
                        on_load: &Closure<
                            dyn Fn(
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        >,
                    ) -> std::result::Result<Item, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = sendToBack , method , js_class = "Item" , catch)]
                    fn __TSB_send_to_back(this: &Item_Class) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = strokeColor , js_class = "Item")]
                    fn __TSB_stroke_color(
                        this: &Item_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = strokeColor , js_class = "Item")]
                    fn __TSB_set_stroke_color(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseMove , js_class = "Item")]
                    fn __TSB_on_mouse_move(
                        this: &Item_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseMove , js_class = "Item")]
                    fn __TSB_set_on_mouse_move(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = replaceWith , method , js_class = "Item" , catch)]
                    fn __TSB_replace_with(
                        this: &Item_Class,
                        item: Item,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = hitTest , method , js_class = "Item" , catch)]
                    fn __TSB_hit_test(
                        this: &Item_Class,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = shear , method , js_class = "Item" , catch)]
                    fn __TSB_shear(
                        this: &Item_Class,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = translate , method , js_class = "Item" , catch)]
                    fn __TSB_translate(
                        this: &Item_Class,
                        delta: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = strokeBounds , js_class = "Item")]
                    fn stroke_bounds(this: &Item_Class) -> std::result::Result<Rectangle, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = strokeBounds , js_class = "Item")]
                    fn set_stroke_bounds(
                        this: &Item_Class,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = insertChildren , method , js_class = "Item" , catch)]
                    fn __TSB_insert_children(
                        this: &Item_Class,
                        index: f64,
                        items: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isChild , method , js_class = "Item" , catch)]
                    fn __TSB_is_child(
                        this: &Item_Class,
                        item: Item,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = shadowOffset , js_class = "Item")]
                    fn shadow_offset(this: &Item_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = shadowOffset , js_class = "Item")]
                    fn set_shadow_offset(
                        this: &Item_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = fillColor , js_class = "Item")]
                    fn __TSB_fill_color(this: &Item_Class)
                        -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = fillColor , js_class = "Item")]
                    fn __TSB_set_fill_color(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = exportSVG , method , js_class = "Item" , catch)]
                    fn __TSB_export_svg(
                        this: &Item_Class,
                        options: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = style , js_class = "Item")]
                    fn style(this: &Item_Class) -> std::result::Result<Style, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = style , js_class = "Item")]
                    fn set_style(
                        this: &Item_Class,
                        value: Style,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = clipMask , js_class = "Item")]
                    fn clip_mask(this: &Item_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = clipMask , js_class = "Item")]
                    fn set_clip_mask(
                        this: &Item_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = className , js_class = "Item")]
                    fn class_name(this: &Item_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = className , js_class = "Item")]
                    fn set_class_name(
                        this: &Item_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseUp , js_class = "Item")]
                    fn __TSB_on_mouse_up(
                        this: &Item_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseUp , js_class = "Item")]
                    fn __TSB_set_on_mouse_up(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onFrame , js_class = "Item")]
                    fn __TSB_on_frame(this: &Item_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onFrame , js_class = "Item")]
                    fn __TSB_set_on_frame(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = parentToLocal , method , js_class = "Item" , catch)]
                    fn __TSB_parent_to_local(
                        this: &Item_Class,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = previousSibling , js_class = "Item")]
                    fn previous_sibling(this: &Item_Class) -> std::result::Result<Item, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = previousSibling , js_class = "Item")]
                    fn set_previous_sibling(
                        this: &Item_Class,
                        value: Item,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = emit , method , js_class = "Item" , catch)]
                    fn __TSB_emit(
                        this: &Item_Class,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = addTo , method , js_class = "Item" , catch)]
                    fn __TSB_add_to(
                        this: &Item_Class,
                        owner: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = hasChildren , method , js_class = "Item" , catch)]
                    fn __TSB_has_children(this: &Item_Class) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = intersects , method , js_class = "Item" , catch)]
                    fn __TSB_intersects(
                        this: &Item_Class,
                        item: Item,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = shadowColor , js_class = "Item")]
                    fn __TSB_shadow_color(
                        this: &Item_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = shadowColor , js_class = "Item")]
                    fn __TSB_set_shadow_color(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = scaling , js_class = "Item")]
                    fn scaling(this: &Item_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = scaling , js_class = "Item")]
                    fn set_scaling(
                        this: &Item_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Item(pub Item_Class);
                impl Item {
                    #[allow(dead_code)]
                    pub fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.stroke_scaling();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_stroke_scaling(
                        &self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_stroke_scaling(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.apply_matrix();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_apply_matrix(
                        &self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_apply_matrix(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn view_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.view_matrix();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_view_matrix(
                        &self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_view_matrix(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_dash_array()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_dash_array(
                        &self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_dash_array(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_ancestor(item);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_descendant(item);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_sibling(item);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn local_to_parent(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_local_to_parent(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.shadow_blur();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_shadow_blur(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_shadow_blur(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_empty(
                        &self,
                        recursively: bool,
                    ) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_empty(recursively);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_parent(item);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_below(item);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.matrix();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_matrix(&self, value: Matrix) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_matrix(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn export_json(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue> {
                        let result = self.0.__TSB_export_json(options);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn global_to_local(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_global_to_local(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn on_mouse_drag(&self) -> std::result::Result<ItemOnMouseDrag, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_drag()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_on_mouse_drag(
                        &self,
                        value: ItemOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_drag(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_item(
                        &self,
                        options: ItemGetItemParamsOptionsParam,
                    ) -> std::result::Result<Item, JsValue> {
                        let result = self.0.__TSB_get_item(
                            ts_bindgen_rt::to_jsvalue(&options)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn remove_children(
                        &self,
                        start: f64,
                        end: f64,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let result =
                            ts_bindgen_rt::from_jsvalue(&self.0.__TSB_remove_children(start, end)?)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn project(&self) -> std::result::Result<Project, JsValue> {
                        let result = self.0.project();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_project(&self, value: Project) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_project(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn data(&self) -> std::result::Result<JsValue, JsValue> {
                        let result = self.0.__TSB_data();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_data(&self, value: JsValue) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_data(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let result = self.0.__TSB_insert_above(item);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_remove_on(options);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_transform(matrix);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_inserted();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn on_mouse_down(&self) -> std::result::Result<ItemOnMouseDown, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_down()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_on_mouse_down(
                        &self,
                        value: ItemOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_down(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn last_child(&self) -> std::result::Result<Item, JsValue> {
                        let result = self.0.last_child();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_last_child(&self, value: Item) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_last_child(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.selected();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_selected(&self, value: bool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_selected(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn global_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.global_matrix();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_global_matrix(
                        &self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_global_matrix(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_responds(type_);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_rotate(angle, center);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn tween(
                        &self,
                        options: ItemTweenParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let result = self.0.__TSB_tween(
                            ts_bindgen_rt::to_jsvalue(&options)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn on_mouse_enter(&self) -> std::result::Result<ItemOnMouseEnter, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_enter()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_on_mouse_enter(
                        &self,
                        value: ItemOnMouseEnter,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_enter(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn id(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.id();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_id(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_id(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn on(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let result = self.0.__TSB_on(object);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn tween_to(
                        &self,
                        to: JsValue,
                        options: ItemTweenToParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let result = self.0.__TSB_tween_to(
                            to,
                            ts_bindgen_rt::to_jsvalue(&options)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn locked(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.locked();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_locked(&self, value: bool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_locked(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_children()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_children(
                        &self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_children(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn copy_attributes(
                        &self,
                        source: Item,
                        exclude_matrix: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_copy_attributes(source, exclude_matrix);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn off(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let result = self.0.__TSB_off(object);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_contains(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_has_stroke();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_remove_on_move();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn add_children(
                        &self,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self.0.__TSB_add_children(
                                ts_bindgen_rt::to_jsvalue(&items)
                                    .map_err(ts_bindgen_rt::Error::from)
                                    .map_err(JsValue::from)?,
                            )?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_reverse_children();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_has_shadow();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.dash_offset();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_dash_offset(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_dash_offset(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn on_mouse_leave(&self) -> std::result::Result<ItemOnMouseLeave, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_leave()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_on_mouse_leave(
                        &self,
                        value: ItemOnMouseLeave,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_leave(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self.0.__TSB_hit_test_all(point, options)?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.stroke_cap();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_stroke_cap(
                        &self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_stroke_cap(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn internal_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let result = self.0.internal_bounds();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_internal_bounds(
                        &self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_internal_bounds(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn index(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.index();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_index(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_index(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                        let result = self.0.__TSB_reduce(options);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_grouped_with(
                        &self,
                        item: Item,
                    ) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_grouped_with(item);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn local_to_global(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_local_to_global(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn first_child(&self) -> std::result::Result<Item, JsValue> {
                        let result = self.0.first_child();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_first_child(&self, value: Item) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_first_child(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn position(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.position();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_position(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_position(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn opacity(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.opacity();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_opacity(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_opacity(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_remove_on_down();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_remove_on_drag();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let result = self.0.bounds();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_bounds(&self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_bounds(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn parent(&self) -> std::result::Result<Item, JsValue> {
                        let result = self.0.parent();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_parent(&self, value: Item) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_parent(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_items(
                        &self,
                        options: ItemGetItemsParamsOptionsParam,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self.0.__TSB_get_items(
                                ts_bindgen_rt::to_jsvalue(&options)
                                    .map_err(ts_bindgen_rt::Error::from)
                                    .map_err(JsValue::from)?,
                            )?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn copy_to(
                        &self,
                        owner: ItemCopyToParamsOwnerParam,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let result = self.0.__TSB_copy_to(
                            ts_bindgen_rt::to_jsvalue(&owner)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn on_double_click(
                        &self,
                    ) -> std::result::Result<ItemOnDoubleClick, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_double_click()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_on_double_click(
                        &self,
                        value: ItemOnDoubleClick,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_double_click(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let result = self.0.__TSB_set(props);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn scale(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_scale(hor, ver, center);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let result = self.0.__TSB_insert_below(item);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn next_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let result = self.0.next_sibling();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_next_sibling(
                        &self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_next_sibling(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn rasterize(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<Raster, JsValue> {
                        let result = self.0.__TSB_rasterize(options);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_bring_to_front();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn matches(
                        &self,
                        name: String,
                        compare: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_matches(name, compare);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_has_fill();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn view(&self) -> std::result::Result<View, JsValue> {
                        let result = self.0.view();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_view(&self, value: View) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_view(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let result = self.0.__TSB_clone(options);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let result = self.0.handle_bounds();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_handle_bounds(
                        &self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_handle_bounds(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_inside(rect);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_above(item);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_remove();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.stroke_join();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_stroke_join(
                        &self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_stroke_join(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn on_click(&self) -> std::result::Result<ItemOnClick, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_click()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_on_click(
                        &self,
                        value: ItemOnClick,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_click(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn fit_bounds(
                        &self,
                        rectangle: Rectangle,
                        fill: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_fit_bounds(rectangle, fill);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.blend_mode();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_blend_mode(
                        &self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_blend_mode(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.stroke_width();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_stroke_width(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_stroke_width(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.rotation();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_rotation(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_rotation(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn selected_color(
                        &self,
                    ) -> std::result::Result<ItemSelectedColor, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_selected_color()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_selected_color(
                        &self,
                        value: ItemSelectedColor,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_selected_color(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn skew(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_skew(hor, ver, center);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn name(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.name();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_name(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_name(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                        let result = self.0.__TSB_import_json(json);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let result = self.0.__TSB_add_child(item);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn visible(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.visible();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_visible(&self, value: bool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_visible(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.fill_rule();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_fill_rule(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_fill_rule(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn layer(&self) -> std::result::Result<Layer, JsValue> {
                        let result = self.0.layer();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_layer(&self, value: Layer) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_layer(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn tween_from(
                        &self,
                        from: JsValue,
                        options: ItemTweenFromParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let result = self.0.__TSB_tween_from(
                            from,
                            ts_bindgen_rt::to_jsvalue(&options)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn insert_child(
                        &self,
                        index: f64,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue> {
                        let result = self.0.__TSB_insert_child(index, item);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_remove_on_up();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn pivot(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.pivot();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_pivot(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_pivot(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.miter_limit();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_miter_limit(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_miter_limit(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_copy_content(source);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn import_svg(
                        &self,
                        svg: ItemImportSvgParamsSvgParam,
                        on_load: &'static dyn Fn(
                            Box<[JsValue]>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue> {
                        # [allow (non_snake_case)] let __TSB_Local_on_load = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 : Box < [JsValue] > = Box :: new ([_Variadic0_arg0 , _Variadic1_arg0 , _Variadic2_arg0 , _Variadic3_arg0 , _Variadic4_arg0 , _Variadic5_arg0 , _Variadic6_arg0]) ; let result = on_load (arg0) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let result = self.0.__TSB_import_svg(
                            ts_bindgen_rt::to_jsvalue(&svg)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                            &__TSB_Local_on_load,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_send_to_back();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn stroke_color(&self) -> std::result::Result<ItemStrokeColor, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_stroke_color()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_stroke_color(
                        &self,
                        value: ItemStrokeColor,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_stroke_color(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn on_mouse_move(&self) -> std::result::Result<ItemOnMouseMove, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_move()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_on_mouse_move(
                        &self,
                        value: ItemOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_move(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_replace_with(item);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue> {
                        let result = self.0.__TSB_hit_test(point, options);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn shear(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_shear(hor, ver, center);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_translate(delta);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let result = self.0.stroke_bounds();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_stroke_bounds(
                        &self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_stroke_bounds(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn insert_children(
                        &self,
                        index: f64,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self.0.__TSB_insert_children(
                                index,
                                ts_bindgen_rt::to_jsvalue(&items)
                                    .map_err(ts_bindgen_rt::Error::from)
                                    .map_err(JsValue::from)?,
                            )?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_child(item);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn shadow_offset(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.shadow_offset();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_shadow_offset(
                        &self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_shadow_offset(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn fill_color(&self) -> std::result::Result<ItemFillColor, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_fill_color()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_fill_color(
                        &self,
                        value: ItemFillColor,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_fill_color(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                        let result =
                            ts_bindgen_rt::from_jsvalue(&self.0.__TSB_export_svg(options)?)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn style(&self) -> std::result::Result<Style, JsValue> {
                        let result = self.0.style();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_style(&self, value: Style) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_style(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.clip_mask();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_clip_mask(&self, value: bool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_clip_mask(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn class_name(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.class_name();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_class_name(
                        &self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_class_name(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn on_mouse_up(&self) -> std::result::Result<ItemOnMouseUp, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_up()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_on_mouse_up(
                        &self,
                        value: ItemOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_up(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn on_frame(&self) -> std::result::Result<ItemOnFrame, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_frame()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_on_frame(
                        &self,
                        value: ItemOnFrame,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_frame(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn parent_to_local(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_parent_to_local(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn previous_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let result = self.0.previous_sibling();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_previous_sibling(
                        &self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_previous_sibling(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_emit(type_, event);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn add_to(
                        &self,
                        owner: ItemAddToParamsOwnerParam,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let result = self.0.__TSB_add_to(
                            ts_bindgen_rt::to_jsvalue(&owner)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn has_children(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_has_children();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_intersects(item);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn shadow_color(&self) -> std::result::Result<ItemShadowColor, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_shadow_color()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_shadow_color(
                        &self,
                        value: ItemShadowColor,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_shadow_color(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.scaling();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_scaling(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_scaling(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Item {
                    fn describe() {
                        <Item_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Item {
                    type Abi = <Item_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Item {
                    type Abi = <Item_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Item(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Item {
                    type Abi = <&'a Item_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Item {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Item {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Item_Class =
                            <Item_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait Item_Trait {
                    fn set_stroke_scaling(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    fn stroke_scaling(&self) -> std::result::Result<bool, JsValue>;
                    fn set_apply_matrix(&mut self, value: bool)
                        -> std::result::Result<(), JsValue>;
                    fn apply_matrix(&self) -> std::result::Result<bool, JsValue>;
                    fn set_view_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue>;
                    fn view_matrix(&self) -> std::result::Result<Matrix, JsValue>;
                    fn set_dash_array(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue>;
                    fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue>;
                    fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue>;
                    fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue>;
                    fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue>;
                    fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue>;
                    fn set_shadow_blur(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn shadow_blur(&self) -> std::result::Result<f64, JsValue>;
                    fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue>;
                    fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue>;
                    fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue>;
                    fn set_matrix(&mut self, value: Matrix) -> std::result::Result<(), JsValue>;
                    fn matrix(&self) -> std::result::Result<Matrix, JsValue>;
                    fn export_json(&self, options: JsValue)
                        -> std::result::Result<String, JsValue>;
                    fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue>;
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ItemOnMouseDrag,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_drag(&self) -> std::result::Result<ItemOnMouseDrag, JsValue>;
                    fn get_item(
                        &self,
                        options: ItemGetItemParamsOptionsParam,
                    ) -> std::result::Result<Item, JsValue>;
                    fn remove_children(
                        &self,
                        start: f64,
                        end: f64,
                    ) -> std::result::Result<Vec<Item>, JsValue>;
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue>;
                    fn project(&self) -> std::result::Result<Project, JsValue>;
                    fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue>;
                    fn data(&self) -> std::result::Result<JsValue, JsValue>;
                    fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue>;
                    fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue>;
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue>;
                    fn is_inserted(&self) -> std::result::Result<bool, JsValue>;
                    fn set_on_mouse_down(
                        &mut self,
                        value: ItemOnMouseDown,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_down(&self) -> std::result::Result<ItemOnMouseDown, JsValue>;
                    fn set_last_child(&mut self, value: Item) -> std::result::Result<(), JsValue>;
                    fn last_child(&self) -> std::result::Result<Item, JsValue>;
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue>;
                    fn selected(&self) -> std::result::Result<bool, JsValue>;
                    fn set_global_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue>;
                    fn global_matrix(&self) -> std::result::Result<Matrix, JsValue>;
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue>;
                    fn rotate(&self, angle: f64, center: Point)
                        -> std::result::Result<(), JsValue>;
                    fn tween(
                        &self,
                        options: ItemTweenParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue>;
                    fn set_on_mouse_enter(
                        &mut self,
                        value: ItemOnMouseEnter,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_enter(&self) -> std::result::Result<ItemOnMouseEnter, JsValue>;
                    fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn id(&self) -> std::result::Result<f64, JsValue>;
                    fn on(&self, object: JsValue) -> std::result::Result<JsValue, JsValue>;
                    fn tween_to(
                        &self,
                        to: JsValue,
                        options: ItemTweenToParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue>;
                    fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue>;
                    fn locked(&self) -> std::result::Result<bool, JsValue>;
                    fn set_children(
                        &mut self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue>;
                    fn children(&self) -> std::result::Result<Vec<Item>, JsValue>;
                    fn copy_attributes(
                        &self,
                        source: Item,
                        exclude_matrix: bool,
                    ) -> std::result::Result<(), JsValue>;
                    fn off(&self, object: JsValue) -> std::result::Result<JsValue, JsValue>;
                    fn contains(&self, point: Point) -> std::result::Result<bool, JsValue>;
                    fn has_stroke(&self) -> std::result::Result<bool, JsValue>;
                    fn remove_on_move(&self) -> std::result::Result<(), JsValue>;
                    fn add_children(
                        &self,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue>;
                    fn reverse_children(&self) -> std::result::Result<(), JsValue>;
                    fn has_shadow(&self) -> std::result::Result<bool, JsValue>;
                    fn set_dash_offset(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn dash_offset(&self) -> std::result::Result<f64, JsValue>;
                    fn set_on_mouse_leave(
                        &mut self,
                        value: ItemOnMouseLeave,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_leave(&self) -> std::result::Result<ItemOnMouseLeave, JsValue>;
                    fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue>;
                    fn set_stroke_cap(&mut self, value: String)
                        -> std::result::Result<(), JsValue>;
                    fn stroke_cap(&self) -> std::result::Result<String, JsValue>;
                    fn set_internal_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue>;
                    fn internal_bounds(&self) -> std::result::Result<Rectangle, JsValue>;
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn index(&self) -> std::result::Result<f64, JsValue>;
                    fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue>;
                    fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue>;
                    fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue>;
                    fn set_first_child(&mut self, value: Item) -> std::result::Result<(), JsValue>;
                    fn first_child(&self) -> std::result::Result<Item, JsValue>;
                    fn set_position(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn position(&self) -> std::result::Result<Point, JsValue>;
                    fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn opacity(&self) -> std::result::Result<f64, JsValue>;
                    fn remove_on_down(&self) -> std::result::Result<(), JsValue>;
                    fn remove_on_drag(&self) -> std::result::Result<(), JsValue>;
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue>;
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue>;
                    fn set_parent(&mut self, value: Item) -> std::result::Result<(), JsValue>;
                    fn parent(&self) -> std::result::Result<Item, JsValue>;
                    fn get_items(
                        &self,
                        options: ItemGetItemsParamsOptionsParam,
                    ) -> std::result::Result<Vec<Item>, JsValue>;
                    fn copy_to(
                        &self,
                        owner: ItemCopyToParamsOwnerParam,
                    ) -> std::result::Result<JsValue, JsValue>;
                    fn set_on_double_click(
                        &mut self,
                        value: ItemOnDoubleClick,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_double_click(&self) -> std::result::Result<ItemOnDoubleClick, JsValue>;
                    fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue>;
                    fn scale(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue>;
                    fn set_next_sibling(&mut self, value: Item)
                        -> std::result::Result<(), JsValue>;
                    fn next_sibling(&self) -> std::result::Result<Item, JsValue>;
                    fn rasterize(&self, options: JsValue) -> std::result::Result<Raster, JsValue>;
                    fn bring_to_front(&self) -> std::result::Result<(), JsValue>;
                    fn matches(
                        &self,
                        name: String,
                        compare: JsValue,
                    ) -> std::result::Result<bool, JsValue>;
                    fn has_fill(&self) -> std::result::Result<bool, JsValue>;
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue>;
                    fn view(&self) -> std::result::Result<View, JsValue>;
                    fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue>;
                    fn set_handle_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue>;
                    fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue>;
                    fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue>;
                    fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue>;
                    fn remove(&self) -> std::result::Result<bool, JsValue>;
                    fn set_stroke_join(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    fn stroke_join(&self) -> std::result::Result<String, JsValue>;
                    fn set_on_click(
                        &mut self,
                        value: ItemOnClick,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_click(&self) -> std::result::Result<ItemOnClick, JsValue>;
                    fn fit_bounds(
                        &self,
                        rectangle: Rectangle,
                        fill: bool,
                    ) -> std::result::Result<(), JsValue>;
                    fn set_blend_mode(&mut self, value: String)
                        -> std::result::Result<(), JsValue>;
                    fn blend_mode(&self) -> std::result::Result<String, JsValue>;
                    fn set_stroke_width(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn stroke_width(&self) -> std::result::Result<f64, JsValue>;
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn rotation(&self) -> std::result::Result<f64, JsValue>;
                    fn set_selected_color(
                        &mut self,
                        value: ItemSelectedColor,
                    ) -> std::result::Result<(), JsValue>;
                    fn selected_color(&self) -> std::result::Result<ItemSelectedColor, JsValue>;
                    fn skew(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn name(&self) -> std::result::Result<String, JsValue>;
                    fn import_json(&self, json: String) -> std::result::Result<Item, JsValue>;
                    fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue>;
                    fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue>;
                    fn visible(&self) -> std::result::Result<bool, JsValue>;
                    fn set_fill_rule(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn fill_rule(&self) -> std::result::Result<String, JsValue>;
                    fn set_layer(&mut self, value: Layer) -> std::result::Result<(), JsValue>;
                    fn layer(&self) -> std::result::Result<Layer, JsValue>;
                    fn tween_from(
                        &self,
                        from: JsValue,
                        options: ItemTweenFromParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue>;
                    fn insert_child(
                        &self,
                        index: f64,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue>;
                    fn remove_on_up(&self) -> std::result::Result<(), JsValue>;
                    fn set_pivot(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn pivot(&self) -> std::result::Result<Point, JsValue>;
                    fn set_miter_limit(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn miter_limit(&self) -> std::result::Result<f64, JsValue>;
                    fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue>;
                    fn import_svg(
                        &self,
                        svg: ItemImportSvgParamsSvgParam,
                        on_load: &'static dyn Fn(
                            Box<[JsValue]>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue>;
                    fn send_to_back(&self) -> std::result::Result<(), JsValue>;
                    fn set_stroke_color(
                        &mut self,
                        value: ItemStrokeColor,
                    ) -> std::result::Result<(), JsValue>;
                    fn stroke_color(&self) -> std::result::Result<ItemStrokeColor, JsValue>;
                    fn set_on_mouse_move(
                        &mut self,
                        value: ItemOnMouseMove,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_move(&self) -> std::result::Result<ItemOnMouseMove, JsValue>;
                    fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue>;
                    fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue>;
                    fn shear(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn translate(&self, delta: Point) -> std::result::Result<(), JsValue>;
                    fn set_stroke_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue>;
                    fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue>;
                    fn insert_children(
                        &self,
                        index: f64,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue>;
                    fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue>;
                    fn set_shadow_offset(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn shadow_offset(&self) -> std::result::Result<Point, JsValue>;
                    fn set_fill_color(
                        &mut self,
                        value: ItemFillColor,
                    ) -> std::result::Result<(), JsValue>;
                    fn fill_color(&self) -> std::result::Result<ItemFillColor, JsValue>;
                    fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ItemExportSvgReturn, JsValue>;
                    fn set_style(&mut self, value: Style) -> std::result::Result<(), JsValue>;
                    fn style(&self) -> std::result::Result<Style, JsValue>;
                    fn set_clip_mask(&mut self, value: bool) -> std::result::Result<(), JsValue>;
                    fn clip_mask(&self) -> std::result::Result<bool, JsValue>;
                    fn set_class_name(&mut self, value: String)
                        -> std::result::Result<(), JsValue>;
                    fn class_name(&self) -> std::result::Result<String, JsValue>;
                    fn set_on_mouse_up(
                        &mut self,
                        value: ItemOnMouseUp,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_up(&self) -> std::result::Result<ItemOnMouseUp, JsValue>;
                    fn set_on_frame(
                        &mut self,
                        value: ItemOnFrame,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_frame(&self) -> std::result::Result<ItemOnFrame, JsValue>;
                    fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue>;
                    fn set_previous_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue>;
                    fn previous_sibling(&self) -> std::result::Result<Item, JsValue>;
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue>;
                    fn add_to(
                        &self,
                        owner: ItemAddToParamsOwnerParam,
                    ) -> std::result::Result<JsValue, JsValue>;
                    fn has_children(&self) -> std::result::Result<bool, JsValue>;
                    fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue>;
                    fn set_shadow_color(
                        &mut self,
                        value: ItemShadowColor,
                    ) -> std::result::Result<(), JsValue>;
                    fn shadow_color(&self) -> std::result::Result<ItemShadowColor, JsValue>;
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn scaling(&self) -> std::result::Result<Point, JsValue>;
                }
                impl Item_Trait for Item {
                    fn set_stroke_scaling(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_stroke_scaling(&mut target, value)
                    }
                    fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::stroke_scaling(&target)
                    }
                    fn set_apply_matrix(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_apply_matrix(&mut target, value)
                    }
                    fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::apply_matrix(&target)
                    }
                    fn set_view_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_view_matrix(&mut target, value)
                    }
                    fn view_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Item::view_matrix(&target)
                    }
                    fn set_dash_array(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_dash_array(&mut target, value)
                    }
                    fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let target = self;
                        Item::dash_array(&target)
                    }
                    fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::is_ancestor(&target, item)
                    }
                    fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::is_descendant(&target, item)
                    }
                    fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::is_sibling(&target, item)
                    }
                    fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Item::local_to_parent(&target, point)
                    }
                    fn set_shadow_blur(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_shadow_blur(&mut target, value)
                    }
                    fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Item::shadow_blur(&target)
                    }
                    fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::is_empty(&target, recursively)
                    }
                    fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::is_parent(&target, item)
                    }
                    fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::is_below(&target, item)
                    }
                    fn set_matrix(&mut self, value: Matrix) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_matrix(&mut target, value)
                    }
                    fn matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Item::matrix(&target)
                    }
                    fn export_json(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Item::export_json(&target, options)
                    }
                    fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Item::global_to_local(&target, point)
                    }
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ItemOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_on_mouse_drag(&mut target, value)
                    }
                    fn on_mouse_drag(&self) -> std::result::Result<ItemOnMouseDrag, JsValue> {
                        let target = self;
                        Item::on_mouse_drag(&target)
                    }
                    fn get_item(
                        &self,
                        options: ItemGetItemParamsOptionsParam,
                    ) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Item::get_item(&target, options)
                    }
                    fn remove_children(
                        &self,
                        start: f64,
                        end: f64,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target = self;
                        Item::remove_children(&target, start, end)
                    }
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_project(&mut target, value)
                    }
                    fn project(&self) -> std::result::Result<Project, JsValue> {
                        let target = self;
                        Item::project(&target)
                    }
                    fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_data(&mut target, value)
                    }
                    fn data(&self) -> std::result::Result<JsValue, JsValue> {
                        let target = self;
                        Item::data(&target)
                    }
                    fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Item::insert_above(&target, item)
                    }
                    fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::remove_on(&target, options)
                    }
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::transform(&target, matrix)
                    }
                    fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::is_inserted(&target)
                    }
                    fn set_on_mouse_down(
                        &mut self,
                        value: ItemOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_on_mouse_down(&mut target, value)
                    }
                    fn on_mouse_down(&self) -> std::result::Result<ItemOnMouseDown, JsValue> {
                        let target = self;
                        Item::on_mouse_down(&target)
                    }
                    fn set_last_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_last_child(&mut target, value)
                    }
                    fn last_child(&self) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Item::last_child(&target)
                    }
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_selected(&mut target, value)
                    }
                    fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::selected(&target)
                    }
                    fn set_global_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_global_matrix(&mut target, value)
                    }
                    fn global_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Item::global_matrix(&target)
                    }
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::responds(&target, type_)
                    }
                    fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::rotate(&target, angle, center)
                    }
                    fn tween(
                        &self,
                        options: ItemTweenParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target = self;
                        Item::tween(&target, options)
                    }
                    fn set_on_mouse_enter(
                        &mut self,
                        value: ItemOnMouseEnter,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_on_mouse_enter(&mut target, value)
                    }
                    fn on_mouse_enter(&self) -> std::result::Result<ItemOnMouseEnter, JsValue> {
                        let target = self;
                        Item::on_mouse_enter(&target)
                    }
                    fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_id(&mut target, value)
                    }
                    fn id(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Item::id(&target)
                    }
                    fn on(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target = self;
                        Item::on(&target, object)
                    }
                    fn tween_to(
                        &self,
                        to: JsValue,
                        options: ItemTweenToParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target = self;
                        Item::tween_to(&target, to, options)
                    }
                    fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_locked(&mut target, value)
                    }
                    fn locked(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::locked(&target)
                    }
                    fn set_children(
                        &mut self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_children(&mut target, value)
                    }
                    fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                        let target = self;
                        Item::children(&target)
                    }
                    fn copy_attributes(
                        &self,
                        source: Item,
                        exclude_matrix: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::copy_attributes(&target, source, exclude_matrix)
                    }
                    fn off(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target = self;
                        Item::off(&target, object)
                    }
                    fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::contains(&target, point)
                    }
                    fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::has_stroke(&target)
                    }
                    fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::remove_on_move(&target)
                    }
                    fn add_children(
                        &self,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target = self;
                        Item::add_children(&target, items)
                    }
                    fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::reverse_children(&target)
                    }
                    fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::has_shadow(&target)
                    }
                    fn set_dash_offset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_dash_offset(&mut target, value)
                    }
                    fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Item::dash_offset(&target)
                    }
                    fn set_on_mouse_leave(
                        &mut self,
                        value: ItemOnMouseLeave,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_on_mouse_leave(&mut target, value)
                    }
                    fn on_mouse_leave(&self) -> std::result::Result<ItemOnMouseLeave, JsValue> {
                        let target = self;
                        Item::on_mouse_leave(&target)
                    }
                    fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue> {
                        let target = self;
                        Item::hit_test_all(&target, point, options)
                    }
                    fn set_stroke_cap(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_stroke_cap(&mut target, value)
                    }
                    fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Item::stroke_cap(&target)
                    }
                    fn set_internal_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_internal_bounds(&mut target, value)
                    }
                    fn internal_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        Item::internal_bounds(&target)
                    }
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_index(&mut target, value)
                    }
                    fn index(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Item::index(&target)
                    }
                    fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Item::reduce(&target, options)
                    }
                    fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::is_grouped_with(&target, item)
                    }
                    fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Item::local_to_global(&target, point)
                    }
                    fn set_first_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_first_child(&mut target, value)
                    }
                    fn first_child(&self) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Item::first_child(&target)
                    }
                    fn set_position(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_position(&mut target, value)
                    }
                    fn position(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Item::position(&target)
                    }
                    fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_opacity(&mut target, value)
                    }
                    fn opacity(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Item::opacity(&target)
                    }
                    fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::remove_on_down(&target)
                    }
                    fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::remove_on_drag(&target)
                    }
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_bounds(&mut target, value)
                    }
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        Item::bounds(&target)
                    }
                    fn set_parent(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_parent(&mut target, value)
                    }
                    fn parent(&self) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Item::parent(&target)
                    }
                    fn get_items(
                        &self,
                        options: ItemGetItemsParamsOptionsParam,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target = self;
                        Item::get_items(&target, options)
                    }
                    fn copy_to(
                        &self,
                        owner: ItemCopyToParamsOwnerParam,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target = self;
                        Item::copy_to(&target, owner)
                    }
                    fn set_on_double_click(
                        &mut self,
                        value: ItemOnDoubleClick,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_on_double_click(&mut target, value)
                    }
                    fn on_double_click(&self) -> std::result::Result<ItemOnDoubleClick, JsValue> {
                        let target = self;
                        Item::on_double_click(&target)
                    }
                    fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target = self;
                        Item::set(&target, props)
                    }
                    fn scale(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::scale(&target, hor, ver, center)
                    }
                    fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Item::insert_below(&target, item)
                    }
                    fn set_next_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_next_sibling(&mut target, value)
                    }
                    fn next_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Item::next_sibling(&target)
                    }
                    fn rasterize(&self, options: JsValue) -> std::result::Result<Raster, JsValue> {
                        let target = self;
                        Item::rasterize(&target, options)
                    }
                    fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::bring_to_front(&target)
                    }
                    fn matches(
                        &self,
                        name: String,
                        compare: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::matches(&target, name, compare)
                    }
                    fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::has_fill(&target)
                    }
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_view(&mut target, value)
                    }
                    fn view(&self) -> std::result::Result<View, JsValue> {
                        let target = self;
                        Item::view(&target)
                    }
                    fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target = self;
                        Item::clone(&target, options)
                    }
                    fn set_handle_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_handle_bounds(&mut target, value)
                    }
                    fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        Item::handle_bounds(&target)
                    }
                    fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::is_inside(&target, rect)
                    }
                    fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::is_above(&target, item)
                    }
                    fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::remove(&target)
                    }
                    fn set_stroke_join(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_stroke_join(&mut target, value)
                    }
                    fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Item::stroke_join(&target)
                    }
                    fn set_on_click(
                        &mut self,
                        value: ItemOnClick,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_on_click(&mut target, value)
                    }
                    fn on_click(&self) -> std::result::Result<ItemOnClick, JsValue> {
                        let target = self;
                        Item::on_click(&target)
                    }
                    fn fit_bounds(
                        &self,
                        rectangle: Rectangle,
                        fill: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::fit_bounds(&target, rectangle, fill)
                    }
                    fn set_blend_mode(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_blend_mode(&mut target, value)
                    }
                    fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Item::blend_mode(&target)
                    }
                    fn set_stroke_width(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_stroke_width(&mut target, value)
                    }
                    fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Item::stroke_width(&target)
                    }
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_rotation(&mut target, value)
                    }
                    fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Item::rotation(&target)
                    }
                    fn set_selected_color(
                        &mut self,
                        value: ItemSelectedColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_selected_color(&mut target, value)
                    }
                    fn selected_color(&self) -> std::result::Result<ItemSelectedColor, JsValue> {
                        let target = self;
                        Item::selected_color(&target)
                    }
                    fn skew(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::skew(&target, hor, ver, center)
                    }
                    fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_name(&mut target, value)
                    }
                    fn name(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Item::name(&target)
                    }
                    fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Item::import_json(&target, json)
                    }
                    fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Item::add_child(&target, item)
                    }
                    fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_visible(&mut target, value)
                    }
                    fn visible(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::visible(&target)
                    }
                    fn set_fill_rule(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_fill_rule(&mut target, value)
                    }
                    fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Item::fill_rule(&target)
                    }
                    fn set_layer(&mut self, value: Layer) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_layer(&mut target, value)
                    }
                    fn layer(&self) -> std::result::Result<Layer, JsValue> {
                        let target = self;
                        Item::layer(&target)
                    }
                    fn tween_from(
                        &self,
                        from: JsValue,
                        options: ItemTweenFromParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target = self;
                        Item::tween_from(&target, from, options)
                    }
                    fn insert_child(
                        &self,
                        index: f64,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Item::insert_child(&target, index, item)
                    }
                    fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::remove_on_up(&target)
                    }
                    fn set_pivot(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_pivot(&mut target, value)
                    }
                    fn pivot(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Item::pivot(&target)
                    }
                    fn set_miter_limit(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_miter_limit(&mut target, value)
                    }
                    fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Item::miter_limit(&target)
                    }
                    fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::copy_content(&target, source)
                    }
                    fn import_svg(
                        &self,
                        svg: ItemImportSvgParamsSvgParam,
                        on_load: &'static dyn Fn(
                            Box<[JsValue]>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Item::import_svg(&target, svg, on_load)
                    }
                    fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::send_to_back(&target)
                    }
                    fn set_stroke_color(
                        &mut self,
                        value: ItemStrokeColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_stroke_color(&mut target, value)
                    }
                    fn stroke_color(&self) -> std::result::Result<ItemStrokeColor, JsValue> {
                        let target = self;
                        Item::stroke_color(&target)
                    }
                    fn set_on_mouse_move(
                        &mut self,
                        value: ItemOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_on_mouse_move(&mut target, value)
                    }
                    fn on_mouse_move(&self) -> std::result::Result<ItemOnMouseMove, JsValue> {
                        let target = self;
                        Item::on_mouse_move(&target)
                    }
                    fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::replace_with(&target, item)
                    }
                    fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue> {
                        let target = self;
                        Item::hit_test(&target, point, options)
                    }
                    fn shear(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::shear(&target, hor, ver, center)
                    }
                    fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::translate(&target, delta)
                    }
                    fn set_stroke_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_stroke_bounds(&mut target, value)
                    }
                    fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        Item::stroke_bounds(&target)
                    }
                    fn insert_children(
                        &self,
                        index: f64,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target = self;
                        Item::insert_children(&target, index, items)
                    }
                    fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::is_child(&target, item)
                    }
                    fn set_shadow_offset(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_shadow_offset(&mut target, value)
                    }
                    fn shadow_offset(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Item::shadow_offset(&target)
                    }
                    fn set_fill_color(
                        &mut self,
                        value: ItemFillColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_fill_color(&mut target, value)
                    }
                    fn fill_color(&self) -> std::result::Result<ItemFillColor, JsValue> {
                        let target = self;
                        Item::fill_color(&target)
                    }
                    fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                        let target = self;
                        Item::export_svg(&target, options)
                    }
                    fn set_style(&mut self, value: Style) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_style(&mut target, value)
                    }
                    fn style(&self) -> std::result::Result<Style, JsValue> {
                        let target = self;
                        Item::style(&target)
                    }
                    fn set_clip_mask(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_clip_mask(&mut target, value)
                    }
                    fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::clip_mask(&target)
                    }
                    fn set_class_name(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_class_name(&mut target, value)
                    }
                    fn class_name(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Item::class_name(&target)
                    }
                    fn set_on_mouse_up(
                        &mut self,
                        value: ItemOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_on_mouse_up(&mut target, value)
                    }
                    fn on_mouse_up(&self) -> std::result::Result<ItemOnMouseUp, JsValue> {
                        let target = self;
                        Item::on_mouse_up(&target)
                    }
                    fn set_on_frame(
                        &mut self,
                        value: ItemOnFrame,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_on_frame(&mut target, value)
                    }
                    fn on_frame(&self) -> std::result::Result<ItemOnFrame, JsValue> {
                        let target = self;
                        Item::on_frame(&target)
                    }
                    fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Item::parent_to_local(&target, point)
                    }
                    fn set_previous_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_previous_sibling(&mut target, value)
                    }
                    fn previous_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Item::previous_sibling(&target)
                    }
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::emit(&target, type_, event)
                    }
                    fn add_to(
                        &self,
                        owner: ItemAddToParamsOwnerParam,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target = self;
                        Item::add_to(&target, owner)
                    }
                    fn has_children(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::has_children(&target)
                    }
                    fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::intersects(&target, item)
                    }
                    fn set_shadow_color(
                        &mut self,
                        value: ItemShadowColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_shadow_color(&mut target, value)
                    }
                    fn shadow_color(&self) -> std::result::Result<ItemShadowColor, JsValue> {
                        let target = self;
                        Item::shadow_color(&target)
                    }
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Item::set_scaling(&mut target, value)
                    }
                    fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Item::scaling(&target)
                    }
                }
                impl std::clone::Clone for Item_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Item_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Item_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemShadowColor {
                    ColorCase(Color),
                    TsBindgenRtNullCase,
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum StyleFontWeight {
                    F64Case(f64),
                    StringCase(String),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum TextItemFontWeight {
                    F64Case(f64),
                    StringCase(String),
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[wasm_bindgen(js_name = "View")]
                    pub type View_Class;
                    # [wasm_bindgen (method , structural , catch , getter = size , js_class = "View")]
                    fn size(this: &View_Class) -> std::result::Result<Size, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = size , js_class = "View")]
                    fn set_size(this: &View_Class, value: Size)
                        -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = translate , method , js_class = "View" , catch)]
                    fn __TSB_translate(
                        this: &View_Class,
                        delta: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = scale , method , js_class = "View" , catch)]
                    fn __TSB_scale(
                        this: &View_Class,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseMove , js_class = "View")]
                    fn __TSB_on_mouse_move(
                        this: &View_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseMove , js_class = "View")]
                    fn __TSB_set_on_mouse_move(
                        this: &View_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseEnter , js_class = "View")]
                    fn __TSB_on_mouse_enter(
                        this: &View_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseEnter , js_class = "View")]
                    fn __TSB_set_on_mouse_enter(
                        this: &View_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = remove , method , js_class = "View" , catch)]
                    fn __TSB_remove(this: &View_Class) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onDoubleClick , js_class = "View")]
                    fn __TSB_on_double_click(
                        this: &View_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onDoubleClick , js_class = "View")]
                    fn __TSB_set_on_double_click(
                        this: &View_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseUp , js_class = "View")]
                    fn __TSB_on_mouse_up(
                        this: &View_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseUp , js_class = "View")]
                    fn __TSB_set_on_mouse_up(
                        this: &View_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = bounds , js_class = "View")]
                    fn bounds(this: &View_Class) -> std::result::Result<Rectangle, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = bounds , js_class = "View")]
                    fn set_bounds(
                        this: &View_Class,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isVisible , method , js_class = "View" , catch)]
                    fn __TSB_is_visible(this: &View_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = resolution , js_class = "View")]
                    fn resolution(this: &View_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = resolution , js_class = "View")]
                    fn set_resolution(
                        this: &View_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = shear , method , js_class = "View" , catch)]
                    fn __TSB_shear(
                        this: &View_Class,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = pause , method , js_class = "View" , catch)]
                    fn __TSB_pause(this: &View_Class) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = emit , method , js_class = "View" , catch)]
                    fn __TSB_emit(
                        this: &View_Class,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = zoom , js_class = "View")]
                    fn zoom(this: &View_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = zoom , js_class = "View")]
                    fn set_zoom(this: &View_Class, value: f64) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = element , js_class = "View")]
                    fn __TSB_element(
                        this: &View_Class,
                    ) -> std::result::Result<web_sys::HtmlCanvasElement, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = element , js_class = "View")]
                    fn __TSB_set_element(
                        this: &View_Class,
                        value: web_sys::HtmlCanvasElement,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseDrag , js_class = "View")]
                    fn __TSB_on_mouse_drag(
                        this: &View_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseDrag , js_class = "View")]
                    fn __TSB_set_on_mouse_drag(
                        this: &View_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = autoUpdate , js_class = "View")]
                    fn auto_update(this: &View_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = autoUpdate , js_class = "View")]
                    fn set_auto_update(
                        this: &View_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = pixelRatio , js_class = "View")]
                    fn pixel_ratio(this: &View_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = pixelRatio , js_class = "View")]
                    fn set_pixel_ratio(
                        this: &View_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = center , js_class = "View")]
                    fn center(this: &View_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = center , js_class = "View")]
                    fn set_center(
                        this: &View_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onClick , js_class = "View")]
                    fn __TSB_on_click(this: &View_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onClick , js_class = "View")]
                    fn __TSB_set_on_click(
                        this: &View_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onResize , js_class = "View")]
                    fn __TSB_on_resize(this: &View_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onResize , js_class = "View")]
                    fn __TSB_set_on_resize(
                        this: &View_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = viewSize , js_class = "View")]
                    fn view_size(this: &View_Class) -> std::result::Result<Size, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = viewSize , js_class = "View")]
                    fn set_view_size(
                        this: &View_Class,
                        value: Size,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getEventPoint , method , js_class = "View" , catch)]
                    fn __TSB_get_event_point(
                        this: &View_Class,
                        event: Event,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = rotate , method , js_class = "View" , catch)]
                    fn __TSB_rotate(
                        this: &View_Class,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = update , method , js_class = "View" , catch)]
                    fn __TSB_update(this: &View_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseLeave , js_class = "View")]
                    fn __TSB_on_mouse_leave(
                        this: &View_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseLeave , js_class = "View")]
                    fn __TSB_set_on_mouse_leave(
                        this: &View_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = viewToProject , method , js_class = "View" , catch)]
                    fn __TSB_view_to_project(
                        this: &View_Class,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = responds , method , js_class = "View" , catch)]
                    fn __TSB_responds(
                        this: &View_Class,
                        type_: String,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = play , method , js_class = "View" , catch)]
                    fn __TSB_play(this: &View_Class) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isInserted , method , js_class = "View" , catch)]
                    fn __TSB_is_inserted(this: &View_Class) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = transform , method , js_class = "View" , catch)]
                    fn __TSB_transform(
                        this: &View_Class,
                        matrix: Matrix,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseDown , js_class = "View")]
                    fn __TSB_on_mouse_down(
                        this: &View_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseDown , js_class = "View")]
                    fn __TSB_set_on_mouse_down(
                        this: &View_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = rotation , js_class = "View")]
                    fn rotation(this: &View_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = rotation , js_class = "View")]
                    fn set_rotation(
                        this: &View_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = on , method , js_class = "View" , catch)]
                    fn __TSB_on(
                        this: &View_Class,
                        param: JsValue,
                    ) -> std::result::Result<View, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = requestUpdate , method , js_class = "View" , catch)]
                    fn __TSB_request_update(this: &View_Class) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = matrix , js_class = "View")]
                    fn matrix(this: &View_Class) -> std::result::Result<Matrix, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = matrix , js_class = "View")]
                    fn set_matrix(
                        this: &View_Class,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = projectToView , method , js_class = "View" , catch)]
                    fn __TSB_project_to_view(
                        this: &View_Class,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = scaling , js_class = "View")]
                    fn scaling(this: &View_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = scaling , js_class = "View")]
                    fn set_scaling(
                        this: &View_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = skew , method , js_class = "View" , catch)]
                    fn __TSB_skew(
                        this: &View_Class,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = off , method , js_class = "View" , catch)]
                    fn __TSB_off(
                        this: &View_Class,
                        param: JsValue,
                    ) -> std::result::Result<View, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onFrame , js_class = "View")]
                    fn __TSB_on_frame(this: &View_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onFrame , js_class = "View")]
                    fn __TSB_set_on_frame(
                        this: &View_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct View(pub View_Class);
                impl View {
                    #[allow(dead_code)]
                    pub fn size(&self) -> std::result::Result<Size, JsValue> {
                        let result = self.0.size();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_size(&self, value: Size) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_size(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_translate(delta);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn scale(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_scale(hor, ver, center);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn on_mouse_move(&self) -> std::result::Result<ViewOnMouseMove, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_move()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_on_mouse_move(
                        &self,
                        value: ViewOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_move(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn on_mouse_enter(&self) -> std::result::Result<ViewOnMouseEnter, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_enter()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_on_mouse_enter(
                        &self,
                        value: ViewOnMouseEnter,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_enter(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn remove(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_remove();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn on_double_click(
                        &self,
                    ) -> std::result::Result<ViewOnDoubleClick, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_double_click()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_on_double_click(
                        &self,
                        value: ViewOnDoubleClick,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_double_click(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn on_mouse_up(&self) -> std::result::Result<ViewOnMouseUp, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_up()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_on_mouse_up(
                        &self,
                        value: ViewOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_up(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let result = self.0.bounds();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_bounds(&self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_bounds(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_visible(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_visible();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn resolution(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.resolution();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_resolution(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_resolution(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn shear(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_shear(hor, ver, center);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn pause(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_pause();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_emit(type_, event);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn zoom(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.zoom();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_zoom(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_zoom(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn element(
                        &self,
                    ) -> std::result::Result<web_sys::HtmlCanvasElement, JsValue>
                    {
                        let result = self.0.__TSB_element();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_element(
                        &self,
                        value: web_sys::HtmlCanvasElement,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_element(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn on_mouse_drag(&self) -> std::result::Result<ViewOnMouseDrag, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_drag()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_on_mouse_drag(
                        &self,
                        value: ViewOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_drag(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn auto_update(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.auto_update();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_auto_update(&self, value: bool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_auto_update(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn pixel_ratio(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.pixel_ratio();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_pixel_ratio(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_pixel_ratio(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn center(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.center();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_center(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_center(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn on_click(&self) -> std::result::Result<ViewOnClick, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_click()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_on_click(
                        &self,
                        value: ViewOnClick,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_click(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn on_resize(&self) -> std::result::Result<ViewOnResize, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_resize()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_on_resize(
                        &self,
                        value: ViewOnResize,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_resize(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn view_size(&self) -> std::result::Result<Size, JsValue> {
                        let result = self.0.view_size();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_view_size(&self, value: Size) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_view_size(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_event_point(
                        &self,
                        event: Event,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_get_event_point(event);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_rotate(angle, center);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn update(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_update();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn on_mouse_leave(&self) -> std::result::Result<ViewOnMouseLeave, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_leave()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_on_mouse_leave(
                        &self,
                        value: ViewOnMouseLeave,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_leave(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn view_to_project(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_view_to_project(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_responds(type_);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn play(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_play();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_inserted();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_transform(matrix);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn on_mouse_down(&self) -> std::result::Result<ViewOnMouseDown, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_down()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_on_mouse_down(
                        &self,
                        value: ViewOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_down(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.rotation();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_rotation(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_rotation(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn on(&self, param: JsValue) -> std::result::Result<View, JsValue> {
                        let result = self.0.__TSB_on(param);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn request_update(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_request_update();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.matrix();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_matrix(&self, value: Matrix) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_matrix(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn project_to_view(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_project_to_view(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.scaling();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_scaling(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_scaling(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn skew(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_skew(hor, ver, center);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn off(&self, param: JsValue) -> std::result::Result<View, JsValue> {
                        let result = self.0.__TSB_off(param);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn on_frame(&self) -> std::result::Result<ViewOnFrame, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_frame()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_on_frame(
                        &self,
                        value: ViewOnFrame,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_frame(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for View {
                    fn describe() {
                        <View_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for View {
                    type Abi = <View_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for View {
                    type Abi = <View_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        View(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a View {
                    type Abi = <&'a View_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for View {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for View {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: View_Class =
                            <View_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait View_Trait {
                    fn set_size(&mut self, value: Size) -> std::result::Result<(), JsValue>;
                    fn size(&self) -> std::result::Result<Size, JsValue>;
                    fn translate(&self, delta: Point) -> std::result::Result<(), JsValue>;
                    fn scale(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn set_on_mouse_move(
                        &mut self,
                        value: ViewOnMouseMove,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_move(&self) -> std::result::Result<ViewOnMouseMove, JsValue>;
                    fn set_on_mouse_enter(
                        &mut self,
                        value: ViewOnMouseEnter,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_enter(&self) -> std::result::Result<ViewOnMouseEnter, JsValue>;
                    fn remove(&self) -> std::result::Result<(), JsValue>;
                    fn set_on_double_click(
                        &mut self,
                        value: ViewOnDoubleClick,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_double_click(&self) -> std::result::Result<ViewOnDoubleClick, JsValue>;
                    fn set_on_mouse_up(
                        &mut self,
                        value: ViewOnMouseUp,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_up(&self) -> std::result::Result<ViewOnMouseUp, JsValue>;
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue>;
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue>;
                    fn is_visible(&self) -> std::result::Result<bool, JsValue>;
                    fn set_resolution(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn resolution(&self) -> std::result::Result<f64, JsValue>;
                    fn shear(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn pause(&self) -> std::result::Result<(), JsValue>;
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue>;
                    fn set_zoom(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn zoom(&self) -> std::result::Result<f64, JsValue>;
                    fn set_element(
                        &mut self,
                        value: web_sys::HtmlCanvasElement,
                    ) -> std::result::Result<(), JsValue>;
                    fn element(&self) -> std::result::Result<web_sys::HtmlCanvasElement, JsValue>;
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ViewOnMouseDrag,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_drag(&self) -> std::result::Result<ViewOnMouseDrag, JsValue>;
                    fn set_auto_update(&mut self, value: bool) -> std::result::Result<(), JsValue>;
                    fn auto_update(&self) -> std::result::Result<bool, JsValue>;
                    fn set_pixel_ratio(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn pixel_ratio(&self) -> std::result::Result<f64, JsValue>;
                    fn set_center(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn center(&self) -> std::result::Result<Point, JsValue>;
                    fn set_on_click(
                        &mut self,
                        value: ViewOnClick,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_click(&self) -> std::result::Result<ViewOnClick, JsValue>;
                    fn set_on_resize(
                        &mut self,
                        value: ViewOnResize,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_resize(&self) -> std::result::Result<ViewOnResize, JsValue>;
                    fn set_view_size(&mut self, value: Size) -> std::result::Result<(), JsValue>;
                    fn view_size(&self) -> std::result::Result<Size, JsValue>;
                    fn get_event_point(&self, event: Event) -> std::result::Result<Point, JsValue>;
                    fn rotate(&self, angle: f64, center: Point)
                        -> std::result::Result<(), JsValue>;
                    fn update(&self) -> std::result::Result<bool, JsValue>;
                    fn set_on_mouse_leave(
                        &mut self,
                        value: ViewOnMouseLeave,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_leave(&self) -> std::result::Result<ViewOnMouseLeave, JsValue>;
                    fn view_to_project(&self, point: Point) -> std::result::Result<Point, JsValue>;
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue>;
                    fn play(&self) -> std::result::Result<(), JsValue>;
                    fn is_inserted(&self) -> std::result::Result<bool, JsValue>;
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue>;
                    fn set_on_mouse_down(
                        &mut self,
                        value: ViewOnMouseDown,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_down(&self) -> std::result::Result<ViewOnMouseDown, JsValue>;
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn rotation(&self) -> std::result::Result<f64, JsValue>;
                    fn on(&self, param: JsValue) -> std::result::Result<View, JsValue>;
                    fn request_update(&self) -> std::result::Result<(), JsValue>;
                    fn set_matrix(&mut self, value: Matrix) -> std::result::Result<(), JsValue>;
                    fn matrix(&self) -> std::result::Result<Matrix, JsValue>;
                    fn project_to_view(&self, point: Point) -> std::result::Result<Point, JsValue>;
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn scaling(&self) -> std::result::Result<Point, JsValue>;
                    fn skew(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn off(&self, param: JsValue) -> std::result::Result<View, JsValue>;
                    fn set_on_frame(
                        &mut self,
                        value: ViewOnFrame,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_frame(&self) -> std::result::Result<ViewOnFrame, JsValue>;
                }
                impl View_Trait for View {
                    fn set_size(&mut self, value: Size) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        View::set_size(&mut target, value)
                    }
                    fn size(&self) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        View::size(&target)
                    }
                    fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::translate(&target, delta)
                    }
                    fn scale(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::scale(&target, hor, ver, center)
                    }
                    fn set_on_mouse_move(
                        &mut self,
                        value: ViewOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        View::set_on_mouse_move(&mut target, value)
                    }
                    fn on_mouse_move(&self) -> std::result::Result<ViewOnMouseMove, JsValue> {
                        let target = self;
                        View::on_mouse_move(&target)
                    }
                    fn set_on_mouse_enter(
                        &mut self,
                        value: ViewOnMouseEnter,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        View::set_on_mouse_enter(&mut target, value)
                    }
                    fn on_mouse_enter(&self) -> std::result::Result<ViewOnMouseEnter, JsValue> {
                        let target = self;
                        View::on_mouse_enter(&target)
                    }
                    fn remove(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::remove(&target)
                    }
                    fn set_on_double_click(
                        &mut self,
                        value: ViewOnDoubleClick,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        View::set_on_double_click(&mut target, value)
                    }
                    fn on_double_click(&self) -> std::result::Result<ViewOnDoubleClick, JsValue> {
                        let target = self;
                        View::on_double_click(&target)
                    }
                    fn set_on_mouse_up(
                        &mut self,
                        value: ViewOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        View::set_on_mouse_up(&mut target, value)
                    }
                    fn on_mouse_up(&self) -> std::result::Result<ViewOnMouseUp, JsValue> {
                        let target = self;
                        View::on_mouse_up(&target)
                    }
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        View::set_bounds(&mut target, value)
                    }
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        View::bounds(&target)
                    }
                    fn is_visible(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        View::is_visible(&target)
                    }
                    fn set_resolution(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        View::set_resolution(&mut target, value)
                    }
                    fn resolution(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        View::resolution(&target)
                    }
                    fn shear(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::shear(&target, hor, ver, center)
                    }
                    fn pause(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::pause(&target)
                    }
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        View::emit(&target, type_, event)
                    }
                    fn set_zoom(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        View::set_zoom(&mut target, value)
                    }
                    fn zoom(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        View::zoom(&target)
                    }
                    fn set_element(
                        &mut self,
                        value: web_sys::HtmlCanvasElement,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        View::set_element(&mut target, value)
                    }
                    fn element(&self) -> std::result::Result<web_sys::HtmlCanvasElement, JsValue> {
                        let target = self;
                        View::element(&target)
                    }
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ViewOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        View::set_on_mouse_drag(&mut target, value)
                    }
                    fn on_mouse_drag(&self) -> std::result::Result<ViewOnMouseDrag, JsValue> {
                        let target = self;
                        View::on_mouse_drag(&target)
                    }
                    fn set_auto_update(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        View::set_auto_update(&mut target, value)
                    }
                    fn auto_update(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        View::auto_update(&target)
                    }
                    fn set_pixel_ratio(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        View::set_pixel_ratio(&mut target, value)
                    }
                    fn pixel_ratio(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        View::pixel_ratio(&target)
                    }
                    fn set_center(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        View::set_center(&mut target, value)
                    }
                    fn center(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        View::center(&target)
                    }
                    fn set_on_click(
                        &mut self,
                        value: ViewOnClick,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        View::set_on_click(&mut target, value)
                    }
                    fn on_click(&self) -> std::result::Result<ViewOnClick, JsValue> {
                        let target = self;
                        View::on_click(&target)
                    }
                    fn set_on_resize(
                        &mut self,
                        value: ViewOnResize,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        View::set_on_resize(&mut target, value)
                    }
                    fn on_resize(&self) -> std::result::Result<ViewOnResize, JsValue> {
                        let target = self;
                        View::on_resize(&target)
                    }
                    fn set_view_size(&mut self, value: Size) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        View::set_view_size(&mut target, value)
                    }
                    fn view_size(&self) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        View::view_size(&target)
                    }
                    fn get_event_point(&self, event: Event) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        View::get_event_point(&target, event)
                    }
                    fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::rotate(&target, angle, center)
                    }
                    fn update(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        View::update(&target)
                    }
                    fn set_on_mouse_leave(
                        &mut self,
                        value: ViewOnMouseLeave,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        View::set_on_mouse_leave(&mut target, value)
                    }
                    fn on_mouse_leave(&self) -> std::result::Result<ViewOnMouseLeave, JsValue> {
                        let target = self;
                        View::on_mouse_leave(&target)
                    }
                    fn view_to_project(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        View::view_to_project(&target, point)
                    }
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        View::responds(&target, type_)
                    }
                    fn play(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::play(&target)
                    }
                    fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        View::is_inserted(&target)
                    }
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::transform(&target, matrix)
                    }
                    fn set_on_mouse_down(
                        &mut self,
                        value: ViewOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        View::set_on_mouse_down(&mut target, value)
                    }
                    fn on_mouse_down(&self) -> std::result::Result<ViewOnMouseDown, JsValue> {
                        let target = self;
                        View::on_mouse_down(&target)
                    }
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        View::set_rotation(&mut target, value)
                    }
                    fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        View::rotation(&target)
                    }
                    fn on(&self, param: JsValue) -> std::result::Result<View, JsValue> {
                        let target = self;
                        View::on(&target, param)
                    }
                    fn request_update(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::request_update(&target)
                    }
                    fn set_matrix(&mut self, value: Matrix) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        View::set_matrix(&mut target, value)
                    }
                    fn matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        View::matrix(&target)
                    }
                    fn project_to_view(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        View::project_to_view(&target, point)
                    }
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        View::set_scaling(&mut target, value)
                    }
                    fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        View::scaling(&target)
                    }
                    fn skew(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::skew(&target, hor, ver, center)
                    }
                    fn off(&self, param: JsValue) -> std::result::Result<View, JsValue> {
                        let target = self;
                        View::off(&target, param)
                    }
                    fn set_on_frame(
                        &mut self,
                        value: ViewOnFrame,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        View::set_on_frame(&mut target, value)
                    }
                    fn on_frame(&self) -> std::result::Result<ViewOnFrame, JsValue> {
                        let target = self;
                        View::on_frame(&target)
                    }
                }
                impl std::clone::Clone for View_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for View_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for View_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[wasm_bindgen(js_name = "Tool")]
                    pub type Tool_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = off , method , js_class = "Tool" , catch)]
                    fn __TSB_off(
                        this: &Tool_Class,
                        param: JsValue,
                    ) -> std::result::Result<Tool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseDown , js_class = "Tool")]
                    fn __TSB_on_mouse_down(
                        this: &Tool_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseDown , js_class = "Tool")]
                    fn __TSB_set_on_mouse_down(
                        this: &Tool_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = on , method , js_class = "Tool" , catch)]
                    fn __TSB_on(
                        this: &Tool_Class,
                        param: JsValue,
                    ) -> std::result::Result<Tool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = remove , method , js_class = "Tool" , catch)]
                    fn __TSB_remove(this: &Tool_Class) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = responds , method , js_class = "Tool" , catch)]
                    fn __TSB_responds(
                        this: &Tool_Class,
                        type_: String,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onKeyDown , js_class = "Tool")]
                    fn __TSB_on_key_down(
                        this: &Tool_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onKeyDown , js_class = "Tool")]
                    fn __TSB_set_on_key_down(
                        this: &Tool_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = maxDistance , js_class = "Tool")]
                    fn max_distance(this: &Tool_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = maxDistance , js_class = "Tool")]
                    fn set_max_distance(
                        this: &Tool_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = activate , method , js_class = "Tool" , catch)]
                    fn __TSB_activate(this: &Tool_Class) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = fixedDistance , js_class = "Tool")]
                    fn fixed_distance(this: &Tool_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = fixedDistance , js_class = "Tool")]
                    fn set_fixed_distance(
                        this: &Tool_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseUp , js_class = "Tool")]
                    fn __TSB_on_mouse_up(
                        this: &Tool_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseUp , js_class = "Tool")]
                    fn __TSB_set_on_mouse_up(
                        this: &Tool_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onKeyUp , js_class = "Tool")]
                    fn __TSB_on_key_up(this: &Tool_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onKeyUp , js_class = "Tool")]
                    fn __TSB_set_on_key_up(
                        this: &Tool_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseDrag , js_class = "Tool")]
                    fn __TSB_on_mouse_drag(
                        this: &Tool_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseDrag , js_class = "Tool")]
                    fn __TSB_set_on_mouse_drag(
                        this: &Tool_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseMove , js_class = "Tool")]
                    fn __TSB_on_mouse_move(
                        this: &Tool_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseMove , js_class = "Tool")]
                    fn __TSB_set_on_mouse_move(
                        this: &Tool_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = emit , method , js_class = "Tool" , catch)]
                    fn __TSB_emit(
                        this: &Tool_Class,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = minDistance , js_class = "Tool")]
                    fn min_distance(this: &Tool_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = minDistance , js_class = "Tool")]
                    fn set_min_distance(
                        this: &Tool_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Tool(pub Tool_Class);
                impl Tool {
                    #[allow(dead_code)]
                    pub fn off(&self, param: JsValue) -> std::result::Result<Tool, JsValue> {
                        let result = self.0.__TSB_off(param);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn on_mouse_down(&self) -> std::result::Result<ToolOnMouseDown, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_down()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_on_mouse_down(
                        &self,
                        value: ToolOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_down(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn on(&self, param: JsValue) -> std::result::Result<Tool, JsValue> {
                        let result = self.0.__TSB_on(param);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn remove(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_remove();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_responds(type_);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn on_key_down(&self) -> std::result::Result<ToolOnKeyDown, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_key_down()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_on_key_down(
                        &self,
                        value: ToolOnKeyDown,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_key_down(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn max_distance(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.max_distance();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_max_distance(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_max_distance(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn activate(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_activate();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn fixed_distance(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.fixed_distance();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_fixed_distance(
                        &self,
                        value: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_fixed_distance(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn on_mouse_up(&self) -> std::result::Result<ToolOnMouseUp, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_up()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_on_mouse_up(
                        &self,
                        value: ToolOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_up(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn on_key_up(&self) -> std::result::Result<ToolOnKeyUp, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_key_up()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_on_key_up(
                        &self,
                        value: ToolOnKeyUp,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_key_up(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn on_mouse_drag(&self) -> std::result::Result<ToolOnMouseDrag, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_drag()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_on_mouse_drag(
                        &self,
                        value: ToolOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_drag(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn on_mouse_move(&self) -> std::result::Result<ToolOnMouseMove, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_move()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_on_mouse_move(
                        &self,
                        value: ToolOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_move(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_emit(type_, event);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn min_distance(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.min_distance();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_min_distance(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_min_distance(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Tool {
                    fn describe() {
                        <Tool_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Tool {
                    type Abi = <Tool_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Tool {
                    type Abi = <Tool_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Tool(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Tool {
                    type Abi = <&'a Tool_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Tool {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Tool {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Tool_Class =
                            <Tool_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait Tool_Trait {
                    fn off(&self, param: JsValue) -> std::result::Result<Tool, JsValue>;
                    fn set_on_mouse_down(
                        &mut self,
                        value: ToolOnMouseDown,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_down(&self) -> std::result::Result<ToolOnMouseDown, JsValue>;
                    fn on(&self, param: JsValue) -> std::result::Result<Tool, JsValue>;
                    fn remove(&self) -> std::result::Result<(), JsValue>;
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue>;
                    fn set_on_key_down(
                        &mut self,
                        value: ToolOnKeyDown,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_key_down(&self) -> std::result::Result<ToolOnKeyDown, JsValue>;
                    fn set_max_distance(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn max_distance(&self) -> std::result::Result<f64, JsValue>;
                    fn activate(&self) -> std::result::Result<(), JsValue>;
                    fn set_fixed_distance(
                        &mut self,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    fn fixed_distance(&self) -> std::result::Result<f64, JsValue>;
                    fn set_on_mouse_up(
                        &mut self,
                        value: ToolOnMouseUp,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_up(&self) -> std::result::Result<ToolOnMouseUp, JsValue>;
                    fn set_on_key_up(
                        &mut self,
                        value: ToolOnKeyUp,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_key_up(&self) -> std::result::Result<ToolOnKeyUp, JsValue>;
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ToolOnMouseDrag,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_drag(&self) -> std::result::Result<ToolOnMouseDrag, JsValue>;
                    fn set_on_mouse_move(
                        &mut self,
                        value: ToolOnMouseMove,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_move(&self) -> std::result::Result<ToolOnMouseMove, JsValue>;
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue>;
                    fn set_min_distance(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn min_distance(&self) -> std::result::Result<f64, JsValue>;
                }
                impl Tool_Trait for Tool {
                    fn off(&self, param: JsValue) -> std::result::Result<Tool, JsValue> {
                        let target = self;
                        Tool::off(&target, param)
                    }
                    fn set_on_mouse_down(
                        &mut self,
                        value: ToolOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Tool::set_on_mouse_down(&mut target, value)
                    }
                    fn on_mouse_down(&self) -> std::result::Result<ToolOnMouseDown, JsValue> {
                        let target = self;
                        Tool::on_mouse_down(&target)
                    }
                    fn on(&self, param: JsValue) -> std::result::Result<Tool, JsValue> {
                        let target = self;
                        Tool::on(&target, param)
                    }
                    fn remove(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Tool::remove(&target)
                    }
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Tool::responds(&target, type_)
                    }
                    fn set_on_key_down(
                        &mut self,
                        value: ToolOnKeyDown,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Tool::set_on_key_down(&mut target, value)
                    }
                    fn on_key_down(&self) -> std::result::Result<ToolOnKeyDown, JsValue> {
                        let target = self;
                        Tool::on_key_down(&target)
                    }
                    fn set_max_distance(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Tool::set_max_distance(&mut target, value)
                    }
                    fn max_distance(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Tool::max_distance(&target)
                    }
                    fn activate(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Tool::activate(&target)
                    }
                    fn set_fixed_distance(
                        &mut self,
                        value: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Tool::set_fixed_distance(&mut target, value)
                    }
                    fn fixed_distance(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Tool::fixed_distance(&target)
                    }
                    fn set_on_mouse_up(
                        &mut self,
                        value: ToolOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Tool::set_on_mouse_up(&mut target, value)
                    }
                    fn on_mouse_up(&self) -> std::result::Result<ToolOnMouseUp, JsValue> {
                        let target = self;
                        Tool::on_mouse_up(&target)
                    }
                    fn set_on_key_up(
                        &mut self,
                        value: ToolOnKeyUp,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Tool::set_on_key_up(&mut target, value)
                    }
                    fn on_key_up(&self) -> std::result::Result<ToolOnKeyUp, JsValue> {
                        let target = self;
                        Tool::on_key_up(&target)
                    }
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ToolOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Tool::set_on_mouse_drag(&mut target, value)
                    }
                    fn on_mouse_drag(&self) -> std::result::Result<ToolOnMouseDrag, JsValue> {
                        let target = self;
                        Tool::on_mouse_drag(&target)
                    }
                    fn set_on_mouse_move(
                        &mut self,
                        value: ToolOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Tool::set_on_mouse_move(&mut target, value)
                    }
                    fn on_mouse_move(&self) -> std::result::Result<ToolOnMouseMove, JsValue> {
                        let target = self;
                        Tool::on_mouse_move(&target)
                    }
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Tool::emit(&target, type_, event)
                    }
                    fn set_min_distance(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Tool::set_min_distance(&mut target, value)
                    }
                    fn min_distance(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Tool::min_distance(&target)
                    }
                }
                impl std::clone::Clone for Tool_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Tool_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Tool_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemTweenToParamsOptionsParam {
                    F64Case(f64),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    JsValueCase(JsValue),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ProjectGetItemParamsOptionsParam {
                    #[serde(
                        serialize_with = "ProjectGetItemParamsOptionsParam::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "ProjectGetItemParamsOptionsParam::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    JsValueCase(JsValue),
                }
                impl ProjectGetItemParamsOptionsParam {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum TextItemFontSize {
                    StringCase(String),
                    F64Case(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemGetItemsParamsOptionsParam {
                    #[serde(
                        serialize_with = "ItemGetItemsParamsOptionsParam::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "ItemGetItemsParamsOptionsParam::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    JsValueCase(JsValue),
                }
                impl ItemGetItemsParamsOptionsParam {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum RasterOnLoad {
                    TsBindgenRtNullCase,
                    #[serde(
                        serialize_with = "RasterOnLoad::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "RasterOnLoad::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                }
                impl RasterOnLoad {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum StyleFillColor {
                    ColorCase(Color),
                    TsBindgenRtNullCase,
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[wasm_bindgen(js_name = "GradientStop")]
                    pub type GradientStop_Class;
                    # [wasm_bindgen (method , structural , catch , getter = color , js_class = "GradientStop")]
                    fn color(this: &GradientStop_Class) -> std::result::Result<Color, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = color , js_class = "GradientStop")]
                    fn set_color(
                        this: &GradientStop_Class,
                        value: Color,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clone , method , js_class = "GradientStop" , catch)]
                    fn __TSB_clone(
                        this: &GradientStop_Class,
                    ) -> std::result::Result<GradientStop, JsValue>;
                    #[wasm_bindgen(constructor, js_class = "GradientStop")]
                    pub fn new(color: Color, offset: f64) -> GradientStop_Class;
                    # [wasm_bindgen (method , structural , catch , getter = offset , js_class = "GradientStop")]
                    fn offset(this: &GradientStop_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = offset , js_class = "GradientStop")]
                    fn set_offset(
                        this: &GradientStop_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct GradientStop(pub GradientStop_Class);
                impl GradientStop {
                    #[allow(dead_code)]
                    pub fn color(&self) -> std::result::Result<Color, JsValue> {
                        let result = self.0.color();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_color(&self, value: Color) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_color(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn clone(&self) -> std::result::Result<GradientStop, JsValue> {
                        let result = self.0.__TSB_clone();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn new(color: Color, offset: f64) -> GradientStop {
                        let result = GradientStop_Class::new(color, offset);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        GradientStop(result)
                    }
                    #[allow(dead_code)]
                    pub fn offset(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.offset();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_offset(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_offset(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for GradientStop {
                    fn describe() {
                        <GradientStop_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for GradientStop {
                    type Abi = <GradientStop_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for GradientStop {
                    type Abi = <GradientStop_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        GradientStop(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a GradientStop {
                    type Abi = <&'a GradientStop_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for GradientStop {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for GradientStop {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: GradientStop_Class =
                            <GradientStop_Class as serde::de::Deserialize>::deserialize(
                                deserializer,
                            )?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait GradientStop_Trait {
                    fn set_color(&mut self, value: Color) -> std::result::Result<(), JsValue>;
                    fn color(&self) -> std::result::Result<Color, JsValue>;
                    fn clone(&self) -> std::result::Result<GradientStop, JsValue>;
                    fn set_offset(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn offset(&self) -> std::result::Result<f64, JsValue>;
                }
                impl GradientStop_Trait for GradientStop {
                    fn set_color(&mut self, value: Color) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        GradientStop::set_color(&mut target, value)
                    }
                    fn color(&self) -> std::result::Result<Color, JsValue> {
                        let target = self;
                        GradientStop::color(&target)
                    }
                    fn clone(&self) -> std::result::Result<GradientStop, JsValue> {
                        let target = self;
                        GradientStop::clone(&target)
                    }
                    fn set_offset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        GradientStop::set_offset(&mut target, value)
                    }
                    fn offset(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        GradientStop::offset(&target)
                    }
                }
                impl std::clone::Clone for GradientStop_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for GradientStop_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for GradientStop_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum TweenOnUpdate {
                    TsBindgenRtNullCase,
                    #[serde(
                        serialize_with = "TweenOnUpdate::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "TweenOnUpdate::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                }
                impl TweenOnUpdate {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewOnMouseDrag {
                    TsBindgenRtNullCase,
                    #[serde(
                        serialize_with = "ViewOnMouseDrag::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "ViewOnMouseDrag::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                }
                impl ViewOnMouseDrag {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PathInsertParamsSegmentParam {
                    PointCase(Point),
                    SegmentCase(Segment),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum StyleShadowColor {
                    ColorCase(Color),
                    TsBindgenRtNullCase,
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ToolOnMouseMove {
                    TsBindgenRtNullCase,
                    #[serde(
                        serialize_with = "ToolOnMouseMove::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "ToolOnMouseMove::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                }
                impl ToolOnMouseMove {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemStrokeColor {
                    ColorCase(Color),
                    TsBindgenRtNullCase,
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemTweenFromParamsOptionsParam {
                    F64Case(f64),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    JsValueCase(JsValue),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemImportSvgParamsSvgParam {
                    StringCase(String),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    WebSysSvgElementCase(web_sys::SvgElement),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ProjectImportSvgParamsSvgParam {
                    StringCase(String),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    WebSysSvgElementCase(web_sys::SvgElement),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum SymbolItemConstructorDefinitionParam {
                    ItemCase(Item),
                    SymbolDefinitionCase(SymbolDefinition),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ToolOnMouseDrag {
                    TsBindgenRtNullCase,
                    #[serde(
                        serialize_with = "ToolOnMouseDrag::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "ToolOnMouseDrag::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                }
                impl ToolOnMouseDrag {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemOnMouseMove {
                    TsBindgenRtNullCase,
                    #[serde(
                        serialize_with = "ItemOnMouseMove::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "ItemOnMouseMove::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                }
                impl ItemOnMouseMove {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    # [wasm_bindgen (js_name = "Group" , extends = Item_Class)]
                    pub type Group_Class;
                    # [wasm_bindgen (method , structural , catch , getter = clipped , js_class = "Group")]
                    fn clipped(this: &Group_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = clipped , js_class = "Group")]
                    fn set_clipped(
                        this: &Group_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    #[wasm_bindgen(constructor, js_class = "Group")]
                    pub fn new(object: JsValue) -> Group_Class;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Group(pub Group_Class);
                impl std::convert::From<&Group> for Item {
                    fn from(src: &Group) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl std::convert::From<&mut Group> for Item {
                    fn from(src: &mut Group) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl Group {
                    #[allow(dead_code)]
                    pub fn clipped(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.clipped();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_clipped(&self, value: bool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_clipped(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn new(object: JsValue) -> Group {
                        let result = Group_Class::new(object);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Group(result)
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Group {
                    fn describe() {
                        <Group_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Group {
                    type Abi = <Group_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Group {
                    type Abi = <Group_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Group(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Group {
                    type Abi = <&'a Group_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Group {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Group {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Group_Class =
                            <Group_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait Group_Trait: Item_Trait {
                    fn set_clipped(&mut self, value: bool) -> std::result::Result<(), JsValue>;
                    fn clipped(&self) -> std::result::Result<bool, JsValue>;
                }
                impl Item_Trait for Group {
                    fn set_stroke_scaling(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_scaling(&mut target, value)
                    }
                    fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_scaling(&target)
                    }
                    fn set_apply_matrix(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_apply_matrix(&mut target, value)
                    }
                    fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::apply_matrix(&target)
                    }
                    fn set_view_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_view_matrix(&mut target, value)
                    }
                    fn view_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::view_matrix(&target)
                    }
                    fn set_dash_array(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_dash_array(&mut target, value)
                    }
                    fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let target: Item = self.into();
                        Item::dash_array(&target)
                    }
                    fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_ancestor(&target, item)
                    }
                    fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_descendant(&target, item)
                    }
                    fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_sibling(&target, item)
                    }
                    fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_parent(&target, point)
                    }
                    fn set_shadow_blur(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_shadow_blur(&mut target, value)
                    }
                    fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_blur(&target)
                    }
                    fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_empty(&target, recursively)
                    }
                    fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_parent(&target, item)
                    }
                    fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_below(&target, item)
                    }
                    fn set_matrix(&mut self, value: Matrix) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_matrix(&mut target, value)
                    }
                    fn matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::matrix(&target)
                    }
                    fn export_json(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::export_json(&target, options)
                    }
                    fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::global_to_local(&target, point)
                    }
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ItemOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_drag(&mut target, value)
                    }
                    fn on_mouse_drag(&self) -> std::result::Result<ItemOnMouseDrag, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_drag(&target)
                    }
                    fn get_item(
                        &self,
                        options: ItemGetItemParamsOptionsParam,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::get_item(&target, options)
                    }
                    fn remove_children(
                        &self,
                        start: f64,
                        end: f64,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::remove_children(&target, start, end)
                    }
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_project(&mut target, value)
                    }
                    fn project(&self) -> std::result::Result<Project, JsValue> {
                        let target: Item = self.into();
                        Item::project(&target)
                    }
                    fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_data(&mut target, value)
                    }
                    fn data(&self) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::data(&target)
                    }
                    fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_above(&target, item)
                    }
                    fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on(&target, options)
                    }
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::transform(&target, matrix)
                    }
                    fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inserted(&target)
                    }
                    fn set_on_mouse_down(
                        &mut self,
                        value: ItemOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_down(&mut target, value)
                    }
                    fn on_mouse_down(&self) -> std::result::Result<ItemOnMouseDown, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_down(&target)
                    }
                    fn set_last_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_last_child(&mut target, value)
                    }
                    fn last_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::last_child(&target)
                    }
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_selected(&mut target, value)
                    }
                    fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::selected(&target)
                    }
                    fn set_global_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_global_matrix(&mut target, value)
                    }
                    fn global_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::global_matrix(&target)
                    }
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::responds(&target, type_)
                    }
                    fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::rotate(&target, angle, center)
                    }
                    fn tween(
                        &self,
                        options: ItemTweenParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween(&target, options)
                    }
                    fn set_on_mouse_enter(
                        &mut self,
                        value: ItemOnMouseEnter,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_enter(&mut target, value)
                    }
                    fn on_mouse_enter(&self) -> std::result::Result<ItemOnMouseEnter, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_enter(&target)
                    }
                    fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_id(&mut target, value)
                    }
                    fn id(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::id(&target)
                    }
                    fn on(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::on(&target, object)
                    }
                    fn tween_to(
                        &self,
                        to: JsValue,
                        options: ItemTweenToParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_to(&target, to, options)
                    }
                    fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_locked(&mut target, value)
                    }
                    fn locked(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::locked(&target)
                    }
                    fn set_children(
                        &mut self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_children(&mut target, value)
                    }
                    fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::children(&target)
                    }
                    fn copy_attributes(
                        &self,
                        source: Item,
                        exclude_matrix: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_attributes(&target, source, exclude_matrix)
                    }
                    fn off(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::off(&target, object)
                    }
                    fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::contains(&target, point)
                    }
                    fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_stroke(&target)
                    }
                    fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_move(&target)
                    }
                    fn add_children(
                        &self,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::add_children(&target, items)
                    }
                    fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::reverse_children(&target)
                    }
                    fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_shadow(&target)
                    }
                    fn set_dash_offset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_dash_offset(&mut target, value)
                    }
                    fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::dash_offset(&target)
                    }
                    fn set_on_mouse_leave(
                        &mut self,
                        value: ItemOnMouseLeave,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_leave(&mut target, value)
                    }
                    fn on_mouse_leave(&self) -> std::result::Result<ItemOnMouseLeave, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_leave(&target)
                    }
                    fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test_all(&target, point, options)
                    }
                    fn set_stroke_cap(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_cap(&mut target, value)
                    }
                    fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_cap(&target)
                    }
                    fn set_internal_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_internal_bounds(&mut target, value)
                    }
                    fn internal_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::internal_bounds(&target)
                    }
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_index(&mut target, value)
                    }
                    fn index(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::index(&target)
                    }
                    fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::reduce(&target, options)
                    }
                    fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_grouped_with(&target, item)
                    }
                    fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_global(&target, point)
                    }
                    fn set_first_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_first_child(&mut target, value)
                    }
                    fn first_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::first_child(&target)
                    }
                    fn set_position(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_position(&mut target, value)
                    }
                    fn position(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::position(&target)
                    }
                    fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_opacity(&mut target, value)
                    }
                    fn opacity(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::opacity(&target)
                    }
                    fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_down(&target)
                    }
                    fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_drag(&target)
                    }
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_bounds(&mut target, value)
                    }
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::bounds(&target)
                    }
                    fn set_parent(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_parent(&mut target, value)
                    }
                    fn parent(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::parent(&target)
                    }
                    fn get_items(
                        &self,
                        options: ItemGetItemsParamsOptionsParam,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::get_items(&target, options)
                    }
                    fn copy_to(
                        &self,
                        owner: ItemCopyToParamsOwnerParam,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::copy_to(&target, owner)
                    }
                    fn set_on_double_click(
                        &mut self,
                        value: ItemOnDoubleClick,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_double_click(&mut target, value)
                    }
                    fn on_double_click(&self) -> std::result::Result<ItemOnDoubleClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_double_click(&target)
                    }
                    fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::set(&target, props)
                    }
                    fn scale(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::scale(&target, hor, ver, center)
                    }
                    fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_below(&target, item)
                    }
                    fn set_next_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_next_sibling(&mut target, value)
                    }
                    fn next_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::next_sibling(&target)
                    }
                    fn rasterize(&self, options: JsValue) -> std::result::Result<Raster, JsValue> {
                        let target: Item = self.into();
                        Item::rasterize(&target, options)
                    }
                    fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::bring_to_front(&target)
                    }
                    fn matches(
                        &self,
                        name: String,
                        compare: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::matches(&target, name, compare)
                    }
                    fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_fill(&target)
                    }
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_view(&mut target, value)
                    }
                    fn view(&self) -> std::result::Result<View, JsValue> {
                        let target: Item = self.into();
                        Item::view(&target)
                    }
                    fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::clone(&target, options)
                    }
                    fn set_handle_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_handle_bounds(&mut target, value)
                    }
                    fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::handle_bounds(&target)
                    }
                    fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inside(&target, rect)
                    }
                    fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_above(&target, item)
                    }
                    fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::remove(&target)
                    }
                    fn set_stroke_join(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_join(&mut target, value)
                    }
                    fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_join(&target)
                    }
                    fn set_on_click(
                        &mut self,
                        value: ItemOnClick,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_click(&mut target, value)
                    }
                    fn on_click(&self) -> std::result::Result<ItemOnClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_click(&target)
                    }
                    fn fit_bounds(
                        &self,
                        rectangle: Rectangle,
                        fill: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::fit_bounds(&target, rectangle, fill)
                    }
                    fn set_blend_mode(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_blend_mode(&mut target, value)
                    }
                    fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::blend_mode(&target)
                    }
                    fn set_stroke_width(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_width(&mut target, value)
                    }
                    fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_width(&target)
                    }
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_rotation(&mut target, value)
                    }
                    fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::rotation(&target)
                    }
                    fn set_selected_color(
                        &mut self,
                        value: ItemSelectedColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_selected_color(&mut target, value)
                    }
                    fn selected_color(&self) -> std::result::Result<ItemSelectedColor, JsValue> {
                        let target: Item = self.into();
                        Item::selected_color(&target)
                    }
                    fn skew(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::skew(&target, hor, ver, center)
                    }
                    fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_name(&mut target, value)
                    }
                    fn name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::name(&target)
                    }
                    fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_json(&target, json)
                    }
                    fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::add_child(&target, item)
                    }
                    fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_visible(&mut target, value)
                    }
                    fn visible(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::visible(&target)
                    }
                    fn set_fill_rule(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_fill_rule(&mut target, value)
                    }
                    fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::fill_rule(&target)
                    }
                    fn set_layer(&mut self, value: Layer) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_layer(&mut target, value)
                    }
                    fn layer(&self) -> std::result::Result<Layer, JsValue> {
                        let target: Item = self.into();
                        Item::layer(&target)
                    }
                    fn tween_from(
                        &self,
                        from: JsValue,
                        options: ItemTweenFromParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_from(&target, from, options)
                    }
                    fn insert_child(
                        &self,
                        index: f64,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_child(&target, index, item)
                    }
                    fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_up(&target)
                    }
                    fn set_pivot(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_pivot(&mut target, value)
                    }
                    fn pivot(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::pivot(&target)
                    }
                    fn set_miter_limit(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_miter_limit(&mut target, value)
                    }
                    fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::miter_limit(&target)
                    }
                    fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_content(&target, source)
                    }
                    fn import_svg(
                        &self,
                        svg: ItemImportSvgParamsSvgParam,
                        on_load: &'static dyn Fn(
                            Box<[JsValue]>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_svg(&target, svg, on_load)
                    }
                    fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::send_to_back(&target)
                    }
                    fn set_stroke_color(
                        &mut self,
                        value: ItemStrokeColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_color(&mut target, value)
                    }
                    fn stroke_color(&self) -> std::result::Result<ItemStrokeColor, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_color(&target)
                    }
                    fn set_on_mouse_move(
                        &mut self,
                        value: ItemOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_move(&mut target, value)
                    }
                    fn on_mouse_move(&self) -> std::result::Result<ItemOnMouseMove, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_move(&target)
                    }
                    fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::replace_with(&target, item)
                    }
                    fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test(&target, point, options)
                    }
                    fn shear(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::shear(&target, hor, ver, center)
                    }
                    fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::translate(&target, delta)
                    }
                    fn set_stroke_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_bounds(&mut target, value)
                    }
                    fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_bounds(&target)
                    }
                    fn insert_children(
                        &self,
                        index: f64,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::insert_children(&target, index, items)
                    }
                    fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_child(&target, item)
                    }
                    fn set_shadow_offset(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_shadow_offset(&mut target, value)
                    }
                    fn shadow_offset(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_offset(&target)
                    }
                    fn set_fill_color(
                        &mut self,
                        value: ItemFillColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_fill_color(&mut target, value)
                    }
                    fn fill_color(&self) -> std::result::Result<ItemFillColor, JsValue> {
                        let target: Item = self.into();
                        Item::fill_color(&target)
                    }
                    fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                        let target: Item = self.into();
                        Item::export_svg(&target, options)
                    }
                    fn set_style(&mut self, value: Style) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_style(&mut target, value)
                    }
                    fn style(&self) -> std::result::Result<Style, JsValue> {
                        let target: Item = self.into();
                        Item::style(&target)
                    }
                    fn set_clip_mask(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_clip_mask(&mut target, value)
                    }
                    fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::clip_mask(&target)
                    }
                    fn set_class_name(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_class_name(&mut target, value)
                    }
                    fn class_name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::class_name(&target)
                    }
                    fn set_on_mouse_up(
                        &mut self,
                        value: ItemOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_up(&mut target, value)
                    }
                    fn on_mouse_up(&self) -> std::result::Result<ItemOnMouseUp, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_up(&target)
                    }
                    fn set_on_frame(
                        &mut self,
                        value: ItemOnFrame,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_frame(&mut target, value)
                    }
                    fn on_frame(&self) -> std::result::Result<ItemOnFrame, JsValue> {
                        let target: Item = self.into();
                        Item::on_frame(&target)
                    }
                    fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::parent_to_local(&target, point)
                    }
                    fn set_previous_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_previous_sibling(&mut target, value)
                    }
                    fn previous_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::previous_sibling(&target)
                    }
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::emit(&target, type_, event)
                    }
                    fn add_to(
                        &self,
                        owner: ItemAddToParamsOwnerParam,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::add_to(&target, owner)
                    }
                    fn has_children(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_children(&target)
                    }
                    fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::intersects(&target, item)
                    }
                    fn set_shadow_color(
                        &mut self,
                        value: ItemShadowColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_shadow_color(&mut target, value)
                    }
                    fn shadow_color(&self) -> std::result::Result<ItemShadowColor, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_color(&target)
                    }
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_scaling(&mut target, value)
                    }
                    fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::scaling(&target)
                    }
                }
                impl Group_Trait for Group
                where
                    Group: Item_Trait,
                {
                    fn set_clipped(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Group::set_clipped(&mut target, value)
                    }
                    fn clipped(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Group::clipped(&target)
                    }
                }
                impl std::clone::Clone for Group_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Group_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Group_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum StyleFontSize {
                    StringCase(String),
                    F64Case(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum TweenConstructorEasingParam {
                    #[serde(
                        serialize_with = "TweenConstructorEasingParam::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "TweenConstructorEasingParam::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                    StringCase(String),
                }
                impl TweenConstructorEasingParam {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum HitResultColor {
                    ColorCase(Color),
                    TsBindgenRtNullCase,
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    # [wasm_bindgen (js_name = "Path" , extends = PathItem_Class , extends = Item_Class)]
                    pub type Path_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = reduce , method , js_class = "Path" , catch)]
                    fn __TSB_reduce(
                        this: &Path_Class,
                        options: JsValue,
                    ) -> std::result::Result<Path, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getCurvatureAt , method , js_class = "Path" , catch)]
                    fn __TSB_get_curvature_at(
                        this: &Path_Class,
                        offset: f64,
                    ) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = lastCurve , js_class = "Path")]
                    fn last_curve(this: &Path_Class) -> std::result::Result<Curve, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = lastCurve , js_class = "Path")]
                    fn set_last_curve(
                        this: &Path_Class,
                        value: Curve,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = splitAt , method , js_class = "Path" , catch)]
                    fn __TSB_split_at(
                        this: &Path_Class,
                        location: JsValue,
                    ) -> std::result::Result<Path, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = area , js_class = "Path")]
                    fn area(this: &Path_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = area , js_class = "Path")]
                    fn set_area(this: &Path_Class, value: f64) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = divideAt , method , js_class = "Path" , catch)]
                    fn __TSB_divide_at(
                        this: &Path_Class,
                        location: JsValue,
                    ) -> std::result::Result<Segment, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getOffsetsWithTangent , method , js_class = "Path" , catch)]
                    fn __TSB_get_offsets_with_tangent(
                        this: &Path_Class,
                        tangent: Point,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = firstSegment , js_class = "Path")]
                    fn first_segment(this: &Path_Class) -> std::result::Result<Segment, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = firstSegment , js_class = "Path")]
                    fn set_first_segment(
                        this: &Path_Class,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = firstCurve , js_class = "Path")]
                    fn first_curve(this: &Path_Class) -> std::result::Result<Curve, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = firstCurve , js_class = "Path")]
                    fn set_first_curve(
                        this: &Path_Class,
                        value: Curve,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = hasHandles , method , js_class = "Path" , catch)]
                    fn __TSB_has_handles(this: &Path_Class) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getNormalAt , method , js_class = "Path" , catch)]
                    fn __TSB_get_normal_at(
                        this: &Path_Class,
                        offset: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = lastSegment , js_class = "Path")]
                    fn last_segment(this: &Path_Class) -> std::result::Result<Segment, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = lastSegment , js_class = "Path")]
                    fn set_last_segment(
                        this: &Path_Class,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getTangentAt , method , js_class = "Path" , catch)]
                    fn __TSB_get_tangent_at(
                        this: &Path_Class,
                        offset: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getWeightedTangentAt , method , js_class = "Path" , catch)]
                    fn __TSB_get_weighted_tangent_at(
                        this: &Path_Class,
                        offset: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getOffsetOf , method , js_class = "Path" , catch)]
                    fn __TSB_get_offset_of(
                        this: &Path_Class,
                        point: Point,
                    ) -> std::result::Result<f64, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = insert , method , js_class = "Path" , catch)]
                    fn __TSB_insert(
                        this: &Path_Class,
                        index: f64,
                        segment: JsValue,
                    ) -> std::result::Result<Segment, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = insertSegments , method , js_class = "Path" , catch)]
                    fn __TSB_insert_segments(
                        this: &Path_Class,
                        index: f64,
                        segments: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getLocationOf , method , js_class = "Path" , catch)]
                    fn __TSB_get_location_of(
                        this: &Path_Class,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    #[wasm_bindgen(constructor, js_class = "Path")]
                    pub fn new(object: JsValue) -> Path_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getWeightedNormalAt , method , js_class = "Path" , catch)]
                    fn __TSB_get_weighted_normal_at(
                        this: &Path_Class,
                        offset: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = closed , js_class = "Path")]
                    fn closed(this: &Path_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = closed , js_class = "Path")]
                    fn set_closed(
                        this: &Path_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = add , method , js_class = "Path" , catch , variadic)]
                    fn __TSB_add(
                        this: &Path_Class,
                        segment: Box<[JsValue]>,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = length , js_class = "Path")]
                    fn length(this: &Path_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = length , js_class = "Path")]
                    fn set_length(
                        this: &Path_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = toShape , method , js_class = "Path" , catch)]
                    fn __TSB_to_shape(
                        this: &Path_Class,
                        insert: bool,
                    ) -> std::result::Result<Shape, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getLocationAt , method , js_class = "Path" , catch)]
                    fn __TSB_get_location_at(
                        this: &Path_Class,
                        offset: f64,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clearHandles , method , js_class = "Path" , catch)]
                    fn __TSB_clear_handles(this: &Path_Class) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = removeSegment , method , js_class = "Path" , catch)]
                    fn __TSB_remove_segment(
                        this: &Path_Class,
                        index: f64,
                    ) -> std::result::Result<Segment, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = segments , js_class = "Path")]
                    fn __TSB_segments(this: &Path_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = segments , js_class = "Path")]
                    fn __TSB_set_segments(
                        this: &Path_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = removeSegments , method , js_class = "Path" , catch)]
                    fn __TSB_remove_segments(
                        this: &Path_Class,
                        from: f64,
                        to: f64,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getPointAt , method , js_class = "Path" , catch)]
                    fn __TSB_get_point_at(
                        this: &Path_Class,
                        offset: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = addSegments , method , js_class = "Path" , catch)]
                    fn __TSB_add_segments(
                        this: &Path_Class,
                        segments: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = join , method , js_class = "Path" , catch)]
                    fn __TSB_join(
                        this: &Path_Class,
                        path: Path,
                        tolerance: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = curves , js_class = "Path")]
                    fn __TSB_curves(this: &Path_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = curves , js_class = "Path")]
                    fn __TSB_set_curves(
                        this: &Path_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = fullySelected , js_class = "Path")]
                    fn fully_selected(this: &Path_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = fullySelected , js_class = "Path")]
                    fn set_fully_selected(
                        this: &Path_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Path(pub Path_Class);
                impl std::convert::From<&Path> for Item {
                    fn from(src: &Path) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl std::convert::From<&mut Path> for Item {
                    fn from(src: &mut Path) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl std::convert::From<&Path> for PathItem {
                    fn from(src: &Path) -> PathItem {
                        let src: &PathItem_Class = src.0.as_ref();
                        PathItem(src.clone())
                    }
                }
                impl std::convert::From<&mut Path> for PathItem {
                    fn from(src: &mut Path) -> PathItem {
                        let src: &PathItem_Class = src.0.as_ref();
                        PathItem(src.clone())
                    }
                }
                impl Path {
                    #[allow(dead_code)]
                    pub fn reduce(&self, options: JsValue) -> std::result::Result<Path, JsValue> {
                        let result = self.0.__TSB_reduce(options);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_curvature_at(
                        &self,
                        offset: f64,
                    ) -> std::result::Result<f64, JsValue> {
                        let result = self.0.__TSB_get_curvature_at(offset);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn last_curve(&self) -> std::result::Result<Curve, JsValue> {
                        let result = self.0.last_curve();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_last_curve(&self, value: Curve) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_last_curve(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn split_at(
                        &self,
                        location: PathSplitAtParamsLocationParam,
                    ) -> std::result::Result<Path, JsValue> {
                        let result = self.0.__TSB_split_at(
                            ts_bindgen_rt::to_jsvalue(&location)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn area(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.area();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_area(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_area(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn divide_at(
                        &self,
                        location: PathDivideAtParamsLocationParam,
                    ) -> std::result::Result<Segment, JsValue> {
                        let result = self.0.__TSB_divide_at(
                            ts_bindgen_rt::to_jsvalue(&location)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_offsets_with_tangent(
                        &self,
                        tangent: Point,
                    ) -> std::result::Result<Vec<f64>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self.0.__TSB_get_offsets_with_tangent(tangent)?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn first_segment(&self) -> std::result::Result<Segment, JsValue> {
                        let result = self.0.first_segment();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_first_segment(
                        &self,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_first_segment(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn first_curve(&self) -> std::result::Result<Curve, JsValue> {
                        let result = self.0.first_curve();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_first_curve(
                        &self,
                        value: Curve,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_first_curve(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_has_handles();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_normal_at(
                        &self,
                        offset: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_get_normal_at(offset);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn last_segment(&self) -> std::result::Result<Segment, JsValue> {
                        let result = self.0.last_segment();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_last_segment(
                        &self,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_last_segment(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_tangent_at(
                        &self,
                        offset: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_get_tangent_at(offset);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_weighted_tangent_at(
                        &self,
                        offset: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_get_weighted_tangent_at(offset);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_offset_of(&self, point: Point) -> std::result::Result<f64, JsValue> {
                        let result = self.0.__TSB_get_offset_of(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn insert(
                        &self,
                        index: f64,
                        segment: PathInsertParamsSegmentParam,
                    ) -> std::result::Result<Segment, JsValue> {
                        let result = self.0.__TSB_insert(
                            index,
                            ts_bindgen_rt::to_jsvalue(&segment)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn insert_segments(
                        &self,
                        index: f64,
                        segments: Vec<Segment>,
                    ) -> std::result::Result<Vec<Segment>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self.0.__TSB_insert_segments(
                                index,
                                ts_bindgen_rt::to_jsvalue(&segments)
                                    .map_err(ts_bindgen_rt::Error::from)
                                    .map_err(JsValue::from)?,
                            )?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_location_of(
                        &self,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let result = self.0.__TSB_get_location_of(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn new(object: JsValue) -> Path {
                        let result = Path_Class::new(object);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Path(result)
                    }
                    #[allow(dead_code)]
                    pub fn get_weighted_normal_at(
                        &self,
                        offset: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_get_weighted_normal_at(offset);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn closed(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.closed();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_closed(&self, value: bool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_closed(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn add(
                        &self,
                        segment: Box<[PathAddParamsSegmentParam]>,
                    ) -> std::result::Result<PathAddReturn, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self.0.__TSB_add(
                                segment
                                    .into_iter()
                                    .map(|segment| {
                                        ts_bindgen_rt::to_jsvalue(&segment)
                                            .map_err(ts_bindgen_rt::Error::from)
                                            .map_err(JsValue::from)
                                    })
                                    .collect::<std::result::Result<Vec<_>, _>>()?
                                    .into_boxed_slice(),
                            )?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn length(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.length();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_length(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_length(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn to_shape(&self, insert: bool) -> std::result::Result<Shape, JsValue> {
                        let result = self.0.__TSB_to_shape(insert);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_location_at(
                        &self,
                        offset: f64,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let result = self.0.__TSB_get_location_at(offset);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_clear_handles();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn remove_segment(
                        &self,
                        index: f64,
                    ) -> std::result::Result<Segment, JsValue> {
                        let result = self.0.__TSB_remove_segment(index);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn segments(&self) -> std::result::Result<Vec<Segment>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_segments()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_segments(
                        &self,
                        value: Vec<Segment>,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_segments(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn remove_segments(
                        &self,
                        from: f64,
                        to: f64,
                    ) -> std::result::Result<Vec<Segment>, JsValue> {
                        let result =
                            ts_bindgen_rt::from_jsvalue(&self.0.__TSB_remove_segments(from, to)?)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_point_at(&self, offset: f64) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_get_point_at(offset);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn add_segments(
                        &self,
                        segments: Vec<Segment>,
                    ) -> std::result::Result<Vec<Segment>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self.0.__TSB_add_segments(
                                ts_bindgen_rt::to_jsvalue(&segments)
                                    .map_err(ts_bindgen_rt::Error::from)
                                    .map_err(JsValue::from)?,
                            )?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn join(
                        &self,
                        path: Path,
                        tolerance: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_join(path, tolerance);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn curves(&self) -> std::result::Result<Vec<Curve>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_curves()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_curves(
                        &self,
                        value: Vec<Curve>,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_curves(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn fully_selected(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.fully_selected();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_fully_selected(
                        &self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_fully_selected(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Path {
                    fn describe() {
                        <Path_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Path {
                    type Abi = <Path_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Path {
                    type Abi = <Path_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Path(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Path {
                    type Abi = <&'a Path_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Path {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Path {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Path_Class =
                            <Path_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait Path_Trait: PathItem_Trait {
                    fn reduce(&self, options: JsValue) -> std::result::Result<Path, JsValue>;
                    fn get_curvature_at(&self, offset: f64) -> std::result::Result<f64, JsValue>;
                    fn set_last_curve(&mut self, value: Curve) -> std::result::Result<(), JsValue>;
                    fn last_curve(&self) -> std::result::Result<Curve, JsValue>;
                    fn split_at(
                        &self,
                        location: PathSplitAtParamsLocationParam,
                    ) -> std::result::Result<Path, JsValue>;
                    fn set_area(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn area(&self) -> std::result::Result<f64, JsValue>;
                    fn divide_at(
                        &self,
                        location: PathDivideAtParamsLocationParam,
                    ) -> std::result::Result<Segment, JsValue>;
                    fn get_offsets_with_tangent(
                        &self,
                        tangent: Point,
                    ) -> std::result::Result<Vec<f64>, JsValue>;
                    fn set_first_segment(
                        &mut self,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue>;
                    fn first_segment(&self) -> std::result::Result<Segment, JsValue>;
                    fn set_first_curve(&mut self, value: Curve)
                        -> std::result::Result<(), JsValue>;
                    fn first_curve(&self) -> std::result::Result<Curve, JsValue>;
                    fn has_handles(&self) -> std::result::Result<bool, JsValue>;
                    fn get_normal_at(&self, offset: f64) -> std::result::Result<Point, JsValue>;
                    fn set_last_segment(
                        &mut self,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue>;
                    fn last_segment(&self) -> std::result::Result<Segment, JsValue>;
                    fn get_tangent_at(&self, offset: f64) -> std::result::Result<Point, JsValue>;
                    fn get_weighted_tangent_at(
                        &self,
                        offset: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    fn get_offset_of(&self, point: Point) -> std::result::Result<f64, JsValue>;
                    fn insert(
                        &self,
                        index: f64,
                        segment: PathInsertParamsSegmentParam,
                    ) -> std::result::Result<Segment, JsValue>;
                    fn insert_segments(
                        &self,
                        index: f64,
                        segments: Vec<Segment>,
                    ) -> std::result::Result<Vec<Segment>, JsValue>;
                    fn get_location_of(
                        &self,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    fn get_weighted_normal_at(
                        &self,
                        offset: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    fn set_closed(&mut self, value: bool) -> std::result::Result<(), JsValue>;
                    fn closed(&self) -> std::result::Result<bool, JsValue>;
                    fn add(
                        &self,
                        segment: Box<[PathAddParamsSegmentParam]>,
                    ) -> std::result::Result<PathAddReturn, JsValue>;
                    fn set_length(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn length(&self) -> std::result::Result<f64, JsValue>;
                    fn to_shape(&self, insert: bool) -> std::result::Result<Shape, JsValue>;
                    fn get_location_at(
                        &self,
                        offset: f64,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    fn clear_handles(&self) -> std::result::Result<(), JsValue>;
                    fn remove_segment(&self, index: f64) -> std::result::Result<Segment, JsValue>;
                    fn set_segments(
                        &mut self,
                        value: Vec<Segment>,
                    ) -> std::result::Result<(), JsValue>;
                    fn segments(&self) -> std::result::Result<Vec<Segment>, JsValue>;
                    fn remove_segments(
                        &self,
                        from: f64,
                        to: f64,
                    ) -> std::result::Result<Vec<Segment>, JsValue>;
                    fn get_point_at(&self, offset: f64) -> std::result::Result<Point, JsValue>;
                    fn add_segments(
                        &self,
                        segments: Vec<Segment>,
                    ) -> std::result::Result<Vec<Segment>, JsValue>;
                    fn join(&self, path: Path, tolerance: f64) -> std::result::Result<(), JsValue>;
                    fn set_curves(&mut self, value: Vec<Curve>)
                        -> std::result::Result<(), JsValue>;
                    fn curves(&self) -> std::result::Result<Vec<Curve>, JsValue>;
                    fn set_fully_selected(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    fn fully_selected(&self) -> std::result::Result<bool, JsValue>;
                }
                impl PathItem_Trait for Path
                where
                    Path: Item_Trait,
                {
                    fn reverse(&self) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::reverse(&target)
                    }
                    fn get_nearest_location(
                        &self,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::get_nearest_location(&target, point)
                    }
                    fn smooth(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::smooth(&target, options)
                    }
                    fn arc_to(
                        &self,
                        to: Point,
                        clockwise: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::arc_to(&target, to, clockwise)
                    }
                    fn line_to(&self, point: Point) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::line_to(&target, point)
                    }
                    fn cubic_curve_by(
                        &self,
                        handle1: Point,
                        handle2: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::cubic_curve_by(&target, handle1, handle2, to)
                    }
                    fn divide(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::divide(&target, path, options)
                    }
                    fn quadratic_curve_by(
                        &self,
                        handle: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::quadratic_curve_by(&target, handle, to)
                    }
                    fn create(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<PathItemCreateReturn, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::create(&target, object)
                    }
                    fn interpolate(
                        &self,
                        from: PathItem,
                        to: PathItem,
                        factor: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::interpolate(&target, from, to, factor)
                    }
                    fn set_clockwise(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: PathItem = self.into();
                        PathItem::set_clockwise(&mut target, value)
                    }
                    fn clockwise(&self) -> std::result::Result<bool, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::clockwise(&target)
                    }
                    fn set_path_data(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target: PathItem = self.into();
                        PathItem::set_path_data(&mut target, value)
                    }
                    fn path_data(&self) -> std::result::Result<String, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::path_data(&target)
                    }
                    fn curve_to(
                        &self,
                        through: Point,
                        to: Point,
                        time: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::curve_to(&target, through, to, time)
                    }
                    fn move_to(&self, point: Point) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::move_to(&target, point)
                    }
                    fn get_crossings(
                        &self,
                        path: PathItem,
                    ) -> std::result::Result<Vec<CurveLocation>, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::get_crossings(&target, path)
                    }
                    fn close_path(&self) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::close_path(&target)
                    }
                    fn reorient(
                        &self,
                        non_zero: bool,
                        clockwise: bool,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::reorient(&target, non_zero, clockwise)
                    }
                    fn move_by(&self, to: Point) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::move_by(&target, to)
                    }
                    fn quadratic_curve_to(
                        &self,
                        handle: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::quadratic_curve_to(&target, handle, to)
                    }
                    fn cubic_curve_to(
                        &self,
                        handle1: Point,
                        handle2: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::cubic_curve_to(&target, handle1, handle2, to)
                    }
                    fn get_intersections(
                        &self,
                        path: PathItem,
                        include: &'static dyn Fn(
                            Box<[JsValue]>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Vec<CurveLocation>, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::get_intersections(&target, path, include)
                    }
                    fn compare(&self, path: PathItem) -> std::result::Result<bool, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::compare(&target, path)
                    }
                    fn set_interior_point(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: PathItem = self.into();
                        PathItem::set_interior_point(&mut target, value)
                    }
                    fn interior_point(&self) -> std::result::Result<Point, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::interior_point(&target)
                    }
                    fn simplify(&self, tolerance: f64) -> std::result::Result<bool, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::simplify(&target, tolerance)
                    }
                    fn arc_by(
                        &self,
                        to: Point,
                        clockwise: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::arc_by(&target, to, clockwise)
                    }
                    fn intersect(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::intersect(&target, path, options)
                    }
                    fn get_nearest_point(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::get_nearest_point(&target, point)
                    }
                    fn curve_by(
                        &self,
                        through: Point,
                        to: Point,
                        time: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::curve_by(&target, through, to, time)
                    }
                    fn exclude(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::exclude(&target, path, options)
                    }
                    fn line_by(&self, point: Point) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::line_by(&target, point)
                    }
                    fn unite(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::unite(&target, path, options)
                    }
                    fn subtract(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::subtract(&target, path, options)
                    }
                    fn flatten(&self, flatness: f64) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::flatten(&target, flatness)
                    }
                }
                impl Item_Trait for Path {
                    fn set_stroke_scaling(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_scaling(&mut target, value)
                    }
                    fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_scaling(&target)
                    }
                    fn set_apply_matrix(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_apply_matrix(&mut target, value)
                    }
                    fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::apply_matrix(&target)
                    }
                    fn set_view_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_view_matrix(&mut target, value)
                    }
                    fn view_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::view_matrix(&target)
                    }
                    fn set_dash_array(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_dash_array(&mut target, value)
                    }
                    fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let target: Item = self.into();
                        Item::dash_array(&target)
                    }
                    fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_ancestor(&target, item)
                    }
                    fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_descendant(&target, item)
                    }
                    fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_sibling(&target, item)
                    }
                    fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_parent(&target, point)
                    }
                    fn set_shadow_blur(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_shadow_blur(&mut target, value)
                    }
                    fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_blur(&target)
                    }
                    fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_empty(&target, recursively)
                    }
                    fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_parent(&target, item)
                    }
                    fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_below(&target, item)
                    }
                    fn set_matrix(&mut self, value: Matrix) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_matrix(&mut target, value)
                    }
                    fn matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::matrix(&target)
                    }
                    fn export_json(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::export_json(&target, options)
                    }
                    fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::global_to_local(&target, point)
                    }
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ItemOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_drag(&mut target, value)
                    }
                    fn on_mouse_drag(&self) -> std::result::Result<ItemOnMouseDrag, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_drag(&target)
                    }
                    fn get_item(
                        &self,
                        options: ItemGetItemParamsOptionsParam,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::get_item(&target, options)
                    }
                    fn remove_children(
                        &self,
                        start: f64,
                        end: f64,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::remove_children(&target, start, end)
                    }
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_project(&mut target, value)
                    }
                    fn project(&self) -> std::result::Result<Project, JsValue> {
                        let target: Item = self.into();
                        Item::project(&target)
                    }
                    fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_data(&mut target, value)
                    }
                    fn data(&self) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::data(&target)
                    }
                    fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_above(&target, item)
                    }
                    fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on(&target, options)
                    }
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::transform(&target, matrix)
                    }
                    fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inserted(&target)
                    }
                    fn set_on_mouse_down(
                        &mut self,
                        value: ItemOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_down(&mut target, value)
                    }
                    fn on_mouse_down(&self) -> std::result::Result<ItemOnMouseDown, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_down(&target)
                    }
                    fn set_last_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_last_child(&mut target, value)
                    }
                    fn last_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::last_child(&target)
                    }
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_selected(&mut target, value)
                    }
                    fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::selected(&target)
                    }
                    fn set_global_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_global_matrix(&mut target, value)
                    }
                    fn global_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::global_matrix(&target)
                    }
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::responds(&target, type_)
                    }
                    fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::rotate(&target, angle, center)
                    }
                    fn tween(
                        &self,
                        options: ItemTweenParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween(&target, options)
                    }
                    fn set_on_mouse_enter(
                        &mut self,
                        value: ItemOnMouseEnter,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_enter(&mut target, value)
                    }
                    fn on_mouse_enter(&self) -> std::result::Result<ItemOnMouseEnter, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_enter(&target)
                    }
                    fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_id(&mut target, value)
                    }
                    fn id(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::id(&target)
                    }
                    fn on(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::on(&target, object)
                    }
                    fn tween_to(
                        &self,
                        to: JsValue,
                        options: ItemTweenToParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_to(&target, to, options)
                    }
                    fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_locked(&mut target, value)
                    }
                    fn locked(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::locked(&target)
                    }
                    fn set_children(
                        &mut self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_children(&mut target, value)
                    }
                    fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::children(&target)
                    }
                    fn copy_attributes(
                        &self,
                        source: Item,
                        exclude_matrix: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_attributes(&target, source, exclude_matrix)
                    }
                    fn off(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::off(&target, object)
                    }
                    fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::contains(&target, point)
                    }
                    fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_stroke(&target)
                    }
                    fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_move(&target)
                    }
                    fn add_children(
                        &self,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::add_children(&target, items)
                    }
                    fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::reverse_children(&target)
                    }
                    fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_shadow(&target)
                    }
                    fn set_dash_offset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_dash_offset(&mut target, value)
                    }
                    fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::dash_offset(&target)
                    }
                    fn set_on_mouse_leave(
                        &mut self,
                        value: ItemOnMouseLeave,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_leave(&mut target, value)
                    }
                    fn on_mouse_leave(&self) -> std::result::Result<ItemOnMouseLeave, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_leave(&target)
                    }
                    fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test_all(&target, point, options)
                    }
                    fn set_stroke_cap(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_cap(&mut target, value)
                    }
                    fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_cap(&target)
                    }
                    fn set_internal_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_internal_bounds(&mut target, value)
                    }
                    fn internal_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::internal_bounds(&target)
                    }
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_index(&mut target, value)
                    }
                    fn index(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::index(&target)
                    }
                    fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::reduce(&target, options)
                    }
                    fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_grouped_with(&target, item)
                    }
                    fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_global(&target, point)
                    }
                    fn set_first_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_first_child(&mut target, value)
                    }
                    fn first_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::first_child(&target)
                    }
                    fn set_position(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_position(&mut target, value)
                    }
                    fn position(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::position(&target)
                    }
                    fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_opacity(&mut target, value)
                    }
                    fn opacity(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::opacity(&target)
                    }
                    fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_down(&target)
                    }
                    fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_drag(&target)
                    }
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_bounds(&mut target, value)
                    }
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::bounds(&target)
                    }
                    fn set_parent(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_parent(&mut target, value)
                    }
                    fn parent(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::parent(&target)
                    }
                    fn get_items(
                        &self,
                        options: ItemGetItemsParamsOptionsParam,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::get_items(&target, options)
                    }
                    fn copy_to(
                        &self,
                        owner: ItemCopyToParamsOwnerParam,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::copy_to(&target, owner)
                    }
                    fn set_on_double_click(
                        &mut self,
                        value: ItemOnDoubleClick,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_double_click(&mut target, value)
                    }
                    fn on_double_click(&self) -> std::result::Result<ItemOnDoubleClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_double_click(&target)
                    }
                    fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::set(&target, props)
                    }
                    fn scale(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::scale(&target, hor, ver, center)
                    }
                    fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_below(&target, item)
                    }
                    fn set_next_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_next_sibling(&mut target, value)
                    }
                    fn next_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::next_sibling(&target)
                    }
                    fn rasterize(&self, options: JsValue) -> std::result::Result<Raster, JsValue> {
                        let target: Item = self.into();
                        Item::rasterize(&target, options)
                    }
                    fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::bring_to_front(&target)
                    }
                    fn matches(
                        &self,
                        name: String,
                        compare: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::matches(&target, name, compare)
                    }
                    fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_fill(&target)
                    }
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_view(&mut target, value)
                    }
                    fn view(&self) -> std::result::Result<View, JsValue> {
                        let target: Item = self.into();
                        Item::view(&target)
                    }
                    fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::clone(&target, options)
                    }
                    fn set_handle_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_handle_bounds(&mut target, value)
                    }
                    fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::handle_bounds(&target)
                    }
                    fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inside(&target, rect)
                    }
                    fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_above(&target, item)
                    }
                    fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::remove(&target)
                    }
                    fn set_stroke_join(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_join(&mut target, value)
                    }
                    fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_join(&target)
                    }
                    fn set_on_click(
                        &mut self,
                        value: ItemOnClick,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_click(&mut target, value)
                    }
                    fn on_click(&self) -> std::result::Result<ItemOnClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_click(&target)
                    }
                    fn fit_bounds(
                        &self,
                        rectangle: Rectangle,
                        fill: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::fit_bounds(&target, rectangle, fill)
                    }
                    fn set_blend_mode(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_blend_mode(&mut target, value)
                    }
                    fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::blend_mode(&target)
                    }
                    fn set_stroke_width(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_width(&mut target, value)
                    }
                    fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_width(&target)
                    }
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_rotation(&mut target, value)
                    }
                    fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::rotation(&target)
                    }
                    fn set_selected_color(
                        &mut self,
                        value: ItemSelectedColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_selected_color(&mut target, value)
                    }
                    fn selected_color(&self) -> std::result::Result<ItemSelectedColor, JsValue> {
                        let target: Item = self.into();
                        Item::selected_color(&target)
                    }
                    fn skew(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::skew(&target, hor, ver, center)
                    }
                    fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_name(&mut target, value)
                    }
                    fn name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::name(&target)
                    }
                    fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_json(&target, json)
                    }
                    fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::add_child(&target, item)
                    }
                    fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_visible(&mut target, value)
                    }
                    fn visible(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::visible(&target)
                    }
                    fn set_fill_rule(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_fill_rule(&mut target, value)
                    }
                    fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::fill_rule(&target)
                    }
                    fn set_layer(&mut self, value: Layer) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_layer(&mut target, value)
                    }
                    fn layer(&self) -> std::result::Result<Layer, JsValue> {
                        let target: Item = self.into();
                        Item::layer(&target)
                    }
                    fn tween_from(
                        &self,
                        from: JsValue,
                        options: ItemTweenFromParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_from(&target, from, options)
                    }
                    fn insert_child(
                        &self,
                        index: f64,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_child(&target, index, item)
                    }
                    fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_up(&target)
                    }
                    fn set_pivot(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_pivot(&mut target, value)
                    }
                    fn pivot(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::pivot(&target)
                    }
                    fn set_miter_limit(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_miter_limit(&mut target, value)
                    }
                    fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::miter_limit(&target)
                    }
                    fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_content(&target, source)
                    }
                    fn import_svg(
                        &self,
                        svg: ItemImportSvgParamsSvgParam,
                        on_load: &'static dyn Fn(
                            Box<[JsValue]>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_svg(&target, svg, on_load)
                    }
                    fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::send_to_back(&target)
                    }
                    fn set_stroke_color(
                        &mut self,
                        value: ItemStrokeColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_color(&mut target, value)
                    }
                    fn stroke_color(&self) -> std::result::Result<ItemStrokeColor, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_color(&target)
                    }
                    fn set_on_mouse_move(
                        &mut self,
                        value: ItemOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_move(&mut target, value)
                    }
                    fn on_mouse_move(&self) -> std::result::Result<ItemOnMouseMove, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_move(&target)
                    }
                    fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::replace_with(&target, item)
                    }
                    fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test(&target, point, options)
                    }
                    fn shear(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::shear(&target, hor, ver, center)
                    }
                    fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::translate(&target, delta)
                    }
                    fn set_stroke_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_bounds(&mut target, value)
                    }
                    fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_bounds(&target)
                    }
                    fn insert_children(
                        &self,
                        index: f64,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::insert_children(&target, index, items)
                    }
                    fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_child(&target, item)
                    }
                    fn set_shadow_offset(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_shadow_offset(&mut target, value)
                    }
                    fn shadow_offset(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_offset(&target)
                    }
                    fn set_fill_color(
                        &mut self,
                        value: ItemFillColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_fill_color(&mut target, value)
                    }
                    fn fill_color(&self) -> std::result::Result<ItemFillColor, JsValue> {
                        let target: Item = self.into();
                        Item::fill_color(&target)
                    }
                    fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                        let target: Item = self.into();
                        Item::export_svg(&target, options)
                    }
                    fn set_style(&mut self, value: Style) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_style(&mut target, value)
                    }
                    fn style(&self) -> std::result::Result<Style, JsValue> {
                        let target: Item = self.into();
                        Item::style(&target)
                    }
                    fn set_clip_mask(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_clip_mask(&mut target, value)
                    }
                    fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::clip_mask(&target)
                    }
                    fn set_class_name(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_class_name(&mut target, value)
                    }
                    fn class_name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::class_name(&target)
                    }
                    fn set_on_mouse_up(
                        &mut self,
                        value: ItemOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_up(&mut target, value)
                    }
                    fn on_mouse_up(&self) -> std::result::Result<ItemOnMouseUp, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_up(&target)
                    }
                    fn set_on_frame(
                        &mut self,
                        value: ItemOnFrame,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_frame(&mut target, value)
                    }
                    fn on_frame(&self) -> std::result::Result<ItemOnFrame, JsValue> {
                        let target: Item = self.into();
                        Item::on_frame(&target)
                    }
                    fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::parent_to_local(&target, point)
                    }
                    fn set_previous_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_previous_sibling(&mut target, value)
                    }
                    fn previous_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::previous_sibling(&target)
                    }
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::emit(&target, type_, event)
                    }
                    fn add_to(
                        &self,
                        owner: ItemAddToParamsOwnerParam,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::add_to(&target, owner)
                    }
                    fn has_children(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_children(&target)
                    }
                    fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::intersects(&target, item)
                    }
                    fn set_shadow_color(
                        &mut self,
                        value: ItemShadowColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_shadow_color(&mut target, value)
                    }
                    fn shadow_color(&self) -> std::result::Result<ItemShadowColor, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_color(&target)
                    }
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_scaling(&mut target, value)
                    }
                    fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::scaling(&target)
                    }
                }
                impl Path_Trait for Path
                where
                    Path: PathItem_Trait,
                {
                    fn reduce(&self, options: JsValue) -> std::result::Result<Path, JsValue> {
                        let target = self;
                        Path::reduce(&target, options)
                    }
                    fn get_curvature_at(&self, offset: f64) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Path::get_curvature_at(&target, offset)
                    }
                    fn set_last_curve(&mut self, value: Curve) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Path::set_last_curve(&mut target, value)
                    }
                    fn last_curve(&self) -> std::result::Result<Curve, JsValue> {
                        let target = self;
                        Path::last_curve(&target)
                    }
                    fn split_at(
                        &self,
                        location: PathSplitAtParamsLocationParam,
                    ) -> std::result::Result<Path, JsValue> {
                        let target = self;
                        Path::split_at(&target, location)
                    }
                    fn set_area(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Path::set_area(&mut target, value)
                    }
                    fn area(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Path::area(&target)
                    }
                    fn divide_at(
                        &self,
                        location: PathDivideAtParamsLocationParam,
                    ) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        Path::divide_at(&target, location)
                    }
                    fn get_offsets_with_tangent(
                        &self,
                        tangent: Point,
                    ) -> std::result::Result<Vec<f64>, JsValue> {
                        let target = self;
                        Path::get_offsets_with_tangent(&target, tangent)
                    }
                    fn set_first_segment(
                        &mut self,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Path::set_first_segment(&mut target, value)
                    }
                    fn first_segment(&self) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        Path::first_segment(&target)
                    }
                    fn set_first_curve(
                        &mut self,
                        value: Curve,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Path::set_first_curve(&mut target, value)
                    }
                    fn first_curve(&self) -> std::result::Result<Curve, JsValue> {
                        let target = self;
                        Path::first_curve(&target)
                    }
                    fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Path::has_handles(&target)
                    }
                    fn get_normal_at(&self, offset: f64) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Path::get_normal_at(&target, offset)
                    }
                    fn set_last_segment(
                        &mut self,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Path::set_last_segment(&mut target, value)
                    }
                    fn last_segment(&self) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        Path::last_segment(&target)
                    }
                    fn get_tangent_at(&self, offset: f64) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Path::get_tangent_at(&target, offset)
                    }
                    fn get_weighted_tangent_at(
                        &self,
                        offset: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Path::get_weighted_tangent_at(&target, offset)
                    }
                    fn get_offset_of(&self, point: Point) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Path::get_offset_of(&target, point)
                    }
                    fn insert(
                        &self,
                        index: f64,
                        segment: PathInsertParamsSegmentParam,
                    ) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        Path::insert(&target, index, segment)
                    }
                    fn insert_segments(
                        &self,
                        index: f64,
                        segments: Vec<Segment>,
                    ) -> std::result::Result<Vec<Segment>, JsValue> {
                        let target = self;
                        Path::insert_segments(&target, index, segments)
                    }
                    fn get_location_of(
                        &self,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let target = self;
                        Path::get_location_of(&target, point)
                    }
                    fn get_weighted_normal_at(
                        &self,
                        offset: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Path::get_weighted_normal_at(&target, offset)
                    }
                    fn set_closed(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Path::set_closed(&mut target, value)
                    }
                    fn closed(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Path::closed(&target)
                    }
                    fn add(
                        &self,
                        segment: Box<[PathAddParamsSegmentParam]>,
                    ) -> std::result::Result<PathAddReturn, JsValue> {
                        let target = self;
                        Path::add(&target, segment)
                    }
                    fn set_length(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Path::set_length(&mut target, value)
                    }
                    fn length(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Path::length(&target)
                    }
                    fn to_shape(&self, insert: bool) -> std::result::Result<Shape, JsValue> {
                        let target = self;
                        Path::to_shape(&target, insert)
                    }
                    fn get_location_at(
                        &self,
                        offset: f64,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let target = self;
                        Path::get_location_at(&target, offset)
                    }
                    fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Path::clear_handles(&target)
                    }
                    fn remove_segment(&self, index: f64) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        Path::remove_segment(&target, index)
                    }
                    fn set_segments(
                        &mut self,
                        value: Vec<Segment>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Path::set_segments(&mut target, value)
                    }
                    fn segments(&self) -> std::result::Result<Vec<Segment>, JsValue> {
                        let target = self;
                        Path::segments(&target)
                    }
                    fn remove_segments(
                        &self,
                        from: f64,
                        to: f64,
                    ) -> std::result::Result<Vec<Segment>, JsValue> {
                        let target = self;
                        Path::remove_segments(&target, from, to)
                    }
                    fn get_point_at(&self, offset: f64) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Path::get_point_at(&target, offset)
                    }
                    fn add_segments(
                        &self,
                        segments: Vec<Segment>,
                    ) -> std::result::Result<Vec<Segment>, JsValue> {
                        let target = self;
                        Path::add_segments(&target, segments)
                    }
                    fn join(&self, path: Path, tolerance: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Path::join(&target, path, tolerance)
                    }
                    fn set_curves(
                        &mut self,
                        value: Vec<Curve>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Path::set_curves(&mut target, value)
                    }
                    fn curves(&self) -> std::result::Result<Vec<Curve>, JsValue> {
                        let target = self;
                        Path::curves(&target)
                    }
                    fn set_fully_selected(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Path::set_fully_selected(&mut target, value)
                    }
                    fn fully_selected(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Path::fully_selected(&target)
                    }
                }
                impl std::clone::Clone for Path_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Path_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Path_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemOnMouseUp {
                    TsBindgenRtNullCase,
                    #[serde(
                        serialize_with = "ItemOnMouseUp::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "ItemOnMouseUp::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                }
                impl ItemOnMouseUp {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum CurveGetWeightedNormalAtParamsLocationParam {
                    CurveLocationCase(CurveLocation),
                    F64Case(f64),
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[wasm_bindgen(js_name = "CurveLocation")]
                    pub type CurveLocation_Class;
                    # [wasm_bindgen (method , structural , catch , getter = tangent , js_class = "CurveLocation")]
                    fn tangent(this: &CurveLocation_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = tangent , js_class = "CurveLocation")]
                    fn set_tangent(
                        this: &CurveLocation_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = segment , js_class = "CurveLocation")]
                    fn segment(this: &CurveLocation_Class)
                        -> std::result::Result<Segment, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = segment , js_class = "CurveLocation")]
                    fn set_segment(
                        this: &CurveLocation_Class,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = curve , js_class = "CurveLocation")]
                    fn curve(this: &CurveLocation_Class) -> std::result::Result<Curve, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = curve , js_class = "CurveLocation")]
                    fn set_curve(
                        this: &CurveLocation_Class,
                        value: Curve,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isTouching , method , js_class = "CurveLocation" , catch)]
                    fn __TSB_is_touching(
                        this: &CurveLocation_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = index , js_class = "CurveLocation")]
                    fn index(this: &CurveLocation_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = index , js_class = "CurveLocation")]
                    fn set_index(
                        this: &CurveLocation_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = path , js_class = "CurveLocation")]
                    fn path(this: &CurveLocation_Class) -> std::result::Result<Path, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = path , js_class = "CurveLocation")]
                    fn set_path(
                        this: &CurveLocation_Class,
                        value: Path,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isCrossing , method , js_class = "CurveLocation" , catch)]
                    fn __TSB_is_crossing(
                        this: &CurveLocation_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = time , js_class = "CurveLocation")]
                    fn time(this: &CurveLocation_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = time , js_class = "CurveLocation")]
                    fn set_time(
                        this: &CurveLocation_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = hasOverlap , method , js_class = "CurveLocation" , catch)]
                    fn __TSB_has_overlap(
                        this: &CurveLocation_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = normal , js_class = "CurveLocation")]
                    fn normal(this: &CurveLocation_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = normal , js_class = "CurveLocation")]
                    fn set_normal(
                        this: &CurveLocation_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = curvature , js_class = "CurveLocation")]
                    fn curvature(this: &CurveLocation_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = curvature , js_class = "CurveLocation")]
                    fn set_curvature(
                        this: &CurveLocation_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = toString , method , js_class = "CurveLocation" , catch)]
                    fn __TSB_to_string(
                        this: &CurveLocation_Class,
                    ) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = point , js_class = "CurveLocation")]
                    fn point(this: &CurveLocation_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = point , js_class = "CurveLocation")]
                    fn set_point(
                        this: &CurveLocation_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[wasm_bindgen(constructor, js_class = "CurveLocation")]
                    pub fn new(curve: Curve, time: f64, point: Point) -> CurveLocation_Class;
                    # [wasm_bindgen (method , structural , catch , getter = distance , js_class = "CurveLocation")]
                    fn distance(this: &CurveLocation_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = distance , js_class = "CurveLocation")]
                    fn set_distance(
                        this: &CurveLocation_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = offset , js_class = "CurveLocation")]
                    fn offset(this: &CurveLocation_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = offset , js_class = "CurveLocation")]
                    fn set_offset(
                        this: &CurveLocation_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = equals , method , js_class = "CurveLocation" , catch)]
                    fn __TSB_equals(
                        this: &CurveLocation_Class,
                        location: CurveLocation,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = intersection , js_class = "CurveLocation")]
                    fn intersection(
                        this: &CurveLocation_Class,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = intersection , js_class = "CurveLocation")]
                    fn set_intersection(
                        this: &CurveLocation_Class,
                        value: CurveLocation,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = curveOffset , js_class = "CurveLocation")]
                    fn curve_offset(
                        this: &CurveLocation_Class,
                    ) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = curveOffset , js_class = "CurveLocation")]
                    fn set_curve_offset(
                        this: &CurveLocation_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct CurveLocation(pub CurveLocation_Class);
                impl CurveLocation {
                    #[allow(dead_code)]
                    pub fn tangent(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.tangent();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_tangent(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_tangent(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn segment(&self) -> std::result::Result<Segment, JsValue> {
                        let result = self.0.segment();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_segment(&self, value: Segment) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_segment(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn curve(&self) -> std::result::Result<Curve, JsValue> {
                        let result = self.0.curve();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_curve(&self, value: Curve) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_curve(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_touching(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_touching();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn index(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.index();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_index(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_index(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn path(&self) -> std::result::Result<Path, JsValue> {
                        let result = self.0.path();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_path(&self, value: Path) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_path(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_crossing(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_crossing();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn time(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.time();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_time(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_time(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn has_overlap(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_has_overlap();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn normal(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.normal();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_normal(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_normal(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn curvature(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.curvature();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_curvature(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_curvature(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.__TSB_to_string();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn point(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.point();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_point(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_point(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn new(curve: Curve, time: f64, point: Point) -> CurveLocation {
                        let result = CurveLocation_Class::new(curve, time, point);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        CurveLocation(result)
                    }
                    #[allow(dead_code)]
                    pub fn distance(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.distance();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_distance(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_distance(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn offset(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.offset();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_offset(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_offset(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn equals(
                        &self,
                        location: CurveLocation,
                    ) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_equals(location);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn intersection(&self) -> std::result::Result<CurveLocation, JsValue> {
                        let result = self.0.intersection();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_intersection(
                        &self,
                        value: CurveLocation,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_intersection(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn curve_offset(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.curve_offset();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_curve_offset(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_curve_offset(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for CurveLocation {
                    fn describe() {
                        <CurveLocation_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for CurveLocation {
                    type Abi = <CurveLocation_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for CurveLocation {
                    type Abi = <CurveLocation_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        CurveLocation(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a CurveLocation {
                    type Abi = <&'a CurveLocation_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for CurveLocation {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for CurveLocation {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: CurveLocation_Class =
                            <CurveLocation_Class as serde::de::Deserialize>::deserialize(
                                deserializer,
                            )?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait CurveLocation_Trait {
                    fn set_tangent(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn tangent(&self) -> std::result::Result<Point, JsValue>;
                    fn set_segment(&mut self, value: Segment) -> std::result::Result<(), JsValue>;
                    fn segment(&self) -> std::result::Result<Segment, JsValue>;
                    fn set_curve(&mut self, value: Curve) -> std::result::Result<(), JsValue>;
                    fn curve(&self) -> std::result::Result<Curve, JsValue>;
                    fn is_touching(&self) -> std::result::Result<bool, JsValue>;
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn index(&self) -> std::result::Result<f64, JsValue>;
                    fn set_path(&mut self, value: Path) -> std::result::Result<(), JsValue>;
                    fn path(&self) -> std::result::Result<Path, JsValue>;
                    fn is_crossing(&self) -> std::result::Result<bool, JsValue>;
                    fn set_time(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn time(&self) -> std::result::Result<f64, JsValue>;
                    fn has_overlap(&self) -> std::result::Result<bool, JsValue>;
                    fn set_normal(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn normal(&self) -> std::result::Result<Point, JsValue>;
                    fn set_curvature(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn curvature(&self) -> std::result::Result<f64, JsValue>;
                    fn to_string(&self) -> std::result::Result<String, JsValue>;
                    fn set_point(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn point(&self) -> std::result::Result<Point, JsValue>;
                    fn set_distance(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn distance(&self) -> std::result::Result<f64, JsValue>;
                    fn set_offset(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn offset(&self) -> std::result::Result<f64, JsValue>;
                    fn equals(&self, location: CurveLocation)
                        -> std::result::Result<bool, JsValue>;
                    fn set_intersection(
                        &mut self,
                        value: CurveLocation,
                    ) -> std::result::Result<(), JsValue>;
                    fn intersection(&self) -> std::result::Result<CurveLocation, JsValue>;
                    fn set_curve_offset(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn curve_offset(&self) -> std::result::Result<f64, JsValue>;
                }
                impl CurveLocation_Trait for CurveLocation {
                    fn set_tangent(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        CurveLocation::set_tangent(&mut target, value)
                    }
                    fn tangent(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        CurveLocation::tangent(&target)
                    }
                    fn set_segment(&mut self, value: Segment) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        CurveLocation::set_segment(&mut target, value)
                    }
                    fn segment(&self) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        CurveLocation::segment(&target)
                    }
                    fn set_curve(&mut self, value: Curve) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        CurveLocation::set_curve(&mut target, value)
                    }
                    fn curve(&self) -> std::result::Result<Curve, JsValue> {
                        let target = self;
                        CurveLocation::curve(&target)
                    }
                    fn is_touching(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        CurveLocation::is_touching(&target)
                    }
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        CurveLocation::set_index(&mut target, value)
                    }
                    fn index(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        CurveLocation::index(&target)
                    }
                    fn set_path(&mut self, value: Path) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        CurveLocation::set_path(&mut target, value)
                    }
                    fn path(&self) -> std::result::Result<Path, JsValue> {
                        let target = self;
                        CurveLocation::path(&target)
                    }
                    fn is_crossing(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        CurveLocation::is_crossing(&target)
                    }
                    fn set_time(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        CurveLocation::set_time(&mut target, value)
                    }
                    fn time(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        CurveLocation::time(&target)
                    }
                    fn has_overlap(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        CurveLocation::has_overlap(&target)
                    }
                    fn set_normal(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        CurveLocation::set_normal(&mut target, value)
                    }
                    fn normal(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        CurveLocation::normal(&target)
                    }
                    fn set_curvature(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        CurveLocation::set_curvature(&mut target, value)
                    }
                    fn curvature(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        CurveLocation::curvature(&target)
                    }
                    fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        CurveLocation::to_string(&target)
                    }
                    fn set_point(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        CurveLocation::set_point(&mut target, value)
                    }
                    fn point(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        CurveLocation::point(&target)
                    }
                    fn set_distance(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        CurveLocation::set_distance(&mut target, value)
                    }
                    fn distance(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        CurveLocation::distance(&target)
                    }
                    fn set_offset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        CurveLocation::set_offset(&mut target, value)
                    }
                    fn offset(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        CurveLocation::offset(&target)
                    }
                    fn equals(
                        &self,
                        location: CurveLocation,
                    ) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        CurveLocation::equals(&target, location)
                    }
                    fn set_intersection(
                        &mut self,
                        value: CurveLocation,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        CurveLocation::set_intersection(&mut target, value)
                    }
                    fn intersection(&self) -> std::result::Result<CurveLocation, JsValue> {
                        let target = self;
                        CurveLocation::intersection(&target)
                    }
                    fn set_curve_offset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        CurveLocation::set_curve_offset(&mut target, value)
                    }
                    fn curve_offset(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        CurveLocation::curve_offset(&target)
                    }
                }
                impl std::clone::Clone for CurveLocation_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for CurveLocation_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for CurveLocation_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemOnMouseLeave {
                    TsBindgenRtNullCase,
                    #[serde(
                        serialize_with = "ItemOnMouseLeave::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "ItemOnMouseLeave::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                }
                impl ItemOnMouseLeave {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ToolOnMouseDown {
                    TsBindgenRtNullCase,
                    #[serde(
                        serialize_with = "ToolOnMouseDown::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "ToolOnMouseDown::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                }
                impl ToolOnMouseDown {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[wasm_bindgen(js_name = "PaperScript")]
                    pub type PaperScript_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = execute , method , js_class = "PaperScript" , catch)]
                    fn __TSB_execute(
                        this: &PaperScript_Class,
                        code: String,
                        scope: PaperScope,
                        options: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = compile , method , js_class = "PaperScript" , catch)]
                    fn __TSB_compile(
                        this: &PaperScript_Class,
                        code: String,
                        options: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = load , method , js_class = "PaperScript" , catch)]
                    fn __TSB_load(
                        this: &PaperScript_Class,
                        script: web_sys::HtmlScriptElement,
                    ) -> std::result::Result<PaperScope, JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct PaperScript(pub PaperScript_Class);
                impl PaperScript {
                    #[allow(dead_code)]
                    pub fn execute(
                        &self,
                        code: String,
                        scope: PaperScope,
                        options: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let result = self.0.__TSB_execute(code, scope, options);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn compile(
                        &self,
                        code: String,
                        options: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let result = self.0.__TSB_compile(code, options);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn load(
                        &self,
                        script: web_sys::HtmlScriptElement,
                    ) -> std::result::Result<PaperScope, JsValue> {
                        let result = self.0.__TSB_load(script);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for PaperScript {
                    fn describe() {
                        <PaperScript_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for PaperScript {
                    type Abi = <PaperScript_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for PaperScript {
                    type Abi = <PaperScript_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        PaperScript(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a PaperScript {
                    type Abi = <&'a PaperScript_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for PaperScript {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for PaperScript {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: PaperScript_Class =
                            <PaperScript_Class as serde::de::Deserialize>::deserialize(
                                deserializer,
                            )?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait PaperScript_Trait {
                    fn execute(
                        &self,
                        code: String,
                        scope: PaperScope,
                        options: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    fn compile(
                        &self,
                        code: String,
                        options: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    fn load(
                        &self,
                        script: web_sys::HtmlScriptElement,
                    ) -> std::result::Result<PaperScope, JsValue>;
                }
                impl PaperScript_Trait for PaperScript {
                    fn execute(
                        &self,
                        code: String,
                        scope: PaperScope,
                        options: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target = self;
                        PaperScript::execute(&target, code, scope, options)
                    }
                    fn compile(
                        &self,
                        code: String,
                        options: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target = self;
                        PaperScript::compile(&target, code, options)
                    }
                    fn load(
                        &self,
                        script: web_sys::HtmlScriptElement,
                    ) -> std::result::Result<PaperScope, JsValue> {
                        let target = self;
                        PaperScript::load(&target, script)
                    }
                }
                impl std::clone::Clone for PaperScript_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for PaperScript_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for PaperScript_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemGetItemParamsOptionsParam {
                    #[serde(
                        serialize_with = "ItemGetItemParamsOptionsParam::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "ItemGetItemParamsOptionsParam::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    JsValueCase(JsValue),
                }
                impl ItemGetItemParamsOptionsParam {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemCopyToParamsOwnerParam {
                    CompoundPathCase(CompoundPath),
                    LayerCase(Layer),
                    GroupCase(Group),
                    ProjectCase(Project),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum StyleLeading {
                    StringCase(String),
                    F64Case(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum CurveGetNormalAtParamsLocationParam {
                    CurveLocationCase(CurveLocation),
                    F64Case(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemOnMouseDown {
                    TsBindgenRtNullCase,
                    #[serde(
                        serialize_with = "ItemOnMouseDown::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "ItemOnMouseDown::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                }
                impl ItemOnMouseDown {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PathAddParamsSegmentParam {
                    PointCase(Point),
                    SegmentCase(Segment),
                    VecOfF64Case(Vec<f64>),
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[wasm_bindgen(js_name = "Gradient")]
                    pub type Gradient_Class;
                    # [wasm_bindgen (method , structural , catch , getter = radial , js_class = "Gradient")]
                    fn radial(this: &Gradient_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = radial , js_class = "Gradient")]
                    fn set_radial(
                        this: &Gradient_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = stops , js_class = "Gradient")]
                    fn __TSB_stops(this: &Gradient_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = stops , js_class = "Gradient")]
                    fn __TSB_set_stops(
                        this: &Gradient_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clone , method , js_class = "Gradient" , catch)]
                    fn __TSB_clone(this: &Gradient_Class)
                        -> std::result::Result<Gradient, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = equals , method , js_class = "Gradient" , catch)]
                    fn __TSB_equals(
                        this: &Gradient_Class,
                        gradient: Gradient,
                    ) -> std::result::Result<bool, JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Gradient(pub Gradient_Class);
                impl Gradient {
                    #[allow(dead_code)]
                    pub fn radial(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.radial();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_radial(&self, value: bool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_radial(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn stops(&self) -> std::result::Result<Vec<GradientStop>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_stops()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_stops(
                        &self,
                        value: Vec<GradientStop>,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_stops(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn clone(&self) -> std::result::Result<Gradient, JsValue> {
                        let result = self.0.__TSB_clone();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn equals(&self, gradient: Gradient) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_equals(gradient);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Gradient {
                    fn describe() {
                        <Gradient_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Gradient {
                    type Abi = <Gradient_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Gradient {
                    type Abi = <Gradient_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Gradient(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Gradient {
                    type Abi = <&'a Gradient_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Gradient {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Gradient {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Gradient_Class =
                            <Gradient_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait Gradient_Trait {
                    fn set_radial(&mut self, value: bool) -> std::result::Result<(), JsValue>;
                    fn radial(&self) -> std::result::Result<bool, JsValue>;
                    fn set_stops(
                        &mut self,
                        value: Vec<GradientStop>,
                    ) -> std::result::Result<(), JsValue>;
                    fn stops(&self) -> std::result::Result<Vec<GradientStop>, JsValue>;
                    fn clone(&self) -> std::result::Result<Gradient, JsValue>;
                    fn equals(&self, gradient: Gradient) -> std::result::Result<bool, JsValue>;
                }
                impl Gradient_Trait for Gradient {
                    fn set_radial(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Gradient::set_radial(&mut target, value)
                    }
                    fn radial(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Gradient::radial(&target)
                    }
                    fn set_stops(
                        &mut self,
                        value: Vec<GradientStop>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Gradient::set_stops(&mut target, value)
                    }
                    fn stops(&self) -> std::result::Result<Vec<GradientStop>, JsValue> {
                        let target = self;
                        Gradient::stops(&target)
                    }
                    fn clone(&self) -> std::result::Result<Gradient, JsValue> {
                        let target = self;
                        Gradient::clone(&target)
                    }
                    fn equals(&self, gradient: Gradient) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Gradient::equals(&target, gradient)
                    }
                }
                impl std::clone::Clone for Gradient_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Gradient_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Gradient_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemOnDoubleClick {
                    TsBindgenRtNullCase,
                    #[serde(
                        serialize_with = "ItemOnDoubleClick::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "ItemOnDoubleClick::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                }
                impl ItemOnDoubleClick {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemSelectedColor {
                    ColorCase(Color),
                    TsBindgenRtNullCase,
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum RasterImage {
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    WebSysHtmlCanvasElementCase(web_sys::HtmlCanvasElement),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    WebSysHtmlImageElementCase(web_sys::HtmlImageElement),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ToolOnMouseUp {
                    TsBindgenRtNullCase,
                    #[serde(
                        serialize_with = "ToolOnMouseUp::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "ToolOnMouseUp::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                }
                impl ToolOnMouseUp {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[wasm_bindgen(js_name = "Style")]
                    pub type Style_Class;
                    # [wasm_bindgen (method , structural , catch , getter = fontFamily , js_class = "Style")]
                    fn font_family(this: &Style_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = fontFamily , js_class = "Style")]
                    fn set_font_family(
                        this: &Style_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = miterLimit , js_class = "Style")]
                    fn miter_limit(this: &Style_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = miterLimit , js_class = "Style")]
                    fn set_miter_limit(
                        this: &Style_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = strokeCap , js_class = "Style")]
                    fn stroke_cap(this: &Style_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = strokeCap , js_class = "Style")]
                    fn set_stroke_cap(
                        this: &Style_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    #[wasm_bindgen(constructor, js_class = "Style")]
                    pub fn new(style: JsValue) -> Style_Class;
                    # [wasm_bindgen (method , structural , catch , getter = shadowOffset , js_class = "Style")]
                    fn shadow_offset(this: &Style_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = shadowOffset , js_class = "Style")]
                    fn set_shadow_offset(
                        this: &Style_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = strokeColor , js_class = "Style")]
                    fn __TSB_stroke_color(
                        this: &Style_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = strokeColor , js_class = "Style")]
                    fn __TSB_set_stroke_color(
                        this: &Style_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = selectedColor , js_class = "Style")]
                    fn __TSB_selected_color(
                        this: &Style_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = selectedColor , js_class = "Style")]
                    fn __TSB_set_selected_color(
                        this: &Style_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = shadowColor , js_class = "Style")]
                    fn __TSB_shadow_color(
                        this: &Style_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = shadowColor , js_class = "Style")]
                    fn __TSB_set_shadow_color(
                        this: &Style_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = strokeWidth , js_class = "Style")]
                    fn stroke_width(this: &Style_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = strokeWidth , js_class = "Style")]
                    fn set_stroke_width(
                        this: &Style_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = dashArray , js_class = "Style")]
                    fn __TSB_dash_array(
                        this: &Style_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = dashArray , js_class = "Style")]
                    fn __TSB_set_dash_array(
                        this: &Style_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = strokeScaling , js_class = "Style")]
                    fn stroke_scaling(this: &Style_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = strokeScaling , js_class = "Style")]
                    fn set_stroke_scaling(
                        this: &Style_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = dashOffset , js_class = "Style")]
                    fn dash_offset(this: &Style_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = dashOffset , js_class = "Style")]
                    fn set_dash_offset(
                        this: &Style_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = fillRule , js_class = "Style")]
                    fn fill_rule(this: &Style_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = fillRule , js_class = "Style")]
                    fn set_fill_rule(
                        this: &Style_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = leading , js_class = "Style")]
                    fn __TSB_leading(this: &Style_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = leading , js_class = "Style")]
                    fn __TSB_set_leading(
                        this: &Style_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = justification , js_class = "Style")]
                    fn justification(this: &Style_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = justification , js_class = "Style")]
                    fn set_justification(
                        this: &Style_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = view , js_class = "Style")]
                    fn view(this: &Style_Class) -> std::result::Result<View, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = view , js_class = "Style")]
                    fn set_view(
                        this: &Style_Class,
                        value: View,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = strokeJoin , js_class = "Style")]
                    fn stroke_join(this: &Style_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = strokeJoin , js_class = "Style")]
                    fn set_stroke_join(
                        this: &Style_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = fillColor , js_class = "Style")]
                    fn __TSB_fill_color(
                        this: &Style_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = fillColor , js_class = "Style")]
                    fn __TSB_set_fill_color(
                        this: &Style_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = shadowBlur , js_class = "Style")]
                    fn shadow_blur(this: &Style_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = shadowBlur , js_class = "Style")]
                    fn set_shadow_blur(
                        this: &Style_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = fontSize , js_class = "Style")]
                    fn __TSB_font_size(this: &Style_Class)
                        -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = fontSize , js_class = "Style")]
                    fn __TSB_set_font_size(
                        this: &Style_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = fontWeight , js_class = "Style")]
                    fn __TSB_font_weight(
                        this: &Style_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = fontWeight , js_class = "Style")]
                    fn __TSB_set_font_weight(
                        this: &Style_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Style(pub Style_Class);
                impl Style {
                    #[allow(dead_code)]
                    pub fn font_family(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.font_family();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_font_family(
                        &self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_font_family(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.miter_limit();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_miter_limit(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_miter_limit(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.stroke_cap();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_stroke_cap(
                        &self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_stroke_cap(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn new(style: JsValue) -> Style {
                        let result = Style_Class::new(style);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Style(result)
                    }
                    #[allow(dead_code)]
                    pub fn shadow_offset(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.shadow_offset();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_shadow_offset(
                        &self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_shadow_offset(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn stroke_color(&self) -> std::result::Result<StyleStrokeColor, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_stroke_color()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_stroke_color(
                        &self,
                        value: StyleStrokeColor,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_stroke_color(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn selected_color(
                        &self,
                    ) -> std::result::Result<StyleSelectedColor, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_selected_color()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_selected_color(
                        &self,
                        value: StyleSelectedColor,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_selected_color(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn shadow_color(&self) -> std::result::Result<StyleShadowColor, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_shadow_color()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_shadow_color(
                        &self,
                        value: StyleShadowColor,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_shadow_color(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.stroke_width();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_stroke_width(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_stroke_width(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_dash_array()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_dash_array(
                        &self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_dash_array(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.stroke_scaling();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_stroke_scaling(
                        &self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_stroke_scaling(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.dash_offset();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_dash_offset(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_dash_offset(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.fill_rule();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_fill_rule(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_fill_rule(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn leading(&self) -> std::result::Result<StyleLeading, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_leading()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_leading(
                        &self,
                        value: StyleLeading,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_leading(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn justification(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.justification();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_justification(
                        &self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_justification(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn view(&self) -> std::result::Result<View, JsValue> {
                        let result = self.0.view();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_view(&self, value: View) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_view(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.stroke_join();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_stroke_join(
                        &self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_stroke_join(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn fill_color(&self) -> std::result::Result<StyleFillColor, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_fill_color()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_fill_color(
                        &self,
                        value: StyleFillColor,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_fill_color(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.shadow_blur();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_shadow_blur(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_shadow_blur(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn font_size(&self) -> std::result::Result<StyleFontSize, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_font_size()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_font_size(
                        &self,
                        value: StyleFontSize,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_font_size(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code)]
                    pub fn font_weight(&self) -> std::result::Result<StyleFontWeight, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_font_weight()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_font_weight(
                        &self,
                        value: StyleFontWeight,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_font_weight(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Style {
                    fn describe() {
                        <Style_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Style {
                    type Abi = <Style_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Style {
                    type Abi = <Style_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Style(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Style {
                    type Abi = <&'a Style_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Style {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Style {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Style_Class =
                            <Style_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait Style_Trait {
                    fn set_font_family(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    fn font_family(&self) -> std::result::Result<String, JsValue>;
                    fn set_miter_limit(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn miter_limit(&self) -> std::result::Result<f64, JsValue>;
                    fn set_stroke_cap(&mut self, value: String)
                        -> std::result::Result<(), JsValue>;
                    fn stroke_cap(&self) -> std::result::Result<String, JsValue>;
                    fn set_shadow_offset(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn shadow_offset(&self) -> std::result::Result<Point, JsValue>;
                    fn set_stroke_color(
                        &mut self,
                        value: StyleStrokeColor,
                    ) -> std::result::Result<(), JsValue>;
                    fn stroke_color(&self) -> std::result::Result<StyleStrokeColor, JsValue>;
                    fn set_selected_color(
                        &mut self,
                        value: StyleSelectedColor,
                    ) -> std::result::Result<(), JsValue>;
                    fn selected_color(&self) -> std::result::Result<StyleSelectedColor, JsValue>;
                    fn set_shadow_color(
                        &mut self,
                        value: StyleShadowColor,
                    ) -> std::result::Result<(), JsValue>;
                    fn shadow_color(&self) -> std::result::Result<StyleShadowColor, JsValue>;
                    fn set_stroke_width(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn stroke_width(&self) -> std::result::Result<f64, JsValue>;
                    fn set_dash_array(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue>;
                    fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue>;
                    fn set_stroke_scaling(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    fn stroke_scaling(&self) -> std::result::Result<bool, JsValue>;
                    fn set_dash_offset(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn dash_offset(&self) -> std::result::Result<f64, JsValue>;
                    fn set_fill_rule(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn fill_rule(&self) -> std::result::Result<String, JsValue>;
                    fn set_leading(
                        &mut self,
                        value: StyleLeading,
                    ) -> std::result::Result<(), JsValue>;
                    fn leading(&self) -> std::result::Result<StyleLeading, JsValue>;
                    fn set_justification(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    fn justification(&self) -> std::result::Result<String, JsValue>;
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue>;
                    fn view(&self) -> std::result::Result<View, JsValue>;
                    fn set_stroke_join(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    fn stroke_join(&self) -> std::result::Result<String, JsValue>;
                    fn set_fill_color(
                        &mut self,
                        value: StyleFillColor,
                    ) -> std::result::Result<(), JsValue>;
                    fn fill_color(&self) -> std::result::Result<StyleFillColor, JsValue>;
                    fn set_shadow_blur(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn shadow_blur(&self) -> std::result::Result<f64, JsValue>;
                    fn set_font_size(
                        &mut self,
                        value: StyleFontSize,
                    ) -> std::result::Result<(), JsValue>;
                    fn font_size(&self) -> std::result::Result<StyleFontSize, JsValue>;
                    fn set_font_weight(
                        &mut self,
                        value: StyleFontWeight,
                    ) -> std::result::Result<(), JsValue>;
                    fn font_weight(&self) -> std::result::Result<StyleFontWeight, JsValue>;
                }
                impl Style_Trait for Style {
                    fn set_font_family(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Style::set_font_family(&mut target, value)
                    }
                    fn font_family(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Style::font_family(&target)
                    }
                    fn set_miter_limit(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Style::set_miter_limit(&mut target, value)
                    }
                    fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Style::miter_limit(&target)
                    }
                    fn set_stroke_cap(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Style::set_stroke_cap(&mut target, value)
                    }
                    fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Style::stroke_cap(&target)
                    }
                    fn set_shadow_offset(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Style::set_shadow_offset(&mut target, value)
                    }
                    fn shadow_offset(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Style::shadow_offset(&target)
                    }
                    fn set_stroke_color(
                        &mut self,
                        value: StyleStrokeColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Style::set_stroke_color(&mut target, value)
                    }
                    fn stroke_color(&self) -> std::result::Result<StyleStrokeColor, JsValue> {
                        let target = self;
                        Style::stroke_color(&target)
                    }
                    fn set_selected_color(
                        &mut self,
                        value: StyleSelectedColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Style::set_selected_color(&mut target, value)
                    }
                    fn selected_color(&self) -> std::result::Result<StyleSelectedColor, JsValue> {
                        let target = self;
                        Style::selected_color(&target)
                    }
                    fn set_shadow_color(
                        &mut self,
                        value: StyleShadowColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Style::set_shadow_color(&mut target, value)
                    }
                    fn shadow_color(&self) -> std::result::Result<StyleShadowColor, JsValue> {
                        let target = self;
                        Style::shadow_color(&target)
                    }
                    fn set_stroke_width(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Style::set_stroke_width(&mut target, value)
                    }
                    fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Style::stroke_width(&target)
                    }
                    fn set_dash_array(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Style::set_dash_array(&mut target, value)
                    }
                    fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let target = self;
                        Style::dash_array(&target)
                    }
                    fn set_stroke_scaling(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Style::set_stroke_scaling(&mut target, value)
                    }
                    fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Style::stroke_scaling(&target)
                    }
                    fn set_dash_offset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Style::set_dash_offset(&mut target, value)
                    }
                    fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Style::dash_offset(&target)
                    }
                    fn set_fill_rule(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Style::set_fill_rule(&mut target, value)
                    }
                    fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Style::fill_rule(&target)
                    }
                    fn set_leading(
                        &mut self,
                        value: StyleLeading,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Style::set_leading(&mut target, value)
                    }
                    fn leading(&self) -> std::result::Result<StyleLeading, JsValue> {
                        let target = self;
                        Style::leading(&target)
                    }
                    fn set_justification(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Style::set_justification(&mut target, value)
                    }
                    fn justification(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Style::justification(&target)
                    }
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Style::set_view(&mut target, value)
                    }
                    fn view(&self) -> std::result::Result<View, JsValue> {
                        let target = self;
                        Style::view(&target)
                    }
                    fn set_stroke_join(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Style::set_stroke_join(&mut target, value)
                    }
                    fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Style::stroke_join(&target)
                    }
                    fn set_fill_color(
                        &mut self,
                        value: StyleFillColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Style::set_fill_color(&mut target, value)
                    }
                    fn fill_color(&self) -> std::result::Result<StyleFillColor, JsValue> {
                        let target = self;
                        Style::fill_color(&target)
                    }
                    fn set_shadow_blur(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Style::set_shadow_blur(&mut target, value)
                    }
                    fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Style::shadow_blur(&target)
                    }
                    fn set_font_size(
                        &mut self,
                        value: StyleFontSize,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Style::set_font_size(&mut target, value)
                    }
                    fn font_size(&self) -> std::result::Result<StyleFontSize, JsValue> {
                        let target = self;
                        Style::font_size(&target)
                    }
                    fn set_font_weight(
                        &mut self,
                        value: StyleFontWeight,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Style::set_font_weight(&mut target, value)
                    }
                    fn font_weight(&self) -> std::result::Result<StyleFontWeight, JsValue> {
                        let target = self;
                        Style::font_weight(&target)
                    }
                }
                impl std::clone::Clone for Style_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Style_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Style_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum CurveGetPointAtParamsLocationParam {
                    CurveLocationCase(CurveLocation),
                    F64Case(f64),
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    # [wasm_bindgen (js_name = "MouseEvent" , extends = Event_Class)]
                    pub type MouseEvent_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = toString , method , js_class = "MouseEvent" , catch)]
                    fn __TSB_to_string(
                        this: &MouseEvent_Class,
                    ) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = target , js_class = "MouseEvent")]
                    fn target(this: &MouseEvent_Class) -> std::result::Result<Item, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = target , js_class = "MouseEvent")]
                    fn set_target(
                        this: &MouseEvent_Class,
                        value: Item,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = currentTarget , js_class = "MouseEvent")]
                    fn current_target(
                        this: &MouseEvent_Class,
                    ) -> std::result::Result<Item, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = currentTarget , js_class = "MouseEvent")]
                    fn set_current_target(
                        this: &MouseEvent_Class,
                        value: Item,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = type , js_class = "MouseEvent")]
                    fn type_(this: &MouseEvent_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = type , js_class = "MouseEvent")]
                    fn set_type_(
                        this: &MouseEvent_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = point , js_class = "MouseEvent")]
                    fn point(this: &MouseEvent_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = point , js_class = "MouseEvent")]
                    fn set_point(
                        this: &MouseEvent_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = delta , js_class = "MouseEvent")]
                    fn delta(this: &MouseEvent_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = delta , js_class = "MouseEvent")]
                    fn set_delta(
                        this: &MouseEvent_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct MouseEvent(pub MouseEvent_Class);
                impl std::convert::From<&MouseEvent> for Event {
                    fn from(src: &MouseEvent) -> Event {
                        let src: &Event_Class = src.0.as_ref();
                        Event(src.clone())
                    }
                }
                impl std::convert::From<&mut MouseEvent> for Event {
                    fn from(src: &mut MouseEvent) -> Event {
                        let src: &Event_Class = src.0.as_ref();
                        Event(src.clone())
                    }
                }
                impl MouseEvent {
                    #[allow(dead_code)]
                    pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.__TSB_to_string();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn target(&self) -> std::result::Result<Item, JsValue> {
                        let result = self.0.target();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_target(&self, value: Item) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_target(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn current_target(&self) -> std::result::Result<Item, JsValue> {
                        let result = self.0.current_target();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_current_target(
                        &self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_current_target(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn type_(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.type_();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_type_(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_type_(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn point(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.point();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_point(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_point(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn delta(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.delta();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_delta(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_delta(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for MouseEvent {
                    fn describe() {
                        <MouseEvent_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for MouseEvent {
                    type Abi = <MouseEvent_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for MouseEvent {
                    type Abi = <MouseEvent_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        MouseEvent(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a MouseEvent {
                    type Abi = <&'a MouseEvent_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for MouseEvent {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for MouseEvent {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: MouseEvent_Class =
                            <MouseEvent_Class as serde::de::Deserialize>::deserialize(
                                deserializer,
                            )?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait MouseEvent_Trait: Event_Trait {
                    fn to_string(&self) -> std::result::Result<String, JsValue>;
                    fn set_target(&mut self, value: Item) -> std::result::Result<(), JsValue>;
                    fn target(&self) -> std::result::Result<Item, JsValue>;
                    fn set_current_target(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue>;
                    fn current_target(&self) -> std::result::Result<Item, JsValue>;
                    fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn type_(&self) -> std::result::Result<String, JsValue>;
                    fn set_point(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn point(&self) -> std::result::Result<Point, JsValue>;
                    fn set_delta(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn delta(&self) -> std::result::Result<Point, JsValue>;
                }
                impl Event_Trait for MouseEvent {
                    fn set_modifiers(
                        &mut self,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Event = self.into();
                        Event::set_modifiers(&mut target, value)
                    }
                    fn modifiers(&self) -> std::result::Result<JsValue, JsValue> {
                        let target: Event = self.into();
                        Event::modifiers(&target)
                    }
                    fn stop_propagation(&self) -> std::result::Result<(), JsValue> {
                        let target: Event = self.into();
                        Event::stop_propagation(&target)
                    }
                    fn set_time_stamp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Event = self.into();
                        Event::set_time_stamp(&mut target, value)
                    }
                    fn time_stamp(&self) -> std::result::Result<f64, JsValue> {
                        let target: Event = self.into();
                        Event::time_stamp(&target)
                    }
                    fn prevent_default(&self) -> std::result::Result<(), JsValue> {
                        let target: Event = self.into();
                        Event::prevent_default(&target)
                    }
                    fn stop(&self) -> std::result::Result<(), JsValue> {
                        let target: Event = self.into();
                        Event::stop(&target)
                    }
                }
                impl MouseEvent_Trait for MouseEvent
                where
                    MouseEvent: Event_Trait,
                {
                    fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        MouseEvent::to_string(&target)
                    }
                    fn set_target(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        MouseEvent::set_target(&mut target, value)
                    }
                    fn target(&self) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        MouseEvent::target(&target)
                    }
                    fn set_current_target(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        MouseEvent::set_current_target(&mut target, value)
                    }
                    fn current_target(&self) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        MouseEvent::current_target(&target)
                    }
                    fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        MouseEvent::set_type_(&mut target, value)
                    }
                    fn type_(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        MouseEvent::type_(&target)
                    }
                    fn set_point(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        MouseEvent::set_point(&mut target, value)
                    }
                    fn point(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        MouseEvent::point(&target)
                    }
                    fn set_delta(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        MouseEvent::set_delta(&mut target, value)
                    }
                    fn delta(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        MouseEvent::delta(&target)
                    }
                }
                impl std::clone::Clone for MouseEvent_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for MouseEvent_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for MouseEvent_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[wasm_bindgen(js_name = "Segment")]
                    pub type Segment_Class;
                    # [wasm_bindgen (method , structural , catch , getter = handleOut , js_class = "Segment")]
                    fn handle_out(this: &Segment_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = handleOut , js_class = "Segment")]
                    fn set_handle_out(
                        this: &Segment_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = index , js_class = "Segment")]
                    fn index(this: &Segment_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = index , js_class = "Segment")]
                    fn set_index(
                        this: &Segment_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clone , method , js_class = "Segment" , catch)]
                    fn __TSB_clone(this: &Segment_Class) -> std::result::Result<Segment, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = location , js_class = "Segment")]
                    fn location(
                        this: &Segment_Class,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = location , js_class = "Segment")]
                    fn set_location(
                        this: &Segment_Class,
                        value: CurveLocation,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = remove , method , js_class = "Segment" , catch)]
                    fn __TSB_remove(this: &Segment_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = selected , js_class = "Segment")]
                    fn selected(this: &Segment_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = selected , js_class = "Segment")]
                    fn set_selected(
                        this: &Segment_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isSmooth , method , js_class = "Segment" , catch)]
                    fn __TSB_is_smooth(this: &Segment_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = previous , js_class = "Segment")]
                    fn previous(this: &Segment_Class) -> std::result::Result<Segment, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = previous , js_class = "Segment")]
                    fn set_previous(
                        this: &Segment_Class,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = toString , method , js_class = "Segment" , catch)]
                    fn __TSB_to_string(
                        this: &Segment_Class,
                    ) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = point , js_class = "Segment")]
                    fn point(this: &Segment_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = point , js_class = "Segment")]
                    fn set_point(
                        this: &Segment_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = path , js_class = "Segment")]
                    fn path(this: &Segment_Class) -> std::result::Result<Path, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = path , js_class = "Segment")]
                    fn set_path(
                        this: &Segment_Class,
                        value: Path,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = transform , method , js_class = "Segment" , catch)]
                    fn __TSB_transform(
                        this: &Segment_Class,
                        matrix: Matrix,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = reversed , method , js_class = "Segment" , catch)]
                    fn __TSB_reversed(
                        this: &Segment_Class,
                    ) -> std::result::Result<Segment, JsValue>;
                    #[wasm_bindgen(constructor, js_class = "Segment")]
                    pub fn new(object: JsValue) -> Segment_Class;
                    # [wasm_bindgen (method , structural , catch , getter = curve , js_class = "Segment")]
                    fn curve(this: &Segment_Class) -> std::result::Result<Curve, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = curve , js_class = "Segment")]
                    fn set_curve(
                        this: &Segment_Class,
                        value: Curve,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = hasHandles , method , js_class = "Segment" , catch)]
                    fn __TSB_has_handles(
                        this: &Segment_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = handleIn , js_class = "Segment")]
                    fn handle_in(this: &Segment_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = handleIn , js_class = "Segment")]
                    fn set_handle_in(
                        this: &Segment_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isFirst , method , js_class = "Segment" , catch)]
                    fn __TSB_is_first(this: &Segment_Class) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clearHandles , method , js_class = "Segment" , catch)]
                    fn __TSB_clear_handles(
                        this: &Segment_Class,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = next , js_class = "Segment")]
                    fn next(this: &Segment_Class) -> std::result::Result<Segment, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = next , js_class = "Segment")]
                    fn set_next(
                        this: &Segment_Class,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isLast , method , js_class = "Segment" , catch)]
                    fn __TSB_is_last(this: &Segment_Class) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = interpolate , method , js_class = "Segment" , catch)]
                    fn __TSB_interpolate(
                        this: &Segment_Class,
                        from: Segment,
                        to: Segment,
                        factor: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = smooth , method , js_class = "Segment" , catch)]
                    fn __TSB_smooth(
                        this: &Segment_Class,
                        options: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = reverse , method , js_class = "Segment" , catch)]
                    fn __TSB_reverse(this: &Segment_Class)
                        -> std::result::Result<Segment, JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Segment(pub Segment_Class);
                impl Segment {
                    #[allow(dead_code)]
                    pub fn handle_out(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.handle_out();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_handle_out(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_handle_out(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn index(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.index();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_index(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_index(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn clone(&self) -> std::result::Result<Segment, JsValue> {
                        let result = self.0.__TSB_clone();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn location(&self) -> std::result::Result<CurveLocation, JsValue> {
                        let result = self.0.location();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_location(
                        &self,
                        value: CurveLocation,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_location(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_remove();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.selected();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_selected(&self, value: bool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_selected(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_smooth(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_smooth();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn previous(&self) -> std::result::Result<Segment, JsValue> {
                        let result = self.0.previous();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_previous(&self, value: Segment) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_previous(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.__TSB_to_string();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn point(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.point();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_point(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_point(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn path(&self) -> std::result::Result<Path, JsValue> {
                        let result = self.0.path();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_path(&self, value: Path) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_path(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_transform(matrix);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn reversed(&self) -> std::result::Result<Segment, JsValue> {
                        let result = self.0.__TSB_reversed();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn new(object: JsValue) -> Segment {
                        let result = Segment_Class::new(object);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Segment(result)
                    }
                    #[allow(dead_code)]
                    pub fn curve(&self) -> std::result::Result<Curve, JsValue> {
                        let result = self.0.curve();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_curve(&self, value: Curve) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_curve(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_has_handles();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn handle_in(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.handle_in();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_handle_in(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_handle_in(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_first(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_first();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_clear_handles();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn next(&self) -> std::result::Result<Segment, JsValue> {
                        let result = self.0.next();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_next(&self, value: Segment) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_next(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn is_last(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_last();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn interpolate(
                        &self,
                        from: Segment,
                        to: Segment,
                        factor: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_interpolate(from, to, factor);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn smooth(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_smooth(options);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn reverse(&self) -> std::result::Result<Segment, JsValue> {
                        let result = self.0.__TSB_reverse();
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Segment {
                    fn describe() {
                        <Segment_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Segment {
                    type Abi = <Segment_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Segment {
                    type Abi = <Segment_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Segment(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Segment {
                    type Abi = <&'a Segment_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Segment {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Segment {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Segment_Class =
                            <Segment_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait Segment_Trait {
                    fn set_handle_out(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn handle_out(&self) -> std::result::Result<Point, JsValue>;
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn index(&self) -> std::result::Result<f64, JsValue>;
                    fn clone(&self) -> std::result::Result<Segment, JsValue>;
                    fn set_location(
                        &mut self,
                        value: CurveLocation,
                    ) -> std::result::Result<(), JsValue>;
                    fn location(&self) -> std::result::Result<CurveLocation, JsValue>;
                    fn remove(&self) -> std::result::Result<bool, JsValue>;
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue>;
                    fn selected(&self) -> std::result::Result<bool, JsValue>;
                    fn is_smooth(&self) -> std::result::Result<bool, JsValue>;
                    fn set_previous(&mut self, value: Segment) -> std::result::Result<(), JsValue>;
                    fn previous(&self) -> std::result::Result<Segment, JsValue>;
                    fn to_string(&self) -> std::result::Result<String, JsValue>;
                    fn set_point(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn point(&self) -> std::result::Result<Point, JsValue>;
                    fn set_path(&mut self, value: Path) -> std::result::Result<(), JsValue>;
                    fn path(&self) -> std::result::Result<Path, JsValue>;
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue>;
                    fn reversed(&self) -> std::result::Result<Segment, JsValue>;
                    fn set_curve(&mut self, value: Curve) -> std::result::Result<(), JsValue>;
                    fn curve(&self) -> std::result::Result<Curve, JsValue>;
                    fn has_handles(&self) -> std::result::Result<bool, JsValue>;
                    fn set_handle_in(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn handle_in(&self) -> std::result::Result<Point, JsValue>;
                    fn is_first(&self) -> std::result::Result<bool, JsValue>;
                    fn clear_handles(&self) -> std::result::Result<(), JsValue>;
                    fn set_next(&mut self, value: Segment) -> std::result::Result<(), JsValue>;
                    fn next(&self) -> std::result::Result<Segment, JsValue>;
                    fn is_last(&self) -> std::result::Result<bool, JsValue>;
                    fn interpolate(
                        &self,
                        from: Segment,
                        to: Segment,
                        factor: f64,
                    ) -> std::result::Result<(), JsValue>;
                    fn smooth(&self, options: JsValue) -> std::result::Result<(), JsValue>;
                    fn reverse(&self) -> std::result::Result<Segment, JsValue>;
                }
                impl Segment_Trait for Segment {
                    fn set_handle_out(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Segment::set_handle_out(&mut target, value)
                    }
                    fn handle_out(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Segment::handle_out(&target)
                    }
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Segment::set_index(&mut target, value)
                    }
                    fn index(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Segment::index(&target)
                    }
                    fn clone(&self) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        Segment::clone(&target)
                    }
                    fn set_location(
                        &mut self,
                        value: CurveLocation,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Segment::set_location(&mut target, value)
                    }
                    fn location(&self) -> std::result::Result<CurveLocation, JsValue> {
                        let target = self;
                        Segment::location(&target)
                    }
                    fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Segment::remove(&target)
                    }
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Segment::set_selected(&mut target, value)
                    }
                    fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Segment::selected(&target)
                    }
                    fn is_smooth(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Segment::is_smooth(&target)
                    }
                    fn set_previous(&mut self, value: Segment) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Segment::set_previous(&mut target, value)
                    }
                    fn previous(&self) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        Segment::previous(&target)
                    }
                    fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Segment::to_string(&target)
                    }
                    fn set_point(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Segment::set_point(&mut target, value)
                    }
                    fn point(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Segment::point(&target)
                    }
                    fn set_path(&mut self, value: Path) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Segment::set_path(&mut target, value)
                    }
                    fn path(&self) -> std::result::Result<Path, JsValue> {
                        let target = self;
                        Segment::path(&target)
                    }
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Segment::transform(&target, matrix)
                    }
                    fn reversed(&self) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        Segment::reversed(&target)
                    }
                    fn set_curve(&mut self, value: Curve) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Segment::set_curve(&mut target, value)
                    }
                    fn curve(&self) -> std::result::Result<Curve, JsValue> {
                        let target = self;
                        Segment::curve(&target)
                    }
                    fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Segment::has_handles(&target)
                    }
                    fn set_handle_in(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Segment::set_handle_in(&mut target, value)
                    }
                    fn handle_in(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Segment::handle_in(&target)
                    }
                    fn is_first(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Segment::is_first(&target)
                    }
                    fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Segment::clear_handles(&target)
                    }
                    fn set_next(&mut self, value: Segment) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        Segment::set_next(&mut target, value)
                    }
                    fn next(&self) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        Segment::next(&target)
                    }
                    fn is_last(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Segment::is_last(&target)
                    }
                    fn interpolate(
                        &self,
                        from: Segment,
                        to: Segment,
                        factor: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Segment::interpolate(&target, from, to, factor)
                    }
                    fn smooth(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Segment::smooth(&target, options)
                    }
                    fn reverse(&self) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        Segment::reverse(&target)
                    }
                }
                impl std::clone::Clone for Segment_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Segment_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Segment_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewOnMouseMove {
                    TsBindgenRtNullCase,
                    #[serde(
                        serialize_with = "ViewOnMouseMove::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "ViewOnMouseMove::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                }
                impl ViewOnMouseMove {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemOnMouseDrag {
                    TsBindgenRtNullCase,
                    #[serde(
                        serialize_with = "ItemOnMouseDrag::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "ItemOnMouseDrag::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                }
                impl ItemOnMouseDrag {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum TextItemLeading {
                    StringCase(String),
                    F64Case(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewOnMouseDown {
                    TsBindgenRtNullCase,
                    #[serde(
                        serialize_with = "ViewOnMouseDown::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "ViewOnMouseDown::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                }
                impl ViewOnMouseDown {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewOnDoubleClick {
                    TsBindgenRtNullCase,
                    #[serde(
                        serialize_with = "ViewOnDoubleClick::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "ViewOnDoubleClick::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                }
                impl ViewOnDoubleClick {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    # [wasm_bindgen (js_name = "PointText" , extends = TextItem_Class , extends = Item_Class)]
                    pub type PointText_Class;
                    #[wasm_bindgen(constructor, js_class = "PointText")]
                    pub fn new(object: JsValue) -> PointText_Class;
                    # [wasm_bindgen (method , structural , catch , getter = point , js_class = "PointText")]
                    fn point(this: &PointText_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = point , js_class = "PointText")]
                    fn set_point(
                        this: &PointText_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct PointText(pub PointText_Class);
                impl std::convert::From<&PointText> for TextItem {
                    fn from(src: &PointText) -> TextItem {
                        let src: &TextItem_Class = src.0.as_ref();
                        TextItem(src.clone())
                    }
                }
                impl std::convert::From<&mut PointText> for TextItem {
                    fn from(src: &mut PointText) -> TextItem {
                        let src: &TextItem_Class = src.0.as_ref();
                        TextItem(src.clone())
                    }
                }
                impl std::convert::From<&PointText> for Item {
                    fn from(src: &PointText) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl std::convert::From<&mut PointText> for Item {
                    fn from(src: &mut PointText) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl PointText {
                    #[allow(dead_code)]
                    pub fn new(object: JsValue) -> PointText {
                        let result = PointText_Class::new(object);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        PointText(result)
                    }
                    #[allow(dead_code)]
                    pub fn point(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.point();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_point(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_point(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for PointText {
                    fn describe() {
                        <PointText_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for PointText {
                    type Abi = <PointText_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for PointText {
                    type Abi = <PointText_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        PointText(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a PointText {
                    type Abi = <&'a PointText_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for PointText {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for PointText {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: PointText_Class =
                            <PointText_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait PointText_Trait: TextItem_Trait {
                    fn set_point(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn point(&self) -> std::result::Result<Point, JsValue>;
                }
                impl TextItem_Trait for PointText
                where
                    PointText: Item_Trait,
                {
                    fn set_font_weight(
                        &mut self,
                        value: TextItemFontWeight,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: TextItem = self.into();
                        TextItem::set_font_weight(&mut target, value)
                    }
                    fn font_weight(&self) -> std::result::Result<TextItemFontWeight, JsValue> {
                        let target: TextItem = self.into();
                        TextItem::font_weight(&target)
                    }
                    fn set_font_size(
                        &mut self,
                        value: TextItemFontSize,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: TextItem = self.into();
                        TextItem::set_font_size(&mut target, value)
                    }
                    fn font_size(&self) -> std::result::Result<TextItemFontSize, JsValue> {
                        let target: TextItem = self.into();
                        TextItem::font_size(&target)
                    }
                    fn set_content(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target: TextItem = self.into();
                        TextItem::set_content(&mut target, value)
                    }
                    fn content(&self) -> std::result::Result<String, JsValue> {
                        let target: TextItem = self.into();
                        TextItem::content(&target)
                    }
                    fn set_font_family(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: TextItem = self.into();
                        TextItem::set_font_family(&mut target, value)
                    }
                    fn font_family(&self) -> std::result::Result<String, JsValue> {
                        let target: TextItem = self.into();
                        TextItem::font_family(&target)
                    }
                    fn set_leading(
                        &mut self,
                        value: TextItemLeading,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: TextItem = self.into();
                        TextItem::set_leading(&mut target, value)
                    }
                    fn leading(&self) -> std::result::Result<TextItemLeading, JsValue> {
                        let target: TextItem = self.into();
                        TextItem::leading(&target)
                    }
                    fn set_justification(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: TextItem = self.into();
                        TextItem::set_justification(&mut target, value)
                    }
                    fn justification(&self) -> std::result::Result<String, JsValue> {
                        let target: TextItem = self.into();
                        TextItem::justification(&target)
                    }
                }
                impl Item_Trait for PointText {
                    fn set_stroke_scaling(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_scaling(&mut target, value)
                    }
                    fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_scaling(&target)
                    }
                    fn set_apply_matrix(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_apply_matrix(&mut target, value)
                    }
                    fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::apply_matrix(&target)
                    }
                    fn set_view_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_view_matrix(&mut target, value)
                    }
                    fn view_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::view_matrix(&target)
                    }
                    fn set_dash_array(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_dash_array(&mut target, value)
                    }
                    fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let target: Item = self.into();
                        Item::dash_array(&target)
                    }
                    fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_ancestor(&target, item)
                    }
                    fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_descendant(&target, item)
                    }
                    fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_sibling(&target, item)
                    }
                    fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_parent(&target, point)
                    }
                    fn set_shadow_blur(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_shadow_blur(&mut target, value)
                    }
                    fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_blur(&target)
                    }
                    fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_empty(&target, recursively)
                    }
                    fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_parent(&target, item)
                    }
                    fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_below(&target, item)
                    }
                    fn set_matrix(&mut self, value: Matrix) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_matrix(&mut target, value)
                    }
                    fn matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::matrix(&target)
                    }
                    fn export_json(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::export_json(&target, options)
                    }
                    fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::global_to_local(&target, point)
                    }
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ItemOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_drag(&mut target, value)
                    }
                    fn on_mouse_drag(&self) -> std::result::Result<ItemOnMouseDrag, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_drag(&target)
                    }
                    fn get_item(
                        &self,
                        options: ItemGetItemParamsOptionsParam,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::get_item(&target, options)
                    }
                    fn remove_children(
                        &self,
                        start: f64,
                        end: f64,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::remove_children(&target, start, end)
                    }
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_project(&mut target, value)
                    }
                    fn project(&self) -> std::result::Result<Project, JsValue> {
                        let target: Item = self.into();
                        Item::project(&target)
                    }
                    fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_data(&mut target, value)
                    }
                    fn data(&self) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::data(&target)
                    }
                    fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_above(&target, item)
                    }
                    fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on(&target, options)
                    }
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::transform(&target, matrix)
                    }
                    fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inserted(&target)
                    }
                    fn set_on_mouse_down(
                        &mut self,
                        value: ItemOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_down(&mut target, value)
                    }
                    fn on_mouse_down(&self) -> std::result::Result<ItemOnMouseDown, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_down(&target)
                    }
                    fn set_last_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_last_child(&mut target, value)
                    }
                    fn last_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::last_child(&target)
                    }
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_selected(&mut target, value)
                    }
                    fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::selected(&target)
                    }
                    fn set_global_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_global_matrix(&mut target, value)
                    }
                    fn global_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::global_matrix(&target)
                    }
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::responds(&target, type_)
                    }
                    fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::rotate(&target, angle, center)
                    }
                    fn tween(
                        &self,
                        options: ItemTweenParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween(&target, options)
                    }
                    fn set_on_mouse_enter(
                        &mut self,
                        value: ItemOnMouseEnter,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_enter(&mut target, value)
                    }
                    fn on_mouse_enter(&self) -> std::result::Result<ItemOnMouseEnter, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_enter(&target)
                    }
                    fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_id(&mut target, value)
                    }
                    fn id(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::id(&target)
                    }
                    fn on(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::on(&target, object)
                    }
                    fn tween_to(
                        &self,
                        to: JsValue,
                        options: ItemTweenToParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_to(&target, to, options)
                    }
                    fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_locked(&mut target, value)
                    }
                    fn locked(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::locked(&target)
                    }
                    fn set_children(
                        &mut self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_children(&mut target, value)
                    }
                    fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::children(&target)
                    }
                    fn copy_attributes(
                        &self,
                        source: Item,
                        exclude_matrix: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_attributes(&target, source, exclude_matrix)
                    }
                    fn off(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::off(&target, object)
                    }
                    fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::contains(&target, point)
                    }
                    fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_stroke(&target)
                    }
                    fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_move(&target)
                    }
                    fn add_children(
                        &self,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::add_children(&target, items)
                    }
                    fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::reverse_children(&target)
                    }
                    fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_shadow(&target)
                    }
                    fn set_dash_offset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_dash_offset(&mut target, value)
                    }
                    fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::dash_offset(&target)
                    }
                    fn set_on_mouse_leave(
                        &mut self,
                        value: ItemOnMouseLeave,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_leave(&mut target, value)
                    }
                    fn on_mouse_leave(&self) -> std::result::Result<ItemOnMouseLeave, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_leave(&target)
                    }
                    fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test_all(&target, point, options)
                    }
                    fn set_stroke_cap(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_cap(&mut target, value)
                    }
                    fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_cap(&target)
                    }
                    fn set_internal_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_internal_bounds(&mut target, value)
                    }
                    fn internal_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::internal_bounds(&target)
                    }
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_index(&mut target, value)
                    }
                    fn index(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::index(&target)
                    }
                    fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::reduce(&target, options)
                    }
                    fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_grouped_with(&target, item)
                    }
                    fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_global(&target, point)
                    }
                    fn set_first_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_first_child(&mut target, value)
                    }
                    fn first_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::first_child(&target)
                    }
                    fn set_position(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_position(&mut target, value)
                    }
                    fn position(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::position(&target)
                    }
                    fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_opacity(&mut target, value)
                    }
                    fn opacity(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::opacity(&target)
                    }
                    fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_down(&target)
                    }
                    fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_drag(&target)
                    }
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_bounds(&mut target, value)
                    }
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::bounds(&target)
                    }
                    fn set_parent(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_parent(&mut target, value)
                    }
                    fn parent(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::parent(&target)
                    }
                    fn get_items(
                        &self,
                        options: ItemGetItemsParamsOptionsParam,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::get_items(&target, options)
                    }
                    fn copy_to(
                        &self,
                        owner: ItemCopyToParamsOwnerParam,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::copy_to(&target, owner)
                    }
                    fn set_on_double_click(
                        &mut self,
                        value: ItemOnDoubleClick,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_double_click(&mut target, value)
                    }
                    fn on_double_click(&self) -> std::result::Result<ItemOnDoubleClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_double_click(&target)
                    }
                    fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::set(&target, props)
                    }
                    fn scale(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::scale(&target, hor, ver, center)
                    }
                    fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_below(&target, item)
                    }
                    fn set_next_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_next_sibling(&mut target, value)
                    }
                    fn next_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::next_sibling(&target)
                    }
                    fn rasterize(&self, options: JsValue) -> std::result::Result<Raster, JsValue> {
                        let target: Item = self.into();
                        Item::rasterize(&target, options)
                    }
                    fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::bring_to_front(&target)
                    }
                    fn matches(
                        &self,
                        name: String,
                        compare: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::matches(&target, name, compare)
                    }
                    fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_fill(&target)
                    }
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_view(&mut target, value)
                    }
                    fn view(&self) -> std::result::Result<View, JsValue> {
                        let target: Item = self.into();
                        Item::view(&target)
                    }
                    fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::clone(&target, options)
                    }
                    fn set_handle_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_handle_bounds(&mut target, value)
                    }
                    fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::handle_bounds(&target)
                    }
                    fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inside(&target, rect)
                    }
                    fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_above(&target, item)
                    }
                    fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::remove(&target)
                    }
                    fn set_stroke_join(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_join(&mut target, value)
                    }
                    fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_join(&target)
                    }
                    fn set_on_click(
                        &mut self,
                        value: ItemOnClick,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_click(&mut target, value)
                    }
                    fn on_click(&self) -> std::result::Result<ItemOnClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_click(&target)
                    }
                    fn fit_bounds(
                        &self,
                        rectangle: Rectangle,
                        fill: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::fit_bounds(&target, rectangle, fill)
                    }
                    fn set_blend_mode(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_blend_mode(&mut target, value)
                    }
                    fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::blend_mode(&target)
                    }
                    fn set_stroke_width(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_width(&mut target, value)
                    }
                    fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_width(&target)
                    }
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_rotation(&mut target, value)
                    }
                    fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::rotation(&target)
                    }
                    fn set_selected_color(
                        &mut self,
                        value: ItemSelectedColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_selected_color(&mut target, value)
                    }
                    fn selected_color(&self) -> std::result::Result<ItemSelectedColor, JsValue> {
                        let target: Item = self.into();
                        Item::selected_color(&target)
                    }
                    fn skew(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::skew(&target, hor, ver, center)
                    }
                    fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_name(&mut target, value)
                    }
                    fn name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::name(&target)
                    }
                    fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_json(&target, json)
                    }
                    fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::add_child(&target, item)
                    }
                    fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_visible(&mut target, value)
                    }
                    fn visible(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::visible(&target)
                    }
                    fn set_fill_rule(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_fill_rule(&mut target, value)
                    }
                    fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::fill_rule(&target)
                    }
                    fn set_layer(&mut self, value: Layer) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_layer(&mut target, value)
                    }
                    fn layer(&self) -> std::result::Result<Layer, JsValue> {
                        let target: Item = self.into();
                        Item::layer(&target)
                    }
                    fn tween_from(
                        &self,
                        from: JsValue,
                        options: ItemTweenFromParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_from(&target, from, options)
                    }
                    fn insert_child(
                        &self,
                        index: f64,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_child(&target, index, item)
                    }
                    fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_up(&target)
                    }
                    fn set_pivot(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_pivot(&mut target, value)
                    }
                    fn pivot(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::pivot(&target)
                    }
                    fn set_miter_limit(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_miter_limit(&mut target, value)
                    }
                    fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::miter_limit(&target)
                    }
                    fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_content(&target, source)
                    }
                    fn import_svg(
                        &self,
                        svg: ItemImportSvgParamsSvgParam,
                        on_load: &'static dyn Fn(
                            Box<[JsValue]>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_svg(&target, svg, on_load)
                    }
                    fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::send_to_back(&target)
                    }
                    fn set_stroke_color(
                        &mut self,
                        value: ItemStrokeColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_color(&mut target, value)
                    }
                    fn stroke_color(&self) -> std::result::Result<ItemStrokeColor, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_color(&target)
                    }
                    fn set_on_mouse_move(
                        &mut self,
                        value: ItemOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_move(&mut target, value)
                    }
                    fn on_mouse_move(&self) -> std::result::Result<ItemOnMouseMove, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_move(&target)
                    }
                    fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::replace_with(&target, item)
                    }
                    fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test(&target, point, options)
                    }
                    fn shear(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::shear(&target, hor, ver, center)
                    }
                    fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::translate(&target, delta)
                    }
                    fn set_stroke_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_bounds(&mut target, value)
                    }
                    fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_bounds(&target)
                    }
                    fn insert_children(
                        &self,
                        index: f64,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::insert_children(&target, index, items)
                    }
                    fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_child(&target, item)
                    }
                    fn set_shadow_offset(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_shadow_offset(&mut target, value)
                    }
                    fn shadow_offset(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_offset(&target)
                    }
                    fn set_fill_color(
                        &mut self,
                        value: ItemFillColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_fill_color(&mut target, value)
                    }
                    fn fill_color(&self) -> std::result::Result<ItemFillColor, JsValue> {
                        let target: Item = self.into();
                        Item::fill_color(&target)
                    }
                    fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                        let target: Item = self.into();
                        Item::export_svg(&target, options)
                    }
                    fn set_style(&mut self, value: Style) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_style(&mut target, value)
                    }
                    fn style(&self) -> std::result::Result<Style, JsValue> {
                        let target: Item = self.into();
                        Item::style(&target)
                    }
                    fn set_clip_mask(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_clip_mask(&mut target, value)
                    }
                    fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::clip_mask(&target)
                    }
                    fn set_class_name(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_class_name(&mut target, value)
                    }
                    fn class_name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::class_name(&target)
                    }
                    fn set_on_mouse_up(
                        &mut self,
                        value: ItemOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_up(&mut target, value)
                    }
                    fn on_mouse_up(&self) -> std::result::Result<ItemOnMouseUp, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_up(&target)
                    }
                    fn set_on_frame(
                        &mut self,
                        value: ItemOnFrame,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_frame(&mut target, value)
                    }
                    fn on_frame(&self) -> std::result::Result<ItemOnFrame, JsValue> {
                        let target: Item = self.into();
                        Item::on_frame(&target)
                    }
                    fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::parent_to_local(&target, point)
                    }
                    fn set_previous_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_previous_sibling(&mut target, value)
                    }
                    fn previous_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::previous_sibling(&target)
                    }
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::emit(&target, type_, event)
                    }
                    fn add_to(
                        &self,
                        owner: ItemAddToParamsOwnerParam,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::add_to(&target, owner)
                    }
                    fn has_children(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_children(&target)
                    }
                    fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::intersects(&target, item)
                    }
                    fn set_shadow_color(
                        &mut self,
                        value: ItemShadowColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_shadow_color(&mut target, value)
                    }
                    fn shadow_color(&self) -> std::result::Result<ItemShadowColor, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_color(&target)
                    }
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_scaling(&mut target, value)
                    }
                    fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::scaling(&target)
                    }
                }
                impl PointText_Trait for PointText
                where
                    PointText: TextItem_Trait,
                {
                    fn set_point(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        PointText::set_point(&mut target, value)
                    }
                    fn point(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        PointText::point(&target)
                    }
                }
                impl std::clone::Clone for PointText_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for PointText_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for PointText_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    # [wasm_bindgen (js_name = "PathItem" , extends = Item_Class)]
                    pub type PathItem_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = reverse , method , js_class = "PathItem" , catch)]
                    fn __TSB_reverse(this: &PathItem_Class) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getNearestLocation , method , js_class = "PathItem" , catch)]
                    fn __TSB_get_nearest_location(
                        this: &PathItem_Class,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = smooth , method , js_class = "PathItem" , catch)]
                    fn __TSB_smooth(
                        this: &PathItem_Class,
                        options: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = arcTo , method , js_class = "PathItem" , catch)]
                    fn __TSB_arc_to(
                        this: &PathItem_Class,
                        to: Point,
                        clockwise: bool,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = lineTo , method , js_class = "PathItem" , catch)]
                    fn __TSB_line_to(
                        this: &PathItem_Class,
                        point: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = cubicCurveBy , method , js_class = "PathItem" , catch)]
                    fn __TSB_cubic_curve_by(
                        this: &PathItem_Class,
                        handle1: Point,
                        handle2: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = divide , method , js_class = "PathItem" , catch)]
                    fn __TSB_divide(
                        this: &PathItem_Class,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = quadraticCurveBy , method , js_class = "PathItem" , catch)]
                    fn __TSB_quadratic_curve_by(
                        this: &PathItem_Class,
                        handle: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = create , method , js_class = "PathItem" , catch)]
                    fn __TSB_create(
                        this: &PathItem_Class,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = interpolate , method , js_class = "PathItem" , catch)]
                    fn __TSB_interpolate(
                        this: &PathItem_Class,
                        from: PathItem,
                        to: PathItem,
                        factor: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = clockwise , js_class = "PathItem")]
                    fn clockwise(this: &PathItem_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = clockwise , js_class = "PathItem")]
                    fn set_clockwise(
                        this: &PathItem_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = pathData , js_class = "PathItem")]
                    fn path_data(this: &PathItem_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = pathData , js_class = "PathItem")]
                    fn set_path_data(
                        this: &PathItem_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = curveTo , method , js_class = "PathItem" , catch)]
                    fn __TSB_curve_to(
                        this: &PathItem_Class,
                        through: Point,
                        to: Point,
                        time: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = moveTo , method , js_class = "PathItem" , catch)]
                    fn __TSB_move_to(
                        this: &PathItem_Class,
                        point: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getCrossings , method , js_class = "PathItem" , catch)]
                    fn __TSB_get_crossings(
                        this: &PathItem_Class,
                        path: PathItem,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = closePath , method , js_class = "PathItem" , catch)]
                    fn __TSB_close_path(this: &PathItem_Class) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = reorient , method , js_class = "PathItem" , catch)]
                    fn __TSB_reorient(
                        this: &PathItem_Class,
                        non_zero: bool,
                        clockwise: bool,
                    ) -> std::result::Result<PathItem, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = moveBy , method , js_class = "PathItem" , catch)]
                    fn __TSB_move_by(
                        this: &PathItem_Class,
                        to: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = quadraticCurveTo , method , js_class = "PathItem" , catch)]
                    fn __TSB_quadratic_curve_to(
                        this: &PathItem_Class,
                        handle: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = cubicCurveTo , method , js_class = "PathItem" , catch)]
                    fn __TSB_cubic_curve_to(
                        this: &PathItem_Class,
                        handle1: Point,
                        handle2: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getIntersections , method , js_class = "PathItem" , catch)]
                    fn __TSB_get_intersections(
                        this: &PathItem_Class,
                        path: PathItem,
                        include: &Closure<
                            dyn Fn(
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        >,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = compare , method , js_class = "PathItem" , catch)]
                    fn __TSB_compare(
                        this: &PathItem_Class,
                        path: PathItem,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = interiorPoint , js_class = "PathItem")]
                    fn interior_point(this: &PathItem_Class)
                        -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = interiorPoint , js_class = "PathItem")]
                    fn set_interior_point(
                        this: &PathItem_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = simplify , method , js_class = "PathItem" , catch)]
                    fn __TSB_simplify(
                        this: &PathItem_Class,
                        tolerance: f64,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = arcBy , method , js_class = "PathItem" , catch)]
                    fn __TSB_arc_by(
                        this: &PathItem_Class,
                        to: Point,
                        clockwise: bool,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = intersect , method , js_class = "PathItem" , catch)]
                    fn __TSB_intersect(
                        this: &PathItem_Class,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getNearestPoint , method , js_class = "PathItem" , catch)]
                    fn __TSB_get_nearest_point(
                        this: &PathItem_Class,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = curveBy , method , js_class = "PathItem" , catch)]
                    fn __TSB_curve_by(
                        this: &PathItem_Class,
                        through: Point,
                        to: Point,
                        time: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = exclude , method , js_class = "PathItem" , catch)]
                    fn __TSB_exclude(
                        this: &PathItem_Class,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = lineBy , method , js_class = "PathItem" , catch)]
                    fn __TSB_line_by(
                        this: &PathItem_Class,
                        point: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = unite , method , js_class = "PathItem" , catch)]
                    fn __TSB_unite(
                        this: &PathItem_Class,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = subtract , method , js_class = "PathItem" , catch)]
                    fn __TSB_subtract(
                        this: &PathItem_Class,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = flatten , method , js_class = "PathItem" , catch)]
                    fn __TSB_flatten(
                        this: &PathItem_Class,
                        flatness: f64,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct PathItem(pub PathItem_Class);
                impl std::convert::From<&PathItem> for Item {
                    fn from(src: &PathItem) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl std::convert::From<&mut PathItem> for Item {
                    fn from(src: &mut PathItem) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl PathItem {
                    #[allow(dead_code)]
                    pub fn reverse(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_reverse();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_nearest_location(
                        &self,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let result = self.0.__TSB_get_nearest_location(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn smooth(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_smooth(options);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn arc_to(
                        &self,
                        to: Point,
                        clockwise: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_arc_to(to, clockwise);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn line_to(&self, point: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_line_to(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn cubic_curve_by(
                        &self,
                        handle1: Point,
                        handle2: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_cubic_curve_by(handle1, handle2, to);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn divide(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let result = self.0.__TSB_divide(path, options);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn quadratic_curve_by(
                        &self,
                        handle: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_quadratic_curve_by(handle, to);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn create(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<PathItemCreateReturn, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_create(object)?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn interpolate(
                        &self,
                        from: PathItem,
                        to: PathItem,
                        factor: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_interpolate(from, to, factor);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn clockwise(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.clockwise();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_clockwise(&self, value: bool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_clockwise(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn path_data(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.path_data();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_path_data(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_path_data(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn curve_to(
                        &self,
                        through: Point,
                        to: Point,
                        time: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_curve_to(through, to, time);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn move_to(&self, point: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_move_to(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_crossings(
                        &self,
                        path: PathItem,
                    ) -> std::result::Result<Vec<CurveLocation>, JsValue> {
                        let result =
                            ts_bindgen_rt::from_jsvalue(&self.0.__TSB_get_crossings(path)?)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn close_path(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_close_path();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn reorient(
                        &self,
                        non_zero: bool,
                        clockwise: bool,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let result = self.0.__TSB_reorient(non_zero, clockwise);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn move_by(&self, to: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_move_by(to);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn quadratic_curve_to(
                        &self,
                        handle: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_quadratic_curve_to(handle, to);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn cubic_curve_to(
                        &self,
                        handle1: Point,
                        handle2: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_cubic_curve_to(handle1, handle2, to);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_intersections(
                        &self,
                        path: PathItem,
                        include: &'static dyn Fn(
                            Box<[JsValue]>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Vec<CurveLocation>, JsValue> {
                        # [allow (non_snake_case)] let __TSB_Local_include = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 : Box < [JsValue] > = Box :: new ([_Variadic0_arg0 , _Variadic1_arg0 , _Variadic2_arg0 , _Variadic3_arg0 , _Variadic4_arg0 , _Variadic5_arg0 , _Variadic6_arg0]) ; let result = include (arg0) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self.0.__TSB_get_intersections(path, &__TSB_Local_include)?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn compare(&self, path: PathItem) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_compare(path);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn interior_point(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.interior_point();
                        result
                    }
                    #[allow(dead_code)]
                    pub fn set_interior_point(
                        &self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_interior_point(value);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn simplify(&self, tolerance: f64) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_simplify(tolerance);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn arc_by(
                        &self,
                        to: Point,
                        clockwise: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_arc_by(to, clockwise);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn intersect(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let result = self.0.__TSB_intersect(path, options);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn get_nearest_point(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_get_nearest_point(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn curve_by(
                        &self,
                        through: Point,
                        to: Point,
                        time: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_curve_by(through, to, time);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn exclude(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let result = self.0.__TSB_exclude(path, options);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn line_by(&self, point: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_line_by(point);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn unite(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let result = self.0.__TSB_unite(path, options);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn subtract(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let result = self.0.__TSB_subtract(path, options);
                        result
                    }
                    #[allow(dead_code)]
                    pub fn flatten(&self, flatness: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_flatten(flatness);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for PathItem {
                    fn describe() {
                        <PathItem_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for PathItem {
                    type Abi = <PathItem_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for PathItem {
                    type Abi = <PathItem_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        PathItem(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a PathItem {
                    type Abi = <&'a PathItem_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for PathItem {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for PathItem {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: PathItem_Class =
                            <PathItem_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types)]
                pub trait PathItem_Trait: Item_Trait {
                    fn reverse(&self) -> std::result::Result<(), JsValue>;
                    fn get_nearest_location(
                        &self,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    fn smooth(&self, options: JsValue) -> std::result::Result<(), JsValue>;
                    fn arc_to(
                        &self,
                        to: Point,
                        clockwise: bool,
                    ) -> std::result::Result<(), JsValue>;
                    fn line_to(&self, point: Point) -> std::result::Result<(), JsValue>;
                    fn cubic_curve_by(
                        &self,
                        handle1: Point,
                        handle2: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn divide(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue>;
                    fn quadratic_curve_by(
                        &self,
                        handle: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn create(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<PathItemCreateReturn, JsValue>;
                    fn interpolate(
                        &self,
                        from: PathItem,
                        to: PathItem,
                        factor: f64,
                    ) -> std::result::Result<(), JsValue>;
                    fn set_clockwise(&mut self, value: bool) -> std::result::Result<(), JsValue>;
                    fn clockwise(&self) -> std::result::Result<bool, JsValue>;
                    fn set_path_data(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn path_data(&self) -> std::result::Result<String, JsValue>;
                    fn curve_to(
                        &self,
                        through: Point,
                        to: Point,
                        time: f64,
                    ) -> std::result::Result<(), JsValue>;
                    fn move_to(&self, point: Point) -> std::result::Result<(), JsValue>;
                    fn get_crossings(
                        &self,
                        path: PathItem,
                    ) -> std::result::Result<Vec<CurveLocation>, JsValue>;
                    fn close_path(&self) -> std::result::Result<(), JsValue>;
                    fn reorient(
                        &self,
                        non_zero: bool,
                        clockwise: bool,
                    ) -> std::result::Result<PathItem, JsValue>;
                    fn move_by(&self, to: Point) -> std::result::Result<(), JsValue>;
                    fn quadratic_curve_to(
                        &self,
                        handle: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn cubic_curve_to(
                        &self,
                        handle1: Point,
                        handle2: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn get_intersections(
                        &self,
                        path: PathItem,
                        include: &'static dyn Fn(
                            Box<[JsValue]>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Vec<CurveLocation>, JsValue>;
                    fn compare(&self, path: PathItem) -> std::result::Result<bool, JsValue>;
                    fn set_interior_point(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn interior_point(&self) -> std::result::Result<Point, JsValue>;
                    fn simplify(&self, tolerance: f64) -> std::result::Result<bool, JsValue>;
                    fn arc_by(
                        &self,
                        to: Point,
                        clockwise: bool,
                    ) -> std::result::Result<(), JsValue>;
                    fn intersect(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue>;
                    fn get_nearest_point(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    fn curve_by(
                        &self,
                        through: Point,
                        to: Point,
                        time: f64,
                    ) -> std::result::Result<(), JsValue>;
                    fn exclude(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue>;
                    fn line_by(&self, point: Point) -> std::result::Result<(), JsValue>;
                    fn unite(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue>;
                    fn subtract(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue>;
                    fn flatten(&self, flatness: f64) -> std::result::Result<(), JsValue>;
                }
                impl Item_Trait for PathItem {
                    fn set_stroke_scaling(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_scaling(&mut target, value)
                    }
                    fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_scaling(&target)
                    }
                    fn set_apply_matrix(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_apply_matrix(&mut target, value)
                    }
                    fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::apply_matrix(&target)
                    }
                    fn set_view_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_view_matrix(&mut target, value)
                    }
                    fn view_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::view_matrix(&target)
                    }
                    fn set_dash_array(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_dash_array(&mut target, value)
                    }
                    fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let target: Item = self.into();
                        Item::dash_array(&target)
                    }
                    fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_ancestor(&target, item)
                    }
                    fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_descendant(&target, item)
                    }
                    fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_sibling(&target, item)
                    }
                    fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_parent(&target, point)
                    }
                    fn set_shadow_blur(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_shadow_blur(&mut target, value)
                    }
                    fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_blur(&target)
                    }
                    fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_empty(&target, recursively)
                    }
                    fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_parent(&target, item)
                    }
                    fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_below(&target, item)
                    }
                    fn set_matrix(&mut self, value: Matrix) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_matrix(&mut target, value)
                    }
                    fn matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::matrix(&target)
                    }
                    fn export_json(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::export_json(&target, options)
                    }
                    fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::global_to_local(&target, point)
                    }
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ItemOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_drag(&mut target, value)
                    }
                    fn on_mouse_drag(&self) -> std::result::Result<ItemOnMouseDrag, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_drag(&target)
                    }
                    fn get_item(
                        &self,
                        options: ItemGetItemParamsOptionsParam,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::get_item(&target, options)
                    }
                    fn remove_children(
                        &self,
                        start: f64,
                        end: f64,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::remove_children(&target, start, end)
                    }
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_project(&mut target, value)
                    }
                    fn project(&self) -> std::result::Result<Project, JsValue> {
                        let target: Item = self.into();
                        Item::project(&target)
                    }
                    fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_data(&mut target, value)
                    }
                    fn data(&self) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::data(&target)
                    }
                    fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_above(&target, item)
                    }
                    fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on(&target, options)
                    }
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::transform(&target, matrix)
                    }
                    fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inserted(&target)
                    }
                    fn set_on_mouse_down(
                        &mut self,
                        value: ItemOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_down(&mut target, value)
                    }
                    fn on_mouse_down(&self) -> std::result::Result<ItemOnMouseDown, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_down(&target)
                    }
                    fn set_last_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_last_child(&mut target, value)
                    }
                    fn last_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::last_child(&target)
                    }
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_selected(&mut target, value)
                    }
                    fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::selected(&target)
                    }
                    fn set_global_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_global_matrix(&mut target, value)
                    }
                    fn global_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::global_matrix(&target)
                    }
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::responds(&target, type_)
                    }
                    fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::rotate(&target, angle, center)
                    }
                    fn tween(
                        &self,
                        options: ItemTweenParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween(&target, options)
                    }
                    fn set_on_mouse_enter(
                        &mut self,
                        value: ItemOnMouseEnter,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_enter(&mut target, value)
                    }
                    fn on_mouse_enter(&self) -> std::result::Result<ItemOnMouseEnter, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_enter(&target)
                    }
                    fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_id(&mut target, value)
                    }
                    fn id(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::id(&target)
                    }
                    fn on(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::on(&target, object)
                    }
                    fn tween_to(
                        &self,
                        to: JsValue,
                        options: ItemTweenToParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_to(&target, to, options)
                    }
                    fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_locked(&mut target, value)
                    }
                    fn locked(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::locked(&target)
                    }
                    fn set_children(
                        &mut self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_children(&mut target, value)
                    }
                    fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::children(&target)
                    }
                    fn copy_attributes(
                        &self,
                        source: Item,
                        exclude_matrix: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_attributes(&target, source, exclude_matrix)
                    }
                    fn off(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::off(&target, object)
                    }
                    fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::contains(&target, point)
                    }
                    fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_stroke(&target)
                    }
                    fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_move(&target)
                    }
                    fn add_children(
                        &self,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::add_children(&target, items)
                    }
                    fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::reverse_children(&target)
                    }
                    fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_shadow(&target)
                    }
                    fn set_dash_offset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_dash_offset(&mut target, value)
                    }
                    fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::dash_offset(&target)
                    }
                    fn set_on_mouse_leave(
                        &mut self,
                        value: ItemOnMouseLeave,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_leave(&mut target, value)
                    }
                    fn on_mouse_leave(&self) -> std::result::Result<ItemOnMouseLeave, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_leave(&target)
                    }
                    fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test_all(&target, point, options)
                    }
                    fn set_stroke_cap(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_cap(&mut target, value)
                    }
                    fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_cap(&target)
                    }
                    fn set_internal_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_internal_bounds(&mut target, value)
                    }
                    fn internal_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::internal_bounds(&target)
                    }
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_index(&mut target, value)
                    }
                    fn index(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::index(&target)
                    }
                    fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::reduce(&target, options)
                    }
                    fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_grouped_with(&target, item)
                    }
                    fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_global(&target, point)
                    }
                    fn set_first_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_first_child(&mut target, value)
                    }
                    fn first_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::first_child(&target)
                    }
                    fn set_position(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_position(&mut target, value)
                    }
                    fn position(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::position(&target)
                    }
                    fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_opacity(&mut target, value)
                    }
                    fn opacity(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::opacity(&target)
                    }
                    fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_down(&target)
                    }
                    fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_drag(&target)
                    }
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_bounds(&mut target, value)
                    }
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::bounds(&target)
                    }
                    fn set_parent(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_parent(&mut target, value)
                    }
                    fn parent(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::parent(&target)
                    }
                    fn get_items(
                        &self,
                        options: ItemGetItemsParamsOptionsParam,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::get_items(&target, options)
                    }
                    fn copy_to(
                        &self,
                        owner: ItemCopyToParamsOwnerParam,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::copy_to(&target, owner)
                    }
                    fn set_on_double_click(
                        &mut self,
                        value: ItemOnDoubleClick,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_double_click(&mut target, value)
                    }
                    fn on_double_click(&self) -> std::result::Result<ItemOnDoubleClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_double_click(&target)
                    }
                    fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::set(&target, props)
                    }
                    fn scale(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::scale(&target, hor, ver, center)
                    }
                    fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_below(&target, item)
                    }
                    fn set_next_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_next_sibling(&mut target, value)
                    }
                    fn next_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::next_sibling(&target)
                    }
                    fn rasterize(&self, options: JsValue) -> std::result::Result<Raster, JsValue> {
                        let target: Item = self.into();
                        Item::rasterize(&target, options)
                    }
                    fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::bring_to_front(&target)
                    }
                    fn matches(
                        &self,
                        name: String,
                        compare: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::matches(&target, name, compare)
                    }
                    fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_fill(&target)
                    }
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_view(&mut target, value)
                    }
                    fn view(&self) -> std::result::Result<View, JsValue> {
                        let target: Item = self.into();
                        Item::view(&target)
                    }
                    fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::clone(&target, options)
                    }
                    fn set_handle_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_handle_bounds(&mut target, value)
                    }
                    fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::handle_bounds(&target)
                    }
                    fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inside(&target, rect)
                    }
                    fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_above(&target, item)
                    }
                    fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::remove(&target)
                    }
                    fn set_stroke_join(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_join(&mut target, value)
                    }
                    fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_join(&target)
                    }
                    fn set_on_click(
                        &mut self,
                        value: ItemOnClick,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_click(&mut target, value)
                    }
                    fn on_click(&self) -> std::result::Result<ItemOnClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_click(&target)
                    }
                    fn fit_bounds(
                        &self,
                        rectangle: Rectangle,
                        fill: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::fit_bounds(&target, rectangle, fill)
                    }
                    fn set_blend_mode(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_blend_mode(&mut target, value)
                    }
                    fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::blend_mode(&target)
                    }
                    fn set_stroke_width(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_width(&mut target, value)
                    }
                    fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_width(&target)
                    }
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_rotation(&mut target, value)
                    }
                    fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::rotation(&target)
                    }
                    fn set_selected_color(
                        &mut self,
                        value: ItemSelectedColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_selected_color(&mut target, value)
                    }
                    fn selected_color(&self) -> std::result::Result<ItemSelectedColor, JsValue> {
                        let target: Item = self.into();
                        Item::selected_color(&target)
                    }
                    fn skew(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::skew(&target, hor, ver, center)
                    }
                    fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_name(&mut target, value)
                    }
                    fn name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::name(&target)
                    }
                    fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_json(&target, json)
                    }
                    fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::add_child(&target, item)
                    }
                    fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_visible(&mut target, value)
                    }
                    fn visible(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::visible(&target)
                    }
                    fn set_fill_rule(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_fill_rule(&mut target, value)
                    }
                    fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::fill_rule(&target)
                    }
                    fn set_layer(&mut self, value: Layer) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_layer(&mut target, value)
                    }
                    fn layer(&self) -> std::result::Result<Layer, JsValue> {
                        let target: Item = self.into();
                        Item::layer(&target)
                    }
                    fn tween_from(
                        &self,
                        from: JsValue,
                        options: ItemTweenFromParamsOptionsParam,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_from(&target, from, options)
                    }
                    fn insert_child(
                        &self,
                        index: f64,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_child(&target, index, item)
                    }
                    fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_up(&target)
                    }
                    fn set_pivot(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_pivot(&mut target, value)
                    }
                    fn pivot(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::pivot(&target)
                    }
                    fn set_miter_limit(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_miter_limit(&mut target, value)
                    }
                    fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::miter_limit(&target)
                    }
                    fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_content(&target, source)
                    }
                    fn import_svg(
                        &self,
                        svg: ItemImportSvgParamsSvgParam,
                        on_load: &'static dyn Fn(
                            Box<[JsValue]>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_svg(&target, svg, on_load)
                    }
                    fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::send_to_back(&target)
                    }
                    fn set_stroke_color(
                        &mut self,
                        value: ItemStrokeColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_color(&mut target, value)
                    }
                    fn stroke_color(&self) -> std::result::Result<ItemStrokeColor, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_color(&target)
                    }
                    fn set_on_mouse_move(
                        &mut self,
                        value: ItemOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_move(&mut target, value)
                    }
                    fn on_mouse_move(&self) -> std::result::Result<ItemOnMouseMove, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_move(&target)
                    }
                    fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::replace_with(&target, item)
                    }
                    fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test(&target, point, options)
                    }
                    fn shear(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::shear(&target, hor, ver, center)
                    }
                    fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::translate(&target, delta)
                    }
                    fn set_stroke_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_stroke_bounds(&mut target, value)
                    }
                    fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_bounds(&target)
                    }
                    fn insert_children(
                        &self,
                        index: f64,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::insert_children(&target, index, items)
                    }
                    fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_child(&target, item)
                    }
                    fn set_shadow_offset(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_shadow_offset(&mut target, value)
                    }
                    fn shadow_offset(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_offset(&target)
                    }
                    fn set_fill_color(
                        &mut self,
                        value: ItemFillColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_fill_color(&mut target, value)
                    }
                    fn fill_color(&self) -> std::result::Result<ItemFillColor, JsValue> {
                        let target: Item = self.into();
                        Item::fill_color(&target)
                    }
                    fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                        let target: Item = self.into();
                        Item::export_svg(&target, options)
                    }
                    fn set_style(&mut self, value: Style) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_style(&mut target, value)
                    }
                    fn style(&self) -> std::result::Result<Style, JsValue> {
                        let target: Item = self.into();
                        Item::style(&target)
                    }
                    fn set_clip_mask(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_clip_mask(&mut target, value)
                    }
                    fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::clip_mask(&target)
                    }
                    fn set_class_name(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_class_name(&mut target, value)
                    }
                    fn class_name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::class_name(&target)
                    }
                    fn set_on_mouse_up(
                        &mut self,
                        value: ItemOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_mouse_up(&mut target, value)
                    }
                    fn on_mouse_up(&self) -> std::result::Result<ItemOnMouseUp, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_up(&target)
                    }
                    fn set_on_frame(
                        &mut self,
                        value: ItemOnFrame,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_on_frame(&mut target, value)
                    }
                    fn on_frame(&self) -> std::result::Result<ItemOnFrame, JsValue> {
                        let target: Item = self.into();
                        Item::on_frame(&target)
                    }
                    fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::parent_to_local(&target, point)
                    }
                    fn set_previous_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_previous_sibling(&mut target, value)
                    }
                    fn previous_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::previous_sibling(&target)
                    }
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::emit(&target, type_, event)
                    }
                    fn add_to(
                        &self,
                        owner: ItemAddToParamsOwnerParam,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::add_to(&target, owner)
                    }
                    fn has_children(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_children(&target)
                    }
                    fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::intersects(&target, item)
                    }
                    fn set_shadow_color(
                        &mut self,
                        value: ItemShadowColor,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_shadow_color(&mut target, value)
                    }
                    fn shadow_color(&self) -> std::result::Result<ItemShadowColor, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_color(&target)
                    }
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let mut target: Item = self.into();
                        Item::set_scaling(&mut target, value)
                    }
                    fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::scaling(&target)
                    }
                }
                impl PathItem_Trait for PathItem
                where
                    PathItem: Item_Trait,
                {
                    fn reverse(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::reverse(&target)
                    }
                    fn get_nearest_location(
                        &self,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let target = self;
                        PathItem::get_nearest_location(&target, point)
                    }
                    fn smooth(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::smooth(&target, options)
                    }
                    fn arc_to(
                        &self,
                        to: Point,
                        clockwise: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::arc_to(&target, to, clockwise)
                    }
                    fn line_to(&self, point: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::line_to(&target, point)
                    }
                    fn cubic_curve_by(
                        &self,
                        handle1: Point,
                        handle2: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::cubic_curve_by(&target, handle1, handle2, to)
                    }
                    fn divide(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target = self;
                        PathItem::divide(&target, path, options)
                    }
                    fn quadratic_curve_by(
                        &self,
                        handle: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::quadratic_curve_by(&target, handle, to)
                    }
                    fn create(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<PathItemCreateReturn, JsValue> {
                        let target = self;
                        PathItem::create(&target, object)
                    }
                    fn interpolate(
                        &self,
                        from: PathItem,
                        to: PathItem,
                        factor: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::interpolate(&target, from, to, factor)
                    }
                    fn set_clockwise(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        PathItem::set_clockwise(&mut target, value)
                    }
                    fn clockwise(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        PathItem::clockwise(&target)
                    }
                    fn set_path_data(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        PathItem::set_path_data(&mut target, value)
                    }
                    fn path_data(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        PathItem::path_data(&target)
                    }
                    fn curve_to(
                        &self,
                        through: Point,
                        to: Point,
                        time: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::curve_to(&target, through, to, time)
                    }
                    fn move_to(&self, point: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::move_to(&target, point)
                    }
                    fn get_crossings(
                        &self,
                        path: PathItem,
                    ) -> std::result::Result<Vec<CurveLocation>, JsValue> {
                        let target = self;
                        PathItem::get_crossings(&target, path)
                    }
                    fn close_path(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::close_path(&target)
                    }
                    fn reorient(
                        &self,
                        non_zero: bool,
                        clockwise: bool,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target = self;
                        PathItem::reorient(&target, non_zero, clockwise)
                    }
                    fn move_by(&self, to: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::move_by(&target, to)
                    }
                    fn quadratic_curve_to(
                        &self,
                        handle: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::quadratic_curve_to(&target, handle, to)
                    }
                    fn cubic_curve_to(
                        &self,
                        handle1: Point,
                        handle2: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::cubic_curve_to(&target, handle1, handle2, to)
                    }
                    fn get_intersections(
                        &self,
                        path: PathItem,
                        include: &'static dyn Fn(
                            Box<[JsValue]>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Vec<CurveLocation>, JsValue> {
                        let target = self;
                        PathItem::get_intersections(&target, path, include)
                    }
                    fn compare(&self, path: PathItem) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        PathItem::compare(&target, path)
                    }
                    fn set_interior_point(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let mut target = self;
                        PathItem::set_interior_point(&mut target, value)
                    }
                    fn interior_point(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        PathItem::interior_point(&target)
                    }
                    fn simplify(&self, tolerance: f64) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        PathItem::simplify(&target, tolerance)
                    }
                    fn arc_by(
                        &self,
                        to: Point,
                        clockwise: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::arc_by(&target, to, clockwise)
                    }
                    fn intersect(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target = self;
                        PathItem::intersect(&target, path, options)
                    }
                    fn get_nearest_point(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        PathItem::get_nearest_point(&target, point)
                    }
                    fn curve_by(
                        &self,
                        through: Point,
                        to: Point,
                        time: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::curve_by(&target, through, to, time)
                    }
                    fn exclude(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target = self;
                        PathItem::exclude(&target, path, options)
                    }
                    fn line_by(&self, point: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::line_by(&target, point)
                    }
                    fn unite(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target = self;
                        PathItem::unite(&target, path, options)
                    }
                    fn subtract(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target = self;
                        PathItem::subtract(&target, path, options)
                    }
                    fn flatten(&self, flatness: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::flatten(&target, flatness)
                    }
                }
                impl std::clone::Clone for PathItem_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for PathItem_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for PathItem_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewOnClick {
                    TsBindgenRtNullCase,
                    #[serde(
                        serialize_with = "ViewOnClick::__TSB__serialize_fn_js_value_js_value_case",
                        deserialize_with = "ViewOnClick::__TSB__deserialize_fn_js_value_js_value_case"
                    )]
                    FnJsValueJsValueCase(
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                    ),
                }
                impl ViewOnClick {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_fn_js_value_js_value_case<S>(
                        fn_js_value_js_value_case: &std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let fn_js_value_js_value_case = fn_js_value_js_value_case.clone();
                        let fn_js_value_js_value_case = Closure :: wrap (Box :: new (move | _Variadic0_args : JsValue , _Variadic1_args : JsValue , _Variadic2_args : JsValue , _Variadic3_args : JsValue , _Variadic4_args : JsValue , _Variadic5_args : JsValue , _Variadic6_args : JsValue | -> std :: result :: Result < JsValue , JsValue > { let args : Box < [JsValue] > = Box :: new ([_Variadic0_args , _Variadic1_args , _Variadic2_args , _Variadic3_args , _Variadic4_args , _Variadic5_args , _Variadic6_args]) ; fn_js_value_js_value_case (args) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                            serializer,
                            &fn_js_value_js_value_case.into_js_value(),
                        );
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_fn_js_value_js_value_case<'de, D>(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<
                            dyn Fn(Box<[JsValue]>) -> std::result::Result<JsValue, JsValue>,
                        >,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let fn_js_value_js_value_case: Option<&js_sys::Function> =
                            wasm_bindgen::JsCast::dyn_ref(&jsv);
                        Ok(fn_js_value_js_value_case
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |args: Box<[JsValue]>| {
                                    let args = {
                                        let args_Array = js_sys::Array::new();
                                        for args in args.into_iter() {
                                            args_Array.push(&JsValue::from(args));
                                        }
                                        args_Array
                                    };
                                    let _Args = js_sys::Array::new();
                                    for args in args.values().into_iter() {
                                        _Args.push(&args?);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Box<[JsValue]>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)?)
                    }
                }
                #[cfg(target_family = "wasm")]
                pub mod path {
                    #[allow(unused)]
                    use super::*;
                    #[allow(unused)]
                    use wasm_bindgen::prelude::*;
                    #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                    extern "C" {
                        # [wasm_bindgen (js_name = "Line" , extends = Path_Class , extends = PathItem_Class , extends = Item_Class)]
                        pub type Line_Class;
                        #[wasm_bindgen(constructor, js_class = "Line")]
                        pub fn new(object: JsValue) -> Line_Class;
                    }
                    #[derive(std :: clone :: Clone)]
                    pub struct Line(pub Line_Class);
                    impl std::convert::From<&Line> for super::Path {
                        fn from(src: &Line) -> super::Path {
                            let src: &super::Path_Class = src.0.as_ref();
                            super::Path(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Line> for super::Path {
                        fn from(src: &mut Line) -> super::Path {
                            let src: &super::Path_Class = src.0.as_ref();
                            super::Path(src.clone())
                        }
                    }
                    impl std::convert::From<&Line> for super::Item {
                        fn from(src: &Line) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Line> for super::Item {
                        fn from(src: &mut Line) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&Line> for super::PathItem {
                        fn from(src: &Line) -> super::PathItem {
                            let src: &super::PathItem_Class = src.0.as_ref();
                            super::PathItem(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Line> for super::PathItem {
                        fn from(src: &mut Line) -> super::PathItem {
                            let src: &super::PathItem_Class = src.0.as_ref();
                            super::PathItem(src.clone())
                        }
                    }
                    impl Line {
                        #[allow(dead_code)]
                        pub fn new(object: JsValue) -> Line {
                            let result = Line_Class::new(object);
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            Line(result)
                        }
                    }
                    impl wasm_bindgen::describe::WasmDescribe for Line {
                        fn describe() {
                            <Line_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                        }
                    }
                    impl wasm_bindgen::convert::IntoWasmAbi for Line {
                        type Abi = <Line_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                        }
                    }
                    impl wasm_bindgen::convert::FromWasmAbi for Line {
                        type Abi = <Line_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                        unsafe fn from_abi(js: Self::Abi) -> Self {
                            Line(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                        }
                    }
                    impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Line {
                        type Abi = <&'a Line_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                        }
                    }
                    impl serde::ser::Serialize for Line {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde::ser::Serialize::serialize(&self.0, serializer)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Line {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            let internal: Line_Class =
                                <Line_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                            std::result::Result::Ok(Self(internal))
                        }
                    }
                    #[allow(non_camel_case_types)]
                    pub trait Line_Trait: Path_Trait {}
                    impl Path_Trait for Line
                    where
                        Line: PathItem_Trait,
                    {
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::reduce(&target, options)
                        }
                        fn get_curvature_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_curvature_at(&target, offset)
                        }
                        fn set_last_curve(
                            &mut self,
                            value: super::Curve,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_last_curve(&mut target, value)
                        }
                        fn last_curve(&self) -> std::result::Result<super::Curve, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::last_curve(&target)
                        }
                        fn split_at(
                            &self,
                            location: super::PathSplitAtParamsLocationParam,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::split_at(&target, location)
                        }
                        fn set_area(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_area(&mut target, value)
                        }
                        fn area(&self) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::area(&target)
                        }
                        fn divide_at(
                            &self,
                            location: super::PathDivideAtParamsLocationParam,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::divide_at(&target, location)
                        }
                        fn get_offsets_with_tangent(
                            &self,
                            tangent: super::Point,
                        ) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_offsets_with_tangent(&target, tangent)
                        }
                        fn set_first_segment(
                            &mut self,
                            value: super::Segment,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_first_segment(&mut target, value)
                        }
                        fn first_segment(&self) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::first_segment(&target)
                        }
                        fn set_first_curve(
                            &mut self,
                            value: super::Curve,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_first_curve(&mut target, value)
                        }
                        fn first_curve(&self) -> std::result::Result<super::Curve, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::first_curve(&target)
                        }
                        fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::has_handles(&target)
                        }
                        fn get_normal_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_normal_at(&target, offset)
                        }
                        fn set_last_segment(
                            &mut self,
                            value: super::Segment,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_last_segment(&mut target, value)
                        }
                        fn last_segment(&self) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::last_segment(&target)
                        }
                        fn get_tangent_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_tangent_at(&target, offset)
                        }
                        fn get_weighted_tangent_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_weighted_tangent_at(&target, offset)
                        }
                        fn get_offset_of(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_offset_of(&target, point)
                        }
                        fn insert(
                            &self,
                            index: f64,
                            segment: super::PathInsertParamsSegmentParam,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::insert(&target, index, segment)
                        }
                        fn insert_segments(
                            &self,
                            index: f64,
                            segments: Vec<Segment>,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::insert_segments(&target, index, segments)
                        }
                        fn get_location_of(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::get_location_of(&target, point)
                        }
                        fn get_weighted_normal_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_weighted_normal_at(&target, offset)
                        }
                        fn set_closed(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_closed(&mut target, value)
                        }
                        fn closed(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::closed(&target)
                        }
                        fn add(
                            &self,
                            segment: Box<[super::PathAddParamsSegmentParam]>,
                        ) -> std::result::Result<super::PathAddReturn, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::add(&target, segment)
                        }
                        fn set_length(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_length(&mut target, value)
                        }
                        fn length(&self) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::length(&target)
                        }
                        fn to_shape(
                            &self,
                            insert: bool,
                        ) -> std::result::Result<super::Shape, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::to_shape(&target, insert)
                        }
                        fn get_location_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::get_location_at(&target, offset)
                        }
                        fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::clear_handles(&target)
                        }
                        fn remove_segment(
                            &self,
                            index: f64,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segment(&target, index)
                        }
                        fn set_segments(
                            &mut self,
                            value: Vec<Segment>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_segments(&mut target, value)
                        }
                        fn segments(&self) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::segments(&target)
                        }
                        fn remove_segments(
                            &self,
                            from: f64,
                            to: f64,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segments(&target, from, to)
                        }
                        fn get_point_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_point_at(&target, offset)
                        }
                        fn add_segments(
                            &self,
                            segments: Vec<Segment>,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::add_segments(&target, segments)
                        }
                        fn join(
                            &self,
                            path: super::Path,
                            tolerance: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::join(&target, path, tolerance)
                        }
                        fn set_curves(
                            &mut self,
                            value: Vec<Curve>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_curves(&mut target, value)
                        }
                        fn curves(&self) -> std::result::Result<Vec<Curve>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::curves(&target)
                        }
                        fn set_fully_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_fully_selected(&mut target, value)
                        }
                        fn fully_selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::fully_selected(&target)
                        }
                    }
                    impl PathItem_Trait for Line
                    where
                        Line: Item_Trait,
                    {
                        fn reverse(&self) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::reverse(&target)
                        }
                        fn get_nearest_location(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_nearest_location(&target, point)
                        }
                        fn smooth(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::smooth(&target, options)
                        }
                        fn arc_to(
                            &self,
                            to: super::Point,
                            clockwise: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_to(&target, to, clockwise)
                        }
                        fn line_to(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::line_to(&target, point)
                        }
                        fn cubic_curve_by(
                            &self,
                            handle1: super::Point,
                            handle2: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::cubic_curve_by(&target, handle1, handle2, to)
                        }
                        fn divide(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::divide(&target, path, options)
                        }
                        fn quadratic_curve_by(
                            &self,
                            handle: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::quadratic_curve_by(&target, handle, to)
                        }
                        fn create(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<super::PathItemCreateReturn, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::create(&target, object)
                        }
                        fn interpolate(
                            &self,
                            from: super::PathItem,
                            to: super::PathItem,
                            factor: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::interpolate(&target, from, to, factor)
                        }
                        fn set_clockwise(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: PathItem = self.into();
                            super::PathItem::set_clockwise(&mut target, value)
                        }
                        fn clockwise(&self) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::clockwise(&target)
                        }
                        fn set_path_data(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: PathItem = self.into();
                            super::PathItem::set_path_data(&mut target, value)
                        }
                        fn path_data(&self) -> std::result::Result<String, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::path_data(&target)
                        }
                        fn curve_to(
                            &self,
                            through: super::Point,
                            to: super::Point,
                            time: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::curve_to(&target, through, to, time)
                        }
                        fn move_to(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::move_to(&target, point)
                        }
                        fn get_crossings(
                            &self,
                            path: super::PathItem,
                        ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_crossings(&target, path)
                        }
                        fn close_path(&self) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::close_path(&target)
                        }
                        fn reorient(
                            &self,
                            non_zero: bool,
                            clockwise: bool,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::reorient(&target, non_zero, clockwise)
                        }
                        fn move_by(&self, to: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::move_by(&target, to)
                        }
                        fn quadratic_curve_to(
                            &self,
                            handle: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::quadratic_curve_to(&target, handle, to)
                        }
                        fn cubic_curve_to(
                            &self,
                            handle1: super::Point,
                            handle2: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::cubic_curve_to(&target, handle1, handle2, to)
                        }
                        fn get_intersections(
                            &self,
                            path: super::PathItem,
                            include: &'static dyn Fn(
                                Box<[JsValue]>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_intersections(&target, path, include)
                        }
                        fn compare(
                            &self,
                            path: super::PathItem,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::compare(&target, path)
                        }
                        fn set_interior_point(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: PathItem = self.into();
                            super::PathItem::set_interior_point(&mut target, value)
                        }
                        fn interior_point(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::interior_point(&target)
                        }
                        fn simplify(&self, tolerance: f64) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::simplify(&target, tolerance)
                        }
                        fn arc_by(
                            &self,
                            to: super::Point,
                            clockwise: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_by(&target, to, clockwise)
                        }
                        fn intersect(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::intersect(&target, path, options)
                        }
                        fn get_nearest_point(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::get_nearest_point(&target, point)
                        }
                        fn curve_by(
                            &self,
                            through: super::Point,
                            to: super::Point,
                            time: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::curve_by(&target, through, to, time)
                        }
                        fn exclude(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::exclude(&target, path, options)
                        }
                        fn line_by(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::line_by(&target, point)
                        }
                        fn unite(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::unite(&target, path, options)
                        }
                        fn subtract(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::subtract(&target, path, options)
                        }
                        fn flatten(&self, flatness: f64) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::flatten(&target, flatness)
                        }
                    }
                    impl Item_Trait for Line {
                        fn set_stroke_scaling(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_scaling(&mut target, value)
                        }
                        fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_scaling(&target)
                        }
                        fn set_apply_matrix(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_apply_matrix(&mut target, value)
                        }
                        fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::apply_matrix(&target)
                        }
                        fn set_view_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_view_matrix(&mut target, value)
                        }
                        fn view_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::view_matrix(&target)
                        }
                        fn set_dash_array(
                            &mut self,
                            value: Vec<f64>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_dash_array(&mut target, value)
                        }
                        fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_array(&target)
                        }
                        fn is_ancestor(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_ancestor(&target, item)
                        }
                        fn is_descendant(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_descendant(&target, item)
                        }
                        fn is_sibling(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_sibling(&target, item)
                        }
                        fn local_to_parent(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_parent(&target, point)
                        }
                        fn set_shadow_blur(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_shadow_blur(&mut target, value)
                        }
                        fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_blur(&target)
                        }
                        fn is_empty(
                            &self,
                            recursively: bool,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_empty(&target, recursively)
                        }
                        fn is_parent(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_parent(&target, item)
                        }
                        fn is_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_below(&target, item)
                        }
                        fn set_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_matrix(&mut target, value)
                        }
                        fn matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::matrix(&target)
                        }
                        fn export_json(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::export_json(&target, options)
                        }
                        fn global_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_to_local(&target, point)
                        }
                        fn set_on_mouse_drag(
                            &mut self,
                            value: super::ItemOnMouseDrag,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_drag(&mut target, value)
                        }
                        fn on_mouse_drag(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDrag, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_drag(&target)
                        }
                        fn get_item(
                            &self,
                            options: super::ItemGetItemParamsOptionsParam,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_item(&target, options)
                        }
                        fn remove_children(
                            &self,
                            start: f64,
                            end: f64,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_children(&target, start, end)
                        }
                        fn set_project(
                            &mut self,
                            value: super::Project,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_project(&mut target, value)
                        }
                        fn project(&self) -> std::result::Result<super::Project, JsValue> {
                            let target: Item = self.into();
                            super::Item::project(&target)
                        }
                        fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_data(&mut target, value)
                        }
                        fn data(&self) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::data(&target)
                        }
                        fn insert_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_above(&target, item)
                        }
                        fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on(&target, options)
                        }
                        fn transform(
                            &self,
                            matrix: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::transform(&target, matrix)
                        }
                        fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inserted(&target)
                        }
                        fn set_on_mouse_down(
                            &mut self,
                            value: super::ItemOnMouseDown,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_down(&mut target, value)
                        }
                        fn on_mouse_down(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDown, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_down(&target)
                        }
                        fn set_last_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_last_child(&mut target, value)
                        }
                        fn last_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::last_child(&target)
                        }
                        fn set_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_selected(&mut target, value)
                        }
                        fn selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::selected(&target)
                        }
                        fn set_global_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_global_matrix(&mut target, value)
                        }
                        fn global_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_matrix(&target)
                        }
                        fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::responds(&target, type_)
                        }
                        fn rotate(
                            &self,
                            angle: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::rotate(&target, angle, center)
                        }
                        fn tween(
                            &self,
                            options: super::ItemTweenParamsOptionsParam,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween(&target, options)
                        }
                        fn set_on_mouse_enter(
                            &mut self,
                            value: super::ItemOnMouseEnter,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_enter(&mut target, value)
                        }
                        fn on_mouse_enter(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseEnter, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_enter(&target)
                        }
                        fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_id(&mut target, value)
                        }
                        fn id(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::id(&target)
                        }
                        fn on(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::on(&target, object)
                        }
                        fn tween_to(
                            &self,
                            to: JsValue,
                            options: super::ItemTweenToParamsOptionsParam,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_to(&target, to, options)
                        }
                        fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_locked(&mut target, value)
                        }
                        fn locked(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::locked(&target)
                        }
                        fn set_children(
                            &mut self,
                            value: Vec<Item>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_children(&mut target, value)
                        }
                        fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::children(&target)
                        }
                        fn copy_attributes(
                            &self,
                            source: super::Item,
                            exclude_matrix: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_attributes(&target, source, exclude_matrix)
                        }
                        fn off(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::off(&target, object)
                        }
                        fn contains(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::contains(&target, point)
                        }
                        fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_stroke(&target)
                        }
                        fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_move(&target)
                        }
                        fn add_children(
                            &self,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_children(&target, items)
                        }
                        fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::reverse_children(&target)
                        }
                        fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_shadow(&target)
                        }
                        fn set_dash_offset(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_dash_offset(&mut target, value)
                        }
                        fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_offset(&target)
                        }
                        fn set_on_mouse_leave(
                            &mut self,
                            value: super::ItemOnMouseLeave,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_leave(&mut target, value)
                        }
                        fn on_mouse_leave(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseLeave, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_leave(&target)
                        }
                        fn hit_test_all(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<Vec<HitResult>, JsValue> {
                            let target: Item = self.into();
                            super::Item::hit_test_all(&target, point, options)
                        }
                        fn set_stroke_cap(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_cap(&mut target, value)
                        }
                        fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_cap(&target)
                        }
                        fn set_internal_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_internal_bounds(&mut target, value)
                        }
                        fn internal_bounds(
                            &self,
                        ) -> std::result::Result<super::Rectangle, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::internal_bounds(&target)
                        }
                        fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_index(&mut target, value)
                        }
                        fn index(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::index(&target)
                        }
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::reduce(&target, options)
                        }
                        fn is_grouped_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_grouped_with(&target, item)
                        }
                        fn local_to_global(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_global(&target, point)
                        }
                        fn set_first_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_first_child(&mut target, value)
                        }
                        fn first_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::first_child(&target)
                        }
                        fn set_position(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_position(&mut target, value)
                        }
                        fn position(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::position(&target)
                        }
                        fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_opacity(&mut target, value)
                        }
                        fn opacity(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::opacity(&target)
                        }
                        fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_down(&target)
                        }
                        fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_drag(&target)
                        }
                        fn set_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_bounds(&mut target, value)
                        }
                        fn bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::bounds(&target)
                        }
                        fn set_parent(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_parent(&mut target, value)
                        }
                        fn parent(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent(&target)
                        }
                        fn get_items(
                            &self,
                            options: super::ItemGetItemsParamsOptionsParam,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_items(&target, options)
                        }
                        fn copy_to(
                            &self,
                            owner: super::ItemCopyToParamsOwnerParam,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_to(&target, owner)
                        }
                        fn set_on_double_click(
                            &mut self,
                            value: super::ItemOnDoubleClick,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_double_click(&mut target, value)
                        }
                        fn on_double_click(
                            &self,
                        ) -> std::result::Result<super::ItemOnDoubleClick, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_double_click(&target)
                        }
                        fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::set(&target, props)
                        }
                        fn scale(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::scale(&target, hor, ver, center)
                        }
                        fn insert_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_below(&target, item)
                        }
                        fn set_next_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_next_sibling(&mut target, value)
                        }
                        fn next_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::next_sibling(&target)
                        }
                        fn rasterize(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Raster, JsValue> {
                            let target: Item = self.into();
                            super::Item::rasterize(&target, options)
                        }
                        fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::bring_to_front(&target)
                        }
                        fn matches(
                            &self,
                            name: String,
                            compare: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::matches(&target, name, compare)
                        }
                        fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_fill(&target)
                        }
                        fn set_view(
                            &mut self,
                            value: super::View,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_view(&mut target, value)
                        }
                        fn view(&self) -> std::result::Result<super::View, JsValue> {
                            let target: Item = self.into();
                            super::Item::view(&target)
                        }
                        fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::clone(&target, options)
                        }
                        fn set_handle_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_handle_bounds(&mut target, value)
                        }
                        fn handle_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::handle_bounds(&target)
                        }
                        fn is_inside(
                            &self,
                            rect: super::Rectangle,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inside(&target, rect)
                        }
                        fn is_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_above(&target, item)
                        }
                        fn remove(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove(&target)
                        }
                        fn set_stroke_join(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_join(&mut target, value)
                        }
                        fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_join(&target)
                        }
                        fn set_on_click(
                            &mut self,
                            value: super::ItemOnClick,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_click(&mut target, value)
                        }
                        fn on_click(&self) -> std::result::Result<super::ItemOnClick, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_click(&target)
                        }
                        fn fit_bounds(
                            &self,
                            rectangle: super::Rectangle,
                            fill: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::fit_bounds(&target, rectangle, fill)
                        }
                        fn set_blend_mode(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_blend_mode(&mut target, value)
                        }
                        fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::blend_mode(&target)
                        }
                        fn set_stroke_width(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_width(&mut target, value)
                        }
                        fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_width(&target)
                        }
                        fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_rotation(&mut target, value)
                        }
                        fn rotation(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::rotation(&target)
                        }
                        fn set_selected_color(
                            &mut self,
                            value: super::ItemSelectedColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_selected_color(&mut target, value)
                        }
                        fn selected_color(
                            &self,
                        ) -> std::result::Result<super::ItemSelectedColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::selected_color(&target)
                        }
                        fn skew(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::skew(&target, hor, ver, center)
                        }
                        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_name(&mut target, value)
                        }
                        fn name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::name(&target)
                        }
                        fn import_json(
                            &self,
                            json: String,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_json(&target, json)
                        }
                        fn add_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_child(&target, item)
                        }
                        fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_visible(&mut target, value)
                        }
                        fn visible(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::visible(&target)
                        }
                        fn set_fill_rule(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_fill_rule(&mut target, value)
                        }
                        fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_rule(&target)
                        }
                        fn set_layer(
                            &mut self,
                            value: super::Layer,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_layer(&mut target, value)
                        }
                        fn layer(&self) -> std::result::Result<super::Layer, JsValue> {
                            let target: Item = self.into();
                            super::Item::layer(&target)
                        }
                        fn tween_from(
                            &self,
                            from: JsValue,
                            options: super::ItemTweenFromParamsOptionsParam,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_from(&target, from, options)
                        }
                        fn insert_child(
                            &self,
                            index: f64,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_child(&target, index, item)
                        }
                        fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_up(&target)
                        }
                        fn set_pivot(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_pivot(&mut target, value)
                        }
                        fn pivot(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::pivot(&target)
                        }
                        fn set_miter_limit(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_miter_limit(&mut target, value)
                        }
                        fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::miter_limit(&target)
                        }
                        fn copy_content(
                            &self,
                            source: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_content(&target, source)
                        }
                        fn import_svg(
                            &self,
                            svg: super::ItemImportSvgParamsSvgParam,
                            on_load: &'static dyn Fn(
                                Box<[JsValue]>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_svg(&target, svg, on_load)
                        }
                        fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::send_to_back(&target)
                        }
                        fn set_stroke_color(
                            &mut self,
                            value: super::ItemStrokeColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_color(&mut target, value)
                        }
                        fn stroke_color(
                            &self,
                        ) -> std::result::Result<super::ItemStrokeColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::stroke_color(&target)
                        }
                        fn set_on_mouse_move(
                            &mut self,
                            value: super::ItemOnMouseMove,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_move(&mut target, value)
                        }
                        fn on_mouse_move(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseMove, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_move(&target)
                        }
                        fn replace_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::replace_with(&target, item)
                        }
                        fn hit_test(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<super::HitResult, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::hit_test(&target, point, options)
                        }
                        fn shear(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::shear(&target, hor, ver, center)
                        }
                        fn translate(
                            &self,
                            delta: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::translate(&target, delta)
                        }
                        fn set_stroke_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_bounds(&mut target, value)
                        }
                        fn stroke_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_bounds(&target)
                        }
                        fn insert_children(
                            &self,
                            index: f64,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_children(&target, index, items)
                        }
                        fn is_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_child(&target, item)
                        }
                        fn set_shadow_offset(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_shadow_offset(&mut target, value)
                        }
                        fn shadow_offset(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_offset(&target)
                        }
                        fn set_fill_color(
                            &mut self,
                            value: super::ItemFillColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_fill_color(&mut target, value)
                        }
                        fn fill_color(&self) -> std::result::Result<super::ItemFillColor, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_color(&target)
                        }
                        fn export_svg(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::ItemExportSvgReturn, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::export_svg(&target, options)
                        }
                        fn set_style(
                            &mut self,
                            value: super::Style,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_style(&mut target, value)
                        }
                        fn style(&self) -> std::result::Result<super::Style, JsValue> {
                            let target: Item = self.into();
                            super::Item::style(&target)
                        }
                        fn set_clip_mask(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_clip_mask(&mut target, value)
                        }
                        fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::clip_mask(&target)
                        }
                        fn set_class_name(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_class_name(&mut target, value)
                        }
                        fn class_name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::class_name(&target)
                        }
                        fn set_on_mouse_up(
                            &mut self,
                            value: super::ItemOnMouseUp,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_up(&mut target, value)
                        }
                        fn on_mouse_up(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseUp, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_up(&target)
                        }
                        fn set_on_frame(
                            &mut self,
                            value: super::ItemOnFrame,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_frame(&mut target, value)
                        }
                        fn on_frame(&self) -> std::result::Result<super::ItemOnFrame, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_frame(&target)
                        }
                        fn parent_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent_to_local(&target, point)
                        }
                        fn set_previous_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_previous_sibling(&mut target, value)
                        }
                        fn previous_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::previous_sibling(&target)
                        }
                        fn emit(
                            &self,
                            type_: String,
                            event: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::emit(&target, type_, event)
                        }
                        fn add_to(
                            &self,
                            owner: super::ItemAddToParamsOwnerParam,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_to(&target, owner)
                        }
                        fn has_children(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_children(&target)
                        }
                        fn intersects(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::intersects(&target, item)
                        }
                        fn set_shadow_color(
                            &mut self,
                            value: super::ItemShadowColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_shadow_color(&mut target, value)
                        }
                        fn shadow_color(
                            &self,
                        ) -> std::result::Result<super::ItemShadowColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::shadow_color(&target)
                        }
                        fn set_scaling(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_scaling(&mut target, value)
                        }
                        fn scaling(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::scaling(&target)
                        }
                    }
                    impl Line_Trait for Line where Line: Path_Trait {}
                    impl std::clone::Clone for Line_Class {
                        fn clone(&self) -> Self {
                            Self {
                                obj: std::clone::Clone::clone(&self.obj),
                            }
                        }
                    }
                    impl serde::ser::Serialize for Line_Class {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Line_Class {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                        }
                    }
                    #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                    extern "C" {
                        # [wasm_bindgen (js_name = "Star" , extends = Item_Class , extends = Path_Class , extends = PathItem_Class)]
                        pub type Star_Class;
                        #[wasm_bindgen(constructor, js_class = "Star")]
                        pub fn new(object: JsValue) -> Star_Class;
                    }
                    #[derive(std :: clone :: Clone)]
                    pub struct Star(pub Star_Class);
                    impl std::convert::From<&Star> for super::Path {
                        fn from(src: &Star) -> super::Path {
                            let src: &super::Path_Class = src.0.as_ref();
                            super::Path(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Star> for super::Path {
                        fn from(src: &mut Star) -> super::Path {
                            let src: &super::Path_Class = src.0.as_ref();
                            super::Path(src.clone())
                        }
                    }
                    impl std::convert::From<&Star> for super::Item {
                        fn from(src: &Star) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Star> for super::Item {
                        fn from(src: &mut Star) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&Star> for super::PathItem {
                        fn from(src: &Star) -> super::PathItem {
                            let src: &super::PathItem_Class = src.0.as_ref();
                            super::PathItem(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Star> for super::PathItem {
                        fn from(src: &mut Star) -> super::PathItem {
                            let src: &super::PathItem_Class = src.0.as_ref();
                            super::PathItem(src.clone())
                        }
                    }
                    impl Star {
                        #[allow(dead_code)]
                        pub fn new(object: JsValue) -> Star {
                            let result = Star_Class::new(object);
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            Star(result)
                        }
                    }
                    impl wasm_bindgen::describe::WasmDescribe for Star {
                        fn describe() {
                            <Star_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                        }
                    }
                    impl wasm_bindgen::convert::IntoWasmAbi for Star {
                        type Abi = <Star_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                        }
                    }
                    impl wasm_bindgen::convert::FromWasmAbi for Star {
                        type Abi = <Star_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                        unsafe fn from_abi(js: Self::Abi) -> Self {
                            Star(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                        }
                    }
                    impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Star {
                        type Abi = <&'a Star_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                        }
                    }
                    impl serde::ser::Serialize for Star {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde::ser::Serialize::serialize(&self.0, serializer)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Star {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            let internal: Star_Class =
                                <Star_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                            std::result::Result::Ok(Self(internal))
                        }
                    }
                    #[allow(non_camel_case_types)]
                    pub trait Star_Trait: Path_Trait {}
                    impl Path_Trait for Star
                    where
                        Star: PathItem_Trait,
                    {
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::reduce(&target, options)
                        }
                        fn get_curvature_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_curvature_at(&target, offset)
                        }
                        fn set_last_curve(
                            &mut self,
                            value: super::Curve,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_last_curve(&mut target, value)
                        }
                        fn last_curve(&self) -> std::result::Result<super::Curve, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::last_curve(&target)
                        }
                        fn split_at(
                            &self,
                            location: super::PathSplitAtParamsLocationParam,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::split_at(&target, location)
                        }
                        fn set_area(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_area(&mut target, value)
                        }
                        fn area(&self) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::area(&target)
                        }
                        fn divide_at(
                            &self,
                            location: super::PathDivideAtParamsLocationParam,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::divide_at(&target, location)
                        }
                        fn get_offsets_with_tangent(
                            &self,
                            tangent: super::Point,
                        ) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_offsets_with_tangent(&target, tangent)
                        }
                        fn set_first_segment(
                            &mut self,
                            value: super::Segment,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_first_segment(&mut target, value)
                        }
                        fn first_segment(&self) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::first_segment(&target)
                        }
                        fn set_first_curve(
                            &mut self,
                            value: super::Curve,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_first_curve(&mut target, value)
                        }
                        fn first_curve(&self) -> std::result::Result<super::Curve, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::first_curve(&target)
                        }
                        fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::has_handles(&target)
                        }
                        fn get_normal_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_normal_at(&target, offset)
                        }
                        fn set_last_segment(
                            &mut self,
                            value: super::Segment,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_last_segment(&mut target, value)
                        }
                        fn last_segment(&self) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::last_segment(&target)
                        }
                        fn get_tangent_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_tangent_at(&target, offset)
                        }
                        fn get_weighted_tangent_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_weighted_tangent_at(&target, offset)
                        }
                        fn get_offset_of(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_offset_of(&target, point)
                        }
                        fn insert(
                            &self,
                            index: f64,
                            segment: super::PathInsertParamsSegmentParam,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::insert(&target, index, segment)
                        }
                        fn insert_segments(
                            &self,
                            index: f64,
                            segments: Vec<Segment>,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::insert_segments(&target, index, segments)
                        }
                        fn get_location_of(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::get_location_of(&target, point)
                        }
                        fn get_weighted_normal_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_weighted_normal_at(&target, offset)
                        }
                        fn set_closed(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_closed(&mut target, value)
                        }
                        fn closed(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::closed(&target)
                        }
                        fn add(
                            &self,
                            segment: Box<[super::PathAddParamsSegmentParam]>,
                        ) -> std::result::Result<super::PathAddReturn, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::add(&target, segment)
                        }
                        fn set_length(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_length(&mut target, value)
                        }
                        fn length(&self) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::length(&target)
                        }
                        fn to_shape(
                            &self,
                            insert: bool,
                        ) -> std::result::Result<super::Shape, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::to_shape(&target, insert)
                        }
                        fn get_location_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::get_location_at(&target, offset)
                        }
                        fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::clear_handles(&target)
                        }
                        fn remove_segment(
                            &self,
                            index: f64,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segment(&target, index)
                        }
                        fn set_segments(
                            &mut self,
                            value: Vec<Segment>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_segments(&mut target, value)
                        }
                        fn segments(&self) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::segments(&target)
                        }
                        fn remove_segments(
                            &self,
                            from: f64,
                            to: f64,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segments(&target, from, to)
                        }
                        fn get_point_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_point_at(&target, offset)
                        }
                        fn add_segments(
                            &self,
                            segments: Vec<Segment>,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::add_segments(&target, segments)
                        }
                        fn join(
                            &self,
                            path: super::Path,
                            tolerance: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::join(&target, path, tolerance)
                        }
                        fn set_curves(
                            &mut self,
                            value: Vec<Curve>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_curves(&mut target, value)
                        }
                        fn curves(&self) -> std::result::Result<Vec<Curve>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::curves(&target)
                        }
                        fn set_fully_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_fully_selected(&mut target, value)
                        }
                        fn fully_selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::fully_selected(&target)
                        }
                    }
                    impl PathItem_Trait for Star
                    where
                        Star: Item_Trait,
                    {
                        fn reverse(&self) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::reverse(&target)
                        }
                        fn get_nearest_location(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_nearest_location(&target, point)
                        }
                        fn smooth(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::smooth(&target, options)
                        }
                        fn arc_to(
                            &self,
                            to: super::Point,
                            clockwise: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_to(&target, to, clockwise)
                        }
                        fn line_to(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::line_to(&target, point)
                        }
                        fn cubic_curve_by(
                            &self,
                            handle1: super::Point,
                            handle2: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::cubic_curve_by(&target, handle1, handle2, to)
                        }
                        fn divide(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::divide(&target, path, options)
                        }
                        fn quadratic_curve_by(
                            &self,
                            handle: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::quadratic_curve_by(&target, handle, to)
                        }
                        fn create(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<super::PathItemCreateReturn, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::create(&target, object)
                        }
                        fn interpolate(
                            &self,
                            from: super::PathItem,
                            to: super::PathItem,
                            factor: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::interpolate(&target, from, to, factor)
                        }
                        fn set_clockwise(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: PathItem = self.into();
                            super::PathItem::set_clockwise(&mut target, value)
                        }
                        fn clockwise(&self) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::clockwise(&target)
                        }
                        fn set_path_data(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: PathItem = self.into();
                            super::PathItem::set_path_data(&mut target, value)
                        }
                        fn path_data(&self) -> std::result::Result<String, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::path_data(&target)
                        }
                        fn curve_to(
                            &self,
                            through: super::Point,
                            to: super::Point,
                            time: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::curve_to(&target, through, to, time)
                        }
                        fn move_to(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::move_to(&target, point)
                        }
                        fn get_crossings(
                            &self,
                            path: super::PathItem,
                        ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_crossings(&target, path)
                        }
                        fn close_path(&self) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::close_path(&target)
                        }
                        fn reorient(
                            &self,
                            non_zero: bool,
                            clockwise: bool,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::reorient(&target, non_zero, clockwise)
                        }
                        fn move_by(&self, to: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::move_by(&target, to)
                        }
                        fn quadratic_curve_to(
                            &self,
                            handle: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::quadratic_curve_to(&target, handle, to)
                        }
                        fn cubic_curve_to(
                            &self,
                            handle1: super::Point,
                            handle2: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::cubic_curve_to(&target, handle1, handle2, to)
                        }
                        fn get_intersections(
                            &self,
                            path: super::PathItem,
                            include: &'static dyn Fn(
                                Box<[JsValue]>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_intersections(&target, path, include)
                        }
                        fn compare(
                            &self,
                            path: super::PathItem,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::compare(&target, path)
                        }
                        fn set_interior_point(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: PathItem = self.into();
                            super::PathItem::set_interior_point(&mut target, value)
                        }
                        fn interior_point(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::interior_point(&target)
                        }
                        fn simplify(&self, tolerance: f64) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::simplify(&target, tolerance)
                        }
                        fn arc_by(
                            &self,
                            to: super::Point,
                            clockwise: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_by(&target, to, clockwise)
                        }
                        fn intersect(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::intersect(&target, path, options)
                        }
                        fn get_nearest_point(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::get_nearest_point(&target, point)
                        }
                        fn curve_by(
                            &self,
                            through: super::Point,
                            to: super::Point,
                            time: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::curve_by(&target, through, to, time)
                        }
                        fn exclude(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::exclude(&target, path, options)
                        }
                        fn line_by(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::line_by(&target, point)
                        }
                        fn unite(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::unite(&target, path, options)
                        }
                        fn subtract(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::subtract(&target, path, options)
                        }
                        fn flatten(&self, flatness: f64) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::flatten(&target, flatness)
                        }
                    }
                    impl Item_Trait for Star {
                        fn set_stroke_scaling(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_scaling(&mut target, value)
                        }
                        fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_scaling(&target)
                        }
                        fn set_apply_matrix(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_apply_matrix(&mut target, value)
                        }
                        fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::apply_matrix(&target)
                        }
                        fn set_view_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_view_matrix(&mut target, value)
                        }
                        fn view_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::view_matrix(&target)
                        }
                        fn set_dash_array(
                            &mut self,
                            value: Vec<f64>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_dash_array(&mut target, value)
                        }
                        fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_array(&target)
                        }
                        fn is_ancestor(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_ancestor(&target, item)
                        }
                        fn is_descendant(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_descendant(&target, item)
                        }
                        fn is_sibling(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_sibling(&target, item)
                        }
                        fn local_to_parent(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_parent(&target, point)
                        }
                        fn set_shadow_blur(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_shadow_blur(&mut target, value)
                        }
                        fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_blur(&target)
                        }
                        fn is_empty(
                            &self,
                            recursively: bool,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_empty(&target, recursively)
                        }
                        fn is_parent(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_parent(&target, item)
                        }
                        fn is_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_below(&target, item)
                        }
                        fn set_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_matrix(&mut target, value)
                        }
                        fn matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::matrix(&target)
                        }
                        fn export_json(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::export_json(&target, options)
                        }
                        fn global_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_to_local(&target, point)
                        }
                        fn set_on_mouse_drag(
                            &mut self,
                            value: super::ItemOnMouseDrag,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_drag(&mut target, value)
                        }
                        fn on_mouse_drag(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDrag, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_drag(&target)
                        }
                        fn get_item(
                            &self,
                            options: super::ItemGetItemParamsOptionsParam,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_item(&target, options)
                        }
                        fn remove_children(
                            &self,
                            start: f64,
                            end: f64,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_children(&target, start, end)
                        }
                        fn set_project(
                            &mut self,
                            value: super::Project,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_project(&mut target, value)
                        }
                        fn project(&self) -> std::result::Result<super::Project, JsValue> {
                            let target: Item = self.into();
                            super::Item::project(&target)
                        }
                        fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_data(&mut target, value)
                        }
                        fn data(&self) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::data(&target)
                        }
                        fn insert_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_above(&target, item)
                        }
                        fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on(&target, options)
                        }
                        fn transform(
                            &self,
                            matrix: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::transform(&target, matrix)
                        }
                        fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inserted(&target)
                        }
                        fn set_on_mouse_down(
                            &mut self,
                            value: super::ItemOnMouseDown,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_down(&mut target, value)
                        }
                        fn on_mouse_down(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDown, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_down(&target)
                        }
                        fn set_last_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_last_child(&mut target, value)
                        }
                        fn last_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::last_child(&target)
                        }
                        fn set_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_selected(&mut target, value)
                        }
                        fn selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::selected(&target)
                        }
                        fn set_global_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_global_matrix(&mut target, value)
                        }
                        fn global_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_matrix(&target)
                        }
                        fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::responds(&target, type_)
                        }
                        fn rotate(
                            &self,
                            angle: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::rotate(&target, angle, center)
                        }
                        fn tween(
                            &self,
                            options: super::ItemTweenParamsOptionsParam,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween(&target, options)
                        }
                        fn set_on_mouse_enter(
                            &mut self,
                            value: super::ItemOnMouseEnter,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_enter(&mut target, value)
                        }
                        fn on_mouse_enter(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseEnter, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_enter(&target)
                        }
                        fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_id(&mut target, value)
                        }
                        fn id(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::id(&target)
                        }
                        fn on(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::on(&target, object)
                        }
                        fn tween_to(
                            &self,
                            to: JsValue,
                            options: super::ItemTweenToParamsOptionsParam,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_to(&target, to, options)
                        }
                        fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_locked(&mut target, value)
                        }
                        fn locked(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::locked(&target)
                        }
                        fn set_children(
                            &mut self,
                            value: Vec<Item>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_children(&mut target, value)
                        }
                        fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::children(&target)
                        }
                        fn copy_attributes(
                            &self,
                            source: super::Item,
                            exclude_matrix: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_attributes(&target, source, exclude_matrix)
                        }
                        fn off(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::off(&target, object)
                        }
                        fn contains(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::contains(&target, point)
                        }
                        fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_stroke(&target)
                        }
                        fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_move(&target)
                        }
                        fn add_children(
                            &self,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_children(&target, items)
                        }
                        fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::reverse_children(&target)
                        }
                        fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_shadow(&target)
                        }
                        fn set_dash_offset(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_dash_offset(&mut target, value)
                        }
                        fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_offset(&target)
                        }
                        fn set_on_mouse_leave(
                            &mut self,
                            value: super::ItemOnMouseLeave,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_leave(&mut target, value)
                        }
                        fn on_mouse_leave(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseLeave, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_leave(&target)
                        }
                        fn hit_test_all(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<Vec<HitResult>, JsValue> {
                            let target: Item = self.into();
                            super::Item::hit_test_all(&target, point, options)
                        }
                        fn set_stroke_cap(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_cap(&mut target, value)
                        }
                        fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_cap(&target)
                        }
                        fn set_internal_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_internal_bounds(&mut target, value)
                        }
                        fn internal_bounds(
                            &self,
                        ) -> std::result::Result<super::Rectangle, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::internal_bounds(&target)
                        }
                        fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_index(&mut target, value)
                        }
                        fn index(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::index(&target)
                        }
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::reduce(&target, options)
                        }
                        fn is_grouped_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_grouped_with(&target, item)
                        }
                        fn local_to_global(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_global(&target, point)
                        }
                        fn set_first_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_first_child(&mut target, value)
                        }
                        fn first_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::first_child(&target)
                        }
                        fn set_position(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_position(&mut target, value)
                        }
                        fn position(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::position(&target)
                        }
                        fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_opacity(&mut target, value)
                        }
                        fn opacity(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::opacity(&target)
                        }
                        fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_down(&target)
                        }
                        fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_drag(&target)
                        }
                        fn set_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_bounds(&mut target, value)
                        }
                        fn bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::bounds(&target)
                        }
                        fn set_parent(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_parent(&mut target, value)
                        }
                        fn parent(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent(&target)
                        }
                        fn get_items(
                            &self,
                            options: super::ItemGetItemsParamsOptionsParam,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_items(&target, options)
                        }
                        fn copy_to(
                            &self,
                            owner: super::ItemCopyToParamsOwnerParam,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_to(&target, owner)
                        }
                        fn set_on_double_click(
                            &mut self,
                            value: super::ItemOnDoubleClick,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_double_click(&mut target, value)
                        }
                        fn on_double_click(
                            &self,
                        ) -> std::result::Result<super::ItemOnDoubleClick, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_double_click(&target)
                        }
                        fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::set(&target, props)
                        }
                        fn scale(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::scale(&target, hor, ver, center)
                        }
                        fn insert_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_below(&target, item)
                        }
                        fn set_next_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_next_sibling(&mut target, value)
                        }
                        fn next_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::next_sibling(&target)
                        }
                        fn rasterize(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Raster, JsValue> {
                            let target: Item = self.into();
                            super::Item::rasterize(&target, options)
                        }
                        fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::bring_to_front(&target)
                        }
                        fn matches(
                            &self,
                            name: String,
                            compare: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::matches(&target, name, compare)
                        }
                        fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_fill(&target)
                        }
                        fn set_view(
                            &mut self,
                            value: super::View,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_view(&mut target, value)
                        }
                        fn view(&self) -> std::result::Result<super::View, JsValue> {
                            let target: Item = self.into();
                            super::Item::view(&target)
                        }
                        fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::clone(&target, options)
                        }
                        fn set_handle_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_handle_bounds(&mut target, value)
                        }
                        fn handle_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::handle_bounds(&target)
                        }
                        fn is_inside(
                            &self,
                            rect: super::Rectangle,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inside(&target, rect)
                        }
                        fn is_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_above(&target, item)
                        }
                        fn remove(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove(&target)
                        }
                        fn set_stroke_join(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_join(&mut target, value)
                        }
                        fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_join(&target)
                        }
                        fn set_on_click(
                            &mut self,
                            value: super::ItemOnClick,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_click(&mut target, value)
                        }
                        fn on_click(&self) -> std::result::Result<super::ItemOnClick, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_click(&target)
                        }
                        fn fit_bounds(
                            &self,
                            rectangle: super::Rectangle,
                            fill: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::fit_bounds(&target, rectangle, fill)
                        }
                        fn set_blend_mode(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_blend_mode(&mut target, value)
                        }
                        fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::blend_mode(&target)
                        }
                        fn set_stroke_width(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_width(&mut target, value)
                        }
                        fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_width(&target)
                        }
                        fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_rotation(&mut target, value)
                        }
                        fn rotation(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::rotation(&target)
                        }
                        fn set_selected_color(
                            &mut self,
                            value: super::ItemSelectedColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_selected_color(&mut target, value)
                        }
                        fn selected_color(
                            &self,
                        ) -> std::result::Result<super::ItemSelectedColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::selected_color(&target)
                        }
                        fn skew(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::skew(&target, hor, ver, center)
                        }
                        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_name(&mut target, value)
                        }
                        fn name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::name(&target)
                        }
                        fn import_json(
                            &self,
                            json: String,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_json(&target, json)
                        }
                        fn add_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_child(&target, item)
                        }
                        fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_visible(&mut target, value)
                        }
                        fn visible(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::visible(&target)
                        }
                        fn set_fill_rule(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_fill_rule(&mut target, value)
                        }
                        fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_rule(&target)
                        }
                        fn set_layer(
                            &mut self,
                            value: super::Layer,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_layer(&mut target, value)
                        }
                        fn layer(&self) -> std::result::Result<super::Layer, JsValue> {
                            let target: Item = self.into();
                            super::Item::layer(&target)
                        }
                        fn tween_from(
                            &self,
                            from: JsValue,
                            options: super::ItemTweenFromParamsOptionsParam,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_from(&target, from, options)
                        }
                        fn insert_child(
                            &self,
                            index: f64,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_child(&target, index, item)
                        }
                        fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_up(&target)
                        }
                        fn set_pivot(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_pivot(&mut target, value)
                        }
                        fn pivot(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::pivot(&target)
                        }
                        fn set_miter_limit(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_miter_limit(&mut target, value)
                        }
                        fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::miter_limit(&target)
                        }
                        fn copy_content(
                            &self,
                            source: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_content(&target, source)
                        }
                        fn import_svg(
                            &self,
                            svg: super::ItemImportSvgParamsSvgParam,
                            on_load: &'static dyn Fn(
                                Box<[JsValue]>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_svg(&target, svg, on_load)
                        }
                        fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::send_to_back(&target)
                        }
                        fn set_stroke_color(
                            &mut self,
                            value: super::ItemStrokeColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_color(&mut target, value)
                        }
                        fn stroke_color(
                            &self,
                        ) -> std::result::Result<super::ItemStrokeColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::stroke_color(&target)
                        }
                        fn set_on_mouse_move(
                            &mut self,
                            value: super::ItemOnMouseMove,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_move(&mut target, value)
                        }
                        fn on_mouse_move(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseMove, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_move(&target)
                        }
                        fn replace_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::replace_with(&target, item)
                        }
                        fn hit_test(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<super::HitResult, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::hit_test(&target, point, options)
                        }
                        fn shear(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::shear(&target, hor, ver, center)
                        }
                        fn translate(
                            &self,
                            delta: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::translate(&target, delta)
                        }
                        fn set_stroke_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_bounds(&mut target, value)
                        }
                        fn stroke_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_bounds(&target)
                        }
                        fn insert_children(
                            &self,
                            index: f64,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_children(&target, index, items)
                        }
                        fn is_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_child(&target, item)
                        }
                        fn set_shadow_offset(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_shadow_offset(&mut target, value)
                        }
                        fn shadow_offset(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_offset(&target)
                        }
                        fn set_fill_color(
                            &mut self,
                            value: super::ItemFillColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_fill_color(&mut target, value)
                        }
                        fn fill_color(&self) -> std::result::Result<super::ItemFillColor, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_color(&target)
                        }
                        fn export_svg(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::ItemExportSvgReturn, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::export_svg(&target, options)
                        }
                        fn set_style(
                            &mut self,
                            value: super::Style,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_style(&mut target, value)
                        }
                        fn style(&self) -> std::result::Result<super::Style, JsValue> {
                            let target: Item = self.into();
                            super::Item::style(&target)
                        }
                        fn set_clip_mask(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_clip_mask(&mut target, value)
                        }
                        fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::clip_mask(&target)
                        }
                        fn set_class_name(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_class_name(&mut target, value)
                        }
                        fn class_name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::class_name(&target)
                        }
                        fn set_on_mouse_up(
                            &mut self,
                            value: super::ItemOnMouseUp,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_up(&mut target, value)
                        }
                        fn on_mouse_up(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseUp, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_up(&target)
                        }
                        fn set_on_frame(
                            &mut self,
                            value: super::ItemOnFrame,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_frame(&mut target, value)
                        }
                        fn on_frame(&self) -> std::result::Result<super::ItemOnFrame, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_frame(&target)
                        }
                        fn parent_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent_to_local(&target, point)
                        }
                        fn set_previous_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_previous_sibling(&mut target, value)
                        }
                        fn previous_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::previous_sibling(&target)
                        }
                        fn emit(
                            &self,
                            type_: String,
                            event: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::emit(&target, type_, event)
                        }
                        fn add_to(
                            &self,
                            owner: super::ItemAddToParamsOwnerParam,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_to(&target, owner)
                        }
                        fn has_children(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_children(&target)
                        }
                        fn intersects(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::intersects(&target, item)
                        }
                        fn set_shadow_color(
                            &mut self,
                            value: super::ItemShadowColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_shadow_color(&mut target, value)
                        }
                        fn shadow_color(
                            &self,
                        ) -> std::result::Result<super::ItemShadowColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::shadow_color(&target)
                        }
                        fn set_scaling(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_scaling(&mut target, value)
                        }
                        fn scaling(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::scaling(&target)
                        }
                    }
                    impl Star_Trait for Star where Star: Path_Trait {}
                    impl std::clone::Clone for Star_Class {
                        fn clone(&self) -> Self {
                            Self {
                                obj: std::clone::Clone::clone(&self.obj),
                            }
                        }
                    }
                    impl serde::ser::Serialize for Star_Class {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Star_Class {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                        }
                    }
                    #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                    extern "C" {
                        # [wasm_bindgen (js_name = "Rectangle" , extends = Item_Class , extends = Path_Class , extends = PathItem_Class)]
                        pub type Rectangle_Class;
                        #[wasm_bindgen(constructor, js_class = "Rectangle")]
                        pub fn new(object: JsValue) -> Rectangle_Class;
                    }
                    #[derive(std :: clone :: Clone)]
                    pub struct Rectangle(pub Rectangle_Class);
                    impl std::convert::From<&Rectangle> for super::PathItem {
                        fn from(src: &Rectangle) -> super::PathItem {
                            let src: &super::PathItem_Class = src.0.as_ref();
                            super::PathItem(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Rectangle> for super::PathItem {
                        fn from(src: &mut Rectangle) -> super::PathItem {
                            let src: &super::PathItem_Class = src.0.as_ref();
                            super::PathItem(src.clone())
                        }
                    }
                    impl std::convert::From<&Rectangle> for super::Item {
                        fn from(src: &Rectangle) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Rectangle> for super::Item {
                        fn from(src: &mut Rectangle) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&Rectangle> for super::Path {
                        fn from(src: &Rectangle) -> super::Path {
                            let src: &super::Path_Class = src.0.as_ref();
                            super::Path(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Rectangle> for super::Path {
                        fn from(src: &mut Rectangle) -> super::Path {
                            let src: &super::Path_Class = src.0.as_ref();
                            super::Path(src.clone())
                        }
                    }
                    impl Rectangle {
                        #[allow(dead_code)]
                        pub fn new(object: JsValue) -> Rectangle {
                            let result = Rectangle_Class::new(object);
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            Rectangle(result)
                        }
                    }
                    impl wasm_bindgen::describe::WasmDescribe for Rectangle {
                        fn describe() {
                            <Rectangle_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                        }
                    }
                    impl wasm_bindgen::convert::IntoWasmAbi for Rectangle {
                        type Abi = <Rectangle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                        }
                    }
                    impl wasm_bindgen::convert::FromWasmAbi for Rectangle {
                        type Abi = <Rectangle_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                        unsafe fn from_abi(js: Self::Abi) -> Self {
                            Rectangle(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                        }
                    }
                    impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Rectangle {
                        type Abi = <&'a Rectangle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                        }
                    }
                    impl serde::ser::Serialize for Rectangle {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde::ser::Serialize::serialize(&self.0, serializer)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Rectangle {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            let internal: Rectangle_Class =
                                <Rectangle_Class as serde::de::Deserialize>::deserialize(
                                    deserializer,
                                )?;
                            std::result::Result::Ok(Self(internal))
                        }
                    }
                    #[allow(non_camel_case_types)]
                    pub trait Rectangle_Trait: Path_Trait {}
                    impl Path_Trait for Rectangle
                    where
                        Rectangle: PathItem_Trait,
                    {
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::reduce(&target, options)
                        }
                        fn get_curvature_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_curvature_at(&target, offset)
                        }
                        fn set_last_curve(
                            &mut self,
                            value: super::Curve,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_last_curve(&mut target, value)
                        }
                        fn last_curve(&self) -> std::result::Result<super::Curve, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::last_curve(&target)
                        }
                        fn split_at(
                            &self,
                            location: super::PathSplitAtParamsLocationParam,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::split_at(&target, location)
                        }
                        fn set_area(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_area(&mut target, value)
                        }
                        fn area(&self) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::area(&target)
                        }
                        fn divide_at(
                            &self,
                            location: super::PathDivideAtParamsLocationParam,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::divide_at(&target, location)
                        }
                        fn get_offsets_with_tangent(
                            &self,
                            tangent: super::Point,
                        ) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_offsets_with_tangent(&target, tangent)
                        }
                        fn set_first_segment(
                            &mut self,
                            value: super::Segment,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_first_segment(&mut target, value)
                        }
                        fn first_segment(&self) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::first_segment(&target)
                        }
                        fn set_first_curve(
                            &mut self,
                            value: super::Curve,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_first_curve(&mut target, value)
                        }
                        fn first_curve(&self) -> std::result::Result<super::Curve, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::first_curve(&target)
                        }
                        fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::has_handles(&target)
                        }
                        fn get_normal_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_normal_at(&target, offset)
                        }
                        fn set_last_segment(
                            &mut self,
                            value: super::Segment,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_last_segment(&mut target, value)
                        }
                        fn last_segment(&self) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::last_segment(&target)
                        }
                        fn get_tangent_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_tangent_at(&target, offset)
                        }
                        fn get_weighted_tangent_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_weighted_tangent_at(&target, offset)
                        }
                        fn get_offset_of(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_offset_of(&target, point)
                        }
                        fn insert(
                            &self,
                            index: f64,
                            segment: super::PathInsertParamsSegmentParam,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::insert(&target, index, segment)
                        }
                        fn insert_segments(
                            &self,
                            index: f64,
                            segments: Vec<Segment>,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::insert_segments(&target, index, segments)
                        }
                        fn get_location_of(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::get_location_of(&target, point)
                        }
                        fn get_weighted_normal_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_weighted_normal_at(&target, offset)
                        }
                        fn set_closed(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_closed(&mut target, value)
                        }
                        fn closed(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::closed(&target)
                        }
                        fn add(
                            &self,
                            segment: Box<[super::PathAddParamsSegmentParam]>,
                        ) -> std::result::Result<super::PathAddReturn, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::add(&target, segment)
                        }
                        fn set_length(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_length(&mut target, value)
                        }
                        fn length(&self) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::length(&target)
                        }
                        fn to_shape(
                            &self,
                            insert: bool,
                        ) -> std::result::Result<super::Shape, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::to_shape(&target, insert)
                        }
                        fn get_location_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::get_location_at(&target, offset)
                        }
                        fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::clear_handles(&target)
                        }
                        fn remove_segment(
                            &self,
                            index: f64,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segment(&target, index)
                        }
                        fn set_segments(
                            &mut self,
                            value: Vec<Segment>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_segments(&mut target, value)
                        }
                        fn segments(&self) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::segments(&target)
                        }
                        fn remove_segments(
                            &self,
                            from: f64,
                            to: f64,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segments(&target, from, to)
                        }
                        fn get_point_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_point_at(&target, offset)
                        }
                        fn add_segments(
                            &self,
                            segments: Vec<Segment>,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::add_segments(&target, segments)
                        }
                        fn join(
                            &self,
                            path: super::Path,
                            tolerance: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::join(&target, path, tolerance)
                        }
                        fn set_curves(
                            &mut self,
                            value: Vec<Curve>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_curves(&mut target, value)
                        }
                        fn curves(&self) -> std::result::Result<Vec<Curve>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::curves(&target)
                        }
                        fn set_fully_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_fully_selected(&mut target, value)
                        }
                        fn fully_selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::fully_selected(&target)
                        }
                    }
                    impl PathItem_Trait for Rectangle
                    where
                        Rectangle: Item_Trait,
                    {
                        fn reverse(&self) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::reverse(&target)
                        }
                        fn get_nearest_location(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_nearest_location(&target, point)
                        }
                        fn smooth(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::smooth(&target, options)
                        }
                        fn arc_to(
                            &self,
                            to: super::Point,
                            clockwise: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_to(&target, to, clockwise)
                        }
                        fn line_to(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::line_to(&target, point)
                        }
                        fn cubic_curve_by(
                            &self,
                            handle1: super::Point,
                            handle2: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::cubic_curve_by(&target, handle1, handle2, to)
                        }
                        fn divide(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::divide(&target, path, options)
                        }
                        fn quadratic_curve_by(
                            &self,
                            handle: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::quadratic_curve_by(&target, handle, to)
                        }
                        fn create(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<super::PathItemCreateReturn, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::create(&target, object)
                        }
                        fn interpolate(
                            &self,
                            from: super::PathItem,
                            to: super::PathItem,
                            factor: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::interpolate(&target, from, to, factor)
                        }
                        fn set_clockwise(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: PathItem = self.into();
                            super::PathItem::set_clockwise(&mut target, value)
                        }
                        fn clockwise(&self) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::clockwise(&target)
                        }
                        fn set_path_data(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: PathItem = self.into();
                            super::PathItem::set_path_data(&mut target, value)
                        }
                        fn path_data(&self) -> std::result::Result<String, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::path_data(&target)
                        }
                        fn curve_to(
                            &self,
                            through: super::Point,
                            to: super::Point,
                            time: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::curve_to(&target, through, to, time)
                        }
                        fn move_to(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::move_to(&target, point)
                        }
                        fn get_crossings(
                            &self,
                            path: super::PathItem,
                        ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_crossings(&target, path)
                        }
                        fn close_path(&self) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::close_path(&target)
                        }
                        fn reorient(
                            &self,
                            non_zero: bool,
                            clockwise: bool,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::reorient(&target, non_zero, clockwise)
                        }
                        fn move_by(&self, to: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::move_by(&target, to)
                        }
                        fn quadratic_curve_to(
                            &self,
                            handle: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::quadratic_curve_to(&target, handle, to)
                        }
                        fn cubic_curve_to(
                            &self,
                            handle1: super::Point,
                            handle2: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::cubic_curve_to(&target, handle1, handle2, to)
                        }
                        fn get_intersections(
                            &self,
                            path: super::PathItem,
                            include: &'static dyn Fn(
                                Box<[JsValue]>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_intersections(&target, path, include)
                        }
                        fn compare(
                            &self,
                            path: super::PathItem,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::compare(&target, path)
                        }
                        fn set_interior_point(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: PathItem = self.into();
                            super::PathItem::set_interior_point(&mut target, value)
                        }
                        fn interior_point(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::interior_point(&target)
                        }
                        fn simplify(&self, tolerance: f64) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::simplify(&target, tolerance)
                        }
                        fn arc_by(
                            &self,
                            to: super::Point,
                            clockwise: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_by(&target, to, clockwise)
                        }
                        fn intersect(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::intersect(&target, path, options)
                        }
                        fn get_nearest_point(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::get_nearest_point(&target, point)
                        }
                        fn curve_by(
                            &self,
                            through: super::Point,
                            to: super::Point,
                            time: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::curve_by(&target, through, to, time)
                        }
                        fn exclude(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::exclude(&target, path, options)
                        }
                        fn line_by(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::line_by(&target, point)
                        }
                        fn unite(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::unite(&target, path, options)
                        }
                        fn subtract(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::subtract(&target, path, options)
                        }
                        fn flatten(&self, flatness: f64) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::flatten(&target, flatness)
                        }
                    }
                    impl Item_Trait for Rectangle {
                        fn set_stroke_scaling(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_scaling(&mut target, value)
                        }
                        fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_scaling(&target)
                        }
                        fn set_apply_matrix(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_apply_matrix(&mut target, value)
                        }
                        fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::apply_matrix(&target)
                        }
                        fn set_view_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_view_matrix(&mut target, value)
                        }
                        fn view_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::view_matrix(&target)
                        }
                        fn set_dash_array(
                            &mut self,
                            value: Vec<f64>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_dash_array(&mut target, value)
                        }
                        fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_array(&target)
                        }
                        fn is_ancestor(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_ancestor(&target, item)
                        }
                        fn is_descendant(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_descendant(&target, item)
                        }
                        fn is_sibling(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_sibling(&target, item)
                        }
                        fn local_to_parent(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_parent(&target, point)
                        }
                        fn set_shadow_blur(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_shadow_blur(&mut target, value)
                        }
                        fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_blur(&target)
                        }
                        fn is_empty(
                            &self,
                            recursively: bool,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_empty(&target, recursively)
                        }
                        fn is_parent(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_parent(&target, item)
                        }
                        fn is_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_below(&target, item)
                        }
                        fn set_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_matrix(&mut target, value)
                        }
                        fn matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::matrix(&target)
                        }
                        fn export_json(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::export_json(&target, options)
                        }
                        fn global_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_to_local(&target, point)
                        }
                        fn set_on_mouse_drag(
                            &mut self,
                            value: super::ItemOnMouseDrag,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_drag(&mut target, value)
                        }
                        fn on_mouse_drag(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDrag, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_drag(&target)
                        }
                        fn get_item(
                            &self,
                            options: super::ItemGetItemParamsOptionsParam,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_item(&target, options)
                        }
                        fn remove_children(
                            &self,
                            start: f64,
                            end: f64,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_children(&target, start, end)
                        }
                        fn set_project(
                            &mut self,
                            value: super::Project,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_project(&mut target, value)
                        }
                        fn project(&self) -> std::result::Result<super::Project, JsValue> {
                            let target: Item = self.into();
                            super::Item::project(&target)
                        }
                        fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_data(&mut target, value)
                        }
                        fn data(&self) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::data(&target)
                        }
                        fn insert_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_above(&target, item)
                        }
                        fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on(&target, options)
                        }
                        fn transform(
                            &self,
                            matrix: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::transform(&target, matrix)
                        }
                        fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inserted(&target)
                        }
                        fn set_on_mouse_down(
                            &mut self,
                            value: super::ItemOnMouseDown,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_down(&mut target, value)
                        }
                        fn on_mouse_down(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDown, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_down(&target)
                        }
                        fn set_last_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_last_child(&mut target, value)
                        }
                        fn last_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::last_child(&target)
                        }
                        fn set_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_selected(&mut target, value)
                        }
                        fn selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::selected(&target)
                        }
                        fn set_global_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_global_matrix(&mut target, value)
                        }
                        fn global_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_matrix(&target)
                        }
                        fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::responds(&target, type_)
                        }
                        fn rotate(
                            &self,
                            angle: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::rotate(&target, angle, center)
                        }
                        fn tween(
                            &self,
                            options: super::ItemTweenParamsOptionsParam,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween(&target, options)
                        }
                        fn set_on_mouse_enter(
                            &mut self,
                            value: super::ItemOnMouseEnter,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_enter(&mut target, value)
                        }
                        fn on_mouse_enter(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseEnter, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_enter(&target)
                        }
                        fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_id(&mut target, value)
                        }
                        fn id(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::id(&target)
                        }
                        fn on(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::on(&target, object)
                        }
                        fn tween_to(
                            &self,
                            to: JsValue,
                            options: super::ItemTweenToParamsOptionsParam,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_to(&target, to, options)
                        }
                        fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_locked(&mut target, value)
                        }
                        fn locked(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::locked(&target)
                        }
                        fn set_children(
                            &mut self,
                            value: Vec<Item>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_children(&mut target, value)
                        }
                        fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::children(&target)
                        }
                        fn copy_attributes(
                            &self,
                            source: super::Item,
                            exclude_matrix: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_attributes(&target, source, exclude_matrix)
                        }
                        fn off(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::off(&target, object)
                        }
                        fn contains(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::contains(&target, point)
                        }
                        fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_stroke(&target)
                        }
                        fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_move(&target)
                        }
                        fn add_children(
                            &self,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_children(&target, items)
                        }
                        fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::reverse_children(&target)
                        }
                        fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_shadow(&target)
                        }
                        fn set_dash_offset(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_dash_offset(&mut target, value)
                        }
                        fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_offset(&target)
                        }
                        fn set_on_mouse_leave(
                            &mut self,
                            value: super::ItemOnMouseLeave,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_leave(&mut target, value)
                        }
                        fn on_mouse_leave(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseLeave, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_leave(&target)
                        }
                        fn hit_test_all(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<Vec<HitResult>, JsValue> {
                            let target: Item = self.into();
                            super::Item::hit_test_all(&target, point, options)
                        }
                        fn set_stroke_cap(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_cap(&mut target, value)
                        }
                        fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_cap(&target)
                        }
                        fn set_internal_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_internal_bounds(&mut target, value)
                        }
                        fn internal_bounds(
                            &self,
                        ) -> std::result::Result<super::Rectangle, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::internal_bounds(&target)
                        }
                        fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_index(&mut target, value)
                        }
                        fn index(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::index(&target)
                        }
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::reduce(&target, options)
                        }
                        fn is_grouped_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_grouped_with(&target, item)
                        }
                        fn local_to_global(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_global(&target, point)
                        }
                        fn set_first_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_first_child(&mut target, value)
                        }
                        fn first_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::first_child(&target)
                        }
                        fn set_position(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_position(&mut target, value)
                        }
                        fn position(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::position(&target)
                        }
                        fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_opacity(&mut target, value)
                        }
                        fn opacity(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::opacity(&target)
                        }
                        fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_down(&target)
                        }
                        fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_drag(&target)
                        }
                        fn set_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_bounds(&mut target, value)
                        }
                        fn bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::bounds(&target)
                        }
                        fn set_parent(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_parent(&mut target, value)
                        }
                        fn parent(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent(&target)
                        }
                        fn get_items(
                            &self,
                            options: super::ItemGetItemsParamsOptionsParam,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_items(&target, options)
                        }
                        fn copy_to(
                            &self,
                            owner: super::ItemCopyToParamsOwnerParam,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_to(&target, owner)
                        }
                        fn set_on_double_click(
                            &mut self,
                            value: super::ItemOnDoubleClick,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_double_click(&mut target, value)
                        }
                        fn on_double_click(
                            &self,
                        ) -> std::result::Result<super::ItemOnDoubleClick, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_double_click(&target)
                        }
                        fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::set(&target, props)
                        }
                        fn scale(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::scale(&target, hor, ver, center)
                        }
                        fn insert_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_below(&target, item)
                        }
                        fn set_next_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_next_sibling(&mut target, value)
                        }
                        fn next_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::next_sibling(&target)
                        }
                        fn rasterize(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Raster, JsValue> {
                            let target: Item = self.into();
                            super::Item::rasterize(&target, options)
                        }
                        fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::bring_to_front(&target)
                        }
                        fn matches(
                            &self,
                            name: String,
                            compare: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::matches(&target, name, compare)
                        }
                        fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_fill(&target)
                        }
                        fn set_view(
                            &mut self,
                            value: super::View,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_view(&mut target, value)
                        }
                        fn view(&self) -> std::result::Result<super::View, JsValue> {
                            let target: Item = self.into();
                            super::Item::view(&target)
                        }
                        fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::clone(&target, options)
                        }
                        fn set_handle_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_handle_bounds(&mut target, value)
                        }
                        fn handle_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::handle_bounds(&target)
                        }
                        fn is_inside(
                            &self,
                            rect: super::Rectangle,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inside(&target, rect)
                        }
                        fn is_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_above(&target, item)
                        }
                        fn remove(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove(&target)
                        }
                        fn set_stroke_join(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_join(&mut target, value)
                        }
                        fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_join(&target)
                        }
                        fn set_on_click(
                            &mut self,
                            value: super::ItemOnClick,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_click(&mut target, value)
                        }
                        fn on_click(&self) -> std::result::Result<super::ItemOnClick, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_click(&target)
                        }
                        fn fit_bounds(
                            &self,
                            rectangle: super::Rectangle,
                            fill: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::fit_bounds(&target, rectangle, fill)
                        }
                        fn set_blend_mode(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_blend_mode(&mut target, value)
                        }
                        fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::blend_mode(&target)
                        }
                        fn set_stroke_width(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_width(&mut target, value)
                        }
                        fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_width(&target)
                        }
                        fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_rotation(&mut target, value)
                        }
                        fn rotation(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::rotation(&target)
                        }
                        fn set_selected_color(
                            &mut self,
                            value: super::ItemSelectedColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_selected_color(&mut target, value)
                        }
                        fn selected_color(
                            &self,
                        ) -> std::result::Result<super::ItemSelectedColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::selected_color(&target)
                        }
                        fn skew(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::skew(&target, hor, ver, center)
                        }
                        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_name(&mut target, value)
                        }
                        fn name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::name(&target)
                        }
                        fn import_json(
                            &self,
                            json: String,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_json(&target, json)
                        }
                        fn add_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_child(&target, item)
                        }
                        fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_visible(&mut target, value)
                        }
                        fn visible(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::visible(&target)
                        }
                        fn set_fill_rule(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_fill_rule(&mut target, value)
                        }
                        fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_rule(&target)
                        }
                        fn set_layer(
                            &mut self,
                            value: super::Layer,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_layer(&mut target, value)
                        }
                        fn layer(&self) -> std::result::Result<super::Layer, JsValue> {
                            let target: Item = self.into();
                            super::Item::layer(&target)
                        }
                        fn tween_from(
                            &self,
                            from: JsValue,
                            options: super::ItemTweenFromParamsOptionsParam,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_from(&target, from, options)
                        }
                        fn insert_child(
                            &self,
                            index: f64,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_child(&target, index, item)
                        }
                        fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_up(&target)
                        }
                        fn set_pivot(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_pivot(&mut target, value)
                        }
                        fn pivot(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::pivot(&target)
                        }
                        fn set_miter_limit(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_miter_limit(&mut target, value)
                        }
                        fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::miter_limit(&target)
                        }
                        fn copy_content(
                            &self,
                            source: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_content(&target, source)
                        }
                        fn import_svg(
                            &self,
                            svg: super::ItemImportSvgParamsSvgParam,
                            on_load: &'static dyn Fn(
                                Box<[JsValue]>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_svg(&target, svg, on_load)
                        }
                        fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::send_to_back(&target)
                        }
                        fn set_stroke_color(
                            &mut self,
                            value: super::ItemStrokeColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_color(&mut target, value)
                        }
                        fn stroke_color(
                            &self,
                        ) -> std::result::Result<super::ItemStrokeColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::stroke_color(&target)
                        }
                        fn set_on_mouse_move(
                            &mut self,
                            value: super::ItemOnMouseMove,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_move(&mut target, value)
                        }
                        fn on_mouse_move(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseMove, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_move(&target)
                        }
                        fn replace_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::replace_with(&target, item)
                        }
                        fn hit_test(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<super::HitResult, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::hit_test(&target, point, options)
                        }
                        fn shear(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::shear(&target, hor, ver, center)
                        }
                        fn translate(
                            &self,
                            delta: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::translate(&target, delta)
                        }
                        fn set_stroke_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_bounds(&mut target, value)
                        }
                        fn stroke_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_bounds(&target)
                        }
                        fn insert_children(
                            &self,
                            index: f64,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_children(&target, index, items)
                        }
                        fn is_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_child(&target, item)
                        }
                        fn set_shadow_offset(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_shadow_offset(&mut target, value)
                        }
                        fn shadow_offset(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_offset(&target)
                        }
                        fn set_fill_color(
                            &mut self,
                            value: super::ItemFillColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_fill_color(&mut target, value)
                        }
                        fn fill_color(&self) -> std::result::Result<super::ItemFillColor, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_color(&target)
                        }
                        fn export_svg(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::ItemExportSvgReturn, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::export_svg(&target, options)
                        }
                        fn set_style(
                            &mut self,
                            value: super::Style,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_style(&mut target, value)
                        }
                        fn style(&self) -> std::result::Result<super::Style, JsValue> {
                            let target: Item = self.into();
                            super::Item::style(&target)
                        }
                        fn set_clip_mask(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_clip_mask(&mut target, value)
                        }
                        fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::clip_mask(&target)
                        }
                        fn set_class_name(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_class_name(&mut target, value)
                        }
                        fn class_name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::class_name(&target)
                        }
                        fn set_on_mouse_up(
                            &mut self,
                            value: super::ItemOnMouseUp,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_up(&mut target, value)
                        }
                        fn on_mouse_up(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseUp, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_up(&target)
                        }
                        fn set_on_frame(
                            &mut self,
                            value: super::ItemOnFrame,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_frame(&mut target, value)
                        }
                        fn on_frame(&self) -> std::result::Result<super::ItemOnFrame, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_frame(&target)
                        }
                        fn parent_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent_to_local(&target, point)
                        }
                        fn set_previous_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_previous_sibling(&mut target, value)
                        }
                        fn previous_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::previous_sibling(&target)
                        }
                        fn emit(
                            &self,
                            type_: String,
                            event: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::emit(&target, type_, event)
                        }
                        fn add_to(
                            &self,
                            owner: super::ItemAddToParamsOwnerParam,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_to(&target, owner)
                        }
                        fn has_children(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_children(&target)
                        }
                        fn intersects(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::intersects(&target, item)
                        }
                        fn set_shadow_color(
                            &mut self,
                            value: super::ItemShadowColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_shadow_color(&mut target, value)
                        }
                        fn shadow_color(
                            &self,
                        ) -> std::result::Result<super::ItemShadowColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::shadow_color(&target)
                        }
                        fn set_scaling(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_scaling(&mut target, value)
                        }
                        fn scaling(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::scaling(&target)
                        }
                    }
                    impl Rectangle_Trait for Rectangle where Rectangle: Path_Trait {}
                    impl std::clone::Clone for Rectangle_Class {
                        fn clone(&self) -> Self {
                            Self {
                                obj: std::clone::Clone::clone(&self.obj),
                            }
                        }
                    }
                    impl serde::ser::Serialize for Rectangle_Class {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Rectangle_Class {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                        }
                    }
                    #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                    extern "C" {
                        # [wasm_bindgen (js_name = "Ellipse" , extends = Item_Class , extends = Path_Class , extends = PathItem_Class)]
                        pub type Ellipse_Class;
                        #[wasm_bindgen(constructor, js_class = "Ellipse")]
                        pub fn new(object: JsValue) -> Ellipse_Class;
                    }
                    #[derive(std :: clone :: Clone)]
                    pub struct Ellipse(pub Ellipse_Class);
                    impl std::convert::From<&Ellipse> for super::PathItem {
                        fn from(src: &Ellipse) -> super::PathItem {
                            let src: &super::PathItem_Class = src.0.as_ref();
                            super::PathItem(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Ellipse> for super::PathItem {
                        fn from(src: &mut Ellipse) -> super::PathItem {
                            let src: &super::PathItem_Class = src.0.as_ref();
                            super::PathItem(src.clone())
                        }
                    }
                    impl std::convert::From<&Ellipse> for super::Path {
                        fn from(src: &Ellipse) -> super::Path {
                            let src: &super::Path_Class = src.0.as_ref();
                            super::Path(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Ellipse> for super::Path {
                        fn from(src: &mut Ellipse) -> super::Path {
                            let src: &super::Path_Class = src.0.as_ref();
                            super::Path(src.clone())
                        }
                    }
                    impl std::convert::From<&Ellipse> for super::Item {
                        fn from(src: &Ellipse) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Ellipse> for super::Item {
                        fn from(src: &mut Ellipse) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl Ellipse {
                        #[allow(dead_code)]
                        pub fn new(object: JsValue) -> Ellipse {
                            let result = Ellipse_Class::new(object);
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            Ellipse(result)
                        }
                    }
                    impl wasm_bindgen::describe::WasmDescribe for Ellipse {
                        fn describe() {
                            <Ellipse_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                        }
                    }
                    impl wasm_bindgen::convert::IntoWasmAbi for Ellipse {
                        type Abi = <Ellipse_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                        }
                    }
                    impl wasm_bindgen::convert::FromWasmAbi for Ellipse {
                        type Abi = <Ellipse_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                        unsafe fn from_abi(js: Self::Abi) -> Self {
                            Ellipse(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                        }
                    }
                    impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Ellipse {
                        type Abi = <&'a Ellipse_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                        }
                    }
                    impl serde::ser::Serialize for Ellipse {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde::ser::Serialize::serialize(&self.0, serializer)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Ellipse {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            let internal: Ellipse_Class =
                                <Ellipse_Class as serde::de::Deserialize>::deserialize(
                                    deserializer,
                                )?;
                            std::result::Result::Ok(Self(internal))
                        }
                    }
                    #[allow(non_camel_case_types)]
                    pub trait Ellipse_Trait: Path_Trait {}
                    impl Path_Trait for Ellipse
                    where
                        Ellipse: PathItem_Trait,
                    {
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::reduce(&target, options)
                        }
                        fn get_curvature_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_curvature_at(&target, offset)
                        }
                        fn set_last_curve(
                            &mut self,
                            value: super::Curve,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_last_curve(&mut target, value)
                        }
                        fn last_curve(&self) -> std::result::Result<super::Curve, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::last_curve(&target)
                        }
                        fn split_at(
                            &self,
                            location: super::PathSplitAtParamsLocationParam,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::split_at(&target, location)
                        }
                        fn set_area(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_area(&mut target, value)
                        }
                        fn area(&self) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::area(&target)
                        }
                        fn divide_at(
                            &self,
                            location: super::PathDivideAtParamsLocationParam,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::divide_at(&target, location)
                        }
                        fn get_offsets_with_tangent(
                            &self,
                            tangent: super::Point,
                        ) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_offsets_with_tangent(&target, tangent)
                        }
                        fn set_first_segment(
                            &mut self,
                            value: super::Segment,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_first_segment(&mut target, value)
                        }
                        fn first_segment(&self) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::first_segment(&target)
                        }
                        fn set_first_curve(
                            &mut self,
                            value: super::Curve,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_first_curve(&mut target, value)
                        }
                        fn first_curve(&self) -> std::result::Result<super::Curve, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::first_curve(&target)
                        }
                        fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::has_handles(&target)
                        }
                        fn get_normal_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_normal_at(&target, offset)
                        }
                        fn set_last_segment(
                            &mut self,
                            value: super::Segment,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_last_segment(&mut target, value)
                        }
                        fn last_segment(&self) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::last_segment(&target)
                        }
                        fn get_tangent_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_tangent_at(&target, offset)
                        }
                        fn get_weighted_tangent_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_weighted_tangent_at(&target, offset)
                        }
                        fn get_offset_of(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_offset_of(&target, point)
                        }
                        fn insert(
                            &self,
                            index: f64,
                            segment: super::PathInsertParamsSegmentParam,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::insert(&target, index, segment)
                        }
                        fn insert_segments(
                            &self,
                            index: f64,
                            segments: Vec<Segment>,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::insert_segments(&target, index, segments)
                        }
                        fn get_location_of(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::get_location_of(&target, point)
                        }
                        fn get_weighted_normal_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_weighted_normal_at(&target, offset)
                        }
                        fn set_closed(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_closed(&mut target, value)
                        }
                        fn closed(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::closed(&target)
                        }
                        fn add(
                            &self,
                            segment: Box<[super::PathAddParamsSegmentParam]>,
                        ) -> std::result::Result<super::PathAddReturn, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::add(&target, segment)
                        }
                        fn set_length(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_length(&mut target, value)
                        }
                        fn length(&self) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::length(&target)
                        }
                        fn to_shape(
                            &self,
                            insert: bool,
                        ) -> std::result::Result<super::Shape, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::to_shape(&target, insert)
                        }
                        fn get_location_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::get_location_at(&target, offset)
                        }
                        fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::clear_handles(&target)
                        }
                        fn remove_segment(
                            &self,
                            index: f64,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segment(&target, index)
                        }
                        fn set_segments(
                            &mut self,
                            value: Vec<Segment>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_segments(&mut target, value)
                        }
                        fn segments(&self) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::segments(&target)
                        }
                        fn remove_segments(
                            &self,
                            from: f64,
                            to: f64,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segments(&target, from, to)
                        }
                        fn get_point_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_point_at(&target, offset)
                        }
                        fn add_segments(
                            &self,
                            segments: Vec<Segment>,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::add_segments(&target, segments)
                        }
                        fn join(
                            &self,
                            path: super::Path,
                            tolerance: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::join(&target, path, tolerance)
                        }
                        fn set_curves(
                            &mut self,
                            value: Vec<Curve>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_curves(&mut target, value)
                        }
                        fn curves(&self) -> std::result::Result<Vec<Curve>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::curves(&target)
                        }
                        fn set_fully_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_fully_selected(&mut target, value)
                        }
                        fn fully_selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::fully_selected(&target)
                        }
                    }
                    impl PathItem_Trait for Ellipse
                    where
                        Ellipse: Item_Trait,
                    {
                        fn reverse(&self) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::reverse(&target)
                        }
                        fn get_nearest_location(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_nearest_location(&target, point)
                        }
                        fn smooth(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::smooth(&target, options)
                        }
                        fn arc_to(
                            &self,
                            to: super::Point,
                            clockwise: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_to(&target, to, clockwise)
                        }
                        fn line_to(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::line_to(&target, point)
                        }
                        fn cubic_curve_by(
                            &self,
                            handle1: super::Point,
                            handle2: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::cubic_curve_by(&target, handle1, handle2, to)
                        }
                        fn divide(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::divide(&target, path, options)
                        }
                        fn quadratic_curve_by(
                            &self,
                            handle: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::quadratic_curve_by(&target, handle, to)
                        }
                        fn create(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<super::PathItemCreateReturn, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::create(&target, object)
                        }
                        fn interpolate(
                            &self,
                            from: super::PathItem,
                            to: super::PathItem,
                            factor: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::interpolate(&target, from, to, factor)
                        }
                        fn set_clockwise(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: PathItem = self.into();
                            super::PathItem::set_clockwise(&mut target, value)
                        }
                        fn clockwise(&self) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::clockwise(&target)
                        }
                        fn set_path_data(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: PathItem = self.into();
                            super::PathItem::set_path_data(&mut target, value)
                        }
                        fn path_data(&self) -> std::result::Result<String, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::path_data(&target)
                        }
                        fn curve_to(
                            &self,
                            through: super::Point,
                            to: super::Point,
                            time: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::curve_to(&target, through, to, time)
                        }
                        fn move_to(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::move_to(&target, point)
                        }
                        fn get_crossings(
                            &self,
                            path: super::PathItem,
                        ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_crossings(&target, path)
                        }
                        fn close_path(&self) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::close_path(&target)
                        }
                        fn reorient(
                            &self,
                            non_zero: bool,
                            clockwise: bool,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::reorient(&target, non_zero, clockwise)
                        }
                        fn move_by(&self, to: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::move_by(&target, to)
                        }
                        fn quadratic_curve_to(
                            &self,
                            handle: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::quadratic_curve_to(&target, handle, to)
                        }
                        fn cubic_curve_to(
                            &self,
                            handle1: super::Point,
                            handle2: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::cubic_curve_to(&target, handle1, handle2, to)
                        }
                        fn get_intersections(
                            &self,
                            path: super::PathItem,
                            include: &'static dyn Fn(
                                Box<[JsValue]>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_intersections(&target, path, include)
                        }
                        fn compare(
                            &self,
                            path: super::PathItem,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::compare(&target, path)
                        }
                        fn set_interior_point(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: PathItem = self.into();
                            super::PathItem::set_interior_point(&mut target, value)
                        }
                        fn interior_point(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::interior_point(&target)
                        }
                        fn simplify(&self, tolerance: f64) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::simplify(&target, tolerance)
                        }
                        fn arc_by(
                            &self,
                            to: super::Point,
                            clockwise: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_by(&target, to, clockwise)
                        }
                        fn intersect(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::intersect(&target, path, options)
                        }
                        fn get_nearest_point(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::get_nearest_point(&target, point)
                        }
                        fn curve_by(
                            &self,
                            through: super::Point,
                            to: super::Point,
                            time: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::curve_by(&target, through, to, time)
                        }
                        fn exclude(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::exclude(&target, path, options)
                        }
                        fn line_by(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::line_by(&target, point)
                        }
                        fn unite(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::unite(&target, path, options)
                        }
                        fn subtract(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::subtract(&target, path, options)
                        }
                        fn flatten(&self, flatness: f64) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::flatten(&target, flatness)
                        }
                    }
                    impl Item_Trait for Ellipse {
                        fn set_stroke_scaling(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_scaling(&mut target, value)
                        }
                        fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_scaling(&target)
                        }
                        fn set_apply_matrix(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_apply_matrix(&mut target, value)
                        }
                        fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::apply_matrix(&target)
                        }
                        fn set_view_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_view_matrix(&mut target, value)
                        }
                        fn view_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::view_matrix(&target)
                        }
                        fn set_dash_array(
                            &mut self,
                            value: Vec<f64>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_dash_array(&mut target, value)
                        }
                        fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_array(&target)
                        }
                        fn is_ancestor(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_ancestor(&target, item)
                        }
                        fn is_descendant(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_descendant(&target, item)
                        }
                        fn is_sibling(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_sibling(&target, item)
                        }
                        fn local_to_parent(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_parent(&target, point)
                        }
                        fn set_shadow_blur(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_shadow_blur(&mut target, value)
                        }
                        fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_blur(&target)
                        }
                        fn is_empty(
                            &self,
                            recursively: bool,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_empty(&target, recursively)
                        }
                        fn is_parent(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_parent(&target, item)
                        }
                        fn is_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_below(&target, item)
                        }
                        fn set_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_matrix(&mut target, value)
                        }
                        fn matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::matrix(&target)
                        }
                        fn export_json(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::export_json(&target, options)
                        }
                        fn global_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_to_local(&target, point)
                        }
                        fn set_on_mouse_drag(
                            &mut self,
                            value: super::ItemOnMouseDrag,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_drag(&mut target, value)
                        }
                        fn on_mouse_drag(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDrag, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_drag(&target)
                        }
                        fn get_item(
                            &self,
                            options: super::ItemGetItemParamsOptionsParam,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_item(&target, options)
                        }
                        fn remove_children(
                            &self,
                            start: f64,
                            end: f64,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_children(&target, start, end)
                        }
                        fn set_project(
                            &mut self,
                            value: super::Project,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_project(&mut target, value)
                        }
                        fn project(&self) -> std::result::Result<super::Project, JsValue> {
                            let target: Item = self.into();
                            super::Item::project(&target)
                        }
                        fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_data(&mut target, value)
                        }
                        fn data(&self) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::data(&target)
                        }
                        fn insert_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_above(&target, item)
                        }
                        fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on(&target, options)
                        }
                        fn transform(
                            &self,
                            matrix: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::transform(&target, matrix)
                        }
                        fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inserted(&target)
                        }
                        fn set_on_mouse_down(
                            &mut self,
                            value: super::ItemOnMouseDown,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_down(&mut target, value)
                        }
                        fn on_mouse_down(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDown, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_down(&target)
                        }
                        fn set_last_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_last_child(&mut target, value)
                        }
                        fn last_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::last_child(&target)
                        }
                        fn set_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_selected(&mut target, value)
                        }
                        fn selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::selected(&target)
                        }
                        fn set_global_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_global_matrix(&mut target, value)
                        }
                        fn global_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_matrix(&target)
                        }
                        fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::responds(&target, type_)
                        }
                        fn rotate(
                            &self,
                            angle: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::rotate(&target, angle, center)
                        }
                        fn tween(
                            &self,
                            options: super::ItemTweenParamsOptionsParam,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween(&target, options)
                        }
                        fn set_on_mouse_enter(
                            &mut self,
                            value: super::ItemOnMouseEnter,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_enter(&mut target, value)
                        }
                        fn on_mouse_enter(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseEnter, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_enter(&target)
                        }
                        fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_id(&mut target, value)
                        }
                        fn id(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::id(&target)
                        }
                        fn on(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::on(&target, object)
                        }
                        fn tween_to(
                            &self,
                            to: JsValue,
                            options: super::ItemTweenToParamsOptionsParam,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_to(&target, to, options)
                        }
                        fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_locked(&mut target, value)
                        }
                        fn locked(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::locked(&target)
                        }
                        fn set_children(
                            &mut self,
                            value: Vec<Item>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_children(&mut target, value)
                        }
                        fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::children(&target)
                        }
                        fn copy_attributes(
                            &self,
                            source: super::Item,
                            exclude_matrix: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_attributes(&target, source, exclude_matrix)
                        }
                        fn off(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::off(&target, object)
                        }
                        fn contains(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::contains(&target, point)
                        }
                        fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_stroke(&target)
                        }
                        fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_move(&target)
                        }
                        fn add_children(
                            &self,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_children(&target, items)
                        }
                        fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::reverse_children(&target)
                        }
                        fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_shadow(&target)
                        }
                        fn set_dash_offset(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_dash_offset(&mut target, value)
                        }
                        fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_offset(&target)
                        }
                        fn set_on_mouse_leave(
                            &mut self,
                            value: super::ItemOnMouseLeave,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_leave(&mut target, value)
                        }
                        fn on_mouse_leave(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseLeave, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_leave(&target)
                        }
                        fn hit_test_all(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<Vec<HitResult>, JsValue> {
                            let target: Item = self.into();
                            super::Item::hit_test_all(&target, point, options)
                        }
                        fn set_stroke_cap(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_cap(&mut target, value)
                        }
                        fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_cap(&target)
                        }
                        fn set_internal_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_internal_bounds(&mut target, value)
                        }
                        fn internal_bounds(
                            &self,
                        ) -> std::result::Result<super::Rectangle, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::internal_bounds(&target)
                        }
                        fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_index(&mut target, value)
                        }
                        fn index(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::index(&target)
                        }
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::reduce(&target, options)
                        }
                        fn is_grouped_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_grouped_with(&target, item)
                        }
                        fn local_to_global(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_global(&target, point)
                        }
                        fn set_first_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_first_child(&mut target, value)
                        }
                        fn first_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::first_child(&target)
                        }
                        fn set_position(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_position(&mut target, value)
                        }
                        fn position(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::position(&target)
                        }
                        fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_opacity(&mut target, value)
                        }
                        fn opacity(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::opacity(&target)
                        }
                        fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_down(&target)
                        }
                        fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_drag(&target)
                        }
                        fn set_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_bounds(&mut target, value)
                        }
                        fn bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::bounds(&target)
                        }
                        fn set_parent(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_parent(&mut target, value)
                        }
                        fn parent(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent(&target)
                        }
                        fn get_items(
                            &self,
                            options: super::ItemGetItemsParamsOptionsParam,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_items(&target, options)
                        }
                        fn copy_to(
                            &self,
                            owner: super::ItemCopyToParamsOwnerParam,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_to(&target, owner)
                        }
                        fn set_on_double_click(
                            &mut self,
                            value: super::ItemOnDoubleClick,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_double_click(&mut target, value)
                        }
                        fn on_double_click(
                            &self,
                        ) -> std::result::Result<super::ItemOnDoubleClick, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_double_click(&target)
                        }
                        fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::set(&target, props)
                        }
                        fn scale(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::scale(&target, hor, ver, center)
                        }
                        fn insert_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_below(&target, item)
                        }
                        fn set_next_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_next_sibling(&mut target, value)
                        }
                        fn next_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::next_sibling(&target)
                        }
                        fn rasterize(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Raster, JsValue> {
                            let target: Item = self.into();
                            super::Item::rasterize(&target, options)
                        }
                        fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::bring_to_front(&target)
                        }
                        fn matches(
                            &self,
                            name: String,
                            compare: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::matches(&target, name, compare)
                        }
                        fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_fill(&target)
                        }
                        fn set_view(
                            &mut self,
                            value: super::View,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_view(&mut target, value)
                        }
                        fn view(&self) -> std::result::Result<super::View, JsValue> {
                            let target: Item = self.into();
                            super::Item::view(&target)
                        }
                        fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::clone(&target, options)
                        }
                        fn set_handle_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_handle_bounds(&mut target, value)
                        }
                        fn handle_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::handle_bounds(&target)
                        }
                        fn is_inside(
                            &self,
                            rect: super::Rectangle,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inside(&target, rect)
                        }
                        fn is_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_above(&target, item)
                        }
                        fn remove(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove(&target)
                        }
                        fn set_stroke_join(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_join(&mut target, value)
                        }
                        fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_join(&target)
                        }
                        fn set_on_click(
                            &mut self,
                            value: super::ItemOnClick,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_click(&mut target, value)
                        }
                        fn on_click(&self) -> std::result::Result<super::ItemOnClick, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_click(&target)
                        }
                        fn fit_bounds(
                            &self,
                            rectangle: super::Rectangle,
                            fill: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::fit_bounds(&target, rectangle, fill)
                        }
                        fn set_blend_mode(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_blend_mode(&mut target, value)
                        }
                        fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::blend_mode(&target)
                        }
                        fn set_stroke_width(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_width(&mut target, value)
                        }
                        fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_width(&target)
                        }
                        fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_rotation(&mut target, value)
                        }
                        fn rotation(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::rotation(&target)
                        }
                        fn set_selected_color(
                            &mut self,
                            value: super::ItemSelectedColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_selected_color(&mut target, value)
                        }
                        fn selected_color(
                            &self,
                        ) -> std::result::Result<super::ItemSelectedColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::selected_color(&target)
                        }
                        fn skew(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::skew(&target, hor, ver, center)
                        }
                        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_name(&mut target, value)
                        }
                        fn name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::name(&target)
                        }
                        fn import_json(
                            &self,
                            json: String,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_json(&target, json)
                        }
                        fn add_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_child(&target, item)
                        }
                        fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_visible(&mut target, value)
                        }
                        fn visible(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::visible(&target)
                        }
                        fn set_fill_rule(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_fill_rule(&mut target, value)
                        }
                        fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_rule(&target)
                        }
                        fn set_layer(
                            &mut self,
                            value: super::Layer,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_layer(&mut target, value)
                        }
                        fn layer(&self) -> std::result::Result<super::Layer, JsValue> {
                            let target: Item = self.into();
                            super::Item::layer(&target)
                        }
                        fn tween_from(
                            &self,
                            from: JsValue,
                            options: super::ItemTweenFromParamsOptionsParam,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_from(&target, from, options)
                        }
                        fn insert_child(
                            &self,
                            index: f64,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_child(&target, index, item)
                        }
                        fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_up(&target)
                        }
                        fn set_pivot(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_pivot(&mut target, value)
                        }
                        fn pivot(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::pivot(&target)
                        }
                        fn set_miter_limit(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_miter_limit(&mut target, value)
                        }
                        fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::miter_limit(&target)
                        }
                        fn copy_content(
                            &self,
                            source: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_content(&target, source)
                        }
                        fn import_svg(
                            &self,
                            svg: super::ItemImportSvgParamsSvgParam,
                            on_load: &'static dyn Fn(
                                Box<[JsValue]>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_svg(&target, svg, on_load)
                        }
                        fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::send_to_back(&target)
                        }
                        fn set_stroke_color(
                            &mut self,
                            value: super::ItemStrokeColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_color(&mut target, value)
                        }
                        fn stroke_color(
                            &self,
                        ) -> std::result::Result<super::ItemStrokeColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::stroke_color(&target)
                        }
                        fn set_on_mouse_move(
                            &mut self,
                            value: super::ItemOnMouseMove,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_move(&mut target, value)
                        }
                        fn on_mouse_move(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseMove, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_move(&target)
                        }
                        fn replace_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::replace_with(&target, item)
                        }
                        fn hit_test(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<super::HitResult, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::hit_test(&target, point, options)
                        }
                        fn shear(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::shear(&target, hor, ver, center)
                        }
                        fn translate(
                            &self,
                            delta: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::translate(&target, delta)
                        }
                        fn set_stroke_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_bounds(&mut target, value)
                        }
                        fn stroke_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_bounds(&target)
                        }
                        fn insert_children(
                            &self,
                            index: f64,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_children(&target, index, items)
                        }
                        fn is_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_child(&target, item)
                        }
                        fn set_shadow_offset(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_shadow_offset(&mut target, value)
                        }
                        fn shadow_offset(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_offset(&target)
                        }
                        fn set_fill_color(
                            &mut self,
                            value: super::ItemFillColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_fill_color(&mut target, value)
                        }
                        fn fill_color(&self) -> std::result::Result<super::ItemFillColor, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_color(&target)
                        }
                        fn export_svg(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::ItemExportSvgReturn, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::export_svg(&target, options)
                        }
                        fn set_style(
                            &mut self,
                            value: super::Style,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_style(&mut target, value)
                        }
                        fn style(&self) -> std::result::Result<super::Style, JsValue> {
                            let target: Item = self.into();
                            super::Item::style(&target)
                        }
                        fn set_clip_mask(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_clip_mask(&mut target, value)
                        }
                        fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::clip_mask(&target)
                        }
                        fn set_class_name(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_class_name(&mut target, value)
                        }
                        fn class_name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::class_name(&target)
                        }
                        fn set_on_mouse_up(
                            &mut self,
                            value: super::ItemOnMouseUp,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_up(&mut target, value)
                        }
                        fn on_mouse_up(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseUp, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_up(&target)
                        }
                        fn set_on_frame(
                            &mut self,
                            value: super::ItemOnFrame,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_frame(&mut target, value)
                        }
                        fn on_frame(&self) -> std::result::Result<super::ItemOnFrame, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_frame(&target)
                        }
                        fn parent_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent_to_local(&target, point)
                        }
                        fn set_previous_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_previous_sibling(&mut target, value)
                        }
                        fn previous_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::previous_sibling(&target)
                        }
                        fn emit(
                            &self,
                            type_: String,
                            event: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::emit(&target, type_, event)
                        }
                        fn add_to(
                            &self,
                            owner: super::ItemAddToParamsOwnerParam,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_to(&target, owner)
                        }
                        fn has_children(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_children(&target)
                        }
                        fn intersects(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::intersects(&target, item)
                        }
                        fn set_shadow_color(
                            &mut self,
                            value: super::ItemShadowColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_shadow_color(&mut target, value)
                        }
                        fn shadow_color(
                            &self,
                        ) -> std::result::Result<super::ItemShadowColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::shadow_color(&target)
                        }
                        fn set_scaling(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_scaling(&mut target, value)
                        }
                        fn scaling(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::scaling(&target)
                        }
                    }
                    impl Ellipse_Trait for Ellipse where Ellipse: Path_Trait {}
                    impl std::clone::Clone for Ellipse_Class {
                        fn clone(&self) -> Self {
                            Self {
                                obj: std::clone::Clone::clone(&self.obj),
                            }
                        }
                    }
                    impl serde::ser::Serialize for Ellipse_Class {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Ellipse_Class {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                        }
                    }
                    #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                    extern "C" {
                        # [wasm_bindgen (js_name = "RegularPolygon" , extends = Item_Class , extends = PathItem_Class , extends = Path_Class)]
                        pub type RegularPolygon_Class;
                        #[wasm_bindgen(constructor, js_class = "RegularPolygon")]
                        pub fn new(object: JsValue) -> RegularPolygon_Class;
                    }
                    #[derive(std :: clone :: Clone)]
                    pub struct RegularPolygon(pub RegularPolygon_Class);
                    impl std::convert::From<&RegularPolygon> for super::Path {
                        fn from(src: &RegularPolygon) -> super::Path {
                            let src: &super::Path_Class = src.0.as_ref();
                            super::Path(src.clone())
                        }
                    }
                    impl std::convert::From<&mut RegularPolygon> for super::Path {
                        fn from(src: &mut RegularPolygon) -> super::Path {
                            let src: &super::Path_Class = src.0.as_ref();
                            super::Path(src.clone())
                        }
                    }
                    impl std::convert::From<&RegularPolygon> for super::Item {
                        fn from(src: &RegularPolygon) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&mut RegularPolygon> for super::Item {
                        fn from(src: &mut RegularPolygon) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&RegularPolygon> for super::PathItem {
                        fn from(src: &RegularPolygon) -> super::PathItem {
                            let src: &super::PathItem_Class = src.0.as_ref();
                            super::PathItem(src.clone())
                        }
                    }
                    impl std::convert::From<&mut RegularPolygon> for super::PathItem {
                        fn from(src: &mut RegularPolygon) -> super::PathItem {
                            let src: &super::PathItem_Class = src.0.as_ref();
                            super::PathItem(src.clone())
                        }
                    }
                    impl RegularPolygon {
                        #[allow(dead_code)]
                        pub fn new(object: JsValue) -> RegularPolygon {
                            let result = RegularPolygon_Class::new(object);
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            RegularPolygon(result)
                        }
                    }
                    impl wasm_bindgen::describe::WasmDescribe for RegularPolygon {
                        fn describe() {
                            <RegularPolygon_Class as wasm_bindgen::describe::WasmDescribe>::describe(
                            )
                        }
                    }
                    impl wasm_bindgen::convert::IntoWasmAbi for RegularPolygon {
                        type Abi =
                            <RegularPolygon_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                        }
                    }
                    impl wasm_bindgen::convert::FromWasmAbi for RegularPolygon {
                        type Abi =
                            <RegularPolygon_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                        unsafe fn from_abi(js: Self::Abi) -> Self {
                            RegularPolygon(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                        }
                    }
                    impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a RegularPolygon {
                        type Abi =
                            <&'a RegularPolygon_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                        }
                    }
                    impl serde::ser::Serialize for RegularPolygon {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde::ser::Serialize::serialize(&self.0, serializer)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for RegularPolygon {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            let internal: RegularPolygon_Class =
                                <RegularPolygon_Class as serde::de::Deserialize>::deserialize(
                                    deserializer,
                                )?;
                            std::result::Result::Ok(Self(internal))
                        }
                    }
                    #[allow(non_camel_case_types)]
                    pub trait RegularPolygon_Trait: Path_Trait {}
                    impl Path_Trait for RegularPolygon
                    where
                        RegularPolygon: PathItem_Trait,
                    {
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::reduce(&target, options)
                        }
                        fn get_curvature_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_curvature_at(&target, offset)
                        }
                        fn set_last_curve(
                            &mut self,
                            value: super::Curve,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_last_curve(&mut target, value)
                        }
                        fn last_curve(&self) -> std::result::Result<super::Curve, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::last_curve(&target)
                        }
                        fn split_at(
                            &self,
                            location: super::PathSplitAtParamsLocationParam,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::split_at(&target, location)
                        }
                        fn set_area(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_area(&mut target, value)
                        }
                        fn area(&self) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::area(&target)
                        }
                        fn divide_at(
                            &self,
                            location: super::PathDivideAtParamsLocationParam,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::divide_at(&target, location)
                        }
                        fn get_offsets_with_tangent(
                            &self,
                            tangent: super::Point,
                        ) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_offsets_with_tangent(&target, tangent)
                        }
                        fn set_first_segment(
                            &mut self,
                            value: super::Segment,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_first_segment(&mut target, value)
                        }
                        fn first_segment(&self) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::first_segment(&target)
                        }
                        fn set_first_curve(
                            &mut self,
                            value: super::Curve,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_first_curve(&mut target, value)
                        }
                        fn first_curve(&self) -> std::result::Result<super::Curve, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::first_curve(&target)
                        }
                        fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::has_handles(&target)
                        }
                        fn get_normal_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_normal_at(&target, offset)
                        }
                        fn set_last_segment(
                            &mut self,
                            value: super::Segment,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_last_segment(&mut target, value)
                        }
                        fn last_segment(&self) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::last_segment(&target)
                        }
                        fn get_tangent_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_tangent_at(&target, offset)
                        }
                        fn get_weighted_tangent_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_weighted_tangent_at(&target, offset)
                        }
                        fn get_offset_of(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_offset_of(&target, point)
                        }
                        fn insert(
                            &self,
                            index: f64,
                            segment: super::PathInsertParamsSegmentParam,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::insert(&target, index, segment)
                        }
                        fn insert_segments(
                            &self,
                            index: f64,
                            segments: Vec<Segment>,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::insert_segments(&target, index, segments)
                        }
                        fn get_location_of(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::get_location_of(&target, point)
                        }
                        fn get_weighted_normal_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_weighted_normal_at(&target, offset)
                        }
                        fn set_closed(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_closed(&mut target, value)
                        }
                        fn closed(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::closed(&target)
                        }
                        fn add(
                            &self,
                            segment: Box<[super::PathAddParamsSegmentParam]>,
                        ) -> std::result::Result<super::PathAddReturn, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::add(&target, segment)
                        }
                        fn set_length(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_length(&mut target, value)
                        }
                        fn length(&self) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::length(&target)
                        }
                        fn to_shape(
                            &self,
                            insert: bool,
                        ) -> std::result::Result<super::Shape, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::to_shape(&target, insert)
                        }
                        fn get_location_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::get_location_at(&target, offset)
                        }
                        fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::clear_handles(&target)
                        }
                        fn remove_segment(
                            &self,
                            index: f64,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segment(&target, index)
                        }
                        fn set_segments(
                            &mut self,
                            value: Vec<Segment>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_segments(&mut target, value)
                        }
                        fn segments(&self) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::segments(&target)
                        }
                        fn remove_segments(
                            &self,
                            from: f64,
                            to: f64,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segments(&target, from, to)
                        }
                        fn get_point_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_point_at(&target, offset)
                        }
                        fn add_segments(
                            &self,
                            segments: Vec<Segment>,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::add_segments(&target, segments)
                        }
                        fn join(
                            &self,
                            path: super::Path,
                            tolerance: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::join(&target, path, tolerance)
                        }
                        fn set_curves(
                            &mut self,
                            value: Vec<Curve>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_curves(&mut target, value)
                        }
                        fn curves(&self) -> std::result::Result<Vec<Curve>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::curves(&target)
                        }
                        fn set_fully_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_fully_selected(&mut target, value)
                        }
                        fn fully_selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::fully_selected(&target)
                        }
                    }
                    impl PathItem_Trait for RegularPolygon
                    where
                        RegularPolygon: Item_Trait,
                    {
                        fn reverse(&self) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::reverse(&target)
                        }
                        fn get_nearest_location(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_nearest_location(&target, point)
                        }
                        fn smooth(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::smooth(&target, options)
                        }
                        fn arc_to(
                            &self,
                            to: super::Point,
                            clockwise: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_to(&target, to, clockwise)
                        }
                        fn line_to(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::line_to(&target, point)
                        }
                        fn cubic_curve_by(
                            &self,
                            handle1: super::Point,
                            handle2: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::cubic_curve_by(&target, handle1, handle2, to)
                        }
                        fn divide(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::divide(&target, path, options)
                        }
                        fn quadratic_curve_by(
                            &self,
                            handle: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::quadratic_curve_by(&target, handle, to)
                        }
                        fn create(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<super::PathItemCreateReturn, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::create(&target, object)
                        }
                        fn interpolate(
                            &self,
                            from: super::PathItem,
                            to: super::PathItem,
                            factor: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::interpolate(&target, from, to, factor)
                        }
                        fn set_clockwise(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: PathItem = self.into();
                            super::PathItem::set_clockwise(&mut target, value)
                        }
                        fn clockwise(&self) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::clockwise(&target)
                        }
                        fn set_path_data(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: PathItem = self.into();
                            super::PathItem::set_path_data(&mut target, value)
                        }
                        fn path_data(&self) -> std::result::Result<String, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::path_data(&target)
                        }
                        fn curve_to(
                            &self,
                            through: super::Point,
                            to: super::Point,
                            time: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::curve_to(&target, through, to, time)
                        }
                        fn move_to(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::move_to(&target, point)
                        }
                        fn get_crossings(
                            &self,
                            path: super::PathItem,
                        ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_crossings(&target, path)
                        }
                        fn close_path(&self) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::close_path(&target)
                        }
                        fn reorient(
                            &self,
                            non_zero: bool,
                            clockwise: bool,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::reorient(&target, non_zero, clockwise)
                        }
                        fn move_by(&self, to: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::move_by(&target, to)
                        }
                        fn quadratic_curve_to(
                            &self,
                            handle: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::quadratic_curve_to(&target, handle, to)
                        }
                        fn cubic_curve_to(
                            &self,
                            handle1: super::Point,
                            handle2: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::cubic_curve_to(&target, handle1, handle2, to)
                        }
                        fn get_intersections(
                            &self,
                            path: super::PathItem,
                            include: &'static dyn Fn(
                                Box<[JsValue]>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_intersections(&target, path, include)
                        }
                        fn compare(
                            &self,
                            path: super::PathItem,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::compare(&target, path)
                        }
                        fn set_interior_point(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: PathItem = self.into();
                            super::PathItem::set_interior_point(&mut target, value)
                        }
                        fn interior_point(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::interior_point(&target)
                        }
                        fn simplify(&self, tolerance: f64) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::simplify(&target, tolerance)
                        }
                        fn arc_by(
                            &self,
                            to: super::Point,
                            clockwise: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_by(&target, to, clockwise)
                        }
                        fn intersect(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::intersect(&target, path, options)
                        }
                        fn get_nearest_point(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::get_nearest_point(&target, point)
                        }
                        fn curve_by(
                            &self,
                            through: super::Point,
                            to: super::Point,
                            time: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::curve_by(&target, through, to, time)
                        }
                        fn exclude(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::exclude(&target, path, options)
                        }
                        fn line_by(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::line_by(&target, point)
                        }
                        fn unite(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::unite(&target, path, options)
                        }
                        fn subtract(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::subtract(&target, path, options)
                        }
                        fn flatten(&self, flatness: f64) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::flatten(&target, flatness)
                        }
                    }
                    impl Item_Trait for RegularPolygon {
                        fn set_stroke_scaling(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_scaling(&mut target, value)
                        }
                        fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_scaling(&target)
                        }
                        fn set_apply_matrix(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_apply_matrix(&mut target, value)
                        }
                        fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::apply_matrix(&target)
                        }
                        fn set_view_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_view_matrix(&mut target, value)
                        }
                        fn view_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::view_matrix(&target)
                        }
                        fn set_dash_array(
                            &mut self,
                            value: Vec<f64>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_dash_array(&mut target, value)
                        }
                        fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_array(&target)
                        }
                        fn is_ancestor(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_ancestor(&target, item)
                        }
                        fn is_descendant(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_descendant(&target, item)
                        }
                        fn is_sibling(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_sibling(&target, item)
                        }
                        fn local_to_parent(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_parent(&target, point)
                        }
                        fn set_shadow_blur(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_shadow_blur(&mut target, value)
                        }
                        fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_blur(&target)
                        }
                        fn is_empty(
                            &self,
                            recursively: bool,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_empty(&target, recursively)
                        }
                        fn is_parent(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_parent(&target, item)
                        }
                        fn is_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_below(&target, item)
                        }
                        fn set_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_matrix(&mut target, value)
                        }
                        fn matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::matrix(&target)
                        }
                        fn export_json(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::export_json(&target, options)
                        }
                        fn global_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_to_local(&target, point)
                        }
                        fn set_on_mouse_drag(
                            &mut self,
                            value: super::ItemOnMouseDrag,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_drag(&mut target, value)
                        }
                        fn on_mouse_drag(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDrag, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_drag(&target)
                        }
                        fn get_item(
                            &self,
                            options: super::ItemGetItemParamsOptionsParam,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_item(&target, options)
                        }
                        fn remove_children(
                            &self,
                            start: f64,
                            end: f64,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_children(&target, start, end)
                        }
                        fn set_project(
                            &mut self,
                            value: super::Project,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_project(&mut target, value)
                        }
                        fn project(&self) -> std::result::Result<super::Project, JsValue> {
                            let target: Item = self.into();
                            super::Item::project(&target)
                        }
                        fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_data(&mut target, value)
                        }
                        fn data(&self) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::data(&target)
                        }
                        fn insert_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_above(&target, item)
                        }
                        fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on(&target, options)
                        }
                        fn transform(
                            &self,
                            matrix: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::transform(&target, matrix)
                        }
                        fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inserted(&target)
                        }
                        fn set_on_mouse_down(
                            &mut self,
                            value: super::ItemOnMouseDown,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_down(&mut target, value)
                        }
                        fn on_mouse_down(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDown, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_down(&target)
                        }
                        fn set_last_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_last_child(&mut target, value)
                        }
                        fn last_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::last_child(&target)
                        }
                        fn set_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_selected(&mut target, value)
                        }
                        fn selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::selected(&target)
                        }
                        fn set_global_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_global_matrix(&mut target, value)
                        }
                        fn global_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_matrix(&target)
                        }
                        fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::responds(&target, type_)
                        }
                        fn rotate(
                            &self,
                            angle: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::rotate(&target, angle, center)
                        }
                        fn tween(
                            &self,
                            options: super::ItemTweenParamsOptionsParam,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween(&target, options)
                        }
                        fn set_on_mouse_enter(
                            &mut self,
                            value: super::ItemOnMouseEnter,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_enter(&mut target, value)
                        }
                        fn on_mouse_enter(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseEnter, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_enter(&target)
                        }
                        fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_id(&mut target, value)
                        }
                        fn id(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::id(&target)
                        }
                        fn on(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::on(&target, object)
                        }
                        fn tween_to(
                            &self,
                            to: JsValue,
                            options: super::ItemTweenToParamsOptionsParam,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_to(&target, to, options)
                        }
                        fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_locked(&mut target, value)
                        }
                        fn locked(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::locked(&target)
                        }
                        fn set_children(
                            &mut self,
                            value: Vec<Item>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_children(&mut target, value)
                        }
                        fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::children(&target)
                        }
                        fn copy_attributes(
                            &self,
                            source: super::Item,
                            exclude_matrix: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_attributes(&target, source, exclude_matrix)
                        }
                        fn off(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::off(&target, object)
                        }
                        fn contains(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::contains(&target, point)
                        }
                        fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_stroke(&target)
                        }
                        fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_move(&target)
                        }
                        fn add_children(
                            &self,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_children(&target, items)
                        }
                        fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::reverse_children(&target)
                        }
                        fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_shadow(&target)
                        }
                        fn set_dash_offset(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_dash_offset(&mut target, value)
                        }
                        fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_offset(&target)
                        }
                        fn set_on_mouse_leave(
                            &mut self,
                            value: super::ItemOnMouseLeave,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_leave(&mut target, value)
                        }
                        fn on_mouse_leave(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseLeave, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_leave(&target)
                        }
                        fn hit_test_all(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<Vec<HitResult>, JsValue> {
                            let target: Item = self.into();
                            super::Item::hit_test_all(&target, point, options)
                        }
                        fn set_stroke_cap(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_cap(&mut target, value)
                        }
                        fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_cap(&target)
                        }
                        fn set_internal_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_internal_bounds(&mut target, value)
                        }
                        fn internal_bounds(
                            &self,
                        ) -> std::result::Result<super::Rectangle, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::internal_bounds(&target)
                        }
                        fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_index(&mut target, value)
                        }
                        fn index(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::index(&target)
                        }
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::reduce(&target, options)
                        }
                        fn is_grouped_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_grouped_with(&target, item)
                        }
                        fn local_to_global(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_global(&target, point)
                        }
                        fn set_first_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_first_child(&mut target, value)
                        }
                        fn first_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::first_child(&target)
                        }
                        fn set_position(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_position(&mut target, value)
                        }
                        fn position(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::position(&target)
                        }
                        fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_opacity(&mut target, value)
                        }
                        fn opacity(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::opacity(&target)
                        }
                        fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_down(&target)
                        }
                        fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_drag(&target)
                        }
                        fn set_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_bounds(&mut target, value)
                        }
                        fn bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::bounds(&target)
                        }
                        fn set_parent(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_parent(&mut target, value)
                        }
                        fn parent(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent(&target)
                        }
                        fn get_items(
                            &self,
                            options: super::ItemGetItemsParamsOptionsParam,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_items(&target, options)
                        }
                        fn copy_to(
                            &self,
                            owner: super::ItemCopyToParamsOwnerParam,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_to(&target, owner)
                        }
                        fn set_on_double_click(
                            &mut self,
                            value: super::ItemOnDoubleClick,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_double_click(&mut target, value)
                        }
                        fn on_double_click(
                            &self,
                        ) -> std::result::Result<super::ItemOnDoubleClick, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_double_click(&target)
                        }
                        fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::set(&target, props)
                        }
                        fn scale(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::scale(&target, hor, ver, center)
                        }
                        fn insert_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_below(&target, item)
                        }
                        fn set_next_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_next_sibling(&mut target, value)
                        }
                        fn next_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::next_sibling(&target)
                        }
                        fn rasterize(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Raster, JsValue> {
                            let target: Item = self.into();
                            super::Item::rasterize(&target, options)
                        }
                        fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::bring_to_front(&target)
                        }
                        fn matches(
                            &self,
                            name: String,
                            compare: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::matches(&target, name, compare)
                        }
                        fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_fill(&target)
                        }
                        fn set_view(
                            &mut self,
                            value: super::View,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_view(&mut target, value)
                        }
                        fn view(&self) -> std::result::Result<super::View, JsValue> {
                            let target: Item = self.into();
                            super::Item::view(&target)
                        }
                        fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::clone(&target, options)
                        }
                        fn set_handle_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_handle_bounds(&mut target, value)
                        }
                        fn handle_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::handle_bounds(&target)
                        }
                        fn is_inside(
                            &self,
                            rect: super::Rectangle,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inside(&target, rect)
                        }
                        fn is_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_above(&target, item)
                        }
                        fn remove(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove(&target)
                        }
                        fn set_stroke_join(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_join(&mut target, value)
                        }
                        fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_join(&target)
                        }
                        fn set_on_click(
                            &mut self,
                            value: super::ItemOnClick,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_click(&mut target, value)
                        }
                        fn on_click(&self) -> std::result::Result<super::ItemOnClick, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_click(&target)
                        }
                        fn fit_bounds(
                            &self,
                            rectangle: super::Rectangle,
                            fill: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::fit_bounds(&target, rectangle, fill)
                        }
                        fn set_blend_mode(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_blend_mode(&mut target, value)
                        }
                        fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::blend_mode(&target)
                        }
                        fn set_stroke_width(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_width(&mut target, value)
                        }
                        fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_width(&target)
                        }
                        fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_rotation(&mut target, value)
                        }
                        fn rotation(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::rotation(&target)
                        }
                        fn set_selected_color(
                            &mut self,
                            value: super::ItemSelectedColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_selected_color(&mut target, value)
                        }
                        fn selected_color(
                            &self,
                        ) -> std::result::Result<super::ItemSelectedColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::selected_color(&target)
                        }
                        fn skew(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::skew(&target, hor, ver, center)
                        }
                        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_name(&mut target, value)
                        }
                        fn name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::name(&target)
                        }
                        fn import_json(
                            &self,
                            json: String,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_json(&target, json)
                        }
                        fn add_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_child(&target, item)
                        }
                        fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_visible(&mut target, value)
                        }
                        fn visible(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::visible(&target)
                        }
                        fn set_fill_rule(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_fill_rule(&mut target, value)
                        }
                        fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_rule(&target)
                        }
                        fn set_layer(
                            &mut self,
                            value: super::Layer,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_layer(&mut target, value)
                        }
                        fn layer(&self) -> std::result::Result<super::Layer, JsValue> {
                            let target: Item = self.into();
                            super::Item::layer(&target)
                        }
                        fn tween_from(
                            &self,
                            from: JsValue,
                            options: super::ItemTweenFromParamsOptionsParam,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_from(&target, from, options)
                        }
                        fn insert_child(
                            &self,
                            index: f64,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_child(&target, index, item)
                        }
                        fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_up(&target)
                        }
                        fn set_pivot(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_pivot(&mut target, value)
                        }
                        fn pivot(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::pivot(&target)
                        }
                        fn set_miter_limit(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_miter_limit(&mut target, value)
                        }
                        fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::miter_limit(&target)
                        }
                        fn copy_content(
                            &self,
                            source: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_content(&target, source)
                        }
                        fn import_svg(
                            &self,
                            svg: super::ItemImportSvgParamsSvgParam,
                            on_load: &'static dyn Fn(
                                Box<[JsValue]>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_svg(&target, svg, on_load)
                        }
                        fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::send_to_back(&target)
                        }
                        fn set_stroke_color(
                            &mut self,
                            value: super::ItemStrokeColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_color(&mut target, value)
                        }
                        fn stroke_color(
                            &self,
                        ) -> std::result::Result<super::ItemStrokeColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::stroke_color(&target)
                        }
                        fn set_on_mouse_move(
                            &mut self,
                            value: super::ItemOnMouseMove,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_move(&mut target, value)
                        }
                        fn on_mouse_move(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseMove, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_move(&target)
                        }
                        fn replace_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::replace_with(&target, item)
                        }
                        fn hit_test(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<super::HitResult, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::hit_test(&target, point, options)
                        }
                        fn shear(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::shear(&target, hor, ver, center)
                        }
                        fn translate(
                            &self,
                            delta: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::translate(&target, delta)
                        }
                        fn set_stroke_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_bounds(&mut target, value)
                        }
                        fn stroke_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_bounds(&target)
                        }
                        fn insert_children(
                            &self,
                            index: f64,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_children(&target, index, items)
                        }
                        fn is_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_child(&target, item)
                        }
                        fn set_shadow_offset(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_shadow_offset(&mut target, value)
                        }
                        fn shadow_offset(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_offset(&target)
                        }
                        fn set_fill_color(
                            &mut self,
                            value: super::ItemFillColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_fill_color(&mut target, value)
                        }
                        fn fill_color(&self) -> std::result::Result<super::ItemFillColor, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_color(&target)
                        }
                        fn export_svg(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::ItemExportSvgReturn, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::export_svg(&target, options)
                        }
                        fn set_style(
                            &mut self,
                            value: super::Style,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_style(&mut target, value)
                        }
                        fn style(&self) -> std::result::Result<super::Style, JsValue> {
                            let target: Item = self.into();
                            super::Item::style(&target)
                        }
                        fn set_clip_mask(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_clip_mask(&mut target, value)
                        }
                        fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::clip_mask(&target)
                        }
                        fn set_class_name(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_class_name(&mut target, value)
                        }
                        fn class_name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::class_name(&target)
                        }
                        fn set_on_mouse_up(
                            &mut self,
                            value: super::ItemOnMouseUp,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_up(&mut target, value)
                        }
                        fn on_mouse_up(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseUp, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_up(&target)
                        }
                        fn set_on_frame(
                            &mut self,
                            value: super::ItemOnFrame,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_frame(&mut target, value)
                        }
                        fn on_frame(&self) -> std::result::Result<super::ItemOnFrame, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_frame(&target)
                        }
                        fn parent_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent_to_local(&target, point)
                        }
                        fn set_previous_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_previous_sibling(&mut target, value)
                        }
                        fn previous_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::previous_sibling(&target)
                        }
                        fn emit(
                            &self,
                            type_: String,
                            event: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::emit(&target, type_, event)
                        }
                        fn add_to(
                            &self,
                            owner: super::ItemAddToParamsOwnerParam,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_to(&target, owner)
                        }
                        fn has_children(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_children(&target)
                        }
                        fn intersects(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::intersects(&target, item)
                        }
                        fn set_shadow_color(
                            &mut self,
                            value: super::ItemShadowColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_shadow_color(&mut target, value)
                        }
                        fn shadow_color(
                            &self,
                        ) -> std::result::Result<super::ItemShadowColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::shadow_color(&target)
                        }
                        fn set_scaling(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_scaling(&mut target, value)
                        }
                        fn scaling(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::scaling(&target)
                        }
                    }
                    impl RegularPolygon_Trait for RegularPolygon where RegularPolygon: Path_Trait {}
                    impl std::clone::Clone for RegularPolygon_Class {
                        fn clone(&self) -> Self {
                            Self {
                                obj: std::clone::Clone::clone(&self.obj),
                            }
                        }
                    }
                    impl serde::ser::Serialize for RegularPolygon_Class {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for RegularPolygon_Class {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                        }
                    }
                    #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                    extern "C" {
                        # [wasm_bindgen (js_name = "Circle" , extends = PathItem_Class , extends = Path_Class , extends = Item_Class)]
                        pub type Circle_Class;
                        #[wasm_bindgen(constructor, js_class = "Circle")]
                        pub fn new(object: JsValue) -> Circle_Class;
                    }
                    #[derive(std :: clone :: Clone)]
                    pub struct Circle(pub Circle_Class);
                    impl std::convert::From<&Circle> for super::Item {
                        fn from(src: &Circle) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Circle> for super::Item {
                        fn from(src: &mut Circle) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&Circle> for super::Path {
                        fn from(src: &Circle) -> super::Path {
                            let src: &super::Path_Class = src.0.as_ref();
                            super::Path(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Circle> for super::Path {
                        fn from(src: &mut Circle) -> super::Path {
                            let src: &super::Path_Class = src.0.as_ref();
                            super::Path(src.clone())
                        }
                    }
                    impl std::convert::From<&Circle> for super::PathItem {
                        fn from(src: &Circle) -> super::PathItem {
                            let src: &super::PathItem_Class = src.0.as_ref();
                            super::PathItem(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Circle> for super::PathItem {
                        fn from(src: &mut Circle) -> super::PathItem {
                            let src: &super::PathItem_Class = src.0.as_ref();
                            super::PathItem(src.clone())
                        }
                    }
                    impl Circle {
                        #[allow(dead_code)]
                        pub fn new(object: JsValue) -> Circle {
                            let result = Circle_Class::new(object);
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            Circle(result)
                        }
                    }
                    impl wasm_bindgen::describe::WasmDescribe for Circle {
                        fn describe() {
                            <Circle_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                        }
                    }
                    impl wasm_bindgen::convert::IntoWasmAbi for Circle {
                        type Abi = <Circle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                        }
                    }
                    impl wasm_bindgen::convert::FromWasmAbi for Circle {
                        type Abi = <Circle_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                        unsafe fn from_abi(js: Self::Abi) -> Self {
                            Circle(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                        }
                    }
                    impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Circle {
                        type Abi = <&'a Circle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                        }
                    }
                    impl serde::ser::Serialize for Circle {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde::ser::Serialize::serialize(&self.0, serializer)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Circle {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            let internal: Circle_Class =
                                <Circle_Class as serde::de::Deserialize>::deserialize(
                                    deserializer,
                                )?;
                            std::result::Result::Ok(Self(internal))
                        }
                    }
                    #[allow(non_camel_case_types)]
                    pub trait Circle_Trait: Path_Trait {}
                    impl Path_Trait for Circle
                    where
                        Circle: PathItem_Trait,
                    {
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::reduce(&target, options)
                        }
                        fn get_curvature_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_curvature_at(&target, offset)
                        }
                        fn set_last_curve(
                            &mut self,
                            value: super::Curve,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_last_curve(&mut target, value)
                        }
                        fn last_curve(&self) -> std::result::Result<super::Curve, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::last_curve(&target)
                        }
                        fn split_at(
                            &self,
                            location: super::PathSplitAtParamsLocationParam,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::split_at(&target, location)
                        }
                        fn set_area(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_area(&mut target, value)
                        }
                        fn area(&self) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::area(&target)
                        }
                        fn divide_at(
                            &self,
                            location: super::PathDivideAtParamsLocationParam,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::divide_at(&target, location)
                        }
                        fn get_offsets_with_tangent(
                            &self,
                            tangent: super::Point,
                        ) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_offsets_with_tangent(&target, tangent)
                        }
                        fn set_first_segment(
                            &mut self,
                            value: super::Segment,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_first_segment(&mut target, value)
                        }
                        fn first_segment(&self) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::first_segment(&target)
                        }
                        fn set_first_curve(
                            &mut self,
                            value: super::Curve,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_first_curve(&mut target, value)
                        }
                        fn first_curve(&self) -> std::result::Result<super::Curve, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::first_curve(&target)
                        }
                        fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::has_handles(&target)
                        }
                        fn get_normal_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_normal_at(&target, offset)
                        }
                        fn set_last_segment(
                            &mut self,
                            value: super::Segment,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_last_segment(&mut target, value)
                        }
                        fn last_segment(&self) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::last_segment(&target)
                        }
                        fn get_tangent_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_tangent_at(&target, offset)
                        }
                        fn get_weighted_tangent_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_weighted_tangent_at(&target, offset)
                        }
                        fn get_offset_of(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_offset_of(&target, point)
                        }
                        fn insert(
                            &self,
                            index: f64,
                            segment: super::PathInsertParamsSegmentParam,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::insert(&target, index, segment)
                        }
                        fn insert_segments(
                            &self,
                            index: f64,
                            segments: Vec<Segment>,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::insert_segments(&target, index, segments)
                        }
                        fn get_location_of(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::get_location_of(&target, point)
                        }
                        fn get_weighted_normal_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_weighted_normal_at(&target, offset)
                        }
                        fn set_closed(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_closed(&mut target, value)
                        }
                        fn closed(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::closed(&target)
                        }
                        fn add(
                            &self,
                            segment: Box<[super::PathAddParamsSegmentParam]>,
                        ) -> std::result::Result<super::PathAddReturn, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::add(&target, segment)
                        }
                        fn set_length(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_length(&mut target, value)
                        }
                        fn length(&self) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::length(&target)
                        }
                        fn to_shape(
                            &self,
                            insert: bool,
                        ) -> std::result::Result<super::Shape, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::to_shape(&target, insert)
                        }
                        fn get_location_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::get_location_at(&target, offset)
                        }
                        fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::clear_handles(&target)
                        }
                        fn remove_segment(
                            &self,
                            index: f64,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segment(&target, index)
                        }
                        fn set_segments(
                            &mut self,
                            value: Vec<Segment>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_segments(&mut target, value)
                        }
                        fn segments(&self) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::segments(&target)
                        }
                        fn remove_segments(
                            &self,
                            from: f64,
                            to: f64,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segments(&target, from, to)
                        }
                        fn get_point_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_point_at(&target, offset)
                        }
                        fn add_segments(
                            &self,
                            segments: Vec<Segment>,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::add_segments(&target, segments)
                        }
                        fn join(
                            &self,
                            path: super::Path,
                            tolerance: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::join(&target, path, tolerance)
                        }
                        fn set_curves(
                            &mut self,
                            value: Vec<Curve>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_curves(&mut target, value)
                        }
                        fn curves(&self) -> std::result::Result<Vec<Curve>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::curves(&target)
                        }
                        fn set_fully_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_fully_selected(&mut target, value)
                        }
                        fn fully_selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::fully_selected(&target)
                        }
                    }
                    impl PathItem_Trait for Circle
                    where
                        Circle: Item_Trait,
                    {
                        fn reverse(&self) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::reverse(&target)
                        }
                        fn get_nearest_location(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_nearest_location(&target, point)
                        }
                        fn smooth(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::smooth(&target, options)
                        }
                        fn arc_to(
                            &self,
                            to: super::Point,
                            clockwise: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_to(&target, to, clockwise)
                        }
                        fn line_to(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::line_to(&target, point)
                        }
                        fn cubic_curve_by(
                            &self,
                            handle1: super::Point,
                            handle2: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::cubic_curve_by(&target, handle1, handle2, to)
                        }
                        fn divide(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::divide(&target, path, options)
                        }
                        fn quadratic_curve_by(
                            &self,
                            handle: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::quadratic_curve_by(&target, handle, to)
                        }
                        fn create(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<super::PathItemCreateReturn, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::create(&target, object)
                        }
                        fn interpolate(
                            &self,
                            from: super::PathItem,
                            to: super::PathItem,
                            factor: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::interpolate(&target, from, to, factor)
                        }
                        fn set_clockwise(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: PathItem = self.into();
                            super::PathItem::set_clockwise(&mut target, value)
                        }
                        fn clockwise(&self) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::clockwise(&target)
                        }
                        fn set_path_data(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: PathItem = self.into();
                            super::PathItem::set_path_data(&mut target, value)
                        }
                        fn path_data(&self) -> std::result::Result<String, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::path_data(&target)
                        }
                        fn curve_to(
                            &self,
                            through: super::Point,
                            to: super::Point,
                            time: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::curve_to(&target, through, to, time)
                        }
                        fn move_to(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::move_to(&target, point)
                        }
                        fn get_crossings(
                            &self,
                            path: super::PathItem,
                        ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_crossings(&target, path)
                        }
                        fn close_path(&self) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::close_path(&target)
                        }
                        fn reorient(
                            &self,
                            non_zero: bool,
                            clockwise: bool,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::reorient(&target, non_zero, clockwise)
                        }
                        fn move_by(&self, to: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::move_by(&target, to)
                        }
                        fn quadratic_curve_to(
                            &self,
                            handle: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::quadratic_curve_to(&target, handle, to)
                        }
                        fn cubic_curve_to(
                            &self,
                            handle1: super::Point,
                            handle2: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::cubic_curve_to(&target, handle1, handle2, to)
                        }
                        fn get_intersections(
                            &self,
                            path: super::PathItem,
                            include: &'static dyn Fn(
                                Box<[JsValue]>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_intersections(&target, path, include)
                        }
                        fn compare(
                            &self,
                            path: super::PathItem,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::compare(&target, path)
                        }
                        fn set_interior_point(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: PathItem = self.into();
                            super::PathItem::set_interior_point(&mut target, value)
                        }
                        fn interior_point(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::interior_point(&target)
                        }
                        fn simplify(&self, tolerance: f64) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::simplify(&target, tolerance)
                        }
                        fn arc_by(
                            &self,
                            to: super::Point,
                            clockwise: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_by(&target, to, clockwise)
                        }
                        fn intersect(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::intersect(&target, path, options)
                        }
                        fn get_nearest_point(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::get_nearest_point(&target, point)
                        }
                        fn curve_by(
                            &self,
                            through: super::Point,
                            to: super::Point,
                            time: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::curve_by(&target, through, to, time)
                        }
                        fn exclude(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::exclude(&target, path, options)
                        }
                        fn line_by(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::line_by(&target, point)
                        }
                        fn unite(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::unite(&target, path, options)
                        }
                        fn subtract(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::subtract(&target, path, options)
                        }
                        fn flatten(&self, flatness: f64) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::flatten(&target, flatness)
                        }
                    }
                    impl Item_Trait for Circle {
                        fn set_stroke_scaling(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_scaling(&mut target, value)
                        }
                        fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_scaling(&target)
                        }
                        fn set_apply_matrix(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_apply_matrix(&mut target, value)
                        }
                        fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::apply_matrix(&target)
                        }
                        fn set_view_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_view_matrix(&mut target, value)
                        }
                        fn view_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::view_matrix(&target)
                        }
                        fn set_dash_array(
                            &mut self,
                            value: Vec<f64>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_dash_array(&mut target, value)
                        }
                        fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_array(&target)
                        }
                        fn is_ancestor(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_ancestor(&target, item)
                        }
                        fn is_descendant(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_descendant(&target, item)
                        }
                        fn is_sibling(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_sibling(&target, item)
                        }
                        fn local_to_parent(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_parent(&target, point)
                        }
                        fn set_shadow_blur(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_shadow_blur(&mut target, value)
                        }
                        fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_blur(&target)
                        }
                        fn is_empty(
                            &self,
                            recursively: bool,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_empty(&target, recursively)
                        }
                        fn is_parent(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_parent(&target, item)
                        }
                        fn is_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_below(&target, item)
                        }
                        fn set_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_matrix(&mut target, value)
                        }
                        fn matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::matrix(&target)
                        }
                        fn export_json(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::export_json(&target, options)
                        }
                        fn global_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_to_local(&target, point)
                        }
                        fn set_on_mouse_drag(
                            &mut self,
                            value: super::ItemOnMouseDrag,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_drag(&mut target, value)
                        }
                        fn on_mouse_drag(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDrag, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_drag(&target)
                        }
                        fn get_item(
                            &self,
                            options: super::ItemGetItemParamsOptionsParam,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_item(&target, options)
                        }
                        fn remove_children(
                            &self,
                            start: f64,
                            end: f64,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_children(&target, start, end)
                        }
                        fn set_project(
                            &mut self,
                            value: super::Project,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_project(&mut target, value)
                        }
                        fn project(&self) -> std::result::Result<super::Project, JsValue> {
                            let target: Item = self.into();
                            super::Item::project(&target)
                        }
                        fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_data(&mut target, value)
                        }
                        fn data(&self) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::data(&target)
                        }
                        fn insert_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_above(&target, item)
                        }
                        fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on(&target, options)
                        }
                        fn transform(
                            &self,
                            matrix: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::transform(&target, matrix)
                        }
                        fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inserted(&target)
                        }
                        fn set_on_mouse_down(
                            &mut self,
                            value: super::ItemOnMouseDown,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_down(&mut target, value)
                        }
                        fn on_mouse_down(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDown, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_down(&target)
                        }
                        fn set_last_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_last_child(&mut target, value)
                        }
                        fn last_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::last_child(&target)
                        }
                        fn set_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_selected(&mut target, value)
                        }
                        fn selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::selected(&target)
                        }
                        fn set_global_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_global_matrix(&mut target, value)
                        }
                        fn global_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_matrix(&target)
                        }
                        fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::responds(&target, type_)
                        }
                        fn rotate(
                            &self,
                            angle: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::rotate(&target, angle, center)
                        }
                        fn tween(
                            &self,
                            options: super::ItemTweenParamsOptionsParam,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween(&target, options)
                        }
                        fn set_on_mouse_enter(
                            &mut self,
                            value: super::ItemOnMouseEnter,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_enter(&mut target, value)
                        }
                        fn on_mouse_enter(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseEnter, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_enter(&target)
                        }
                        fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_id(&mut target, value)
                        }
                        fn id(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::id(&target)
                        }
                        fn on(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::on(&target, object)
                        }
                        fn tween_to(
                            &self,
                            to: JsValue,
                            options: super::ItemTweenToParamsOptionsParam,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_to(&target, to, options)
                        }
                        fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_locked(&mut target, value)
                        }
                        fn locked(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::locked(&target)
                        }
                        fn set_children(
                            &mut self,
                            value: Vec<Item>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_children(&mut target, value)
                        }
                        fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::children(&target)
                        }
                        fn copy_attributes(
                            &self,
                            source: super::Item,
                            exclude_matrix: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_attributes(&target, source, exclude_matrix)
                        }
                        fn off(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::off(&target, object)
                        }
                        fn contains(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::contains(&target, point)
                        }
                        fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_stroke(&target)
                        }
                        fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_move(&target)
                        }
                        fn add_children(
                            &self,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_children(&target, items)
                        }
                        fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::reverse_children(&target)
                        }
                        fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_shadow(&target)
                        }
                        fn set_dash_offset(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_dash_offset(&mut target, value)
                        }
                        fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_offset(&target)
                        }
                        fn set_on_mouse_leave(
                            &mut self,
                            value: super::ItemOnMouseLeave,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_leave(&mut target, value)
                        }
                        fn on_mouse_leave(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseLeave, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_leave(&target)
                        }
                        fn hit_test_all(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<Vec<HitResult>, JsValue> {
                            let target: Item = self.into();
                            super::Item::hit_test_all(&target, point, options)
                        }
                        fn set_stroke_cap(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_cap(&mut target, value)
                        }
                        fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_cap(&target)
                        }
                        fn set_internal_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_internal_bounds(&mut target, value)
                        }
                        fn internal_bounds(
                            &self,
                        ) -> std::result::Result<super::Rectangle, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::internal_bounds(&target)
                        }
                        fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_index(&mut target, value)
                        }
                        fn index(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::index(&target)
                        }
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::reduce(&target, options)
                        }
                        fn is_grouped_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_grouped_with(&target, item)
                        }
                        fn local_to_global(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_global(&target, point)
                        }
                        fn set_first_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_first_child(&mut target, value)
                        }
                        fn first_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::first_child(&target)
                        }
                        fn set_position(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_position(&mut target, value)
                        }
                        fn position(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::position(&target)
                        }
                        fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_opacity(&mut target, value)
                        }
                        fn opacity(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::opacity(&target)
                        }
                        fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_down(&target)
                        }
                        fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_drag(&target)
                        }
                        fn set_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_bounds(&mut target, value)
                        }
                        fn bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::bounds(&target)
                        }
                        fn set_parent(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_parent(&mut target, value)
                        }
                        fn parent(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent(&target)
                        }
                        fn get_items(
                            &self,
                            options: super::ItemGetItemsParamsOptionsParam,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_items(&target, options)
                        }
                        fn copy_to(
                            &self,
                            owner: super::ItemCopyToParamsOwnerParam,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_to(&target, owner)
                        }
                        fn set_on_double_click(
                            &mut self,
                            value: super::ItemOnDoubleClick,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_double_click(&mut target, value)
                        }
                        fn on_double_click(
                            &self,
                        ) -> std::result::Result<super::ItemOnDoubleClick, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_double_click(&target)
                        }
                        fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::set(&target, props)
                        }
                        fn scale(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::scale(&target, hor, ver, center)
                        }
                        fn insert_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_below(&target, item)
                        }
                        fn set_next_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_next_sibling(&mut target, value)
                        }
                        fn next_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::next_sibling(&target)
                        }
                        fn rasterize(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Raster, JsValue> {
                            let target: Item = self.into();
                            super::Item::rasterize(&target, options)
                        }
                        fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::bring_to_front(&target)
                        }
                        fn matches(
                            &self,
                            name: String,
                            compare: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::matches(&target, name, compare)
                        }
                        fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_fill(&target)
                        }
                        fn set_view(
                            &mut self,
                            value: super::View,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_view(&mut target, value)
                        }
                        fn view(&self) -> std::result::Result<super::View, JsValue> {
                            let target: Item = self.into();
                            super::Item::view(&target)
                        }
                        fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::clone(&target, options)
                        }
                        fn set_handle_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_handle_bounds(&mut target, value)
                        }
                        fn handle_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::handle_bounds(&target)
                        }
                        fn is_inside(
                            &self,
                            rect: super::Rectangle,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inside(&target, rect)
                        }
                        fn is_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_above(&target, item)
                        }
                        fn remove(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove(&target)
                        }
                        fn set_stroke_join(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_join(&mut target, value)
                        }
                        fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_join(&target)
                        }
                        fn set_on_click(
                            &mut self,
                            value: super::ItemOnClick,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_click(&mut target, value)
                        }
                        fn on_click(&self) -> std::result::Result<super::ItemOnClick, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_click(&target)
                        }
                        fn fit_bounds(
                            &self,
                            rectangle: super::Rectangle,
                            fill: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::fit_bounds(&target, rectangle, fill)
                        }
                        fn set_blend_mode(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_blend_mode(&mut target, value)
                        }
                        fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::blend_mode(&target)
                        }
                        fn set_stroke_width(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_width(&mut target, value)
                        }
                        fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_width(&target)
                        }
                        fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_rotation(&mut target, value)
                        }
                        fn rotation(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::rotation(&target)
                        }
                        fn set_selected_color(
                            &mut self,
                            value: super::ItemSelectedColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_selected_color(&mut target, value)
                        }
                        fn selected_color(
                            &self,
                        ) -> std::result::Result<super::ItemSelectedColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::selected_color(&target)
                        }
                        fn skew(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::skew(&target, hor, ver, center)
                        }
                        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_name(&mut target, value)
                        }
                        fn name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::name(&target)
                        }
                        fn import_json(
                            &self,
                            json: String,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_json(&target, json)
                        }
                        fn add_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_child(&target, item)
                        }
                        fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_visible(&mut target, value)
                        }
                        fn visible(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::visible(&target)
                        }
                        fn set_fill_rule(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_fill_rule(&mut target, value)
                        }
                        fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_rule(&target)
                        }
                        fn set_layer(
                            &mut self,
                            value: super::Layer,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_layer(&mut target, value)
                        }
                        fn layer(&self) -> std::result::Result<super::Layer, JsValue> {
                            let target: Item = self.into();
                            super::Item::layer(&target)
                        }
                        fn tween_from(
                            &self,
                            from: JsValue,
                            options: super::ItemTweenFromParamsOptionsParam,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_from(&target, from, options)
                        }
                        fn insert_child(
                            &self,
                            index: f64,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_child(&target, index, item)
                        }
                        fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_up(&target)
                        }
                        fn set_pivot(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_pivot(&mut target, value)
                        }
                        fn pivot(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::pivot(&target)
                        }
                        fn set_miter_limit(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_miter_limit(&mut target, value)
                        }
                        fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::miter_limit(&target)
                        }
                        fn copy_content(
                            &self,
                            source: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_content(&target, source)
                        }
                        fn import_svg(
                            &self,
                            svg: super::ItemImportSvgParamsSvgParam,
                            on_load: &'static dyn Fn(
                                Box<[JsValue]>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_svg(&target, svg, on_load)
                        }
                        fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::send_to_back(&target)
                        }
                        fn set_stroke_color(
                            &mut self,
                            value: super::ItemStrokeColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_color(&mut target, value)
                        }
                        fn stroke_color(
                            &self,
                        ) -> std::result::Result<super::ItemStrokeColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::stroke_color(&target)
                        }
                        fn set_on_mouse_move(
                            &mut self,
                            value: super::ItemOnMouseMove,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_move(&mut target, value)
                        }
                        fn on_mouse_move(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseMove, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_move(&target)
                        }
                        fn replace_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::replace_with(&target, item)
                        }
                        fn hit_test(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<super::HitResult, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::hit_test(&target, point, options)
                        }
                        fn shear(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::shear(&target, hor, ver, center)
                        }
                        fn translate(
                            &self,
                            delta: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::translate(&target, delta)
                        }
                        fn set_stroke_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_bounds(&mut target, value)
                        }
                        fn stroke_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_bounds(&target)
                        }
                        fn insert_children(
                            &self,
                            index: f64,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_children(&target, index, items)
                        }
                        fn is_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_child(&target, item)
                        }
                        fn set_shadow_offset(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_shadow_offset(&mut target, value)
                        }
                        fn shadow_offset(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_offset(&target)
                        }
                        fn set_fill_color(
                            &mut self,
                            value: super::ItemFillColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_fill_color(&mut target, value)
                        }
                        fn fill_color(&self) -> std::result::Result<super::ItemFillColor, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_color(&target)
                        }
                        fn export_svg(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::ItemExportSvgReturn, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::export_svg(&target, options)
                        }
                        fn set_style(
                            &mut self,
                            value: super::Style,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_style(&mut target, value)
                        }
                        fn style(&self) -> std::result::Result<super::Style, JsValue> {
                            let target: Item = self.into();
                            super::Item::style(&target)
                        }
                        fn set_clip_mask(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_clip_mask(&mut target, value)
                        }
                        fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::clip_mask(&target)
                        }
                        fn set_class_name(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_class_name(&mut target, value)
                        }
                        fn class_name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::class_name(&target)
                        }
                        fn set_on_mouse_up(
                            &mut self,
                            value: super::ItemOnMouseUp,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_up(&mut target, value)
                        }
                        fn on_mouse_up(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseUp, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_up(&target)
                        }
                        fn set_on_frame(
                            &mut self,
                            value: super::ItemOnFrame,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_frame(&mut target, value)
                        }
                        fn on_frame(&self) -> std::result::Result<super::ItemOnFrame, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_frame(&target)
                        }
                        fn parent_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent_to_local(&target, point)
                        }
                        fn set_previous_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_previous_sibling(&mut target, value)
                        }
                        fn previous_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::previous_sibling(&target)
                        }
                        fn emit(
                            &self,
                            type_: String,
                            event: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::emit(&target, type_, event)
                        }
                        fn add_to(
                            &self,
                            owner: super::ItemAddToParamsOwnerParam,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_to(&target, owner)
                        }
                        fn has_children(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_children(&target)
                        }
                        fn intersects(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::intersects(&target, item)
                        }
                        fn set_shadow_color(
                            &mut self,
                            value: super::ItemShadowColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_shadow_color(&mut target, value)
                        }
                        fn shadow_color(
                            &self,
                        ) -> std::result::Result<super::ItemShadowColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::shadow_color(&target)
                        }
                        fn set_scaling(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_scaling(&mut target, value)
                        }
                        fn scaling(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::scaling(&target)
                        }
                    }
                    impl Circle_Trait for Circle where Circle: Path_Trait {}
                    impl std::clone::Clone for Circle_Class {
                        fn clone(&self) -> Self {
                            Self {
                                obj: std::clone::Clone::clone(&self.obj),
                            }
                        }
                    }
                    impl serde::ser::Serialize for Circle_Class {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Circle_Class {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                        }
                    }
                    #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                    extern "C" {
                        # [wasm_bindgen (js_name = "Arc" , extends = PathItem_Class , extends = Path_Class , extends = Item_Class)]
                        pub type Arc_Class;
                        #[wasm_bindgen(constructor, js_class = "Arc")]
                        pub fn new(object: JsValue) -> Arc_Class;
                    }
                    #[derive(std :: clone :: Clone)]
                    pub struct Arc(pub Arc_Class);
                    impl std::convert::From<&Arc> for super::Path {
                        fn from(src: &Arc) -> super::Path {
                            let src: &super::Path_Class = src.0.as_ref();
                            super::Path(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Arc> for super::Path {
                        fn from(src: &mut Arc) -> super::Path {
                            let src: &super::Path_Class = src.0.as_ref();
                            super::Path(src.clone())
                        }
                    }
                    impl std::convert::From<&Arc> for super::PathItem {
                        fn from(src: &Arc) -> super::PathItem {
                            let src: &super::PathItem_Class = src.0.as_ref();
                            super::PathItem(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Arc> for super::PathItem {
                        fn from(src: &mut Arc) -> super::PathItem {
                            let src: &super::PathItem_Class = src.0.as_ref();
                            super::PathItem(src.clone())
                        }
                    }
                    impl std::convert::From<&Arc> for super::Item {
                        fn from(src: &Arc) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Arc> for super::Item {
                        fn from(src: &mut Arc) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl Arc {
                        #[allow(dead_code)]
                        pub fn new(object: JsValue) -> Arc {
                            let result = Arc_Class::new(object);
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            Arc(result)
                        }
                    }
                    impl wasm_bindgen::describe::WasmDescribe for Arc {
                        fn describe() {
                            <Arc_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                        }
                    }
                    impl wasm_bindgen::convert::IntoWasmAbi for Arc {
                        type Abi = <Arc_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                        }
                    }
                    impl wasm_bindgen::convert::FromWasmAbi for Arc {
                        type Abi = <Arc_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                        unsafe fn from_abi(js: Self::Abi) -> Self {
                            Arc(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                        }
                    }
                    impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Arc {
                        type Abi = <&'a Arc_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                        }
                    }
                    impl serde::ser::Serialize for Arc {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde::ser::Serialize::serialize(&self.0, serializer)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Arc {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            let internal: Arc_Class =
                                <Arc_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                            std::result::Result::Ok(Self(internal))
                        }
                    }
                    #[allow(non_camel_case_types)]
                    pub trait Arc_Trait: Path_Trait {}
                    impl Path_Trait for Arc
                    where
                        Arc: PathItem_Trait,
                    {
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::reduce(&target, options)
                        }
                        fn get_curvature_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_curvature_at(&target, offset)
                        }
                        fn set_last_curve(
                            &mut self,
                            value: super::Curve,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_last_curve(&mut target, value)
                        }
                        fn last_curve(&self) -> std::result::Result<super::Curve, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::last_curve(&target)
                        }
                        fn split_at(
                            &self,
                            location: super::PathSplitAtParamsLocationParam,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::split_at(&target, location)
                        }
                        fn set_area(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_area(&mut target, value)
                        }
                        fn area(&self) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::area(&target)
                        }
                        fn divide_at(
                            &self,
                            location: super::PathDivideAtParamsLocationParam,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::divide_at(&target, location)
                        }
                        fn get_offsets_with_tangent(
                            &self,
                            tangent: super::Point,
                        ) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_offsets_with_tangent(&target, tangent)
                        }
                        fn set_first_segment(
                            &mut self,
                            value: super::Segment,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_first_segment(&mut target, value)
                        }
                        fn first_segment(&self) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::first_segment(&target)
                        }
                        fn set_first_curve(
                            &mut self,
                            value: super::Curve,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_first_curve(&mut target, value)
                        }
                        fn first_curve(&self) -> std::result::Result<super::Curve, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::first_curve(&target)
                        }
                        fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::has_handles(&target)
                        }
                        fn get_normal_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_normal_at(&target, offset)
                        }
                        fn set_last_segment(
                            &mut self,
                            value: super::Segment,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_last_segment(&mut target, value)
                        }
                        fn last_segment(&self) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::last_segment(&target)
                        }
                        fn get_tangent_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_tangent_at(&target, offset)
                        }
                        fn get_weighted_tangent_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_weighted_tangent_at(&target, offset)
                        }
                        fn get_offset_of(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_offset_of(&target, point)
                        }
                        fn insert(
                            &self,
                            index: f64,
                            segment: super::PathInsertParamsSegmentParam,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::insert(&target, index, segment)
                        }
                        fn insert_segments(
                            &self,
                            index: f64,
                            segments: Vec<Segment>,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::insert_segments(&target, index, segments)
                        }
                        fn get_location_of(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::get_location_of(&target, point)
                        }
                        fn get_weighted_normal_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_weighted_normal_at(&target, offset)
                        }
                        fn set_closed(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_closed(&mut target, value)
                        }
                        fn closed(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::closed(&target)
                        }
                        fn add(
                            &self,
                            segment: Box<[super::PathAddParamsSegmentParam]>,
                        ) -> std::result::Result<super::PathAddReturn, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::add(&target, segment)
                        }
                        fn set_length(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_length(&mut target, value)
                        }
                        fn length(&self) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::length(&target)
                        }
                        fn to_shape(
                            &self,
                            insert: bool,
                        ) -> std::result::Result<super::Shape, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::to_shape(&target, insert)
                        }
                        fn get_location_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::get_location_at(&target, offset)
                        }
                        fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::clear_handles(&target)
                        }
                        fn remove_segment(
                            &self,
                            index: f64,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segment(&target, index)
                        }
                        fn set_segments(
                            &mut self,
                            value: Vec<Segment>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_segments(&mut target, value)
                        }
                        fn segments(&self) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::segments(&target)
                        }
                        fn remove_segments(
                            &self,
                            from: f64,
                            to: f64,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segments(&target, from, to)
                        }
                        fn get_point_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_point_at(&target, offset)
                        }
                        fn add_segments(
                            &self,
                            segments: Vec<Segment>,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::add_segments(&target, segments)
                        }
                        fn join(
                            &self,
                            path: super::Path,
                            tolerance: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::join(&target, path, tolerance)
                        }
                        fn set_curves(
                            &mut self,
                            value: Vec<Curve>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_curves(&mut target, value)
                        }
                        fn curves(&self) -> std::result::Result<Vec<Curve>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::curves(&target)
                        }
                        fn set_fully_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Path = self.into();
                            super::Path::set_fully_selected(&mut target, value)
                        }
                        fn fully_selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::fully_selected(&target)
                        }
                    }
                    impl PathItem_Trait for Arc
                    where
                        Arc: Item_Trait,
                    {
                        fn reverse(&self) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::reverse(&target)
                        }
                        fn get_nearest_location(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_nearest_location(&target, point)
                        }
                        fn smooth(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::smooth(&target, options)
                        }
                        fn arc_to(
                            &self,
                            to: super::Point,
                            clockwise: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_to(&target, to, clockwise)
                        }
                        fn line_to(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::line_to(&target, point)
                        }
                        fn cubic_curve_by(
                            &self,
                            handle1: super::Point,
                            handle2: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::cubic_curve_by(&target, handle1, handle2, to)
                        }
                        fn divide(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::divide(&target, path, options)
                        }
                        fn quadratic_curve_by(
                            &self,
                            handle: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::quadratic_curve_by(&target, handle, to)
                        }
                        fn create(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<super::PathItemCreateReturn, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::create(&target, object)
                        }
                        fn interpolate(
                            &self,
                            from: super::PathItem,
                            to: super::PathItem,
                            factor: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::interpolate(&target, from, to, factor)
                        }
                        fn set_clockwise(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: PathItem = self.into();
                            super::PathItem::set_clockwise(&mut target, value)
                        }
                        fn clockwise(&self) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::clockwise(&target)
                        }
                        fn set_path_data(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: PathItem = self.into();
                            super::PathItem::set_path_data(&mut target, value)
                        }
                        fn path_data(&self) -> std::result::Result<String, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::path_data(&target)
                        }
                        fn curve_to(
                            &self,
                            through: super::Point,
                            to: super::Point,
                            time: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::curve_to(&target, through, to, time)
                        }
                        fn move_to(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::move_to(&target, point)
                        }
                        fn get_crossings(
                            &self,
                            path: super::PathItem,
                        ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_crossings(&target, path)
                        }
                        fn close_path(&self) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::close_path(&target)
                        }
                        fn reorient(
                            &self,
                            non_zero: bool,
                            clockwise: bool,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::reorient(&target, non_zero, clockwise)
                        }
                        fn move_by(&self, to: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::move_by(&target, to)
                        }
                        fn quadratic_curve_to(
                            &self,
                            handle: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::quadratic_curve_to(&target, handle, to)
                        }
                        fn cubic_curve_to(
                            &self,
                            handle1: super::Point,
                            handle2: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::cubic_curve_to(&target, handle1, handle2, to)
                        }
                        fn get_intersections(
                            &self,
                            path: super::PathItem,
                            include: &'static dyn Fn(
                                Box<[JsValue]>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_intersections(&target, path, include)
                        }
                        fn compare(
                            &self,
                            path: super::PathItem,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::compare(&target, path)
                        }
                        fn set_interior_point(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: PathItem = self.into();
                            super::PathItem::set_interior_point(&mut target, value)
                        }
                        fn interior_point(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::interior_point(&target)
                        }
                        fn simplify(&self, tolerance: f64) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::simplify(&target, tolerance)
                        }
                        fn arc_by(
                            &self,
                            to: super::Point,
                            clockwise: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_by(&target, to, clockwise)
                        }
                        fn intersect(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::intersect(&target, path, options)
                        }
                        fn get_nearest_point(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::get_nearest_point(&target, point)
                        }
                        fn curve_by(
                            &self,
                            through: super::Point,
                            to: super::Point,
                            time: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::curve_by(&target, through, to, time)
                        }
                        fn exclude(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::exclude(&target, path, options)
                        }
                        fn line_by(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::line_by(&target, point)
                        }
                        fn unite(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::unite(&target, path, options)
                        }
                        fn subtract(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::subtract(&target, path, options)
                        }
                        fn flatten(&self, flatness: f64) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::flatten(&target, flatness)
                        }
                    }
                    impl Item_Trait for Arc {
                        fn set_stroke_scaling(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_scaling(&mut target, value)
                        }
                        fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_scaling(&target)
                        }
                        fn set_apply_matrix(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_apply_matrix(&mut target, value)
                        }
                        fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::apply_matrix(&target)
                        }
                        fn set_view_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_view_matrix(&mut target, value)
                        }
                        fn view_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::view_matrix(&target)
                        }
                        fn set_dash_array(
                            &mut self,
                            value: Vec<f64>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_dash_array(&mut target, value)
                        }
                        fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_array(&target)
                        }
                        fn is_ancestor(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_ancestor(&target, item)
                        }
                        fn is_descendant(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_descendant(&target, item)
                        }
                        fn is_sibling(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_sibling(&target, item)
                        }
                        fn local_to_parent(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_parent(&target, point)
                        }
                        fn set_shadow_blur(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_shadow_blur(&mut target, value)
                        }
                        fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_blur(&target)
                        }
                        fn is_empty(
                            &self,
                            recursively: bool,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_empty(&target, recursively)
                        }
                        fn is_parent(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_parent(&target, item)
                        }
                        fn is_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_below(&target, item)
                        }
                        fn set_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_matrix(&mut target, value)
                        }
                        fn matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::matrix(&target)
                        }
                        fn export_json(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::export_json(&target, options)
                        }
                        fn global_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_to_local(&target, point)
                        }
                        fn set_on_mouse_drag(
                            &mut self,
                            value: super::ItemOnMouseDrag,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_drag(&mut target, value)
                        }
                        fn on_mouse_drag(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDrag, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_drag(&target)
                        }
                        fn get_item(
                            &self,
                            options: super::ItemGetItemParamsOptionsParam,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_item(&target, options)
                        }
                        fn remove_children(
                            &self,
                            start: f64,
                            end: f64,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_children(&target, start, end)
                        }
                        fn set_project(
                            &mut self,
                            value: super::Project,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_project(&mut target, value)
                        }
                        fn project(&self) -> std::result::Result<super::Project, JsValue> {
                            let target: Item = self.into();
                            super::Item::project(&target)
                        }
                        fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_data(&mut target, value)
                        }
                        fn data(&self) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::data(&target)
                        }
                        fn insert_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_above(&target, item)
                        }
                        fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on(&target, options)
                        }
                        fn transform(
                            &self,
                            matrix: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::transform(&target, matrix)
                        }
                        fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inserted(&target)
                        }
                        fn set_on_mouse_down(
                            &mut self,
                            value: super::ItemOnMouseDown,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_down(&mut target, value)
                        }
                        fn on_mouse_down(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDown, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_down(&target)
                        }
                        fn set_last_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_last_child(&mut target, value)
                        }
                        fn last_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::last_child(&target)
                        }
                        fn set_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_selected(&mut target, value)
                        }
                        fn selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::selected(&target)
                        }
                        fn set_global_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_global_matrix(&mut target, value)
                        }
                        fn global_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_matrix(&target)
                        }
                        fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::responds(&target, type_)
                        }
                        fn rotate(
                            &self,
                            angle: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::rotate(&target, angle, center)
                        }
                        fn tween(
                            &self,
                            options: super::ItemTweenParamsOptionsParam,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween(&target, options)
                        }
                        fn set_on_mouse_enter(
                            &mut self,
                            value: super::ItemOnMouseEnter,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_enter(&mut target, value)
                        }
                        fn on_mouse_enter(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseEnter, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_enter(&target)
                        }
                        fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_id(&mut target, value)
                        }
                        fn id(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::id(&target)
                        }
                        fn on(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::on(&target, object)
                        }
                        fn tween_to(
                            &self,
                            to: JsValue,
                            options: super::ItemTweenToParamsOptionsParam,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_to(&target, to, options)
                        }
                        fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_locked(&mut target, value)
                        }
                        fn locked(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::locked(&target)
                        }
                        fn set_children(
                            &mut self,
                            value: Vec<Item>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_children(&mut target, value)
                        }
                        fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::children(&target)
                        }
                        fn copy_attributes(
                            &self,
                            source: super::Item,
                            exclude_matrix: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_attributes(&target, source, exclude_matrix)
                        }
                        fn off(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::off(&target, object)
                        }
                        fn contains(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::contains(&target, point)
                        }
                        fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_stroke(&target)
                        }
                        fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_move(&target)
                        }
                        fn add_children(
                            &self,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_children(&target, items)
                        }
                        fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::reverse_children(&target)
                        }
                        fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_shadow(&target)
                        }
                        fn set_dash_offset(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_dash_offset(&mut target, value)
                        }
                        fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_offset(&target)
                        }
                        fn set_on_mouse_leave(
                            &mut self,
                            value: super::ItemOnMouseLeave,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_leave(&mut target, value)
                        }
                        fn on_mouse_leave(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseLeave, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_leave(&target)
                        }
                        fn hit_test_all(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<Vec<HitResult>, JsValue> {
                            let target: Item = self.into();
                            super::Item::hit_test_all(&target, point, options)
                        }
                        fn set_stroke_cap(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_cap(&mut target, value)
                        }
                        fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_cap(&target)
                        }
                        fn set_internal_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_internal_bounds(&mut target, value)
                        }
                        fn internal_bounds(
                            &self,
                        ) -> std::result::Result<super::Rectangle, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::internal_bounds(&target)
                        }
                        fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_index(&mut target, value)
                        }
                        fn index(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::index(&target)
                        }
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::reduce(&target, options)
                        }
                        fn is_grouped_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_grouped_with(&target, item)
                        }
                        fn local_to_global(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_global(&target, point)
                        }
                        fn set_first_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_first_child(&mut target, value)
                        }
                        fn first_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::first_child(&target)
                        }
                        fn set_position(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_position(&mut target, value)
                        }
                        fn position(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::position(&target)
                        }
                        fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_opacity(&mut target, value)
                        }
                        fn opacity(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::opacity(&target)
                        }
                        fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_down(&target)
                        }
                        fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_drag(&target)
                        }
                        fn set_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_bounds(&mut target, value)
                        }
                        fn bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::bounds(&target)
                        }
                        fn set_parent(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_parent(&mut target, value)
                        }
                        fn parent(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent(&target)
                        }
                        fn get_items(
                            &self,
                            options: super::ItemGetItemsParamsOptionsParam,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_items(&target, options)
                        }
                        fn copy_to(
                            &self,
                            owner: super::ItemCopyToParamsOwnerParam,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_to(&target, owner)
                        }
                        fn set_on_double_click(
                            &mut self,
                            value: super::ItemOnDoubleClick,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_double_click(&mut target, value)
                        }
                        fn on_double_click(
                            &self,
                        ) -> std::result::Result<super::ItemOnDoubleClick, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_double_click(&target)
                        }
                        fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::set(&target, props)
                        }
                        fn scale(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::scale(&target, hor, ver, center)
                        }
                        fn insert_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_below(&target, item)
                        }
                        fn set_next_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_next_sibling(&mut target, value)
                        }
                        fn next_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::next_sibling(&target)
                        }
                        fn rasterize(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Raster, JsValue> {
                            let target: Item = self.into();
                            super::Item::rasterize(&target, options)
                        }
                        fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::bring_to_front(&target)
                        }
                        fn matches(
                            &self,
                            name: String,
                            compare: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::matches(&target, name, compare)
                        }
                        fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_fill(&target)
                        }
                        fn set_view(
                            &mut self,
                            value: super::View,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_view(&mut target, value)
                        }
                        fn view(&self) -> std::result::Result<super::View, JsValue> {
                            let target: Item = self.into();
                            super::Item::view(&target)
                        }
                        fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::clone(&target, options)
                        }
                        fn set_handle_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_handle_bounds(&mut target, value)
                        }
                        fn handle_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::handle_bounds(&target)
                        }
                        fn is_inside(
                            &self,
                            rect: super::Rectangle,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inside(&target, rect)
                        }
                        fn is_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_above(&target, item)
                        }
                        fn remove(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove(&target)
                        }
                        fn set_stroke_join(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_join(&mut target, value)
                        }
                        fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_join(&target)
                        }
                        fn set_on_click(
                            &mut self,
                            value: super::ItemOnClick,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_click(&mut target, value)
                        }
                        fn on_click(&self) -> std::result::Result<super::ItemOnClick, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_click(&target)
                        }
                        fn fit_bounds(
                            &self,
                            rectangle: super::Rectangle,
                            fill: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::fit_bounds(&target, rectangle, fill)
                        }
                        fn set_blend_mode(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_blend_mode(&mut target, value)
                        }
                        fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::blend_mode(&target)
                        }
                        fn set_stroke_width(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_width(&mut target, value)
                        }
                        fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_width(&target)
                        }
                        fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_rotation(&mut target, value)
                        }
                        fn rotation(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::rotation(&target)
                        }
                        fn set_selected_color(
                            &mut self,
                            value: super::ItemSelectedColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_selected_color(&mut target, value)
                        }
                        fn selected_color(
                            &self,
                        ) -> std::result::Result<super::ItemSelectedColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::selected_color(&target)
                        }
                        fn skew(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::skew(&target, hor, ver, center)
                        }
                        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_name(&mut target, value)
                        }
                        fn name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::name(&target)
                        }
                        fn import_json(
                            &self,
                            json: String,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_json(&target, json)
                        }
                        fn add_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_child(&target, item)
                        }
                        fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_visible(&mut target, value)
                        }
                        fn visible(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::visible(&target)
                        }
                        fn set_fill_rule(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_fill_rule(&mut target, value)
                        }
                        fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_rule(&target)
                        }
                        fn set_layer(
                            &mut self,
                            value: super::Layer,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_layer(&mut target, value)
                        }
                        fn layer(&self) -> std::result::Result<super::Layer, JsValue> {
                            let target: Item = self.into();
                            super::Item::layer(&target)
                        }
                        fn tween_from(
                            &self,
                            from: JsValue,
                            options: super::ItemTweenFromParamsOptionsParam,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_from(&target, from, options)
                        }
                        fn insert_child(
                            &self,
                            index: f64,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_child(&target, index, item)
                        }
                        fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_up(&target)
                        }
                        fn set_pivot(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_pivot(&mut target, value)
                        }
                        fn pivot(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::pivot(&target)
                        }
                        fn set_miter_limit(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_miter_limit(&mut target, value)
                        }
                        fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::miter_limit(&target)
                        }
                        fn copy_content(
                            &self,
                            source: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_content(&target, source)
                        }
                        fn import_svg(
                            &self,
                            svg: super::ItemImportSvgParamsSvgParam,
                            on_load: &'static dyn Fn(
                                Box<[JsValue]>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_svg(&target, svg, on_load)
                        }
                        fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::send_to_back(&target)
                        }
                        fn set_stroke_color(
                            &mut self,
                            value: super::ItemStrokeColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_color(&mut target, value)
                        }
                        fn stroke_color(
                            &self,
                        ) -> std::result::Result<super::ItemStrokeColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::stroke_color(&target)
                        }
                        fn set_on_mouse_move(
                            &mut self,
                            value: super::ItemOnMouseMove,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_move(&mut target, value)
                        }
                        fn on_mouse_move(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseMove, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_move(&target)
                        }
                        fn replace_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::replace_with(&target, item)
                        }
                        fn hit_test(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<super::HitResult, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::hit_test(&target, point, options)
                        }
                        fn shear(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::shear(&target, hor, ver, center)
                        }
                        fn translate(
                            &self,
                            delta: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::translate(&target, delta)
                        }
                        fn set_stroke_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_bounds(&mut target, value)
                        }
                        fn stroke_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_bounds(&target)
                        }
                        fn insert_children(
                            &self,
                            index: f64,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_children(&target, index, items)
                        }
                        fn is_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_child(&target, item)
                        }
                        fn set_shadow_offset(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_shadow_offset(&mut target, value)
                        }
                        fn shadow_offset(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_offset(&target)
                        }
                        fn set_fill_color(
                            &mut self,
                            value: super::ItemFillColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_fill_color(&mut target, value)
                        }
                        fn fill_color(&self) -> std::result::Result<super::ItemFillColor, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_color(&target)
                        }
                        fn export_svg(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::ItemExportSvgReturn, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::export_svg(&target, options)
                        }
                        fn set_style(
                            &mut self,
                            value: super::Style,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_style(&mut target, value)
                        }
                        fn style(&self) -> std::result::Result<super::Style, JsValue> {
                            let target: Item = self.into();
                            super::Item::style(&target)
                        }
                        fn set_clip_mask(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_clip_mask(&mut target, value)
                        }
                        fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::clip_mask(&target)
                        }
                        fn set_class_name(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_class_name(&mut target, value)
                        }
                        fn class_name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::class_name(&target)
                        }
                        fn set_on_mouse_up(
                            &mut self,
                            value: super::ItemOnMouseUp,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_up(&mut target, value)
                        }
                        fn on_mouse_up(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseUp, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_up(&target)
                        }
                        fn set_on_frame(
                            &mut self,
                            value: super::ItemOnFrame,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_frame(&mut target, value)
                        }
                        fn on_frame(&self) -> std::result::Result<super::ItemOnFrame, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_frame(&target)
                        }
                        fn parent_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent_to_local(&target, point)
                        }
                        fn set_previous_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_previous_sibling(&mut target, value)
                        }
                        fn previous_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::previous_sibling(&target)
                        }
                        fn emit(
                            &self,
                            type_: String,
                            event: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::emit(&target, type_, event)
                        }
                        fn add_to(
                            &self,
                            owner: super::ItemAddToParamsOwnerParam,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_to(&target, owner)
                        }
                        fn has_children(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_children(&target)
                        }
                        fn intersects(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::intersects(&target, item)
                        }
                        fn set_shadow_color(
                            &mut self,
                            value: super::ItemShadowColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_shadow_color(&mut target, value)
                        }
                        fn shadow_color(
                            &self,
                        ) -> std::result::Result<super::ItemShadowColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::shadow_color(&target)
                        }
                        fn set_scaling(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_scaling(&mut target, value)
                        }
                        fn scaling(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::scaling(&target)
                        }
                    }
                    impl Arc_Trait for Arc where Arc: Path_Trait {}
                    impl std::clone::Clone for Arc_Class {
                        fn clone(&self) -> Self {
                            Self {
                                obj: std::clone::Clone::clone(&self.obj),
                            }
                        }
                    }
                    impl serde::ser::Serialize for Arc_Class {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Arc_Class {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                        }
                    }
                }
                #[cfg(target_family = "wasm")]
                pub mod shape {
                    #[allow(unused)]
                    use super::*;
                    #[allow(unused)]
                    use wasm_bindgen::prelude::*;
                    #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                    extern "C" {
                        # [wasm_bindgen (js_name = "Ellipse" , extends = Item_Class , extends = Shape_Class)]
                        pub type Ellipse_Class;
                        #[wasm_bindgen(constructor, js_class = "Ellipse")]
                        pub fn new(object: JsValue) -> Ellipse_Class;
                    }
                    #[derive(std :: clone :: Clone)]
                    pub struct Ellipse(pub Ellipse_Class);
                    impl std::convert::From<&Ellipse> for super::Shape {
                        fn from(src: &Ellipse) -> super::Shape {
                            let src: &super::Shape_Class = src.0.as_ref();
                            super::Shape(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Ellipse> for super::Shape {
                        fn from(src: &mut Ellipse) -> super::Shape {
                            let src: &super::Shape_Class = src.0.as_ref();
                            super::Shape(src.clone())
                        }
                    }
                    impl std::convert::From<&Ellipse> for super::Item {
                        fn from(src: &Ellipse) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Ellipse> for super::Item {
                        fn from(src: &mut Ellipse) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl Ellipse {
                        #[allow(dead_code)]
                        pub fn new(object: JsValue) -> Ellipse {
                            let result = Ellipse_Class::new(object);
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            Ellipse(result)
                        }
                    }
                    impl wasm_bindgen::describe::WasmDescribe for Ellipse {
                        fn describe() {
                            <Ellipse_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                        }
                    }
                    impl wasm_bindgen::convert::IntoWasmAbi for Ellipse {
                        type Abi = <Ellipse_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                        }
                    }
                    impl wasm_bindgen::convert::FromWasmAbi for Ellipse {
                        type Abi = <Ellipse_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                        unsafe fn from_abi(js: Self::Abi) -> Self {
                            Ellipse(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                        }
                    }
                    impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Ellipse {
                        type Abi = <&'a Ellipse_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                        }
                    }
                    impl serde::ser::Serialize for Ellipse {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde::ser::Serialize::serialize(&self.0, serializer)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Ellipse {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            let internal: Ellipse_Class =
                                <Ellipse_Class as serde::de::Deserialize>::deserialize(
                                    deserializer,
                                )?;
                            std::result::Result::Ok(Self(internal))
                        }
                    }
                    #[allow(non_camel_case_types)]
                    pub trait Ellipse_Trait: Shape_Trait {}
                    impl Shape_Trait for Ellipse
                    where
                        Ellipse: Item_Trait,
                    {
                        fn set_size(
                            &mut self,
                            value: super::Size,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Shape = self.into();
                            super::Shape::set_size(&mut target, value)
                        }
                        fn size(&self) -> std::result::Result<super::Size, JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::size(&target)
                        }
                        fn to_path(
                            &self,
                            insert: bool,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::to_path(&target, insert)
                        }
                        fn set_radius(
                            &mut self,
                            value: super::ShapeRadius,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Shape = self.into();
                            super::Shape::set_radius(&mut target, value)
                        }
                        fn radius(&self) -> std::result::Result<super::ShapeRadius, JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::radius(&target)
                        }
                        fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue> {
                            let mut target: super::Shape = self.into();
                            super::Shape::set_type_(&mut target, value)
                        }
                        fn type_(&self) -> std::result::Result<String, JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::type_(&target)
                        }
                    }
                    impl Item_Trait for Ellipse {
                        fn set_stroke_scaling(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_scaling(&mut target, value)
                        }
                        fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_scaling(&target)
                        }
                        fn set_apply_matrix(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_apply_matrix(&mut target, value)
                        }
                        fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::apply_matrix(&target)
                        }
                        fn set_view_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_view_matrix(&mut target, value)
                        }
                        fn view_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::view_matrix(&target)
                        }
                        fn set_dash_array(
                            &mut self,
                            value: Vec<f64>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_dash_array(&mut target, value)
                        }
                        fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_array(&target)
                        }
                        fn is_ancestor(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_ancestor(&target, item)
                        }
                        fn is_descendant(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_descendant(&target, item)
                        }
                        fn is_sibling(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_sibling(&target, item)
                        }
                        fn local_to_parent(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_parent(&target, point)
                        }
                        fn set_shadow_blur(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_shadow_blur(&mut target, value)
                        }
                        fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_blur(&target)
                        }
                        fn is_empty(
                            &self,
                            recursively: bool,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_empty(&target, recursively)
                        }
                        fn is_parent(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_parent(&target, item)
                        }
                        fn is_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_below(&target, item)
                        }
                        fn set_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_matrix(&mut target, value)
                        }
                        fn matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::matrix(&target)
                        }
                        fn export_json(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::export_json(&target, options)
                        }
                        fn global_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_to_local(&target, point)
                        }
                        fn set_on_mouse_drag(
                            &mut self,
                            value: super::ItemOnMouseDrag,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_drag(&mut target, value)
                        }
                        fn on_mouse_drag(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDrag, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_drag(&target)
                        }
                        fn get_item(
                            &self,
                            options: super::ItemGetItemParamsOptionsParam,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_item(&target, options)
                        }
                        fn remove_children(
                            &self,
                            start: f64,
                            end: f64,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_children(&target, start, end)
                        }
                        fn set_project(
                            &mut self,
                            value: super::Project,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_project(&mut target, value)
                        }
                        fn project(&self) -> std::result::Result<super::Project, JsValue> {
                            let target: Item = self.into();
                            super::Item::project(&target)
                        }
                        fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_data(&mut target, value)
                        }
                        fn data(&self) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::data(&target)
                        }
                        fn insert_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_above(&target, item)
                        }
                        fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on(&target, options)
                        }
                        fn transform(
                            &self,
                            matrix: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::transform(&target, matrix)
                        }
                        fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inserted(&target)
                        }
                        fn set_on_mouse_down(
                            &mut self,
                            value: super::ItemOnMouseDown,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_down(&mut target, value)
                        }
                        fn on_mouse_down(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDown, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_down(&target)
                        }
                        fn set_last_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_last_child(&mut target, value)
                        }
                        fn last_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::last_child(&target)
                        }
                        fn set_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_selected(&mut target, value)
                        }
                        fn selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::selected(&target)
                        }
                        fn set_global_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_global_matrix(&mut target, value)
                        }
                        fn global_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_matrix(&target)
                        }
                        fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::responds(&target, type_)
                        }
                        fn rotate(
                            &self,
                            angle: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::rotate(&target, angle, center)
                        }
                        fn tween(
                            &self,
                            options: super::ItemTweenParamsOptionsParam,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween(&target, options)
                        }
                        fn set_on_mouse_enter(
                            &mut self,
                            value: super::ItemOnMouseEnter,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_enter(&mut target, value)
                        }
                        fn on_mouse_enter(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseEnter, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_enter(&target)
                        }
                        fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_id(&mut target, value)
                        }
                        fn id(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::id(&target)
                        }
                        fn on(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::on(&target, object)
                        }
                        fn tween_to(
                            &self,
                            to: JsValue,
                            options: super::ItemTweenToParamsOptionsParam,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_to(&target, to, options)
                        }
                        fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_locked(&mut target, value)
                        }
                        fn locked(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::locked(&target)
                        }
                        fn set_children(
                            &mut self,
                            value: Vec<Item>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_children(&mut target, value)
                        }
                        fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::children(&target)
                        }
                        fn copy_attributes(
                            &self,
                            source: super::Item,
                            exclude_matrix: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_attributes(&target, source, exclude_matrix)
                        }
                        fn off(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::off(&target, object)
                        }
                        fn contains(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::contains(&target, point)
                        }
                        fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_stroke(&target)
                        }
                        fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_move(&target)
                        }
                        fn add_children(
                            &self,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_children(&target, items)
                        }
                        fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::reverse_children(&target)
                        }
                        fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_shadow(&target)
                        }
                        fn set_dash_offset(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_dash_offset(&mut target, value)
                        }
                        fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_offset(&target)
                        }
                        fn set_on_mouse_leave(
                            &mut self,
                            value: super::ItemOnMouseLeave,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_leave(&mut target, value)
                        }
                        fn on_mouse_leave(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseLeave, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_leave(&target)
                        }
                        fn hit_test_all(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<Vec<HitResult>, JsValue> {
                            let target: Item = self.into();
                            super::Item::hit_test_all(&target, point, options)
                        }
                        fn set_stroke_cap(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_cap(&mut target, value)
                        }
                        fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_cap(&target)
                        }
                        fn set_internal_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_internal_bounds(&mut target, value)
                        }
                        fn internal_bounds(
                            &self,
                        ) -> std::result::Result<super::Rectangle, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::internal_bounds(&target)
                        }
                        fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_index(&mut target, value)
                        }
                        fn index(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::index(&target)
                        }
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::reduce(&target, options)
                        }
                        fn is_grouped_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_grouped_with(&target, item)
                        }
                        fn local_to_global(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_global(&target, point)
                        }
                        fn set_first_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_first_child(&mut target, value)
                        }
                        fn first_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::first_child(&target)
                        }
                        fn set_position(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_position(&mut target, value)
                        }
                        fn position(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::position(&target)
                        }
                        fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_opacity(&mut target, value)
                        }
                        fn opacity(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::opacity(&target)
                        }
                        fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_down(&target)
                        }
                        fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_drag(&target)
                        }
                        fn set_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_bounds(&mut target, value)
                        }
                        fn bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::bounds(&target)
                        }
                        fn set_parent(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_parent(&mut target, value)
                        }
                        fn parent(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent(&target)
                        }
                        fn get_items(
                            &self,
                            options: super::ItemGetItemsParamsOptionsParam,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_items(&target, options)
                        }
                        fn copy_to(
                            &self,
                            owner: super::ItemCopyToParamsOwnerParam,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_to(&target, owner)
                        }
                        fn set_on_double_click(
                            &mut self,
                            value: super::ItemOnDoubleClick,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_double_click(&mut target, value)
                        }
                        fn on_double_click(
                            &self,
                        ) -> std::result::Result<super::ItemOnDoubleClick, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_double_click(&target)
                        }
                        fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::set(&target, props)
                        }
                        fn scale(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::scale(&target, hor, ver, center)
                        }
                        fn insert_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_below(&target, item)
                        }
                        fn set_next_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_next_sibling(&mut target, value)
                        }
                        fn next_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::next_sibling(&target)
                        }
                        fn rasterize(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Raster, JsValue> {
                            let target: Item = self.into();
                            super::Item::rasterize(&target, options)
                        }
                        fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::bring_to_front(&target)
                        }
                        fn matches(
                            &self,
                            name: String,
                            compare: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::matches(&target, name, compare)
                        }
                        fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_fill(&target)
                        }
                        fn set_view(
                            &mut self,
                            value: super::View,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_view(&mut target, value)
                        }
                        fn view(&self) -> std::result::Result<super::View, JsValue> {
                            let target: Item = self.into();
                            super::Item::view(&target)
                        }
                        fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::clone(&target, options)
                        }
                        fn set_handle_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_handle_bounds(&mut target, value)
                        }
                        fn handle_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::handle_bounds(&target)
                        }
                        fn is_inside(
                            &self,
                            rect: super::Rectangle,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inside(&target, rect)
                        }
                        fn is_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_above(&target, item)
                        }
                        fn remove(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove(&target)
                        }
                        fn set_stroke_join(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_join(&mut target, value)
                        }
                        fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_join(&target)
                        }
                        fn set_on_click(
                            &mut self,
                            value: super::ItemOnClick,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_click(&mut target, value)
                        }
                        fn on_click(&self) -> std::result::Result<super::ItemOnClick, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_click(&target)
                        }
                        fn fit_bounds(
                            &self,
                            rectangle: super::Rectangle,
                            fill: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::fit_bounds(&target, rectangle, fill)
                        }
                        fn set_blend_mode(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_blend_mode(&mut target, value)
                        }
                        fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::blend_mode(&target)
                        }
                        fn set_stroke_width(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_width(&mut target, value)
                        }
                        fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_width(&target)
                        }
                        fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_rotation(&mut target, value)
                        }
                        fn rotation(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::rotation(&target)
                        }
                        fn set_selected_color(
                            &mut self,
                            value: super::ItemSelectedColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_selected_color(&mut target, value)
                        }
                        fn selected_color(
                            &self,
                        ) -> std::result::Result<super::ItemSelectedColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::selected_color(&target)
                        }
                        fn skew(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::skew(&target, hor, ver, center)
                        }
                        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_name(&mut target, value)
                        }
                        fn name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::name(&target)
                        }
                        fn import_json(
                            &self,
                            json: String,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_json(&target, json)
                        }
                        fn add_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_child(&target, item)
                        }
                        fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_visible(&mut target, value)
                        }
                        fn visible(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::visible(&target)
                        }
                        fn set_fill_rule(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_fill_rule(&mut target, value)
                        }
                        fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_rule(&target)
                        }
                        fn set_layer(
                            &mut self,
                            value: super::Layer,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_layer(&mut target, value)
                        }
                        fn layer(&self) -> std::result::Result<super::Layer, JsValue> {
                            let target: Item = self.into();
                            super::Item::layer(&target)
                        }
                        fn tween_from(
                            &self,
                            from: JsValue,
                            options: super::ItemTweenFromParamsOptionsParam,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_from(&target, from, options)
                        }
                        fn insert_child(
                            &self,
                            index: f64,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_child(&target, index, item)
                        }
                        fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_up(&target)
                        }
                        fn set_pivot(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_pivot(&mut target, value)
                        }
                        fn pivot(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::pivot(&target)
                        }
                        fn set_miter_limit(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_miter_limit(&mut target, value)
                        }
                        fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::miter_limit(&target)
                        }
                        fn copy_content(
                            &self,
                            source: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_content(&target, source)
                        }
                        fn import_svg(
                            &self,
                            svg: super::ItemImportSvgParamsSvgParam,
                            on_load: &'static dyn Fn(
                                Box<[JsValue]>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_svg(&target, svg, on_load)
                        }
                        fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::send_to_back(&target)
                        }
                        fn set_stroke_color(
                            &mut self,
                            value: super::ItemStrokeColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_color(&mut target, value)
                        }
                        fn stroke_color(
                            &self,
                        ) -> std::result::Result<super::ItemStrokeColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::stroke_color(&target)
                        }
                        fn set_on_mouse_move(
                            &mut self,
                            value: super::ItemOnMouseMove,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_move(&mut target, value)
                        }
                        fn on_mouse_move(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseMove, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_move(&target)
                        }
                        fn replace_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::replace_with(&target, item)
                        }
                        fn hit_test(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<super::HitResult, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::hit_test(&target, point, options)
                        }
                        fn shear(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::shear(&target, hor, ver, center)
                        }
                        fn translate(
                            &self,
                            delta: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::translate(&target, delta)
                        }
                        fn set_stroke_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_bounds(&mut target, value)
                        }
                        fn stroke_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_bounds(&target)
                        }
                        fn insert_children(
                            &self,
                            index: f64,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_children(&target, index, items)
                        }
                        fn is_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_child(&target, item)
                        }
                        fn set_shadow_offset(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_shadow_offset(&mut target, value)
                        }
                        fn shadow_offset(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_offset(&target)
                        }
                        fn set_fill_color(
                            &mut self,
                            value: super::ItemFillColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_fill_color(&mut target, value)
                        }
                        fn fill_color(&self) -> std::result::Result<super::ItemFillColor, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_color(&target)
                        }
                        fn export_svg(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::ItemExportSvgReturn, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::export_svg(&target, options)
                        }
                        fn set_style(
                            &mut self,
                            value: super::Style,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_style(&mut target, value)
                        }
                        fn style(&self) -> std::result::Result<super::Style, JsValue> {
                            let target: Item = self.into();
                            super::Item::style(&target)
                        }
                        fn set_clip_mask(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_clip_mask(&mut target, value)
                        }
                        fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::clip_mask(&target)
                        }
                        fn set_class_name(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_class_name(&mut target, value)
                        }
                        fn class_name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::class_name(&target)
                        }
                        fn set_on_mouse_up(
                            &mut self,
                            value: super::ItemOnMouseUp,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_up(&mut target, value)
                        }
                        fn on_mouse_up(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseUp, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_up(&target)
                        }
                        fn set_on_frame(
                            &mut self,
                            value: super::ItemOnFrame,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_frame(&mut target, value)
                        }
                        fn on_frame(&self) -> std::result::Result<super::ItemOnFrame, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_frame(&target)
                        }
                        fn parent_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent_to_local(&target, point)
                        }
                        fn set_previous_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_previous_sibling(&mut target, value)
                        }
                        fn previous_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::previous_sibling(&target)
                        }
                        fn emit(
                            &self,
                            type_: String,
                            event: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::emit(&target, type_, event)
                        }
                        fn add_to(
                            &self,
                            owner: super::ItemAddToParamsOwnerParam,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_to(&target, owner)
                        }
                        fn has_children(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_children(&target)
                        }
                        fn intersects(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::intersects(&target, item)
                        }
                        fn set_shadow_color(
                            &mut self,
                            value: super::ItemShadowColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_shadow_color(&mut target, value)
                        }
                        fn shadow_color(
                            &self,
                        ) -> std::result::Result<super::ItemShadowColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::shadow_color(&target)
                        }
                        fn set_scaling(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_scaling(&mut target, value)
                        }
                        fn scaling(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::scaling(&target)
                        }
                    }
                    impl Ellipse_Trait for Ellipse where Ellipse: Shape_Trait {}
                    impl std::clone::Clone for Ellipse_Class {
                        fn clone(&self) -> Self {
                            Self {
                                obj: std::clone::Clone::clone(&self.obj),
                            }
                        }
                    }
                    impl serde::ser::Serialize for Ellipse_Class {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Ellipse_Class {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                        }
                    }
                    #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                    extern "C" {
                        # [wasm_bindgen (js_name = "Rectangle" , extends = Item_Class , extends = Shape_Class)]
                        pub type Rectangle_Class;
                        #[wasm_bindgen(constructor, js_class = "Rectangle")]
                        pub fn new(object: JsValue) -> Rectangle_Class;
                    }
                    #[derive(std :: clone :: Clone)]
                    pub struct Rectangle(pub Rectangle_Class);
                    impl std::convert::From<&Rectangle> for super::Item {
                        fn from(src: &Rectangle) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Rectangle> for super::Item {
                        fn from(src: &mut Rectangle) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&Rectangle> for super::Shape {
                        fn from(src: &Rectangle) -> super::Shape {
                            let src: &super::Shape_Class = src.0.as_ref();
                            super::Shape(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Rectangle> for super::Shape {
                        fn from(src: &mut Rectangle) -> super::Shape {
                            let src: &super::Shape_Class = src.0.as_ref();
                            super::Shape(src.clone())
                        }
                    }
                    impl Rectangle {
                        #[allow(dead_code)]
                        pub fn new(object: JsValue) -> Rectangle {
                            let result = Rectangle_Class::new(object);
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            Rectangle(result)
                        }
                    }
                    impl wasm_bindgen::describe::WasmDescribe for Rectangle {
                        fn describe() {
                            <Rectangle_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                        }
                    }
                    impl wasm_bindgen::convert::IntoWasmAbi for Rectangle {
                        type Abi = <Rectangle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                        }
                    }
                    impl wasm_bindgen::convert::FromWasmAbi for Rectangle {
                        type Abi = <Rectangle_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                        unsafe fn from_abi(js: Self::Abi) -> Self {
                            Rectangle(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                        }
                    }
                    impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Rectangle {
                        type Abi = <&'a Rectangle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                        }
                    }
                    impl serde::ser::Serialize for Rectangle {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde::ser::Serialize::serialize(&self.0, serializer)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Rectangle {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            let internal: Rectangle_Class =
                                <Rectangle_Class as serde::de::Deserialize>::deserialize(
                                    deserializer,
                                )?;
                            std::result::Result::Ok(Self(internal))
                        }
                    }
                    #[allow(non_camel_case_types)]
                    pub trait Rectangle_Trait: Shape_Trait {}
                    impl Shape_Trait for Rectangle
                    where
                        Rectangle: Item_Trait,
                    {
                        fn set_size(
                            &mut self,
                            value: super::Size,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Shape = self.into();
                            super::Shape::set_size(&mut target, value)
                        }
                        fn size(&self) -> std::result::Result<super::Size, JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::size(&target)
                        }
                        fn to_path(
                            &self,
                            insert: bool,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::to_path(&target, insert)
                        }
                        fn set_radius(
                            &mut self,
                            value: super::ShapeRadius,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Shape = self.into();
                            super::Shape::set_radius(&mut target, value)
                        }
                        fn radius(&self) -> std::result::Result<super::ShapeRadius, JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::radius(&target)
                        }
                        fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue> {
                            let mut target: super::Shape = self.into();
                            super::Shape::set_type_(&mut target, value)
                        }
                        fn type_(&self) -> std::result::Result<String, JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::type_(&target)
                        }
                    }
                    impl Item_Trait for Rectangle {
                        fn set_stroke_scaling(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_scaling(&mut target, value)
                        }
                        fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_scaling(&target)
                        }
                        fn set_apply_matrix(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_apply_matrix(&mut target, value)
                        }
                        fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::apply_matrix(&target)
                        }
                        fn set_view_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_view_matrix(&mut target, value)
                        }
                        fn view_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::view_matrix(&target)
                        }
                        fn set_dash_array(
                            &mut self,
                            value: Vec<f64>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_dash_array(&mut target, value)
                        }
                        fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_array(&target)
                        }
                        fn is_ancestor(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_ancestor(&target, item)
                        }
                        fn is_descendant(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_descendant(&target, item)
                        }
                        fn is_sibling(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_sibling(&target, item)
                        }
                        fn local_to_parent(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_parent(&target, point)
                        }
                        fn set_shadow_blur(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_shadow_blur(&mut target, value)
                        }
                        fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_blur(&target)
                        }
                        fn is_empty(
                            &self,
                            recursively: bool,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_empty(&target, recursively)
                        }
                        fn is_parent(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_parent(&target, item)
                        }
                        fn is_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_below(&target, item)
                        }
                        fn set_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_matrix(&mut target, value)
                        }
                        fn matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::matrix(&target)
                        }
                        fn export_json(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::export_json(&target, options)
                        }
                        fn global_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_to_local(&target, point)
                        }
                        fn set_on_mouse_drag(
                            &mut self,
                            value: super::ItemOnMouseDrag,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_drag(&mut target, value)
                        }
                        fn on_mouse_drag(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDrag, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_drag(&target)
                        }
                        fn get_item(
                            &self,
                            options: super::ItemGetItemParamsOptionsParam,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_item(&target, options)
                        }
                        fn remove_children(
                            &self,
                            start: f64,
                            end: f64,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_children(&target, start, end)
                        }
                        fn set_project(
                            &mut self,
                            value: super::Project,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_project(&mut target, value)
                        }
                        fn project(&self) -> std::result::Result<super::Project, JsValue> {
                            let target: Item = self.into();
                            super::Item::project(&target)
                        }
                        fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_data(&mut target, value)
                        }
                        fn data(&self) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::data(&target)
                        }
                        fn insert_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_above(&target, item)
                        }
                        fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on(&target, options)
                        }
                        fn transform(
                            &self,
                            matrix: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::transform(&target, matrix)
                        }
                        fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inserted(&target)
                        }
                        fn set_on_mouse_down(
                            &mut self,
                            value: super::ItemOnMouseDown,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_down(&mut target, value)
                        }
                        fn on_mouse_down(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDown, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_down(&target)
                        }
                        fn set_last_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_last_child(&mut target, value)
                        }
                        fn last_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::last_child(&target)
                        }
                        fn set_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_selected(&mut target, value)
                        }
                        fn selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::selected(&target)
                        }
                        fn set_global_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_global_matrix(&mut target, value)
                        }
                        fn global_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_matrix(&target)
                        }
                        fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::responds(&target, type_)
                        }
                        fn rotate(
                            &self,
                            angle: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::rotate(&target, angle, center)
                        }
                        fn tween(
                            &self,
                            options: super::ItemTweenParamsOptionsParam,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween(&target, options)
                        }
                        fn set_on_mouse_enter(
                            &mut self,
                            value: super::ItemOnMouseEnter,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_enter(&mut target, value)
                        }
                        fn on_mouse_enter(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseEnter, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_enter(&target)
                        }
                        fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_id(&mut target, value)
                        }
                        fn id(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::id(&target)
                        }
                        fn on(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::on(&target, object)
                        }
                        fn tween_to(
                            &self,
                            to: JsValue,
                            options: super::ItemTweenToParamsOptionsParam,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_to(&target, to, options)
                        }
                        fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_locked(&mut target, value)
                        }
                        fn locked(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::locked(&target)
                        }
                        fn set_children(
                            &mut self,
                            value: Vec<Item>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_children(&mut target, value)
                        }
                        fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::children(&target)
                        }
                        fn copy_attributes(
                            &self,
                            source: super::Item,
                            exclude_matrix: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_attributes(&target, source, exclude_matrix)
                        }
                        fn off(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::off(&target, object)
                        }
                        fn contains(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::contains(&target, point)
                        }
                        fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_stroke(&target)
                        }
                        fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_move(&target)
                        }
                        fn add_children(
                            &self,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_children(&target, items)
                        }
                        fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::reverse_children(&target)
                        }
                        fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_shadow(&target)
                        }
                        fn set_dash_offset(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_dash_offset(&mut target, value)
                        }
                        fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_offset(&target)
                        }
                        fn set_on_mouse_leave(
                            &mut self,
                            value: super::ItemOnMouseLeave,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_leave(&mut target, value)
                        }
                        fn on_mouse_leave(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseLeave, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_leave(&target)
                        }
                        fn hit_test_all(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<Vec<HitResult>, JsValue> {
                            let target: Item = self.into();
                            super::Item::hit_test_all(&target, point, options)
                        }
                        fn set_stroke_cap(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_cap(&mut target, value)
                        }
                        fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_cap(&target)
                        }
                        fn set_internal_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_internal_bounds(&mut target, value)
                        }
                        fn internal_bounds(
                            &self,
                        ) -> std::result::Result<super::Rectangle, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::internal_bounds(&target)
                        }
                        fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_index(&mut target, value)
                        }
                        fn index(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::index(&target)
                        }
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::reduce(&target, options)
                        }
                        fn is_grouped_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_grouped_with(&target, item)
                        }
                        fn local_to_global(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_global(&target, point)
                        }
                        fn set_first_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_first_child(&mut target, value)
                        }
                        fn first_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::first_child(&target)
                        }
                        fn set_position(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_position(&mut target, value)
                        }
                        fn position(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::position(&target)
                        }
                        fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_opacity(&mut target, value)
                        }
                        fn opacity(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::opacity(&target)
                        }
                        fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_down(&target)
                        }
                        fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_drag(&target)
                        }
                        fn set_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_bounds(&mut target, value)
                        }
                        fn bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::bounds(&target)
                        }
                        fn set_parent(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_parent(&mut target, value)
                        }
                        fn parent(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent(&target)
                        }
                        fn get_items(
                            &self,
                            options: super::ItemGetItemsParamsOptionsParam,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_items(&target, options)
                        }
                        fn copy_to(
                            &self,
                            owner: super::ItemCopyToParamsOwnerParam,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_to(&target, owner)
                        }
                        fn set_on_double_click(
                            &mut self,
                            value: super::ItemOnDoubleClick,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_double_click(&mut target, value)
                        }
                        fn on_double_click(
                            &self,
                        ) -> std::result::Result<super::ItemOnDoubleClick, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_double_click(&target)
                        }
                        fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::set(&target, props)
                        }
                        fn scale(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::scale(&target, hor, ver, center)
                        }
                        fn insert_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_below(&target, item)
                        }
                        fn set_next_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_next_sibling(&mut target, value)
                        }
                        fn next_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::next_sibling(&target)
                        }
                        fn rasterize(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Raster, JsValue> {
                            let target: Item = self.into();
                            super::Item::rasterize(&target, options)
                        }
                        fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::bring_to_front(&target)
                        }
                        fn matches(
                            &self,
                            name: String,
                            compare: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::matches(&target, name, compare)
                        }
                        fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_fill(&target)
                        }
                        fn set_view(
                            &mut self,
                            value: super::View,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_view(&mut target, value)
                        }
                        fn view(&self) -> std::result::Result<super::View, JsValue> {
                            let target: Item = self.into();
                            super::Item::view(&target)
                        }
                        fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::clone(&target, options)
                        }
                        fn set_handle_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_handle_bounds(&mut target, value)
                        }
                        fn handle_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::handle_bounds(&target)
                        }
                        fn is_inside(
                            &self,
                            rect: super::Rectangle,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inside(&target, rect)
                        }
                        fn is_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_above(&target, item)
                        }
                        fn remove(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove(&target)
                        }
                        fn set_stroke_join(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_join(&mut target, value)
                        }
                        fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_join(&target)
                        }
                        fn set_on_click(
                            &mut self,
                            value: super::ItemOnClick,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_click(&mut target, value)
                        }
                        fn on_click(&self) -> std::result::Result<super::ItemOnClick, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_click(&target)
                        }
                        fn fit_bounds(
                            &self,
                            rectangle: super::Rectangle,
                            fill: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::fit_bounds(&target, rectangle, fill)
                        }
                        fn set_blend_mode(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_blend_mode(&mut target, value)
                        }
                        fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::blend_mode(&target)
                        }
                        fn set_stroke_width(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_width(&mut target, value)
                        }
                        fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_width(&target)
                        }
                        fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_rotation(&mut target, value)
                        }
                        fn rotation(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::rotation(&target)
                        }
                        fn set_selected_color(
                            &mut self,
                            value: super::ItemSelectedColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_selected_color(&mut target, value)
                        }
                        fn selected_color(
                            &self,
                        ) -> std::result::Result<super::ItemSelectedColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::selected_color(&target)
                        }
                        fn skew(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::skew(&target, hor, ver, center)
                        }
                        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_name(&mut target, value)
                        }
                        fn name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::name(&target)
                        }
                        fn import_json(
                            &self,
                            json: String,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_json(&target, json)
                        }
                        fn add_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_child(&target, item)
                        }
                        fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_visible(&mut target, value)
                        }
                        fn visible(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::visible(&target)
                        }
                        fn set_fill_rule(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_fill_rule(&mut target, value)
                        }
                        fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_rule(&target)
                        }
                        fn set_layer(
                            &mut self,
                            value: super::Layer,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_layer(&mut target, value)
                        }
                        fn layer(&self) -> std::result::Result<super::Layer, JsValue> {
                            let target: Item = self.into();
                            super::Item::layer(&target)
                        }
                        fn tween_from(
                            &self,
                            from: JsValue,
                            options: super::ItemTweenFromParamsOptionsParam,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_from(&target, from, options)
                        }
                        fn insert_child(
                            &self,
                            index: f64,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_child(&target, index, item)
                        }
                        fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_up(&target)
                        }
                        fn set_pivot(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_pivot(&mut target, value)
                        }
                        fn pivot(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::pivot(&target)
                        }
                        fn set_miter_limit(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_miter_limit(&mut target, value)
                        }
                        fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::miter_limit(&target)
                        }
                        fn copy_content(
                            &self,
                            source: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_content(&target, source)
                        }
                        fn import_svg(
                            &self,
                            svg: super::ItemImportSvgParamsSvgParam,
                            on_load: &'static dyn Fn(
                                Box<[JsValue]>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_svg(&target, svg, on_load)
                        }
                        fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::send_to_back(&target)
                        }
                        fn set_stroke_color(
                            &mut self,
                            value: super::ItemStrokeColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_color(&mut target, value)
                        }
                        fn stroke_color(
                            &self,
                        ) -> std::result::Result<super::ItemStrokeColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::stroke_color(&target)
                        }
                        fn set_on_mouse_move(
                            &mut self,
                            value: super::ItemOnMouseMove,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_move(&mut target, value)
                        }
                        fn on_mouse_move(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseMove, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_move(&target)
                        }
                        fn replace_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::replace_with(&target, item)
                        }
                        fn hit_test(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<super::HitResult, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::hit_test(&target, point, options)
                        }
                        fn shear(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::shear(&target, hor, ver, center)
                        }
                        fn translate(
                            &self,
                            delta: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::translate(&target, delta)
                        }
                        fn set_stroke_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_bounds(&mut target, value)
                        }
                        fn stroke_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_bounds(&target)
                        }
                        fn insert_children(
                            &self,
                            index: f64,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_children(&target, index, items)
                        }
                        fn is_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_child(&target, item)
                        }
                        fn set_shadow_offset(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_shadow_offset(&mut target, value)
                        }
                        fn shadow_offset(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_offset(&target)
                        }
                        fn set_fill_color(
                            &mut self,
                            value: super::ItemFillColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_fill_color(&mut target, value)
                        }
                        fn fill_color(&self) -> std::result::Result<super::ItemFillColor, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_color(&target)
                        }
                        fn export_svg(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::ItemExportSvgReturn, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::export_svg(&target, options)
                        }
                        fn set_style(
                            &mut self,
                            value: super::Style,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_style(&mut target, value)
                        }
                        fn style(&self) -> std::result::Result<super::Style, JsValue> {
                            let target: Item = self.into();
                            super::Item::style(&target)
                        }
                        fn set_clip_mask(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_clip_mask(&mut target, value)
                        }
                        fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::clip_mask(&target)
                        }
                        fn set_class_name(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_class_name(&mut target, value)
                        }
                        fn class_name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::class_name(&target)
                        }
                        fn set_on_mouse_up(
                            &mut self,
                            value: super::ItemOnMouseUp,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_up(&mut target, value)
                        }
                        fn on_mouse_up(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseUp, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_up(&target)
                        }
                        fn set_on_frame(
                            &mut self,
                            value: super::ItemOnFrame,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_frame(&mut target, value)
                        }
                        fn on_frame(&self) -> std::result::Result<super::ItemOnFrame, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_frame(&target)
                        }
                        fn parent_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent_to_local(&target, point)
                        }
                        fn set_previous_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_previous_sibling(&mut target, value)
                        }
                        fn previous_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::previous_sibling(&target)
                        }
                        fn emit(
                            &self,
                            type_: String,
                            event: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::emit(&target, type_, event)
                        }
                        fn add_to(
                            &self,
                            owner: super::ItemAddToParamsOwnerParam,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_to(&target, owner)
                        }
                        fn has_children(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_children(&target)
                        }
                        fn intersects(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::intersects(&target, item)
                        }
                        fn set_shadow_color(
                            &mut self,
                            value: super::ItemShadowColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_shadow_color(&mut target, value)
                        }
                        fn shadow_color(
                            &self,
                        ) -> std::result::Result<super::ItemShadowColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::shadow_color(&target)
                        }
                        fn set_scaling(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_scaling(&mut target, value)
                        }
                        fn scaling(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::scaling(&target)
                        }
                    }
                    impl Rectangle_Trait for Rectangle where Rectangle: Shape_Trait {}
                    impl std::clone::Clone for Rectangle_Class {
                        fn clone(&self) -> Self {
                            Self {
                                obj: std::clone::Clone::clone(&self.obj),
                            }
                        }
                    }
                    impl serde::ser::Serialize for Rectangle_Class {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Rectangle_Class {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                        }
                    }
                    #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                    extern "C" {
                        # [wasm_bindgen (js_name = "Circle" , extends = Item_Class , extends = Shape_Class)]
                        pub type Circle_Class;
                        #[wasm_bindgen(constructor, js_class = "Circle")]
                        pub fn new(object: JsValue) -> Circle_Class;
                    }
                    #[derive(std :: clone :: Clone)]
                    pub struct Circle(pub Circle_Class);
                    impl std::convert::From<&Circle> for super::Shape {
                        fn from(src: &Circle) -> super::Shape {
                            let src: &super::Shape_Class = src.0.as_ref();
                            super::Shape(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Circle> for super::Shape {
                        fn from(src: &mut Circle) -> super::Shape {
                            let src: &super::Shape_Class = src.0.as_ref();
                            super::Shape(src.clone())
                        }
                    }
                    impl std::convert::From<&Circle> for super::Item {
                        fn from(src: &Circle) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Circle> for super::Item {
                        fn from(src: &mut Circle) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl Circle {
                        #[allow(dead_code)]
                        pub fn new(object: JsValue) -> Circle {
                            let result = Circle_Class::new(object);
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            Circle(result)
                        }
                    }
                    impl wasm_bindgen::describe::WasmDescribe for Circle {
                        fn describe() {
                            <Circle_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                        }
                    }
                    impl wasm_bindgen::convert::IntoWasmAbi for Circle {
                        type Abi = <Circle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                        }
                    }
                    impl wasm_bindgen::convert::FromWasmAbi for Circle {
                        type Abi = <Circle_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                        unsafe fn from_abi(js: Self::Abi) -> Self {
                            Circle(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                        }
                    }
                    impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Circle {
                        type Abi = <&'a Circle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                        }
                    }
                    impl serde::ser::Serialize for Circle {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde::ser::Serialize::serialize(&self.0, serializer)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Circle {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            let internal: Circle_Class =
                                <Circle_Class as serde::de::Deserialize>::deserialize(
                                    deserializer,
                                )?;
                            std::result::Result::Ok(Self(internal))
                        }
                    }
                    #[allow(non_camel_case_types)]
                    pub trait Circle_Trait: Shape_Trait {}
                    impl Shape_Trait for Circle
                    where
                        Circle: Item_Trait,
                    {
                        fn set_size(
                            &mut self,
                            value: super::Size,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Shape = self.into();
                            super::Shape::set_size(&mut target, value)
                        }
                        fn size(&self) -> std::result::Result<super::Size, JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::size(&target)
                        }
                        fn to_path(
                            &self,
                            insert: bool,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::to_path(&target, insert)
                        }
                        fn set_radius(
                            &mut self,
                            value: super::ShapeRadius,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: super::Shape = self.into();
                            super::Shape::set_radius(&mut target, value)
                        }
                        fn radius(&self) -> std::result::Result<super::ShapeRadius, JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::radius(&target)
                        }
                        fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue> {
                            let mut target: super::Shape = self.into();
                            super::Shape::set_type_(&mut target, value)
                        }
                        fn type_(&self) -> std::result::Result<String, JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::type_(&target)
                        }
                    }
                    impl Item_Trait for Circle {
                        fn set_stroke_scaling(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_scaling(&mut target, value)
                        }
                        fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_scaling(&target)
                        }
                        fn set_apply_matrix(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_apply_matrix(&mut target, value)
                        }
                        fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::apply_matrix(&target)
                        }
                        fn set_view_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_view_matrix(&mut target, value)
                        }
                        fn view_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::view_matrix(&target)
                        }
                        fn set_dash_array(
                            &mut self,
                            value: Vec<f64>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_dash_array(&mut target, value)
                        }
                        fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_array(&target)
                        }
                        fn is_ancestor(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_ancestor(&target, item)
                        }
                        fn is_descendant(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_descendant(&target, item)
                        }
                        fn is_sibling(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_sibling(&target, item)
                        }
                        fn local_to_parent(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_parent(&target, point)
                        }
                        fn set_shadow_blur(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_shadow_blur(&mut target, value)
                        }
                        fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_blur(&target)
                        }
                        fn is_empty(
                            &self,
                            recursively: bool,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_empty(&target, recursively)
                        }
                        fn is_parent(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_parent(&target, item)
                        }
                        fn is_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_below(&target, item)
                        }
                        fn set_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_matrix(&mut target, value)
                        }
                        fn matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::matrix(&target)
                        }
                        fn export_json(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::export_json(&target, options)
                        }
                        fn global_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_to_local(&target, point)
                        }
                        fn set_on_mouse_drag(
                            &mut self,
                            value: super::ItemOnMouseDrag,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_drag(&mut target, value)
                        }
                        fn on_mouse_drag(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDrag, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_drag(&target)
                        }
                        fn get_item(
                            &self,
                            options: super::ItemGetItemParamsOptionsParam,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_item(&target, options)
                        }
                        fn remove_children(
                            &self,
                            start: f64,
                            end: f64,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_children(&target, start, end)
                        }
                        fn set_project(
                            &mut self,
                            value: super::Project,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_project(&mut target, value)
                        }
                        fn project(&self) -> std::result::Result<super::Project, JsValue> {
                            let target: Item = self.into();
                            super::Item::project(&target)
                        }
                        fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_data(&mut target, value)
                        }
                        fn data(&self) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::data(&target)
                        }
                        fn insert_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_above(&target, item)
                        }
                        fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on(&target, options)
                        }
                        fn transform(
                            &self,
                            matrix: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::transform(&target, matrix)
                        }
                        fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inserted(&target)
                        }
                        fn set_on_mouse_down(
                            &mut self,
                            value: super::ItemOnMouseDown,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_down(&mut target, value)
                        }
                        fn on_mouse_down(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDown, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_down(&target)
                        }
                        fn set_last_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_last_child(&mut target, value)
                        }
                        fn last_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::last_child(&target)
                        }
                        fn set_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_selected(&mut target, value)
                        }
                        fn selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::selected(&target)
                        }
                        fn set_global_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_global_matrix(&mut target, value)
                        }
                        fn global_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_matrix(&target)
                        }
                        fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::responds(&target, type_)
                        }
                        fn rotate(
                            &self,
                            angle: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::rotate(&target, angle, center)
                        }
                        fn tween(
                            &self,
                            options: super::ItemTweenParamsOptionsParam,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween(&target, options)
                        }
                        fn set_on_mouse_enter(
                            &mut self,
                            value: super::ItemOnMouseEnter,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_enter(&mut target, value)
                        }
                        fn on_mouse_enter(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseEnter, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_enter(&target)
                        }
                        fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_id(&mut target, value)
                        }
                        fn id(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::id(&target)
                        }
                        fn on(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::on(&target, object)
                        }
                        fn tween_to(
                            &self,
                            to: JsValue,
                            options: super::ItemTweenToParamsOptionsParam,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_to(&target, to, options)
                        }
                        fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_locked(&mut target, value)
                        }
                        fn locked(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::locked(&target)
                        }
                        fn set_children(
                            &mut self,
                            value: Vec<Item>,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_children(&mut target, value)
                        }
                        fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::children(&target)
                        }
                        fn copy_attributes(
                            &self,
                            source: super::Item,
                            exclude_matrix: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_attributes(&target, source, exclude_matrix)
                        }
                        fn off(&self, object: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::off(&target, object)
                        }
                        fn contains(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::contains(&target, point)
                        }
                        fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_stroke(&target)
                        }
                        fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_move(&target)
                        }
                        fn add_children(
                            &self,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_children(&target, items)
                        }
                        fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::reverse_children(&target)
                        }
                        fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_shadow(&target)
                        }
                        fn set_dash_offset(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_dash_offset(&mut target, value)
                        }
                        fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_offset(&target)
                        }
                        fn set_on_mouse_leave(
                            &mut self,
                            value: super::ItemOnMouseLeave,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_leave(&mut target, value)
                        }
                        fn on_mouse_leave(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseLeave, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_leave(&target)
                        }
                        fn hit_test_all(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<Vec<HitResult>, JsValue> {
                            let target: Item = self.into();
                            super::Item::hit_test_all(&target, point, options)
                        }
                        fn set_stroke_cap(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_cap(&mut target, value)
                        }
                        fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_cap(&target)
                        }
                        fn set_internal_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_internal_bounds(&mut target, value)
                        }
                        fn internal_bounds(
                            &self,
                        ) -> std::result::Result<super::Rectangle, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::internal_bounds(&target)
                        }
                        fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_index(&mut target, value)
                        }
                        fn index(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::index(&target)
                        }
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::reduce(&target, options)
                        }
                        fn is_grouped_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_grouped_with(&target, item)
                        }
                        fn local_to_global(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_global(&target, point)
                        }
                        fn set_first_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_first_child(&mut target, value)
                        }
                        fn first_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::first_child(&target)
                        }
                        fn set_position(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_position(&mut target, value)
                        }
                        fn position(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::position(&target)
                        }
                        fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_opacity(&mut target, value)
                        }
                        fn opacity(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::opacity(&target)
                        }
                        fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_down(&target)
                        }
                        fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_drag(&target)
                        }
                        fn set_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_bounds(&mut target, value)
                        }
                        fn bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::bounds(&target)
                        }
                        fn set_parent(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_parent(&mut target, value)
                        }
                        fn parent(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent(&target)
                        }
                        fn get_items(
                            &self,
                            options: super::ItemGetItemsParamsOptionsParam,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_items(&target, options)
                        }
                        fn copy_to(
                            &self,
                            owner: super::ItemCopyToParamsOwnerParam,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_to(&target, owner)
                        }
                        fn set_on_double_click(
                            &mut self,
                            value: super::ItemOnDoubleClick,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_double_click(&mut target, value)
                        }
                        fn on_double_click(
                            &self,
                        ) -> std::result::Result<super::ItemOnDoubleClick, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_double_click(&target)
                        }
                        fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::set(&target, props)
                        }
                        fn scale(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::scale(&target, hor, ver, center)
                        }
                        fn insert_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_below(&target, item)
                        }
                        fn set_next_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_next_sibling(&mut target, value)
                        }
                        fn next_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::next_sibling(&target)
                        }
                        fn rasterize(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Raster, JsValue> {
                            let target: Item = self.into();
                            super::Item::rasterize(&target, options)
                        }
                        fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::bring_to_front(&target)
                        }
                        fn matches(
                            &self,
                            name: String,
                            compare: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::matches(&target, name, compare)
                        }
                        fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_fill(&target)
                        }
                        fn set_view(
                            &mut self,
                            value: super::View,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_view(&mut target, value)
                        }
                        fn view(&self) -> std::result::Result<super::View, JsValue> {
                            let target: Item = self.into();
                            super::Item::view(&target)
                        }
                        fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::clone(&target, options)
                        }
                        fn set_handle_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_handle_bounds(&mut target, value)
                        }
                        fn handle_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::handle_bounds(&target)
                        }
                        fn is_inside(
                            &self,
                            rect: super::Rectangle,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inside(&target, rect)
                        }
                        fn is_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_above(&target, item)
                        }
                        fn remove(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove(&target)
                        }
                        fn set_stroke_join(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_join(&mut target, value)
                        }
                        fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_join(&target)
                        }
                        fn set_on_click(
                            &mut self,
                            value: super::ItemOnClick,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_click(&mut target, value)
                        }
                        fn on_click(&self) -> std::result::Result<super::ItemOnClick, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_click(&target)
                        }
                        fn fit_bounds(
                            &self,
                            rectangle: super::Rectangle,
                            fill: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::fit_bounds(&target, rectangle, fill)
                        }
                        fn set_blend_mode(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_blend_mode(&mut target, value)
                        }
                        fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::blend_mode(&target)
                        }
                        fn set_stroke_width(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_width(&mut target, value)
                        }
                        fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_width(&target)
                        }
                        fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_rotation(&mut target, value)
                        }
                        fn rotation(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::rotation(&target)
                        }
                        fn set_selected_color(
                            &mut self,
                            value: super::ItemSelectedColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_selected_color(&mut target, value)
                        }
                        fn selected_color(
                            &self,
                        ) -> std::result::Result<super::ItemSelectedColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::selected_color(&target)
                        }
                        fn skew(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::skew(&target, hor, ver, center)
                        }
                        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_name(&mut target, value)
                        }
                        fn name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::name(&target)
                        }
                        fn import_json(
                            &self,
                            json: String,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_json(&target, json)
                        }
                        fn add_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_child(&target, item)
                        }
                        fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_visible(&mut target, value)
                        }
                        fn visible(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::visible(&target)
                        }
                        fn set_fill_rule(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_fill_rule(&mut target, value)
                        }
                        fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_rule(&target)
                        }
                        fn set_layer(
                            &mut self,
                            value: super::Layer,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_layer(&mut target, value)
                        }
                        fn layer(&self) -> std::result::Result<super::Layer, JsValue> {
                            let target: Item = self.into();
                            super::Item::layer(&target)
                        }
                        fn tween_from(
                            &self,
                            from: JsValue,
                            options: super::ItemTweenFromParamsOptionsParam,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_from(&target, from, options)
                        }
                        fn insert_child(
                            &self,
                            index: f64,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_child(&target, index, item)
                        }
                        fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_up(&target)
                        }
                        fn set_pivot(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_pivot(&mut target, value)
                        }
                        fn pivot(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::pivot(&target)
                        }
                        fn set_miter_limit(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_miter_limit(&mut target, value)
                        }
                        fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::miter_limit(&target)
                        }
                        fn copy_content(
                            &self,
                            source: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_content(&target, source)
                        }
                        fn import_svg(
                            &self,
                            svg: super::ItemImportSvgParamsSvgParam,
                            on_load: &'static dyn Fn(
                                Box<[JsValue]>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_svg(&target, svg, on_load)
                        }
                        fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::send_to_back(&target)
                        }
                        fn set_stroke_color(
                            &mut self,
                            value: super::ItemStrokeColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_color(&mut target, value)
                        }
                        fn stroke_color(
                            &self,
                        ) -> std::result::Result<super::ItemStrokeColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::stroke_color(&target)
                        }
                        fn set_on_mouse_move(
                            &mut self,
                            value: super::ItemOnMouseMove,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_move(&mut target, value)
                        }
                        fn on_mouse_move(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseMove, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_move(&target)
                        }
                        fn replace_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::replace_with(&target, item)
                        }
                        fn hit_test(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<super::HitResult, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::hit_test(&target, point, options)
                        }
                        fn shear(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::shear(&target, hor, ver, center)
                        }
                        fn translate(
                            &self,
                            delta: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::translate(&target, delta)
                        }
                        fn set_stroke_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_stroke_bounds(&mut target, value)
                        }
                        fn stroke_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_bounds(&target)
                        }
                        fn insert_children(
                            &self,
                            index: f64,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_children(&target, index, items)
                        }
                        fn is_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_child(&target, item)
                        }
                        fn set_shadow_offset(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_shadow_offset(&mut target, value)
                        }
                        fn shadow_offset(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_offset(&target)
                        }
                        fn set_fill_color(
                            &mut self,
                            value: super::ItemFillColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_fill_color(&mut target, value)
                        }
                        fn fill_color(&self) -> std::result::Result<super::ItemFillColor, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_color(&target)
                        }
                        fn export_svg(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::ItemExportSvgReturn, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::export_svg(&target, options)
                        }
                        fn set_style(
                            &mut self,
                            value: super::Style,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_style(&mut target, value)
                        }
                        fn style(&self) -> std::result::Result<super::Style, JsValue> {
                            let target: Item = self.into();
                            super::Item::style(&target)
                        }
                        fn set_clip_mask(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_clip_mask(&mut target, value)
                        }
                        fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::clip_mask(&target)
                        }
                        fn set_class_name(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_class_name(&mut target, value)
                        }
                        fn class_name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::class_name(&target)
                        }
                        fn set_on_mouse_up(
                            &mut self,
                            value: super::ItemOnMouseUp,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_mouse_up(&mut target, value)
                        }
                        fn on_mouse_up(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseUp, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_up(&target)
                        }
                        fn set_on_frame(
                            &mut self,
                            value: super::ItemOnFrame,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_on_frame(&mut target, value)
                        }
                        fn on_frame(&self) -> std::result::Result<super::ItemOnFrame, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_frame(&target)
                        }
                        fn parent_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent_to_local(&target, point)
                        }
                        fn set_previous_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_previous_sibling(&mut target, value)
                        }
                        fn previous_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::previous_sibling(&target)
                        }
                        fn emit(
                            &self,
                            type_: String,
                            event: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::emit(&target, type_, event)
                        }
                        fn add_to(
                            &self,
                            owner: super::ItemAddToParamsOwnerParam,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_to(&target, owner)
                        }
                        fn has_children(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_children(&target)
                        }
                        fn intersects(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::intersects(&target, item)
                        }
                        fn set_shadow_color(
                            &mut self,
                            value: super::ItemShadowColor,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_shadow_color(&mut target, value)
                        }
                        fn shadow_color(
                            &self,
                        ) -> std::result::Result<super::ItemShadowColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::shadow_color(&target)
                        }
                        fn set_scaling(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let mut target: Item = self.into();
                            super::Item::set_scaling(&mut target, value)
                        }
                        fn scaling(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::scaling(&target)
                        }
                    }
                    impl Circle_Trait for Circle where Circle: Shape_Trait {}
                    impl std::clone::Clone for Circle_Class {
                        fn clone(&self) -> Self {
                            Self {
                                obj: std::clone::Clone::clone(&self.obj),
                            }
                        }
                    }
                    impl serde::ser::Serialize for Circle_Class {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Circle_Class {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                        }
                    }
                }
            }
        }
        #[cfg(target_family = "wasm")]
        pub mod paper_core {
            #[allow(unused)]
            use super::*;
            #[allow(unused)]
            use wasm_bindgen::prelude::*;
        }
    }
}
