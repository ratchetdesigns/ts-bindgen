#![allow(
    clippy::let_and_return,
    clippy::type_complexity,
    clippy::unused_unit,
    clippy::manual_non_exhaustive,
    clippy::redundant_closure
)]
#[cfg(target_family = "wasm")]
pub mod paper {
    #[cfg(target_family = "wasm")]
    pub mod dist {
        #[cfg(target_family = "wasm")]
        pub mod paper {
            #[allow(unused)]
            use super::*;
            #[allow(unused)]
            use wasm_bindgen::prelude::*;
            #[cfg(target_family = "wasm")]
            pub mod paper {
                #[allow(unused)]
                use super::*;
                #[allow(unused)]
                use wasm_bindgen::prelude::*;
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    #[wasm_bindgen(js_name = "Size")]
                    pub type Size_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = set , method , js_class = "Size" , catch , variadic)]
                    fn __TSB_set_FnVecOfJsValueToSize(
                        this: &Size_Class,
                        values: Box<[JsValue]>,
                    ) -> std::result::Result<Size, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = modulo , method , js_class = "Size" , catch)]
                    fn __TSB_modulo_FnF64ToSize(
                        this: &Size_Class,
                        value: f64,
                    ) -> std::result::Result<Size, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = modulo , method , js_class = "Size" , catch)]
                    fn __TSB_modulo_FnSizeToSize(
                        this: &Size_Class,
                        size: Size,
                    ) -> std::result::Result<Size, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clone , method , js_class = "Size" , catch)]
                    fn __TSB_clone_FnToSize(
                        this: &Size_Class,
                    ) -> std::result::Result<Size, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = toString , method , js_class = "Size" , catch)]
                    fn __TSB_to_string_FnToString(
                        this: &Size_Class,
                    ) -> std::result::Result<String, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = round , method , js_class = "Size" , catch)]
                    fn __TSB_round_FnToSize(
                        this: &Size_Class,
                    ) -> std::result::Result<Size, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = floor , method , js_class = "Size" , catch)]
                    fn __TSB_floor_FnToSize(
                        this: &Size_Class,
                    ) -> std::result::Result<Size, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isZero , method , js_class = "Size" , catch)]
                    fn __TSB_is_zero_FnToBool(
                        this: &Size_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = add , method , js_class = "Size" , catch)]
                    fn __TSB_add_FnF64ToSize(
                        this: &Size_Class,
                        number: f64,
                    ) -> std::result::Result<Size, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = add , method , js_class = "Size" , catch)]
                    fn __TSB_add_FnSizeToSize(
                        this: &Size_Class,
                        size: Size,
                    ) -> std::result::Result<Size, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = random , method , js_class = "Size" , catch)]
                    fn __TSB_random_FnToSize(
                        this: &Size_Class,
                    ) -> std::result::Result<Size, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = abs , method , js_class = "Size" , catch)]
                    fn __TSB_abs_FnToSize(this: &Size_Class) -> std::result::Result<Size, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = min , method , js_class = "Size" , catch)]
                    fn __TSB_min_FnSizeAndSizeToSize(
                        this: &Size_Class,
                        size1: Size,
                        size2: Size,
                    ) -> std::result::Result<Size, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = divide , method , js_class = "Size" , catch)]
                    fn __TSB_divide_FnF64ToSize(
                        this: &Size_Class,
                        number: f64,
                    ) -> std::result::Result<Size, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = divide , method , js_class = "Size" , catch)]
                    fn __TSB_divide_FnSizeToSize(
                        this: &Size_Class,
                        size: Size,
                    ) -> std::result::Result<Size, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = width , js_class = "Size")]
                    fn width(this: &Size_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = width , js_class = "Size")]
                    fn set_width(this: &Size_Class, value: f64)
                        -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = subtract , method , js_class = "Size" , catch)]
                    fn __TSB_subtract_FnF64ToSize(
                        this: &Size_Class,
                        number: f64,
                    ) -> std::result::Result<Size, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = subtract , method , js_class = "Size" , catch)]
                    fn __TSB_subtract_FnSizeToSize(
                        this: &Size_Class,
                        size: Size,
                    ) -> std::result::Result<Size, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = ceil , method , js_class = "Size" , catch)]
                    fn __TSB_ceil_FnToSize(this: &Size_Class)
                        -> std::result::Result<Size, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = height , js_class = "Size")]
                    fn height(this: &Size_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = height , js_class = "Size")]
                    fn set_height(
                        this: &Size_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = equals , method , js_class = "Size" , catch)]
                    fn __TSB_equals_FnSizeToBool(
                        this: &Size_Class,
                        size: Size,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = multiply , method , js_class = "Size" , catch)]
                    fn __TSB_multiply_FnF64ToSize(
                        this: &Size_Class,
                        number: f64,
                    ) -> std::result::Result<Size, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = multiply , method , js_class = "Size" , catch)]
                    fn __TSB_multiply_FnSizeToSize(
                        this: &Size_Class,
                        size: Size,
                    ) -> std::result::Result<Size, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = max , method , js_class = "Size" , catch)]
                    fn __TSB_max_FnSizeAndSizeToSize(
                        this: &Size_Class,
                        size1: Size,
                        size2: Size,
                    ) -> std::result::Result<Size, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isNaN , method , js_class = "Size" , catch)]
                    fn __TSB_is_na_n_FnToBool(
                        this: &Size_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    #[wasm_bindgen(constructor, js_class = "Size")]
                    pub fn new_FnF64AndF64ToSize(width: f64, height: f64) -> Size_Class;
                    #[wasm_bindgen(constructor, js_class = "Size")]
                    pub fn new_FnVecOfJsValueToSize(array: JsValue) -> Size_Class;
                    #[wasm_bindgen(constructor, js_class = "Size")]
                    pub fn new_FnSizeToSize(size: Size) -> Size_Class;
                    #[wasm_bindgen(constructor, js_class = "Size")]
                    pub fn new_FnPointToSize(point: Point) -> Size_Class;
                    #[wasm_bindgen(constructor, js_class = "Size")]
                    pub fn new_FnJsValueToSize(object: JsValue) -> Size_Class;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Size(pub Size_Class);
                impl std::convert::From<Size> for JsValue {
                    fn from(src: Size) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for Size {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for Size {
                    fn instanceof(val: &JsValue) -> bool {
                        Size_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        Size(Size_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(Size_Class::unchecked_from_js_ref(val) as *const Size_Class
                                as *const Self)
                        }
                    }
                }
                impl Size {
                    #[allow(dead_code, non_snake_case)]
                    pub fn set(&self, values: Vec<JsValue>) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_set_FnVecOfJsValueToSize(
                            values
                                .into_iter()
                                .map(|values_item| JsValue::from(values_item))
                                .collect::<Vec<_>>()
                                .into_boxed_slice(),
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn modulo_FnF64ToSize(
                        &self,
                        value: f64,
                    ) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_modulo_FnF64ToSize(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn modulo_FnSizeToSize(
                        &self,
                        size: Size,
                    ) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_modulo_FnSizeToSize(size);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn clone(&self) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_clone_FnToSize();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.__TSB_to_string_FnToString();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn round(&self) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_round_FnToSize();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn floor(&self) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_floor_FnToSize();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_zero(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_zero_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn add_FnF64ToSize(
                        &self,
                        number: f64,
                    ) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_add_FnF64ToSize(number);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn add_FnSizeToSize(
                        &self,
                        size: Size,
                    ) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_add_FnSizeToSize(size);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn random(&self) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_random_FnToSize();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn abs(&self) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_abs_FnToSize();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn min(
                        &self,
                        size1: Size,
                        size2: Size,
                    ) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_min_FnSizeAndSizeToSize(size1, size2);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn divide_FnF64ToSize(
                        &self,
                        number: f64,
                    ) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_divide_FnF64ToSize(number);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn divide_FnSizeToSize(
                        &self,
                        size: Size,
                    ) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_divide_FnSizeToSize(size);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn width(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.width();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_width(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_width(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn subtract_FnF64ToSize(
                        &self,
                        number: f64,
                    ) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_subtract_FnF64ToSize(number);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn subtract_FnSizeToSize(
                        &self,
                        size: Size,
                    ) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_subtract_FnSizeToSize(size);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn ceil(&self) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_ceil_FnToSize();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn height(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.height();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_height(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_height(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn equals(&self, size: Size) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_equals_FnSizeToBool(size);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn multiply_FnF64ToSize(
                        &self,
                        number: f64,
                    ) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_multiply_FnF64ToSize(number);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn multiply_FnSizeToSize(
                        &self,
                        size: Size,
                    ) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_multiply_FnSizeToSize(size);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn max(
                        &self,
                        size1: Size,
                        size2: Size,
                    ) -> std::result::Result<Size, JsValue> {
                        let result = self.0.__TSB_max_FnSizeAndSizeToSize(size1, size2);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_na_n(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_na_n_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnF64AndF64ToSize(width: f64, height: f64) -> Size {
                        let result = Size_Class::new_FnF64AndF64ToSize(width, height);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Size(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnVecOfJsValueToSize(array: Vec<JsValue>) -> Size {
                        let result = Size_Class::new_FnVecOfJsValueToSize({
                            let array_array = js_sys::Array::new();
                            for array_item in array {
                                array_array.push(&JsValue::from(array_item));
                            }
                            array_array.into()
                        });
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Size(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnSizeToSize(size: Size) -> Size {
                        let result = Size_Class::new_FnSizeToSize(size);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Size(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnPointToSize(point: Point) -> Size {
                        let result = Size_Class::new_FnPointToSize(point);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Size(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnJsValueToSize(object: JsValue) -> Size {
                        let result = Size_Class::new_FnJsValueToSize(object);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Size(result)
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Size {
                    fn describe() {
                        <Size_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Size {
                    type Abi = <Size_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Size {
                    type Abi = <Size_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Size(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Size {
                    type Abi = <&'a Size_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Size {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Size {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Size_Class =
                            <Size_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait Size_Trait {
                    fn set(&self, values: Vec<JsValue>) -> std::result::Result<Size, JsValue>;
                    fn modulo_FnF64ToSize(&self, value: f64) -> std::result::Result<Size, JsValue>;
                    fn modulo_FnSizeToSize(&self, size: Size)
                        -> std::result::Result<Size, JsValue>;
                    fn clone(&self) -> std::result::Result<Size, JsValue>;
                    fn to_string(&self) -> std::result::Result<String, JsValue>;
                    fn round(&self) -> std::result::Result<Size, JsValue>;
                    fn floor(&self) -> std::result::Result<Size, JsValue>;
                    fn is_zero(&self) -> std::result::Result<bool, JsValue>;
                    fn add_FnF64ToSize(&self, number: f64) -> std::result::Result<Size, JsValue>;
                    fn add_FnSizeToSize(&self, size: Size) -> std::result::Result<Size, JsValue>;
                    fn random(&self) -> std::result::Result<Size, JsValue>;
                    fn abs(&self) -> std::result::Result<Size, JsValue>;
                    fn min(&self, size1: Size, size2: Size) -> std::result::Result<Size, JsValue>;
                    fn divide_FnF64ToSize(&self, number: f64)
                        -> std::result::Result<Size, JsValue>;
                    fn divide_FnSizeToSize(&self, size: Size)
                        -> std::result::Result<Size, JsValue>;
                    fn set_width(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn width(&self) -> std::result::Result<f64, JsValue>;
                    fn subtract_FnF64ToSize(
                        &self,
                        number: f64,
                    ) -> std::result::Result<Size, JsValue>;
                    fn subtract_FnSizeToSize(
                        &self,
                        size: Size,
                    ) -> std::result::Result<Size, JsValue>;
                    fn ceil(&self) -> std::result::Result<Size, JsValue>;
                    fn set_height(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn height(&self) -> std::result::Result<f64, JsValue>;
                    fn equals(&self, size: Size) -> std::result::Result<bool, JsValue>;
                    fn multiply_FnF64ToSize(
                        &self,
                        number: f64,
                    ) -> std::result::Result<Size, JsValue>;
                    fn multiply_FnSizeToSize(
                        &self,
                        size: Size,
                    ) -> std::result::Result<Size, JsValue>;
                    fn max(&self, size1: Size, size2: Size) -> std::result::Result<Size, JsValue>;
                    fn is_na_n(&self) -> std::result::Result<bool, JsValue>;
                }
                impl Size_Trait for Size {
                    fn set(&self, values: Vec<JsValue>) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::set(target, values)
                    }
                    fn modulo_FnF64ToSize(&self, value: f64) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::modulo_FnF64ToSize(target, value)
                    }
                    fn modulo_FnSizeToSize(
                        &self,
                        size: Size,
                    ) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::modulo_FnSizeToSize(target, size)
                    }
                    fn clone(&self) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::clone(target)
                    }
                    fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Size::to_string(target)
                    }
                    fn round(&self) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::round(target)
                    }
                    fn floor(&self) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::floor(target)
                    }
                    fn is_zero(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Size::is_zero(target)
                    }
                    fn add_FnF64ToSize(&self, number: f64) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::add_FnF64ToSize(target, number)
                    }
                    fn add_FnSizeToSize(&self, size: Size) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::add_FnSizeToSize(target, size)
                    }
                    fn random(&self) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::random(target)
                    }
                    fn abs(&self) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::abs(target)
                    }
                    fn min(&self, size1: Size, size2: Size) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::min(target, size1, size2)
                    }
                    fn divide_FnF64ToSize(
                        &self,
                        number: f64,
                    ) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::divide_FnF64ToSize(target, number)
                    }
                    fn divide_FnSizeToSize(
                        &self,
                        size: Size,
                    ) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::divide_FnSizeToSize(target, size)
                    }
                    fn set_width(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Size::set_width(target, value)
                    }
                    fn width(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Size::width(target)
                    }
                    fn subtract_FnF64ToSize(
                        &self,
                        number: f64,
                    ) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::subtract_FnF64ToSize(target, number)
                    }
                    fn subtract_FnSizeToSize(
                        &self,
                        size: Size,
                    ) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::subtract_FnSizeToSize(target, size)
                    }
                    fn ceil(&self) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::ceil(target)
                    }
                    fn set_height(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Size::set_height(target, value)
                    }
                    fn height(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Size::height(target)
                    }
                    fn equals(&self, size: Size) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Size::equals(target, size)
                    }
                    fn multiply_FnF64ToSize(
                        &self,
                        number: f64,
                    ) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::multiply_FnF64ToSize(target, number)
                    }
                    fn multiply_FnSizeToSize(
                        &self,
                        size: Size,
                    ) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::multiply_FnSizeToSize(target, size)
                    }
                    fn max(&self, size1: Size, size2: Size) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Size::max(target, size1, size2)
                    }
                    fn is_na_n(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Size::is_na_n(target)
                    }
                }
                impl std::clone::Clone for Size_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Size_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Size_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum MatrixRotateReturn {
                    Matrix(Matrix),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum RasterOnLoad {
                    TsBindgenRtNull,
                    #[serde(
                        serialize_with = "RasterOnLoad::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "RasterOnLoad::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                }
                impl RasterOnLoad {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PathAddReturn {
                    Segment(Segment),
                    VecOfSegment(Vec<Segment>),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PointSubtractParamsNumber {
                    Point(Point),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewSkewReturn {
                    __,
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    # [wasm_bindgen (js_name = "PathItem" , extends = Item_Class)]
                    pub type PathItem_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = unite , method , js_class = "PathItem" , catch)]
                    fn __TSB_unite_FnPathItemAndJsValueToPathItem(
                        this: &PathItem_Class,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = lineBy , method , js_class = "PathItem" , catch)]
                    fn __TSB_line_by_FnPointTo(
                        this: &PathItem_Class,
                        point: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = moveTo , method , js_class = "PathItem" , catch)]
                    fn __TSB_move_to_FnPointTo(
                        this: &PathItem_Class,
                        point: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = pathData , js_class = "PathItem")]
                    fn path_data(this: &PathItem_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = pathData , js_class = "PathItem")]
                    fn set_path_data(
                        this: &PathItem_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = intersect , method , js_class = "PathItem" , catch)]
                    fn __TSB_intersect_FnPathItemAndJsValueToPathItem(
                        this: &PathItem_Class,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = create , method , js_class = "PathItem" , catch)]
                    fn __TSB_create_FnStringToPathItemCreateReturn(
                        this: &PathItem_Class,
                        path_data: String,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = create , method , js_class = "PathItem" , catch)]
                    fn __TSB_create_FnVecOfVecOfF64ToPathItemCreateReturn(
                        this: &PathItem_Class,
                        segments: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = create , method , js_class = "PathItem" , catch)]
                    fn __TSB_create_FnJsValueToPathItemCreateReturn(
                        this: &PathItem_Class,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = smooth , method , js_class = "PathItem" , catch)]
                    fn __TSB_smooth_FnJsValueTo(
                        this: &PathItem_Class,
                        options: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = compare , method , js_class = "PathItem" , catch)]
                    fn __TSB_compare_FnPathItemToBool(
                        this: &PathItem_Class,
                        path: PathItem,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = arcTo , method , js_class = "PathItem" , catch)]
                    fn __TSB_arc_to_FnPointAndPointTo(
                        this: &PathItem_Class,
                        through: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = arcTo , method , js_class = "PathItem" , catch)]
                    fn __TSB_arc_to_FnPointAndBoolTo(
                        this: &PathItem_Class,
                        to: Point,
                        clockwise: bool,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = quadraticCurveTo , method , js_class = "PathItem" , catch)]
                    fn __TSB_quadratic_curve_to_FnPointAndPointTo(
                        this: &PathItem_Class,
                        handle: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = interiorPoint , js_class = "PathItem")]
                    fn interior_point(this: &PathItem_Class)
                        -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = interiorPoint , js_class = "PathItem")]
                    fn set_interior_point(
                        this: &PathItem_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = simplify , method , js_class = "PathItem" , catch)]
                    fn __TSB_simplify_FnF64ToBool(
                        this: &PathItem_Class,
                        tolerance: f64,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = reorient , method , js_class = "PathItem" , catch)]
                    fn __TSB_reorient_FnBoolAndBoolToPathItem(
                        this: &PathItem_Class,
                        non_zero: bool,
                        clockwise: bool,
                    ) -> std::result::Result<PathItem, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = cubicCurveBy , method , js_class = "PathItem" , catch)]
                    fn __TSB_cubic_curve_by_FnPointAndPointAndPointTo(
                        this: &PathItem_Class,
                        handle1: Point,
                        handle2: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = closePath , method , js_class = "PathItem" , catch)]
                    fn __TSB_close_path_FnTo(
                        this: &PathItem_Class,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = flatten , method , js_class = "PathItem" , catch)]
                    fn __TSB_flatten_FnF64To(
                        this: &PathItem_Class,
                        flatness: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = quadraticCurveBy , method , js_class = "PathItem" , catch)]
                    fn __TSB_quadratic_curve_by_FnPointAndPointTo(
                        this: &PathItem_Class,
                        handle: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = cubicCurveTo , method , js_class = "PathItem" , catch)]
                    fn __TSB_cubic_curve_to_FnPointAndPointAndPointTo(
                        this: &PathItem_Class,
                        handle1: Point,
                        handle2: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = divide , method , js_class = "PathItem" , catch)]
                    fn __TSB_divide_FnPathItemAndJsValueToPathItem(
                        this: &PathItem_Class,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = arcBy , method , js_class = "PathItem" , catch)]
                    fn __TSB_arc_by_FnPointAndPointTo(
                        this: &PathItem_Class,
                        through: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = arcBy , method , js_class = "PathItem" , catch)]
                    fn __TSB_arc_by_FnPointAndBoolTo(
                        this: &PathItem_Class,
                        to: Point,
                        clockwise: bool,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = moveBy , method , js_class = "PathItem" , catch)]
                    fn __TSB_move_by_FnPointTo(
                        this: &PathItem_Class,
                        to: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getNearestLocation , method , js_class = "PathItem" , catch)]
                    fn __TSB_get_nearest_location_FnPointToCurveLocation(
                        this: &PathItem_Class,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = reverse , method , js_class = "PathItem" , catch)]
                    fn __TSB_reverse_FnTo(
                        this: &PathItem_Class,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = lineTo , method , js_class = "PathItem" , catch)]
                    fn __TSB_line_to_FnPointTo(
                        this: &PathItem_Class,
                        point: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getNearestPoint , method , js_class = "PathItem" , catch)]
                    fn __TSB_get_nearest_point_FnPointToPoint(
                        this: &PathItem_Class,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = interpolate , method , js_class = "PathItem" , catch)]
                    fn __TSB_interpolate_FnPathItemAndPathItemAndF64To(
                        this: &PathItem_Class,
                        from: PathItem,
                        to: PathItem,
                        factor: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getCrossings , method , js_class = "PathItem" , catch)]
                    fn __TSB_get_crossings_FnPathItemToVecOfCurveLocation(
                        this: &PathItem_Class,
                        path: PathItem,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = curveBy , method , js_class = "PathItem" , catch)]
                    fn __TSB_curve_by_FnPointAndPointAndF64To(
                        this: &PathItem_Class,
                        through: Point,
                        to: Point,
                        time: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = curveTo , method , js_class = "PathItem" , catch)]
                    fn __TSB_curve_to_FnPointAndPointAndF64To(
                        this: &PathItem_Class,
                        through: Point,
                        to: Point,
                        time: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = subtract , method , js_class = "PathItem" , catch)]
                    fn __TSB_subtract_FnPathItemAndJsValueToPathItem(
                        this: &PathItem_Class,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getIntersections , method , js_class = "PathItem" , catch)]
                    fn __TSB_get_intersections_FnPathItemAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToVecOfCurveLocation(
                        this: &PathItem_Class,
                        path: PathItem,
                        include: &Closure<
                            dyn Fn(
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        >,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = exclude , method , js_class = "PathItem" , catch)]
                    fn __TSB_exclude_FnPathItemAndJsValueToPathItem(
                        this: &PathItem_Class,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = clockwise , js_class = "PathItem")]
                    fn clockwise(this: &PathItem_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = clockwise , js_class = "PathItem")]
                    fn set_clockwise(
                        this: &PathItem_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct PathItem(pub PathItem_Class);
                impl std::convert::From<&PathItem> for Item {
                    fn from(src: &PathItem) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl std::convert::From<&mut PathItem> for Item {
                    fn from(src: &mut PathItem) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl std::convert::From<PathItem> for JsValue {
                    fn from(src: PathItem) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for PathItem {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for PathItem {
                    fn instanceof(val: &JsValue) -> bool {
                        PathItem_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        PathItem(PathItem_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(PathItem_Class::unchecked_from_js_ref(val) as *const PathItem_Class
                                as *const Self)
                        }
                    }
                }
                impl PathItem {
                    #[allow(dead_code, non_snake_case)]
                    pub fn unite(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let result = self
                            .0
                            .__TSB_unite_FnPathItemAndJsValueToPathItem(path, options);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn line_by(&self, point: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_line_by_FnPointTo(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn move_to(&self, point: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_move_to_FnPointTo(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn path_data(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.path_data();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_path_data(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_path_data(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn intersect(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let result = self
                            .0
                            .__TSB_intersect_FnPathItemAndJsValueToPathItem(path, options);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn create_FnStringToPathItemCreateReturn(
                        &self,
                        path_data: String,
                    ) -> std::result::Result<PathItemCreateReturn, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self
                                .0
                                .__TSB_create_FnStringToPathItemCreateReturn(path_data)?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn create_FnVecOfVecOfF64ToPathItemCreateReturn(
                        &self,
                        segments: Vec<Vec<f64>>,
                    ) -> std::result::Result<PathItemCreateReturn, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self.0.__TSB_create_FnVecOfVecOfF64ToPathItemCreateReturn({
                                let segments_array = js_sys::Array::new();
                                for segments_item in segments {
                                    segments_array.push(&{
                                        let segments_item_array = js_sys::Array::new();
                                        for segments_item_item in segments_item {
                                            segments_item_array
                                                .push(&JsValue::from(segments_item_item));
                                        }
                                        segments_item_array.into()
                                    });
                                }
                                segments_array.into()
                            })?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn create_FnJsValueToPathItemCreateReturn(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<PathItemCreateReturn, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self
                                .0
                                .__TSB_create_FnJsValueToPathItemCreateReturn(object)?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn smooth(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_smooth_FnJsValueTo(options);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn compare(&self, path: PathItem) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_compare_FnPathItemToBool(path);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn arc_to_FnPointAndPointTo(
                        &self,
                        through: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_arc_to_FnPointAndPointTo(through, to);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn arc_to_FnPointAndBoolTo(
                        &self,
                        to: Point,
                        clockwise: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_arc_to_FnPointAndBoolTo(to, clockwise);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn quadratic_curve_to(
                        &self,
                        handle: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self
                            .0
                            .__TSB_quadratic_curve_to_FnPointAndPointTo(handle, to);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn interior_point(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.interior_point();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_interior_point(
                        &self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_interior_point(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn simplify(&self, tolerance: f64) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_simplify_FnF64ToBool(tolerance);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn reorient(
                        &self,
                        non_zero: bool,
                        clockwise: bool,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let result = self
                            .0
                            .__TSB_reorient_FnBoolAndBoolToPathItem(non_zero, clockwise);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn cubic_curve_by(
                        &self,
                        handle1: Point,
                        handle2: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self
                            .0
                            .__TSB_cubic_curve_by_FnPointAndPointAndPointTo(handle1, handle2, to);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn close_path(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_close_path_FnTo();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn flatten(&self, flatness: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_flatten_FnF64To(flatness);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn quadratic_curve_by(
                        &self,
                        handle: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self
                            .0
                            .__TSB_quadratic_curve_by_FnPointAndPointTo(handle, to);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn cubic_curve_to(
                        &self,
                        handle1: Point,
                        handle2: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self
                            .0
                            .__TSB_cubic_curve_to_FnPointAndPointAndPointTo(handle1, handle2, to);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn divide(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let result = self
                            .0
                            .__TSB_divide_FnPathItemAndJsValueToPathItem(path, options);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn arc_by_FnPointAndPointTo(
                        &self,
                        through: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_arc_by_FnPointAndPointTo(through, to);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn arc_by_FnPointAndBoolTo(
                        &self,
                        to: Point,
                        clockwise: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_arc_by_FnPointAndBoolTo(to, clockwise);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn move_by(&self, to: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_move_by_FnPointTo(to);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_nearest_location(
                        &self,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let result = self
                            .0
                            .__TSB_get_nearest_location_FnPointToCurveLocation(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn reverse(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_reverse_FnTo();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn line_to(&self, point: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_line_to_FnPointTo(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_nearest_point(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_get_nearest_point_FnPointToPoint(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn interpolate(
                        &self,
                        from: PathItem,
                        to: PathItem,
                        factor: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self
                            .0
                            .__TSB_interpolate_FnPathItemAndPathItemAndF64To(from, to, factor);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_crossings(
                        &self,
                        path: PathItem,
                    ) -> std::result::Result<Vec<CurveLocation>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self
                                .0
                                .__TSB_get_crossings_FnPathItemToVecOfCurveLocation(path)?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn curve_by(
                        &self,
                        through: Point,
                        to: Point,
                        time: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self
                            .0
                            .__TSB_curve_by_FnPointAndPointAndF64To(through, to, time);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn curve_to(
                        &self,
                        through: Point,
                        to: Point,
                        time: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self
                            .0
                            .__TSB_curve_to_FnPointAndPointAndF64To(through, to, time);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn subtract(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let result = self
                            .0
                            .__TSB_subtract_FnPathItemAndJsValueToPathItem(path, options);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_intersections(
                        &self,
                        path: PathItem,
                        include: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Vec<CurveLocation>, JsValue> {
                        # [allow (non_snake_case)] let __TSB_Local_include = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = include ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let result = ts_bindgen_rt :: from_jsvalue (& self . 0 . __TSB_get_intersections_FnPathItemAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToVecOfCurveLocation (path , & __TSB_Local_include) ?) . map_err (ts_bindgen_rt :: Error :: from) . map_err (JsValue :: from) ;
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn exclude(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let result = self
                            .0
                            .__TSB_exclude_FnPathItemAndJsValueToPathItem(path, options);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn clockwise(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.clockwise();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_clockwise(&self, value: bool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_clockwise(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for PathItem {
                    fn describe() {
                        <PathItem_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for PathItem {
                    type Abi = <PathItem_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for PathItem {
                    type Abi = <PathItem_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        PathItem(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a PathItem {
                    type Abi = <&'a PathItem_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for PathItem {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for PathItem {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: PathItem_Class =
                            <PathItem_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait PathItem_Trait: Item_Trait {
                    fn unite(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue>;
                    fn line_by(&self, point: Point) -> std::result::Result<(), JsValue>;
                    fn move_to(&self, point: Point) -> std::result::Result<(), JsValue>;
                    fn set_path_data(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn path_data(&self) -> std::result::Result<String, JsValue>;
                    fn intersect(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue>;
                    fn create_FnStringToPathItemCreateReturn(
                        &self,
                        path_data: String,
                    ) -> std::result::Result<PathItemCreateReturn, JsValue>;
                    fn create_FnVecOfVecOfF64ToPathItemCreateReturn(
                        &self,
                        segments: Vec<Vec<f64>>,
                    ) -> std::result::Result<PathItemCreateReturn, JsValue>;
                    fn create_FnJsValueToPathItemCreateReturn(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<PathItemCreateReturn, JsValue>;
                    fn smooth(&self, options: JsValue) -> std::result::Result<(), JsValue>;
                    fn compare(&self, path: PathItem) -> std::result::Result<bool, JsValue>;
                    fn arc_to_FnPointAndPointTo(
                        &self,
                        through: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn arc_to_FnPointAndBoolTo(
                        &self,
                        to: Point,
                        clockwise: bool,
                    ) -> std::result::Result<(), JsValue>;
                    fn quadratic_curve_to(
                        &self,
                        handle: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn set_interior_point(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn interior_point(&self) -> std::result::Result<Point, JsValue>;
                    fn simplify(&self, tolerance: f64) -> std::result::Result<bool, JsValue>;
                    fn reorient(
                        &self,
                        non_zero: bool,
                        clockwise: bool,
                    ) -> std::result::Result<PathItem, JsValue>;
                    fn cubic_curve_by(
                        &self,
                        handle1: Point,
                        handle2: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn close_path(&self) -> std::result::Result<(), JsValue>;
                    fn flatten(&self, flatness: f64) -> std::result::Result<(), JsValue>;
                    fn quadratic_curve_by(
                        &self,
                        handle: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn cubic_curve_to(
                        &self,
                        handle1: Point,
                        handle2: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn divide(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue>;
                    fn arc_by_FnPointAndPointTo(
                        &self,
                        through: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn arc_by_FnPointAndBoolTo(
                        &self,
                        to: Point,
                        clockwise: bool,
                    ) -> std::result::Result<(), JsValue>;
                    fn move_by(&self, to: Point) -> std::result::Result<(), JsValue>;
                    fn get_nearest_location(
                        &self,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    fn reverse(&self) -> std::result::Result<(), JsValue>;
                    fn line_to(&self, point: Point) -> std::result::Result<(), JsValue>;
                    fn get_nearest_point(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    fn interpolate(
                        &self,
                        from: PathItem,
                        to: PathItem,
                        factor: f64,
                    ) -> std::result::Result<(), JsValue>;
                    fn get_crossings(
                        &self,
                        path: PathItem,
                    ) -> std::result::Result<Vec<CurveLocation>, JsValue>;
                    fn curve_by(
                        &self,
                        through: Point,
                        to: Point,
                        time: f64,
                    ) -> std::result::Result<(), JsValue>;
                    fn curve_to(
                        &self,
                        through: Point,
                        to: Point,
                        time: f64,
                    ) -> std::result::Result<(), JsValue>;
                    fn subtract(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue>;
                    fn get_intersections(
                        &self,
                        path: PathItem,
                        include: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Vec<CurveLocation>, JsValue>;
                    fn exclude(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue>;
                    fn set_clockwise(&mut self, value: bool) -> std::result::Result<(), JsValue>;
                    fn clockwise(&self) -> std::result::Result<bool, JsValue>;
                }
                impl Item_Trait for PathItem {
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::responds(&target, type_)
                    }
                    fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_content(&target, source)
                    }
                    fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_opacity(&target, value)
                    }
                    fn opacity(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::opacity(&target)
                    }
                    fn set_on_frame(
                        &mut self,
                        value: ItemOnFrame,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_frame(&target, value)
                    }
                    fn on_frame(&self) -> std::result::Result<ItemOnFrame, JsValue> {
                        let target: Item = self.into();
                        Item::on_frame(&target)
                    }
                    fn remove_children_FnToVecOfItem(
                        &self,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::remove_children_FnToVecOfItem(&target)
                    }
                    fn remove_children_FnF64AndF64ToVecOfItem(
                        &self,
                        start: f64,
                        end: f64,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::remove_children_FnF64AndF64ToVecOfItem(&target, start, end)
                    }
                    fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_below(&target, item)
                    }
                    fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_stroke(&target)
                    }
                    fn set_global_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_global_matrix(&target, value)
                    }
                    fn global_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::global_matrix(&target)
                    }
                    fn copy_attributes(
                        &self,
                        source: Item,
                        exclude_matrix: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_attributes(&target, source, exclude_matrix)
                    }
                    fn set_on_mouse_move(
                        &mut self,
                        value: ItemOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_move(&target, value)
                    }
                    fn on_mouse_move(&self) -> std::result::Result<ItemOnMouseMove, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_move(&target)
                    }
                    fn set_position(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_position(&target, value)
                    }
                    fn position(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::position(&target)
                    }
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_bounds(&target, value)
                    }
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::bounds(&target)
                    }
                    fn set_shadow_blur(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_shadow_blur(&target, value)
                    }
                    fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_blur(&target)
                    }
                    fn set_selected_color(
                        &mut self,
                        value: ItemSelectedColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_selected_color(&target, value)
                    }
                    fn selected_color(&self) -> std::result::Result<ItemSelectedColor, JsValue> {
                        let target: Item = self.into();
                        Item::selected_color(&target)
                    }
                    fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::reverse_children(&target)
                    }
                    fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::bring_to_front(&target)
                    }
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_selected(&target, value)
                    }
                    fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::selected(&target)
                    }
                    fn add_children(
                        &self,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::add_children(&target, items)
                    }
                    fn tween_to(
                        &self,
                        to: JsValue,
                        options: ItemTweenToParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_to(&target, to, options)
                    }
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_project(&target, value)
                    }
                    fn project(&self) -> std::result::Result<Project, JsValue> {
                        let target: Item = self.into();
                        Item::project(&target)
                    }
                    fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_name(&target, value)
                    }
                    fn name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::name(&target)
                    }
                    fn set_stroke_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_bounds(&target, value)
                    }
                    fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_bounds(&target)
                    }
                    fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_below(&target, item)
                    }
                    fn set_blend_mode(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_blend_mode(&target, value)
                    }
                    fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::blend_mode(&target)
                    }
                    fn set_clip_mask(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_clip_mask(&target, value)
                    }
                    fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::clip_mask(&target)
                    }
                    fn set_fill_color(
                        &mut self,
                        value: ItemFillColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_fill_color(&target, value)
                    }
                    fn fill_color(&self) -> std::result::Result<ItemFillColor, JsValue> {
                        let target: Item = self.into();
                        Item::fill_color(&target)
                    }
                    fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_drag(&target)
                    }
                    fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::add_child(&target, item)
                    }
                    fn scale_FnF64AndPointTo(
                        &self,
                        scale: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::scale_FnF64AndPointTo(&target, scale, center)
                    }
                    fn scale_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::scale_FnF64AndF64AndPointTo(&target, hor, ver, center)
                    }
                    fn set_first_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_first_child(&target, value)
                    }
                    fn first_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::first_child(&target)
                    }
                    fn set_style(&mut self, value: Style) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_style(&target, value)
                    }
                    fn style(&self) -> std::result::Result<Style, JsValue> {
                        let target: Item = self.into();
                        Item::style(&target)
                    }
                    fn set_class_name(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_class_name(&target, value)
                    }
                    fn class_name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::class_name(&target)
                    }
                    fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_grouped_with(&target, item)
                    }
                    fn set_shadow_offset(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_shadow_offset(&target, value)
                    }
                    fn shadow_offset(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_offset(&target)
                    }
                    fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inside(&target, rect)
                    }
                    fn set_children(
                        &mut self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_children(&target, value)
                    }
                    fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::children(&target)
                    }
                    fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_fill(&target)
                    }
                    fn matches_FnItemMatchesParamsOptionsToBool(
                        &self,
                        options: ItemMatchesParamsOptions,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::matches_FnItemMatchesParamsOptionsToBool(&target, options)
                    }
                    fn matches_FnStringAndJsValueToBool(
                        &self,
                        name: String,
                        compare: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::matches_FnStringAndJsValueToBool(&target, name, compare)
                    }
                    fn set_on_double_click(
                        &mut self,
                        value: ItemOnDoubleClick,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_double_click(&target, value)
                    }
                    fn on_double_click(&self) -> std::result::Result<ItemOnDoubleClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_double_click(&target)
                    }
                    fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::intersects(&target, item)
                    }
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_rotation(&target, value)
                    }
                    fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::rotation(&target)
                    }
                    fn set_on_mouse_down(
                        &mut self,
                        value: ItemOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_down(&target, value)
                    }
                    fn on_mouse_down(&self) -> std::result::Result<ItemOnMouseDown, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_down(&target)
                    }
                    fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_sibling(&target, item)
                    }
                    fn tween_from(
                        &self,
                        from: JsValue,
                        options: ItemTweenFromParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_from(&target, from, options)
                    }
                    fn set_layer(&mut self, value: Layer) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_layer(&target, value)
                    }
                    fn layer(&self) -> std::result::Result<Layer, JsValue> {
                        let target: Item = self.into();
                        Item::layer(&target)
                    }
                    fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::contains(&target, point)
                    }
                    fn set_on_click(
                        &mut self,
                        value: ItemOnClick,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_click(&target, value)
                    }
                    fn on_click(&self) -> std::result::Result<ItemOnClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_click(&target)
                    }
                    fn set_last_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_last_child(&target, value)
                    }
                    fn last_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::last_child(&target)
                    }
                    fn set_dash_offset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_dash_offset(&target, value)
                    }
                    fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::dash_offset(&target)
                    }
                    fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_id(&target, value)
                    }
                    fn id(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::id(&target)
                    }
                    fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_shadow(&target)
                    }
                    fn tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                        &self,
                        from: JsValue,
                        to: JsValue,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                            &target, from, to, options,
                        )
                    }
                    fn tween_FnJsValueAndItemTweenParamsOptionsToTween(
                        &self,
                        to: JsValue,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_FnJsValueAndItemTweenParamsOptionsToTween(&target, to, options)
                    }
                    fn tween_FnItemTweenParamsOptionsToTween(
                        &self,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_FnItemTweenParamsOptionsToTween(&target, options)
                    }
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_scaling(&target, value)
                    }
                    fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::scaling(&target)
                    }
                    fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::send_to_back(&target)
                    }
                    fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::set(&target, props)
                    }
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_index(&target, value)
                    }
                    fn index(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::index(&target)
                    }
                    fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::reduce(&target, options)
                    }
                    fn set_pivot(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_pivot(&target, value)
                    }
                    fn pivot(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::pivot(&target)
                    }
                    fn insert_children(
                        &self,
                        index: f64,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::insert_children(&target, index, items)
                    }
                    fn set_on_mouse_up(
                        &mut self,
                        value: ItemOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_up(&target, value)
                    }
                    fn on_mouse_up(&self) -> std::result::Result<ItemOnMouseUp, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_up(&target)
                    }
                    fn set_stroke_width(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_width(&target, value)
                    }
                    fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_width(&target)
                    }
                    fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on(&target, options)
                    }
                    fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_up(&target)
                    }
                    fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_child(&target, item)
                    }
                    fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::replace_with(&target, item)
                    }
                    fn export_json(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::export_json(&target, options)
                    }
                    fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test_all(&target, point, options)
                    }
                    fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                        let target: Item = self.into();
                        Item::export_svg(&target, options)
                    }
                    fn copy_to(
                        &self,
                        owner: ItemCopyToParamsOwner,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::copy_to(&target, owner)
                    }
                    fn set_matrix(&mut self, value: Matrix) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_matrix(&target, value)
                    }
                    fn matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::matrix(&target)
                    }
                    fn add_to(
                        &self,
                        owner: ItemAddToParamsOwner,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::add_to(&target, owner)
                    }
                    fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::rotate(&target, angle, center)
                    }
                    fn set_view_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_view_matrix(&target, value)
                    }
                    fn view_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::view_matrix(&target)
                    }
                    fn set_previous_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_previous_sibling(&target, value)
                    }
                    fn previous_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::previous_sibling(&target)
                    }
                    fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_data(&target, value)
                    }
                    fn data(&self) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::data(&target)
                    }
                    fn off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item :: off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                    }
                    fn off_FnJsValueToJsValue(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::off_FnJsValueToJsValue(&target, object)
                    }
                    fn set_stroke_scaling(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_scaling(&target, value)
                    }
                    fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_scaling(&target)
                    }
                    fn insert_child(
                        &self,
                        index: f64,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_child(&target, index, item)
                    }
                    fn skew_FnPointAndPointTo(
                        &self,
                        skew: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::skew_FnPointAndPointTo(&target, skew, center)
                    }
                    fn skew_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::skew_FnF64AndF64AndPointTo(&target, hor, ver, center)
                    }
                    fn on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item :: on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                    }
                    fn on_FnJsValueToJsValue(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::on_FnJsValueToJsValue(&target, object)
                    }
                    fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::remove(&target)
                    }
                    fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::global_to_local(&target, point)
                    }
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::emit(&target, type_, event)
                    }
                    fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test(&target, point, options)
                    }
                    fn import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                        &self,
                        svg: ItemImportSvgParamsSvg,
                        options: JsValue,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                            &target, svg, options,
                        )
                    }
                    fn import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem(
                        &self,
                        svg: ItemImportSvgParamsSvg,
                        on_load: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item :: import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem (& target , svg , on_load)
                    }
                    fn set_dash_array(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_dash_array(&target, value)
                    }
                    fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let target: Item = self.into();
                        Item::dash_array(&target)
                    }
                    fn shear_FnPointAndPointTo(
                        &self,
                        shear: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::shear_FnPointAndPointTo(&target, shear, center)
                    }
                    fn shear_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::shear_FnF64AndF64AndPointTo(&target, hor, ver, center)
                    }
                    fn set_internal_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_internal_bounds(&target, value)
                    }
                    fn internal_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::internal_bounds(&target)
                    }
                    fn set_stroke_cap(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_cap(&target, value)
                    }
                    fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_cap(&target)
                    }
                    fn set_on_mouse_enter(
                        &mut self,
                        value: ItemOnMouseEnter,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_enter(&target, value)
                    }
                    fn on_mouse_enter(&self) -> std::result::Result<ItemOnMouseEnter, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_enter(&target)
                    }
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_view(&target, value)
                    }
                    fn view(&self) -> std::result::Result<View, JsValue> {
                        let target: Item = self.into();
                        Item::view(&target)
                    }
                    fn set_stroke_join(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_join(&target, value)
                    }
                    fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_join(&target)
                    }
                    fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_ancestor(&target, item)
                    }
                    fn set_fill_rule(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_fill_rule(&target, value)
                    }
                    fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::fill_rule(&target)
                    }
                    fn fit_bounds(
                        &self,
                        rectangle: Rectangle,
                        fill: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::fit_bounds(&target, rectangle, fill)
                    }
                    fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_parent(&target, point)
                    }
                    fn set_handle_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_handle_bounds(&target, value)
                    }
                    fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::handle_bounds(&target)
                    }
                    fn set_next_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_next_sibling(&target, value)
                    }
                    fn next_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::next_sibling(&target)
                    }
                    fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::clone(&target, options)
                    }
                    fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_descendant(&target, item)
                    }
                    fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_down(&target)
                    }
                    fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_parent(&target, item)
                    }
                    fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_move(&target)
                    }
                    fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_empty(&target, recursively)
                    }
                    fn rasterize(&self, options: JsValue) -> std::result::Result<Raster, JsValue> {
                        let target: Item = self.into();
                        Item::rasterize(&target, options)
                    }
                    fn set_shadow_color(
                        &mut self,
                        value: ItemShadowColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_shadow_color(&target, value)
                    }
                    fn shadow_color(&self) -> std::result::Result<ItemShadowColor, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_color(&target)
                    }
                    fn set_miter_limit(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_miter_limit(&target, value)
                    }
                    fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::miter_limit(&target)
                    }
                    fn get_item(
                        &self,
                        options: ItemGetItemParamsOptions,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::get_item(&target, options)
                    }
                    fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_json(&target, json)
                    }
                    fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_above(&target, item)
                    }
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ItemOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_drag(&target, value)
                    }
                    fn on_mouse_drag(&self) -> std::result::Result<ItemOnMouseDrag, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_drag(&target)
                    }
                    fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inserted(&target)
                    }
                    fn set_apply_matrix(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_apply_matrix(&target, value)
                    }
                    fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::apply_matrix(&target)
                    }
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::transform(&target, matrix)
                    }
                    fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_visible(&target, value)
                    }
                    fn visible(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::visible(&target)
                    }
                    fn set_stroke_color(
                        &mut self,
                        value: ItemStrokeColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_color(&target, value)
                    }
                    fn stroke_color(&self) -> std::result::Result<ItemStrokeColor, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_color(&target)
                    }
                    fn set_on_mouse_leave(
                        &mut self,
                        value: ItemOnMouseLeave,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_leave(&target, value)
                    }
                    fn on_mouse_leave(&self) -> std::result::Result<ItemOnMouseLeave, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_leave(&target)
                    }
                    fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::parent_to_local(&target, point)
                    }
                    fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_above(&target, item)
                    }
                    fn get_items(
                        &self,
                        options: ItemGetItemsParamsOptions,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::get_items(&target, options)
                    }
                    fn has_children(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_children(&target)
                    }
                    fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::translate(&target, delta)
                    }
                    fn set_parent(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_parent(&target, value)
                    }
                    fn parent(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::parent(&target)
                    }
                    fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_locked(&target, value)
                    }
                    fn locked(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::locked(&target)
                    }
                    fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_global(&target, point)
                    }
                }
                impl PathItem_Trait for PathItem
                where
                    PathItem: Item_Trait,
                {
                    fn unite(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target = self;
                        PathItem::unite(target, path, options)
                    }
                    fn line_by(&self, point: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::line_by(target, point)
                    }
                    fn move_to(&self, point: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::move_to(target, point)
                    }
                    fn set_path_data(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::set_path_data(target, value)
                    }
                    fn path_data(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        PathItem::path_data(target)
                    }
                    fn intersect(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target = self;
                        PathItem::intersect(target, path, options)
                    }
                    fn create_FnStringToPathItemCreateReturn(
                        &self,
                        path_data: String,
                    ) -> std::result::Result<PathItemCreateReturn, JsValue> {
                        let target = self;
                        PathItem::create_FnStringToPathItemCreateReturn(target, path_data)
                    }
                    fn create_FnVecOfVecOfF64ToPathItemCreateReturn(
                        &self,
                        segments: Vec<Vec<f64>>,
                    ) -> std::result::Result<PathItemCreateReturn, JsValue> {
                        let target = self;
                        PathItem::create_FnVecOfVecOfF64ToPathItemCreateReturn(target, segments)
                    }
                    fn create_FnJsValueToPathItemCreateReturn(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<PathItemCreateReturn, JsValue> {
                        let target = self;
                        PathItem::create_FnJsValueToPathItemCreateReturn(target, object)
                    }
                    fn smooth(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::smooth(target, options)
                    }
                    fn compare(&self, path: PathItem) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        PathItem::compare(target, path)
                    }
                    fn arc_to_FnPointAndPointTo(
                        &self,
                        through: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::arc_to_FnPointAndPointTo(target, through, to)
                    }
                    fn arc_to_FnPointAndBoolTo(
                        &self,
                        to: Point,
                        clockwise: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::arc_to_FnPointAndBoolTo(target, to, clockwise)
                    }
                    fn quadratic_curve_to(
                        &self,
                        handle: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::quadratic_curve_to(target, handle, to)
                    }
                    fn set_interior_point(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::set_interior_point(target, value)
                    }
                    fn interior_point(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        PathItem::interior_point(target)
                    }
                    fn simplify(&self, tolerance: f64) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        PathItem::simplify(target, tolerance)
                    }
                    fn reorient(
                        &self,
                        non_zero: bool,
                        clockwise: bool,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target = self;
                        PathItem::reorient(target, non_zero, clockwise)
                    }
                    fn cubic_curve_by(
                        &self,
                        handle1: Point,
                        handle2: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::cubic_curve_by(target, handle1, handle2, to)
                    }
                    fn close_path(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::close_path(target)
                    }
                    fn flatten(&self, flatness: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::flatten(target, flatness)
                    }
                    fn quadratic_curve_by(
                        &self,
                        handle: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::quadratic_curve_by(target, handle, to)
                    }
                    fn cubic_curve_to(
                        &self,
                        handle1: Point,
                        handle2: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::cubic_curve_to(target, handle1, handle2, to)
                    }
                    fn divide(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target = self;
                        PathItem::divide(target, path, options)
                    }
                    fn arc_by_FnPointAndPointTo(
                        &self,
                        through: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::arc_by_FnPointAndPointTo(target, through, to)
                    }
                    fn arc_by_FnPointAndBoolTo(
                        &self,
                        to: Point,
                        clockwise: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::arc_by_FnPointAndBoolTo(target, to, clockwise)
                    }
                    fn move_by(&self, to: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::move_by(target, to)
                    }
                    fn get_nearest_location(
                        &self,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let target = self;
                        PathItem::get_nearest_location(target, point)
                    }
                    fn reverse(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::reverse(target)
                    }
                    fn line_to(&self, point: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::line_to(target, point)
                    }
                    fn get_nearest_point(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        PathItem::get_nearest_point(target, point)
                    }
                    fn interpolate(
                        &self,
                        from: PathItem,
                        to: PathItem,
                        factor: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::interpolate(target, from, to, factor)
                    }
                    fn get_crossings(
                        &self,
                        path: PathItem,
                    ) -> std::result::Result<Vec<CurveLocation>, JsValue> {
                        let target = self;
                        PathItem::get_crossings(target, path)
                    }
                    fn curve_by(
                        &self,
                        through: Point,
                        to: Point,
                        time: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::curve_by(target, through, to, time)
                    }
                    fn curve_to(
                        &self,
                        through: Point,
                        to: Point,
                        time: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::curve_to(target, through, to, time)
                    }
                    fn subtract(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target = self;
                        PathItem::subtract(target, path, options)
                    }
                    fn get_intersections(
                        &self,
                        path: PathItem,
                        include: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Vec<CurveLocation>, JsValue> {
                        let target = self;
                        PathItem::get_intersections(target, path, include)
                    }
                    fn exclude(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target = self;
                        PathItem::exclude(target, path, options)
                    }
                    fn set_clockwise(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PathItem::set_clockwise(target, value)
                    }
                    fn clockwise(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        PathItem::clockwise(target)
                    }
                }
                impl std::clone::Clone for PathItem_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for PathItem_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for PathItem_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum SizeDivideReturn {
                    Size(Size),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemImportSvgParamsSvg {
                    String(String),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    WebSysSvgElement(web_sys::SvgElement),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum RectangleContainsReturn {
                    Bool(bool),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum MatrixSkewParamsSkew {
                    Point(Point),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemTweenFromParamsOptions {
                    F64(f64),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    JsValue(JsValue),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemOnFrame {
                    TsBindgenRtNull,
                    #[serde(
                        serialize_with = "ItemOnFrame::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ItemOnFrame::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                }
                impl ItemOnFrame {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemExportSvgReturn {
                    String(String),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    WebSysSvgElement(web_sys::SvgElement),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemShearParamsCenter {
                    Point(Point),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewShearParamsCenter {
                    Point(Point),
                    F64(f64),
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    #[wasm_bindgen(js_name = "Segment")]
                    pub type Segment_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clone , method , js_class = "Segment" , catch)]
                    fn __TSB_clone_FnToSegment(
                        this: &Segment_Class,
                    ) -> std::result::Result<Segment, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = reversed , method , js_class = "Segment" , catch)]
                    fn __TSB_reversed_FnToSegment(
                        this: &Segment_Class,
                    ) -> std::result::Result<Segment, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isLast , method , js_class = "Segment" , catch)]
                    fn __TSB_is_last_FnToBool(
                        this: &Segment_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = hasHandles , method , js_class = "Segment" , catch)]
                    fn __TSB_has_handles_FnToBool(
                        this: &Segment_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = interpolate , method , js_class = "Segment" , catch)]
                    fn __TSB_interpolate_FnSegmentAndSegmentAndF64To(
                        this: &Segment_Class,
                        from: Segment,
                        to: Segment,
                        factor: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = remove , method , js_class = "Segment" , catch)]
                    fn __TSB_remove_FnToBool(
                        this: &Segment_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = toString , method , js_class = "Segment" , catch)]
                    fn __TSB_to_string_FnToString(
                        this: &Segment_Class,
                    ) -> std::result::Result<String, JsValue>;
                    #[wasm_bindgen(constructor, js_class = "Segment")]
                    pub fn new_FnPointAndPointAndPointToSegment(
                        point: Point,
                        handle_in: Point,
                        handle_out: Point,
                    ) -> Segment_Class;
                    #[wasm_bindgen(constructor, js_class = "Segment")]
                    pub fn new_FnJsValueToSegment(object: JsValue) -> Segment_Class;
                    # [wasm_bindgen (method , structural , catch , getter = point , js_class = "Segment")]
                    fn point(this: &Segment_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = point , js_class = "Segment")]
                    fn set_point(
                        this: &Segment_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clearHandles , method , js_class = "Segment" , catch)]
                    fn __TSB_clear_handles_FnTo(
                        this: &Segment_Class,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = previous , js_class = "Segment")]
                    fn previous(this: &Segment_Class) -> std::result::Result<Segment, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = previous , js_class = "Segment")]
                    fn set_previous(
                        this: &Segment_Class,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = index , js_class = "Segment")]
                    fn index(this: &Segment_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = index , js_class = "Segment")]
                    fn set_index(
                        this: &Segment_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isFirst , method , js_class = "Segment" , catch)]
                    fn __TSB_is_first_FnToBool(
                        this: &Segment_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = curve , js_class = "Segment")]
                    fn curve(this: &Segment_Class) -> std::result::Result<Curve, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = curve , js_class = "Segment")]
                    fn set_curve(
                        this: &Segment_Class,
                        value: Curve,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = handleOut , js_class = "Segment")]
                    fn handle_out(this: &Segment_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = handleOut , js_class = "Segment")]
                    fn set_handle_out(
                        this: &Segment_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = reverse , method , js_class = "Segment" , catch)]
                    fn __TSB_reverse_FnToSegment(
                        this: &Segment_Class,
                    ) -> std::result::Result<Segment, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = selected , js_class = "Segment")]
                    fn selected(this: &Segment_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = selected , js_class = "Segment")]
                    fn set_selected(
                        this: &Segment_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = path , js_class = "Segment")]
                    fn path(this: &Segment_Class) -> std::result::Result<Path, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = path , js_class = "Segment")]
                    fn set_path(
                        this: &Segment_Class,
                        value: Path,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = next , js_class = "Segment")]
                    fn next(this: &Segment_Class) -> std::result::Result<Segment, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = next , js_class = "Segment")]
                    fn set_next(
                        this: &Segment_Class,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = handleIn , js_class = "Segment")]
                    fn handle_in(this: &Segment_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = handleIn , js_class = "Segment")]
                    fn set_handle_in(
                        this: &Segment_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = location , js_class = "Segment")]
                    fn location(
                        this: &Segment_Class,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = location , js_class = "Segment")]
                    fn set_location(
                        this: &Segment_Class,
                        value: CurveLocation,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isSmooth , method , js_class = "Segment" , catch)]
                    fn __TSB_is_smooth_FnToBool(
                        this: &Segment_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = transform , method , js_class = "Segment" , catch)]
                    fn __TSB_transform_FnMatrixTo(
                        this: &Segment_Class,
                        matrix: Matrix,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = smooth , method , js_class = "Segment" , catch)]
                    fn __TSB_smooth_FnJsValueTo(
                        this: &Segment_Class,
                        options: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Segment(pub Segment_Class);
                impl std::convert::From<Segment> for JsValue {
                    fn from(src: Segment) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for Segment {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for Segment {
                    fn instanceof(val: &JsValue) -> bool {
                        Segment_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        Segment(Segment_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(Segment_Class::unchecked_from_js_ref(val) as *const Segment_Class
                                as *const Self)
                        }
                    }
                }
                impl Segment {
                    #[allow(dead_code, non_snake_case)]
                    pub fn clone(&self) -> std::result::Result<Segment, JsValue> {
                        let result = self.0.__TSB_clone_FnToSegment();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn reversed(&self) -> std::result::Result<Segment, JsValue> {
                        let result = self.0.__TSB_reversed_FnToSegment();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_last(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_last_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_has_handles_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn interpolate(
                        &self,
                        from: Segment,
                        to: Segment,
                        factor: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self
                            .0
                            .__TSB_interpolate_FnSegmentAndSegmentAndF64To(from, to, factor);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_remove_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.__TSB_to_string_FnToString();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnPointAndPointAndPointToSegment(
                        point: Point,
                        handle_in: Point,
                        handle_out: Point,
                    ) -> Segment {
                        let result = Segment_Class::new_FnPointAndPointAndPointToSegment(
                            point, handle_in, handle_out,
                        );
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Segment(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnJsValueToSegment(object: JsValue) -> Segment {
                        let result = Segment_Class::new_FnJsValueToSegment(object);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Segment(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn point(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.point();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_point(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_point(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_clear_handles_FnTo();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn previous(&self) -> std::result::Result<Segment, JsValue> {
                        let result = self.0.previous();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_previous(&self, value: Segment) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_previous(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn index(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.index();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_index(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_index(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_first(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_first_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn curve(&self) -> std::result::Result<Curve, JsValue> {
                        let result = self.0.curve();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_curve(&self, value: Curve) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_curve(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn handle_out(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.handle_out();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_handle_out(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_handle_out(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn reverse(&self) -> std::result::Result<Segment, JsValue> {
                        let result = self.0.__TSB_reverse_FnToSegment();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.selected();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_selected(&self, value: bool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_selected(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn path(&self) -> std::result::Result<Path, JsValue> {
                        let result = self.0.path();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_path(&self, value: Path) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_path(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn next(&self) -> std::result::Result<Segment, JsValue> {
                        let result = self.0.next();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_next(&self, value: Segment) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_next(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn handle_in(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.handle_in();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_handle_in(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_handle_in(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn location(&self) -> std::result::Result<CurveLocation, JsValue> {
                        let result = self.0.location();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_location(
                        &self,
                        value: CurveLocation,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_location(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_smooth(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_smooth_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_transform_FnMatrixTo(matrix);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn smooth(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_smooth_FnJsValueTo(options);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Segment {
                    fn describe() {
                        <Segment_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Segment {
                    type Abi = <Segment_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Segment {
                    type Abi = <Segment_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Segment(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Segment {
                    type Abi = <&'a Segment_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Segment {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Segment {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Segment_Class =
                            <Segment_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait Segment_Trait {
                    fn clone(&self) -> std::result::Result<Segment, JsValue>;
                    fn reversed(&self) -> std::result::Result<Segment, JsValue>;
                    fn is_last(&self) -> std::result::Result<bool, JsValue>;
                    fn has_handles(&self) -> std::result::Result<bool, JsValue>;
                    fn interpolate(
                        &self,
                        from: Segment,
                        to: Segment,
                        factor: f64,
                    ) -> std::result::Result<(), JsValue>;
                    fn remove(&self) -> std::result::Result<bool, JsValue>;
                    fn to_string(&self) -> std::result::Result<String, JsValue>;
                    fn set_point(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn point(&self) -> std::result::Result<Point, JsValue>;
                    fn clear_handles(&self) -> std::result::Result<(), JsValue>;
                    fn set_previous(&mut self, value: Segment) -> std::result::Result<(), JsValue>;
                    fn previous(&self) -> std::result::Result<Segment, JsValue>;
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn index(&self) -> std::result::Result<f64, JsValue>;
                    fn is_first(&self) -> std::result::Result<bool, JsValue>;
                    fn set_curve(&mut self, value: Curve) -> std::result::Result<(), JsValue>;
                    fn curve(&self) -> std::result::Result<Curve, JsValue>;
                    fn set_handle_out(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn handle_out(&self) -> std::result::Result<Point, JsValue>;
                    fn reverse(&self) -> std::result::Result<Segment, JsValue>;
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue>;
                    fn selected(&self) -> std::result::Result<bool, JsValue>;
                    fn set_path(&mut self, value: Path) -> std::result::Result<(), JsValue>;
                    fn path(&self) -> std::result::Result<Path, JsValue>;
                    fn set_next(&mut self, value: Segment) -> std::result::Result<(), JsValue>;
                    fn next(&self) -> std::result::Result<Segment, JsValue>;
                    fn set_handle_in(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn handle_in(&self) -> std::result::Result<Point, JsValue>;
                    fn set_location(
                        &mut self,
                        value: CurveLocation,
                    ) -> std::result::Result<(), JsValue>;
                    fn location(&self) -> std::result::Result<CurveLocation, JsValue>;
                    fn is_smooth(&self) -> std::result::Result<bool, JsValue>;
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue>;
                    fn smooth(&self, options: JsValue) -> std::result::Result<(), JsValue>;
                }
                impl Segment_Trait for Segment {
                    fn clone(&self) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        Segment::clone(target)
                    }
                    fn reversed(&self) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        Segment::reversed(target)
                    }
                    fn is_last(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Segment::is_last(target)
                    }
                    fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Segment::has_handles(target)
                    }
                    fn interpolate(
                        &self,
                        from: Segment,
                        to: Segment,
                        factor: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Segment::interpolate(target, from, to, factor)
                    }
                    fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Segment::remove(target)
                    }
                    fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Segment::to_string(target)
                    }
                    fn set_point(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Segment::set_point(target, value)
                    }
                    fn point(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Segment::point(target)
                    }
                    fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Segment::clear_handles(target)
                    }
                    fn set_previous(&mut self, value: Segment) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Segment::set_previous(target, value)
                    }
                    fn previous(&self) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        Segment::previous(target)
                    }
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Segment::set_index(target, value)
                    }
                    fn index(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Segment::index(target)
                    }
                    fn is_first(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Segment::is_first(target)
                    }
                    fn set_curve(&mut self, value: Curve) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Segment::set_curve(target, value)
                    }
                    fn curve(&self) -> std::result::Result<Curve, JsValue> {
                        let target = self;
                        Segment::curve(target)
                    }
                    fn set_handle_out(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Segment::set_handle_out(target, value)
                    }
                    fn handle_out(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Segment::handle_out(target)
                    }
                    fn reverse(&self) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        Segment::reverse(target)
                    }
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Segment::set_selected(target, value)
                    }
                    fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Segment::selected(target)
                    }
                    fn set_path(&mut self, value: Path) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Segment::set_path(target, value)
                    }
                    fn path(&self) -> std::result::Result<Path, JsValue> {
                        let target = self;
                        Segment::path(target)
                    }
                    fn set_next(&mut self, value: Segment) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Segment::set_next(target, value)
                    }
                    fn next(&self) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        Segment::next(target)
                    }
                    fn set_handle_in(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Segment::set_handle_in(target, value)
                    }
                    fn handle_in(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Segment::handle_in(target)
                    }
                    fn set_location(
                        &mut self,
                        value: CurveLocation,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Segment::set_location(target, value)
                    }
                    fn location(&self) -> std::result::Result<CurveLocation, JsValue> {
                        let target = self;
                        Segment::location(target)
                    }
                    fn is_smooth(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Segment::is_smooth(target)
                    }
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Segment::transform(target, matrix)
                    }
                    fn smooth(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Segment::smooth(target, options)
                    }
                }
                impl std::clone::Clone for Segment_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Segment_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Segment_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewShearReturn {
                    __,
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ToolOffParamsType {
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    JsValue(JsValue),
                    String(String),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewOnMouseLeave {
                    TsBindgenRtNull,
                    #[serde(
                        serialize_with = "ViewOnMouseLeave::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ViewOnMouseLeave::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                }
                impl ViewOnMouseLeave {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemStrokeColor {
                    Color(Color),
                    TsBindgenRtNull,
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemGetItemParamsOptions {
                    #[serde(
                        serialize_with = "ItemGetItemParamsOptions::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ItemGetItemParamsOptions::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    JsValue(JsValue),
                }
                impl ItemGetItemParamsOptions {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    #[wasm_bindgen(js_name = "Color")]
                    pub type Color_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = transform , method , js_class = "Color" , catch)]
                    fn __TSB_transform_FnMatrixTo(
                        this: &Color_Class,
                        matrix: Matrix,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = alpha , js_class = "Color")]
                    fn alpha(this: &Color_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = alpha , js_class = "Color")]
                    fn set_alpha(
                        this: &Color_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = divide , method , js_class = "Color" , catch)]
                    fn __TSB_divide_FnF64ToColor(
                        this: &Color_Class,
                        number: f64,
                    ) -> std::result::Result<Color, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = divide , method , js_class = "Color" , catch)]
                    fn __TSB_divide_FnColorToColor(
                        this: &Color_Class,
                        color: Color,
                    ) -> std::result::Result<Color, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clone , method , js_class = "Color" , catch)]
                    fn __TSB_clone_FnToColor(
                        this: &Color_Class,
                    ) -> std::result::Result<Color, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = type , js_class = "Color")]
                    fn type_(this: &Color_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = type , js_class = "Color")]
                    fn set_type_(
                        this: &Color_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = add , method , js_class = "Color" , catch)]
                    fn __TSB_add_FnF64ToColor(
                        this: &Color_Class,
                        number: f64,
                    ) -> std::result::Result<Color, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = add , method , js_class = "Color" , catch)]
                    fn __TSB_add_FnColorToColor(
                        this: &Color_Class,
                        color: Color,
                    ) -> std::result::Result<Color, JsValue>;
                    #[wasm_bindgen(constructor, js_class = "Color")]
                    pub fn new_FnF64AndF64AndF64AndF64ToColor(
                        red: f64,
                        green: f64,
                        blue: f64,
                        alpha: f64,
                    ) -> Color_Class;
                    #[wasm_bindgen(constructor, js_class = "Color")]
                    pub fn new_FnF64AndF64ToColor(gray: f64, alpha: f64) -> Color_Class;
                    #[wasm_bindgen(constructor, js_class = "Color")]
                    pub fn new_FnStringToColor(color: String) -> Color_Class;
                    #[wasm_bindgen(constructor, js_class = "Color")]
                    pub fn new_FnGradientAndPointAndPointAndPointToColor(
                        gradient: Gradient,
                        origin: Point,
                        destination: Point,
                        highlight: Point,
                    ) -> Color_Class;
                    #[wasm_bindgen(constructor, js_class = "Color")]
                    pub fn new_FnJsValueToColor(object: JsValue) -> Color_Class;
                    # [wasm_bindgen (method , structural , catch , getter = brightness , js_class = "Color")]
                    fn brightness(this: &Color_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = brightness , js_class = "Color")]
                    fn set_brightness(
                        this: &Color_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = components , js_class = "Color")]
                    fn __TSB_components(
                        this: &Color_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = components , js_class = "Color")]
                    fn __TSB_set_components(
                        this: &Color_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = hasAlpha , method , js_class = "Color" , catch)]
                    fn __TSB_has_alpha_FnToBool(
                        this: &Color_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = multiply , method , js_class = "Color" , catch)]
                    fn __TSB_multiply_FnF64ToColor(
                        this: &Color_Class,
                        number: f64,
                    ) -> std::result::Result<Color, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = multiply , method , js_class = "Color" , catch)]
                    fn __TSB_multiply_FnColorToColor(
                        this: &Color_Class,
                        color: Color,
                    ) -> std::result::Result<Color, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = red , js_class = "Color")]
                    fn red(this: &Color_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = red , js_class = "Color")]
                    fn set_red(this: &Color_Class, value: f64) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = gray , js_class = "Color")]
                    fn gray(this: &Color_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = gray , js_class = "Color")]
                    fn set_gray(this: &Color_Class, value: f64)
                        -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = green , js_class = "Color")]
                    fn green(this: &Color_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = green , js_class = "Color")]
                    fn set_green(
                        this: &Color_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = subtract , method , js_class = "Color" , catch)]
                    fn __TSB_subtract_FnF64ToColor(
                        this: &Color_Class,
                        number: f64,
                    ) -> std::result::Result<Color, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = subtract , method , js_class = "Color" , catch)]
                    fn __TSB_subtract_FnColorToColor(
                        this: &Color_Class,
                        color: Color,
                    ) -> std::result::Result<Color, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = gradient , js_class = "Color")]
                    fn gradient(this: &Color_Class) -> std::result::Result<Gradient, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = gradient , js_class = "Color")]
                    fn set_gradient(
                        this: &Color_Class,
                        value: Gradient,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = lightness , js_class = "Color")]
                    fn lightness(this: &Color_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = lightness , js_class = "Color")]
                    fn set_lightness(
                        this: &Color_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = set , method , js_class = "Color" , catch , variadic)]
                    fn __TSB_set_FnVecOfJsValueToColor(
                        this: &Color_Class,
                        values: Box<[JsValue]>,
                    ) -> std::result::Result<Color, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = random , method , js_class = "Color" , catch)]
                    fn __TSB_random_FnToColor(
                        this: &Color_Class,
                    ) -> std::result::Result<Color, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = hue , js_class = "Color")]
                    fn hue(this: &Color_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = hue , js_class = "Color")]
                    fn set_hue(this: &Color_Class, value: f64) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = convert , method , js_class = "Color" , catch)]
                    fn __TSB_convert_FnStringToColor(
                        this: &Color_Class,
                        type_: String,
                    ) -> std::result::Result<Color, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = saturation , js_class = "Color")]
                    fn saturation(this: &Color_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = saturation , js_class = "Color")]
                    fn set_saturation(
                        this: &Color_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = equals , method , js_class = "Color" , catch)]
                    fn __TSB_equals_FnColorToBool(
                        this: &Color_Class,
                        color: Color,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = toCSS , method , js_class = "Color" , catch)]
                    fn __TSB_to_css_FnBoolToString(
                        this: &Color_Class,
                        hex: bool,
                    ) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = blue , js_class = "Color")]
                    fn blue(this: &Color_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = blue , js_class = "Color")]
                    fn set_blue(this: &Color_Class, value: f64)
                        -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = highlight , js_class = "Color")]
                    fn highlight(this: &Color_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = highlight , js_class = "Color")]
                    fn set_highlight(
                        this: &Color_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = toString , method , js_class = "Color" , catch)]
                    fn __TSB_to_string_FnToString(
                        this: &Color_Class,
                    ) -> std::result::Result<String, JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Color(pub Color_Class);
                impl std::convert::From<Color> for JsValue {
                    fn from(src: Color) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for Color {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for Color {
                    fn instanceof(val: &JsValue) -> bool {
                        Color_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        Color(Color_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(Color_Class::unchecked_from_js_ref(val) as *const Color_Class
                                as *const Self)
                        }
                    }
                }
                impl Color {
                    #[allow(dead_code, non_snake_case)]
                    pub fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_transform_FnMatrixTo(matrix);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn alpha(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.alpha();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_alpha(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_alpha(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn divide_FnF64ToColor(
                        &self,
                        number: f64,
                    ) -> std::result::Result<Color, JsValue> {
                        let result = self.0.__TSB_divide_FnF64ToColor(number);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn divide_FnColorToColor(
                        &self,
                        color: Color,
                    ) -> std::result::Result<Color, JsValue> {
                        let result = self.0.__TSB_divide_FnColorToColor(color);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn clone(&self) -> std::result::Result<Color, JsValue> {
                        let result = self.0.__TSB_clone_FnToColor();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn type_(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.type_();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_type_(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_type_(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn add_FnF64ToColor(
                        &self,
                        number: f64,
                    ) -> std::result::Result<Color, JsValue> {
                        let result = self.0.__TSB_add_FnF64ToColor(number);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn add_FnColorToColor(
                        &self,
                        color: Color,
                    ) -> std::result::Result<Color, JsValue> {
                        let result = self.0.__TSB_add_FnColorToColor(color);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnF64AndF64AndF64AndF64ToColor(
                        red: f64,
                        green: f64,
                        blue: f64,
                        alpha: f64,
                    ) -> Color {
                        let result = Color_Class::new_FnF64AndF64AndF64AndF64ToColor(
                            red, green, blue, alpha,
                        );
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Color(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnF64AndF64ToColor(gray: f64, alpha: f64) -> Color {
                        let result = Color_Class::new_FnF64AndF64ToColor(gray, alpha);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Color(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnStringToColor(color: String) -> Color {
                        let result = Color_Class::new_FnStringToColor(color);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Color(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnGradientAndPointAndPointAndPointToColor(
                        gradient: Gradient,
                        origin: Point,
                        destination: Point,
                        highlight: Point,
                    ) -> Color {
                        let result = Color_Class::new_FnGradientAndPointAndPointAndPointToColor(
                            gradient,
                            origin,
                            destination,
                            highlight,
                        );
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Color(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnJsValueToColor(object: JsValue) -> Color {
                        let result = Color_Class::new_FnJsValueToColor(object);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Color(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn brightness(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.brightness();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_brightness(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_brightness(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn components(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_components()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_components(
                        &self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_components({
                            let value_array = js_sys::Array::new();
                            for value_item in value {
                                value_array.push(&JsValue::from(value_item));
                            }
                            value_array.into()
                        });
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn has_alpha(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_has_alpha_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn multiply_FnF64ToColor(
                        &self,
                        number: f64,
                    ) -> std::result::Result<Color, JsValue> {
                        let result = self.0.__TSB_multiply_FnF64ToColor(number);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn multiply_FnColorToColor(
                        &self,
                        color: Color,
                    ) -> std::result::Result<Color, JsValue> {
                        let result = self.0.__TSB_multiply_FnColorToColor(color);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn red(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.red();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_red(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_red(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn gray(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.gray();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_gray(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_gray(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn green(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.green();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_green(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_green(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn subtract_FnF64ToColor(
                        &self,
                        number: f64,
                    ) -> std::result::Result<Color, JsValue> {
                        let result = self.0.__TSB_subtract_FnF64ToColor(number);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn subtract_FnColorToColor(
                        &self,
                        color: Color,
                    ) -> std::result::Result<Color, JsValue> {
                        let result = self.0.__TSB_subtract_FnColorToColor(color);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn gradient(&self) -> std::result::Result<Gradient, JsValue> {
                        let result = self.0.gradient();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_gradient(
                        &self,
                        value: Gradient,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_gradient(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn lightness(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.lightness();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_lightness(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_lightness(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set(&self, values: Vec<JsValue>) -> std::result::Result<Color, JsValue> {
                        let result = self.0.__TSB_set_FnVecOfJsValueToColor(
                            values
                                .into_iter()
                                .map(|values_item| JsValue::from(values_item))
                                .collect::<Vec<_>>()
                                .into_boxed_slice(),
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn random(&self) -> std::result::Result<Color, JsValue> {
                        let result = self.0.__TSB_random_FnToColor();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn hue(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.hue();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_hue(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_hue(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn convert(&self, type_: String) -> std::result::Result<Color, JsValue> {
                        let result = self.0.__TSB_convert_FnStringToColor(type_);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn saturation(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.saturation();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_saturation(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_saturation(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn equals(&self, color: Color) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_equals_FnColorToBool(color);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn to_css(&self, hex: bool) -> std::result::Result<String, JsValue> {
                        let result = self.0.__TSB_to_css_FnBoolToString(hex);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn blue(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.blue();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_blue(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_blue(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn highlight(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.highlight();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_highlight(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_highlight(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.__TSB_to_string_FnToString();
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Color {
                    fn describe() {
                        <Color_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Color {
                    type Abi = <Color_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Color {
                    type Abi = <Color_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Color(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Color {
                    type Abi = <&'a Color_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Color {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Color {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Color_Class =
                            <Color_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait Color_Trait {
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue>;
                    fn set_alpha(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn alpha(&self) -> std::result::Result<f64, JsValue>;
                    fn divide_FnF64ToColor(
                        &self,
                        number: f64,
                    ) -> std::result::Result<Color, JsValue>;
                    fn divide_FnColorToColor(
                        &self,
                        color: Color,
                    ) -> std::result::Result<Color, JsValue>;
                    fn clone(&self) -> std::result::Result<Color, JsValue>;
                    fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn type_(&self) -> std::result::Result<String, JsValue>;
                    fn add_FnF64ToColor(&self, number: f64) -> std::result::Result<Color, JsValue>;
                    fn add_FnColorToColor(
                        &self,
                        color: Color,
                    ) -> std::result::Result<Color, JsValue>;
                    fn set_brightness(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn brightness(&self) -> std::result::Result<f64, JsValue>;
                    fn set_components(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue>;
                    fn components(&self) -> std::result::Result<Vec<f64>, JsValue>;
                    fn has_alpha(&self) -> std::result::Result<bool, JsValue>;
                    fn multiply_FnF64ToColor(
                        &self,
                        number: f64,
                    ) -> std::result::Result<Color, JsValue>;
                    fn multiply_FnColorToColor(
                        &self,
                        color: Color,
                    ) -> std::result::Result<Color, JsValue>;
                    fn set_red(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn red(&self) -> std::result::Result<f64, JsValue>;
                    fn set_gray(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn gray(&self) -> std::result::Result<f64, JsValue>;
                    fn set_green(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn green(&self) -> std::result::Result<f64, JsValue>;
                    fn subtract_FnF64ToColor(
                        &self,
                        number: f64,
                    ) -> std::result::Result<Color, JsValue>;
                    fn subtract_FnColorToColor(
                        &self,
                        color: Color,
                    ) -> std::result::Result<Color, JsValue>;
                    fn set_gradient(&mut self, value: Gradient)
                        -> std::result::Result<(), JsValue>;
                    fn gradient(&self) -> std::result::Result<Gradient, JsValue>;
                    fn set_lightness(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn lightness(&self) -> std::result::Result<f64, JsValue>;
                    fn set(&self, values: Vec<JsValue>) -> std::result::Result<Color, JsValue>;
                    fn random(&self) -> std::result::Result<Color, JsValue>;
                    fn set_hue(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn hue(&self) -> std::result::Result<f64, JsValue>;
                    fn convert(&self, type_: String) -> std::result::Result<Color, JsValue>;
                    fn set_saturation(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn saturation(&self) -> std::result::Result<f64, JsValue>;
                    fn equals(&self, color: Color) -> std::result::Result<bool, JsValue>;
                    fn to_css(&self, hex: bool) -> std::result::Result<String, JsValue>;
                    fn set_blue(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn blue(&self) -> std::result::Result<f64, JsValue>;
                    fn set_highlight(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn highlight(&self) -> std::result::Result<Point, JsValue>;
                    fn to_string(&self) -> std::result::Result<String, JsValue>;
                }
                impl Color_Trait for Color {
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Color::transform(target, matrix)
                    }
                    fn set_alpha(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Color::set_alpha(target, value)
                    }
                    fn alpha(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Color::alpha(target)
                    }
                    fn divide_FnF64ToColor(
                        &self,
                        number: f64,
                    ) -> std::result::Result<Color, JsValue> {
                        let target = self;
                        Color::divide_FnF64ToColor(target, number)
                    }
                    fn divide_FnColorToColor(
                        &self,
                        color: Color,
                    ) -> std::result::Result<Color, JsValue> {
                        let target = self;
                        Color::divide_FnColorToColor(target, color)
                    }
                    fn clone(&self) -> std::result::Result<Color, JsValue> {
                        let target = self;
                        Color::clone(target)
                    }
                    fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Color::set_type_(target, value)
                    }
                    fn type_(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Color::type_(target)
                    }
                    fn add_FnF64ToColor(&self, number: f64) -> std::result::Result<Color, JsValue> {
                        let target = self;
                        Color::add_FnF64ToColor(target, number)
                    }
                    fn add_FnColorToColor(
                        &self,
                        color: Color,
                    ) -> std::result::Result<Color, JsValue> {
                        let target = self;
                        Color::add_FnColorToColor(target, color)
                    }
                    fn set_brightness(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Color::set_brightness(target, value)
                    }
                    fn brightness(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Color::brightness(target)
                    }
                    fn set_components(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Color::set_components(target, value)
                    }
                    fn components(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let target = self;
                        Color::components(target)
                    }
                    fn has_alpha(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Color::has_alpha(target)
                    }
                    fn multiply_FnF64ToColor(
                        &self,
                        number: f64,
                    ) -> std::result::Result<Color, JsValue> {
                        let target = self;
                        Color::multiply_FnF64ToColor(target, number)
                    }
                    fn multiply_FnColorToColor(
                        &self,
                        color: Color,
                    ) -> std::result::Result<Color, JsValue> {
                        let target = self;
                        Color::multiply_FnColorToColor(target, color)
                    }
                    fn set_red(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Color::set_red(target, value)
                    }
                    fn red(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Color::red(target)
                    }
                    fn set_gray(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Color::set_gray(target, value)
                    }
                    fn gray(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Color::gray(target)
                    }
                    fn set_green(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Color::set_green(target, value)
                    }
                    fn green(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Color::green(target)
                    }
                    fn subtract_FnF64ToColor(
                        &self,
                        number: f64,
                    ) -> std::result::Result<Color, JsValue> {
                        let target = self;
                        Color::subtract_FnF64ToColor(target, number)
                    }
                    fn subtract_FnColorToColor(
                        &self,
                        color: Color,
                    ) -> std::result::Result<Color, JsValue> {
                        let target = self;
                        Color::subtract_FnColorToColor(target, color)
                    }
                    fn set_gradient(
                        &mut self,
                        value: Gradient,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Color::set_gradient(target, value)
                    }
                    fn gradient(&self) -> std::result::Result<Gradient, JsValue> {
                        let target = self;
                        Color::gradient(target)
                    }
                    fn set_lightness(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Color::set_lightness(target, value)
                    }
                    fn lightness(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Color::lightness(target)
                    }
                    fn set(&self, values: Vec<JsValue>) -> std::result::Result<Color, JsValue> {
                        let target = self;
                        Color::set(target, values)
                    }
                    fn random(&self) -> std::result::Result<Color, JsValue> {
                        let target = self;
                        Color::random(target)
                    }
                    fn set_hue(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Color::set_hue(target, value)
                    }
                    fn hue(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Color::hue(target)
                    }
                    fn convert(&self, type_: String) -> std::result::Result<Color, JsValue> {
                        let target = self;
                        Color::convert(target, type_)
                    }
                    fn set_saturation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Color::set_saturation(target, value)
                    }
                    fn saturation(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Color::saturation(target)
                    }
                    fn equals(&self, color: Color) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Color::equals(target, color)
                    }
                    fn to_css(&self, hex: bool) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Color::to_css(target, hex)
                    }
                    fn set_blue(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Color::set_blue(target, value)
                    }
                    fn blue(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Color::blue(target)
                    }
                    fn set_highlight(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Color::set_highlight(target, value)
                    }
                    fn highlight(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Color::highlight(target)
                    }
                    fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Color::to_string(target)
                    }
                }
                impl std::clone::Clone for Color_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Color_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Color_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemGetItemsParamsOptions {
                    #[serde(
                        serialize_with = "ItemGetItemsParamsOptions::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ItemGetItemsParamsOptions::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    JsValue(JsValue),
                }
                impl ItemGetItemsParamsOptions {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PointAddReturn {
                    Point(Point),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum CurveSplitAtParamsLocation {
                    CurveLocation(CurveLocation),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewOnMouseDown {
                    TsBindgenRtNull,
                    #[serde(
                        serialize_with = "ViewOnMouseDown::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ViewOnMouseDown::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                }
                impl ViewOnMouseDown {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    #[wasm_bindgen(js_name = "Point")]
                    pub type Point_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = round , method , js_class = "Point" , catch)]
                    fn __TSB_round_FnToPoint(
                        this: &Point_Class,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = dot , method , js_class = "Point" , catch)]
                    fn __TSB_dot_FnPointToF64(
                        this: &Point_Class,
                        point: Point,
                    ) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = length , js_class = "Point")]
                    fn length(this: &Point_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = length , js_class = "Point")]
                    fn set_length(
                        this: &Point_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = angleInRadians , js_class = "Point")]
                    fn angle_in_radians(this: &Point_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = angleInRadians , js_class = "Point")]
                    fn set_angle_in_radians(
                        this: &Point_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isInside , method , js_class = "Point" , catch)]
                    fn __TSB_is_inside_FnRectangleToBool(
                        this: &Point_Class,
                        rect: Rectangle,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = toString , method , js_class = "Point" , catch)]
                    fn __TSB_to_string_FnToString(
                        this: &Point_Class,
                    ) -> std::result::Result<String, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isOrthogonal , method , js_class = "Point" , catch)]
                    fn __TSB_is_orthogonal_FnPointToBool(
                        this: &Point_Class,
                        point: Point,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = multiply , method , js_class = "Point" , catch)]
                    fn __TSB_multiply_FnF64ToPoint(
                        this: &Point_Class,
                        number: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = multiply , method , js_class = "Point" , catch)]
                    fn __TSB_multiply_FnPointToPoint(
                        this: &Point_Class,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = add , method , js_class = "Point" , catch)]
                    fn __TSB_add_FnF64ToPoint(
                        this: &Point_Class,
                        number: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = add , method , js_class = "Point" , catch)]
                    fn __TSB_add_FnPointToPoint(
                        this: &Point_Class,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = ceil , method , js_class = "Point" , catch)]
                    fn __TSB_ceil_FnToPoint(
                        this: &Point_Class,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = cross , method , js_class = "Point" , catch)]
                    fn __TSB_cross_FnPointToF64(
                        this: &Point_Class,
                        point: Point,
                    ) -> std::result::Result<f64, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = min , method , js_class = "Point" , catch)]
                    fn __TSB_min_FnPointAndPointToPoint(
                        this: &Point_Class,
                        point1: Point,
                        point2: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getDistance , method , js_class = "Point" , catch)]
                    fn __TSB_get_distance_FnPointAndBoolToF64(
                        this: &Point_Class,
                        point: Point,
                        squared: bool,
                    ) -> std::result::Result<f64, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = divide , method , js_class = "Point" , catch)]
                    fn __TSB_divide_FnF64ToPoint(
                        this: &Point_Class,
                        number: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = divide , method , js_class = "Point" , catch)]
                    fn __TSB_divide_FnPointToPoint(
                        this: &Point_Class,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getAngleInRadians , method , js_class = "Point" , catch)]
                    fn __TSB_get_angle_in_radians_FnPointToF64(
                        this: &Point_Class,
                        point: Point,
                    ) -> std::result::Result<f64, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isZero , method , js_class = "Point" , catch)]
                    fn __TSB_is_zero_FnToBool(
                        this: &Point_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = project , method , js_class = "Point" , catch)]
                    fn __TSB_project_FnPointToPoint(
                        this: &Point_Class,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getAngle , method , js_class = "Point" , catch)]
                    fn __TSB_get_angle_FnPointToF64(
                        this: &Point_Class,
                        point: Point,
                    ) -> std::result::Result<f64, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = modulo , method , js_class = "Point" , catch)]
                    fn __TSB_modulo_FnF64ToPoint(
                        this: &Point_Class,
                        value: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = modulo , method , js_class = "Point" , catch)]
                    fn __TSB_modulo_FnPointToPoint(
                        this: &Point_Class,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = x , js_class = "Point")]
                    fn x(this: &Point_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = x , js_class = "Point")]
                    fn set_x(this: &Point_Class, value: f64) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = random , method , js_class = "Point" , catch)]
                    fn __TSB_random_FnToPoint(
                        this: &Point_Class,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getDirectedAngle , method , js_class = "Point" , catch)]
                    fn __TSB_get_directed_angle_FnPointToF64(
                        this: &Point_Class,
                        point: Point,
                    ) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = quadrant , js_class = "Point")]
                    fn quadrant(this: &Point_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = quadrant , js_class = "Point")]
                    fn set_quadrant(
                        this: &Point_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = normalize , method , js_class = "Point" , catch)]
                    fn __TSB_normalize_FnF64ToPoint(
                        this: &Point_Class,
                        length: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = rotate , method , js_class = "Point" , catch)]
                    fn __TSB_rotate_FnF64AndPointToPoint(
                        this: &Point_Class,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = angle , js_class = "Point")]
                    fn angle(this: &Point_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = angle , js_class = "Point")]
                    fn set_angle(
                        this: &Point_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isInQuadrant , method , js_class = "Point" , catch)]
                    fn __TSB_is_in_quadrant_FnF64ToBool(
                        this: &Point_Class,
                        quadrant: f64,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = floor , method , js_class = "Point" , catch)]
                    fn __TSB_floor_FnToPoint(
                        this: &Point_Class,
                    ) -> std::result::Result<Point, JsValue>;
                    #[wasm_bindgen(constructor, js_class = "Point")]
                    pub fn new_FnF64AndF64ToPoint(x: f64, y: f64) -> Point_Class;
                    #[wasm_bindgen(constructor, js_class = "Point")]
                    pub fn new_FnVecOfJsValueToPoint(array: JsValue) -> Point_Class;
                    #[wasm_bindgen(constructor, js_class = "Point")]
                    pub fn new_FnSizeToPoint(size: Size) -> Point_Class;
                    #[wasm_bindgen(constructor, js_class = "Point")]
                    pub fn new_FnPointToPoint(point: Point) -> Point_Class;
                    #[wasm_bindgen(constructor, js_class = "Point")]
                    pub fn new_FnJsValueToPoint(object: JsValue) -> Point_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = set , method , js_class = "Point" , catch , variadic)]
                    fn __TSB_set_FnVecOfJsValueToPoint(
                        this: &Point_Class,
                        values: Box<[JsValue]>,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clone , method , js_class = "Point" , catch)]
                    fn __TSB_clone_FnToPoint(
                        this: &Point_Class,
                    ) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = y , js_class = "Point")]
                    fn y(this: &Point_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = y , js_class = "Point")]
                    fn set_y(this: &Point_Class, value: f64) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = abs , method , js_class = "Point" , catch)]
                    fn __TSB_abs_FnToPoint(
                        this: &Point_Class,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isNaN , method , js_class = "Point" , catch)]
                    fn __TSB_is_na_n_FnToBool(
                        this: &Point_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = equals , method , js_class = "Point" , catch)]
                    fn __TSB_equals_FnPointToBool(
                        this: &Point_Class,
                        point: Point,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = subtract , method , js_class = "Point" , catch)]
                    fn __TSB_subtract_FnF64ToPoint(
                        this: &Point_Class,
                        number: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = subtract , method , js_class = "Point" , catch)]
                    fn __TSB_subtract_FnPointToPoint(
                        this: &Point_Class,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = selected , js_class = "Point")]
                    fn selected(this: &Point_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = selected , js_class = "Point")]
                    fn set_selected(
                        this: &Point_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = transform , method , js_class = "Point" , catch)]
                    fn __TSB_transform_FnMatrixToPoint(
                        this: &Point_Class,
                        matrix: Matrix,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = max , method , js_class = "Point" , catch)]
                    fn __TSB_max_FnPointAndPointToPoint(
                        this: &Point_Class,
                        point1: Point,
                        point2: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isCollinear , method , js_class = "Point" , catch)]
                    fn __TSB_is_collinear_FnPointToBool(
                        this: &Point_Class,
                        point: Point,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isClose , method , js_class = "Point" , catch)]
                    fn __TSB_is_close_FnPointAndF64ToBool(
                        this: &Point_Class,
                        point: Point,
                        tolerance: f64,
                    ) -> std::result::Result<bool, JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Point(pub Point_Class);
                impl std::convert::From<Point> for JsValue {
                    fn from(src: Point) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for Point {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for Point {
                    fn instanceof(val: &JsValue) -> bool {
                        Point_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        Point(Point_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(Point_Class::unchecked_from_js_ref(val) as *const Point_Class
                                as *const Self)
                        }
                    }
                }
                impl Point {
                    #[allow(dead_code, non_snake_case)]
                    pub fn round(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_round_FnToPoint();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn dot(&self, point: Point) -> std::result::Result<f64, JsValue> {
                        let result = self.0.__TSB_dot_FnPointToF64(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn length(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.length();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_length(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_length(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn angle_in_radians(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.angle_in_radians();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_angle_in_radians(
                        &self,
                        value: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_angle_in_radians(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_inside_FnRectangleToBool(rect);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.__TSB_to_string_FnToString();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_orthogonal(
                        &self,
                        point: Point,
                    ) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_orthogonal_FnPointToBool(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn multiply_FnF64ToPoint(
                        &self,
                        number: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_multiply_FnF64ToPoint(number);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn multiply_FnPointToPoint(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_multiply_FnPointToPoint(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn add_FnF64ToPoint(
                        &self,
                        number: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_add_FnF64ToPoint(number);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn add_FnPointToPoint(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_add_FnPointToPoint(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn ceil(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_ceil_FnToPoint();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn cross(&self, point: Point) -> std::result::Result<f64, JsValue> {
                        let result = self.0.__TSB_cross_FnPointToF64(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn min(
                        &self,
                        point1: Point,
                        point2: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_min_FnPointAndPointToPoint(point1, point2);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_distance(
                        &self,
                        point: Point,
                        squared: bool,
                    ) -> std::result::Result<f64, JsValue> {
                        let result = self
                            .0
                            .__TSB_get_distance_FnPointAndBoolToF64(point, squared);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn divide_FnF64ToPoint(
                        &self,
                        number: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_divide_FnF64ToPoint(number);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn divide_FnPointToPoint(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_divide_FnPointToPoint(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_angle_in_radians(
                        &self,
                        point: Point,
                    ) -> std::result::Result<f64, JsValue> {
                        let result = self.0.__TSB_get_angle_in_radians_FnPointToF64(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_zero(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_zero_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn project(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_project_FnPointToPoint(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_angle(&self, point: Point) -> std::result::Result<f64, JsValue> {
                        let result = self.0.__TSB_get_angle_FnPointToF64(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn modulo_FnF64ToPoint(
                        &self,
                        value: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_modulo_FnF64ToPoint(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn modulo_FnPointToPoint(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_modulo_FnPointToPoint(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn x(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.x();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_x(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_x(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn random(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_random_FnToPoint();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_directed_angle(
                        &self,
                        point: Point,
                    ) -> std::result::Result<f64, JsValue> {
                        let result = self.0.__TSB_get_directed_angle_FnPointToF64(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn quadrant(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.quadrant();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_quadrant(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_quadrant(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn normalize(&self, length: f64) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_normalize_FnF64ToPoint(length);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_rotate_FnF64AndPointToPoint(angle, center);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn angle(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.angle();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_angle(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_angle(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_in_quadrant(
                        &self,
                        quadrant: f64,
                    ) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_in_quadrant_FnF64ToBool(quadrant);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn floor(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_floor_FnToPoint();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnF64AndF64ToPoint(x: f64, y: f64) -> Point {
                        let result = Point_Class::new_FnF64AndF64ToPoint(x, y);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Point(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnVecOfJsValueToPoint(array: Vec<JsValue>) -> Point {
                        let result = Point_Class::new_FnVecOfJsValueToPoint({
                            let array_array = js_sys::Array::new();
                            for array_item in array {
                                array_array.push(&JsValue::from(array_item));
                            }
                            array_array.into()
                        });
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Point(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnSizeToPoint(size: Size) -> Point {
                        let result = Point_Class::new_FnSizeToPoint(size);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Point(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnPointToPoint(point: Point) -> Point {
                        let result = Point_Class::new_FnPointToPoint(point);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Point(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnJsValueToPoint(object: JsValue) -> Point {
                        let result = Point_Class::new_FnJsValueToPoint(object);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Point(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set(&self, values: Vec<JsValue>) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_set_FnVecOfJsValueToPoint(
                            values
                                .into_iter()
                                .map(|values_item| JsValue::from(values_item))
                                .collect::<Vec<_>>()
                                .into_boxed_slice(),
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn clone(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_clone_FnToPoint();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn y(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.y();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_y(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_y(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn abs(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_abs_FnToPoint();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_na_n(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_na_n_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn equals(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_equals_FnPointToBool(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn subtract_FnF64ToPoint(
                        &self,
                        number: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_subtract_FnF64ToPoint(number);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn subtract_FnPointToPoint(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_subtract_FnPointToPoint(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.selected();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_selected(&self, value: bool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_selected(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn transform(&self, matrix: Matrix) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_transform_FnMatrixToPoint(matrix);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn max(
                        &self,
                        point1: Point,
                        point2: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_max_FnPointAndPointToPoint(point1, point2);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_collinear(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_collinear_FnPointToBool(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_close(
                        &self,
                        point: Point,
                        tolerance: f64,
                    ) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_close_FnPointAndF64ToBool(point, tolerance);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Point {
                    fn describe() {
                        <Point_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Point {
                    type Abi = <Point_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Point {
                    type Abi = <Point_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Point(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Point {
                    type Abi = <&'a Point_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Point {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Point {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Point_Class =
                            <Point_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait Point_Trait {
                    fn round(&self) -> std::result::Result<Point, JsValue>;
                    fn dot(&self, point: Point) -> std::result::Result<f64, JsValue>;
                    fn set_length(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn length(&self) -> std::result::Result<f64, JsValue>;
                    fn set_angle_in_radians(
                        &mut self,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    fn angle_in_radians(&self) -> std::result::Result<f64, JsValue>;
                    fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue>;
                    fn to_string(&self) -> std::result::Result<String, JsValue>;
                    fn is_orthogonal(&self, point: Point) -> std::result::Result<bool, JsValue>;
                    fn multiply_FnF64ToPoint(
                        &self,
                        number: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    fn multiply_FnPointToPoint(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    fn add_FnF64ToPoint(&self, number: f64) -> std::result::Result<Point, JsValue>;
                    fn add_FnPointToPoint(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    fn ceil(&self) -> std::result::Result<Point, JsValue>;
                    fn cross(&self, point: Point) -> std::result::Result<f64, JsValue>;
                    fn min(
                        &self,
                        point1: Point,
                        point2: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    fn get_distance(
                        &self,
                        point: Point,
                        squared: bool,
                    ) -> std::result::Result<f64, JsValue>;
                    fn divide_FnF64ToPoint(
                        &self,
                        number: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    fn divide_FnPointToPoint(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    fn get_angle_in_radians(
                        &self,
                        point: Point,
                    ) -> std::result::Result<f64, JsValue>;
                    fn is_zero(&self) -> std::result::Result<bool, JsValue>;
                    fn project(&self, point: Point) -> std::result::Result<Point, JsValue>;
                    fn get_angle(&self, point: Point) -> std::result::Result<f64, JsValue>;
                    fn modulo_FnF64ToPoint(
                        &self,
                        value: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    fn modulo_FnPointToPoint(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    fn set_x(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn x(&self) -> std::result::Result<f64, JsValue>;
                    fn random(&self) -> std::result::Result<Point, JsValue>;
                    fn get_directed_angle(&self, point: Point)
                        -> std::result::Result<f64, JsValue>;
                    fn set_quadrant(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn quadrant(&self) -> std::result::Result<f64, JsValue>;
                    fn normalize(&self, length: f64) -> std::result::Result<Point, JsValue>;
                    fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    fn set_angle(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn angle(&self) -> std::result::Result<f64, JsValue>;
                    fn is_in_quadrant(&self, quadrant: f64) -> std::result::Result<bool, JsValue>;
                    fn floor(&self) -> std::result::Result<Point, JsValue>;
                    fn set(&self, values: Vec<JsValue>) -> std::result::Result<Point, JsValue>;
                    fn clone(&self) -> std::result::Result<Point, JsValue>;
                    fn set_y(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn y(&self) -> std::result::Result<f64, JsValue>;
                    fn abs(&self) -> std::result::Result<Point, JsValue>;
                    fn is_na_n(&self) -> std::result::Result<bool, JsValue>;
                    fn equals(&self, point: Point) -> std::result::Result<bool, JsValue>;
                    fn subtract_FnF64ToPoint(
                        &self,
                        number: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    fn subtract_FnPointToPoint(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue>;
                    fn selected(&self) -> std::result::Result<bool, JsValue>;
                    fn transform(&self, matrix: Matrix) -> std::result::Result<Point, JsValue>;
                    fn max(
                        &self,
                        point1: Point,
                        point2: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    fn is_collinear(&self, point: Point) -> std::result::Result<bool, JsValue>;
                    fn is_close(
                        &self,
                        point: Point,
                        tolerance: f64,
                    ) -> std::result::Result<bool, JsValue>;
                }
                impl Point_Trait for Point {
                    fn round(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::round(target)
                    }
                    fn dot(&self, point: Point) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Point::dot(target, point)
                    }
                    fn set_length(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Point::set_length(target, value)
                    }
                    fn length(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Point::length(target)
                    }
                    fn set_angle_in_radians(
                        &mut self,
                        value: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Point::set_angle_in_radians(target, value)
                    }
                    fn angle_in_radians(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Point::angle_in_radians(target)
                    }
                    fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Point::is_inside(target, rect)
                    }
                    fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Point::to_string(target)
                    }
                    fn is_orthogonal(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Point::is_orthogonal(target, point)
                    }
                    fn multiply_FnF64ToPoint(
                        &self,
                        number: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::multiply_FnF64ToPoint(target, number)
                    }
                    fn multiply_FnPointToPoint(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::multiply_FnPointToPoint(target, point)
                    }
                    fn add_FnF64ToPoint(&self, number: f64) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::add_FnF64ToPoint(target, number)
                    }
                    fn add_FnPointToPoint(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::add_FnPointToPoint(target, point)
                    }
                    fn ceil(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::ceil(target)
                    }
                    fn cross(&self, point: Point) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Point::cross(target, point)
                    }
                    fn min(
                        &self,
                        point1: Point,
                        point2: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::min(target, point1, point2)
                    }
                    fn get_distance(
                        &self,
                        point: Point,
                        squared: bool,
                    ) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Point::get_distance(target, point, squared)
                    }
                    fn divide_FnF64ToPoint(
                        &self,
                        number: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::divide_FnF64ToPoint(target, number)
                    }
                    fn divide_FnPointToPoint(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::divide_FnPointToPoint(target, point)
                    }
                    fn get_angle_in_radians(
                        &self,
                        point: Point,
                    ) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Point::get_angle_in_radians(target, point)
                    }
                    fn is_zero(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Point::is_zero(target)
                    }
                    fn project(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::project(target, point)
                    }
                    fn get_angle(&self, point: Point) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Point::get_angle(target, point)
                    }
                    fn modulo_FnF64ToPoint(
                        &self,
                        value: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::modulo_FnF64ToPoint(target, value)
                    }
                    fn modulo_FnPointToPoint(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::modulo_FnPointToPoint(target, point)
                    }
                    fn set_x(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Point::set_x(target, value)
                    }
                    fn x(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Point::x(target)
                    }
                    fn random(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::random(target)
                    }
                    fn get_directed_angle(
                        &self,
                        point: Point,
                    ) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Point::get_directed_angle(target, point)
                    }
                    fn set_quadrant(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Point::set_quadrant(target, value)
                    }
                    fn quadrant(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Point::quadrant(target)
                    }
                    fn normalize(&self, length: f64) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::normalize(target, length)
                    }
                    fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::rotate(target, angle, center)
                    }
                    fn set_angle(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Point::set_angle(target, value)
                    }
                    fn angle(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Point::angle(target)
                    }
                    fn is_in_quadrant(&self, quadrant: f64) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Point::is_in_quadrant(target, quadrant)
                    }
                    fn floor(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::floor(target)
                    }
                    fn set(&self, values: Vec<JsValue>) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::set(target, values)
                    }
                    fn clone(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::clone(target)
                    }
                    fn set_y(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Point::set_y(target, value)
                    }
                    fn y(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Point::y(target)
                    }
                    fn abs(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::abs(target)
                    }
                    fn is_na_n(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Point::is_na_n(target)
                    }
                    fn equals(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Point::equals(target, point)
                    }
                    fn subtract_FnF64ToPoint(
                        &self,
                        number: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::subtract_FnF64ToPoint(target, number)
                    }
                    fn subtract_FnPointToPoint(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::subtract_FnPointToPoint(target, point)
                    }
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Point::set_selected(target, value)
                    }
                    fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Point::selected(target)
                    }
                    fn transform(&self, matrix: Matrix) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::transform(target, matrix)
                    }
                    fn max(
                        &self,
                        point1: Point,
                        point2: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Point::max(target, point1, point2)
                    }
                    fn is_collinear(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Point::is_collinear(target, point)
                    }
                    fn is_close(
                        &self,
                        point: Point,
                        tolerance: f64,
                    ) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Point::is_close(target, point, tolerance)
                    }
                }
                impl std::clone::Clone for Point_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Point_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Point_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ToolOffReturn {
                    Tool(Tool),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewOnResize {
                    TsBindgenRtNull,
                    #[serde(
                        serialize_with = "ViewOnResize::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ViewOnResize::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                }
                impl ViewOnResize {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum SizeModuloReturn {
                    Size(Size),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemMatchesParamsOptions {
                    String(String),
                    #[serde(
                        serialize_with = "ItemMatchesParamsOptions::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ItemMatchesParamsOptions::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    JsValue(JsValue),
                }
                impl ItemMatchesParamsOptions {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemOnMouseEnter {
                    TsBindgenRtNull,
                    #[serde(
                        serialize_with = "ItemOnMouseEnter::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ItemOnMouseEnter::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                }
                impl ItemOnMouseEnter {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PathItemArcByParamsThrough {
                    Point(Point),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemOnParamsType {
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    JsValue(JsValue),
                    String(String),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum RectangleContainsParamsPoint {
                    Point(Point),
                    Rectangle(Rectangle),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewSkewParamsSkew {
                    Point(Point),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum MatrixRotateParamsAngle {
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemTweenToParamsOptions {
                    F64(f64),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    JsValue(JsValue),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewOnReturn {
                    View(View),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemAddToParamsOwner {
                    CompoundPath(CompoundPath),
                    Layer(Layer),
                    Group(Group),
                    Project(Project),
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    #[wasm_bindgen(js_name = "Style")]
                    pub type Style_Class;
                    # [wasm_bindgen (method , structural , catch , getter = justification , js_class = "Style")]
                    fn justification(this: &Style_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = justification , js_class = "Style")]
                    fn set_justification(
                        this: &Style_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = strokeWidth , js_class = "Style")]
                    fn stroke_width(this: &Style_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = strokeWidth , js_class = "Style")]
                    fn set_stroke_width(
                        this: &Style_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = strokeCap , js_class = "Style")]
                    fn stroke_cap(this: &Style_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = strokeCap , js_class = "Style")]
                    fn set_stroke_cap(
                        this: &Style_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = fillColor , js_class = "Style")]
                    fn __TSB_fill_color(
                        this: &Style_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = fillColor , js_class = "Style")]
                    fn __TSB_set_fill_color(
                        this: &Style_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = fontFamily , js_class = "Style")]
                    fn font_family(this: &Style_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = fontFamily , js_class = "Style")]
                    fn set_font_family(
                        this: &Style_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = fontSize , js_class = "Style")]
                    fn __TSB_font_size(this: &Style_Class)
                        -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = fontSize , js_class = "Style")]
                    fn __TSB_set_font_size(
                        this: &Style_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = fontWeight , js_class = "Style")]
                    fn __TSB_font_weight(
                        this: &Style_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = fontWeight , js_class = "Style")]
                    fn __TSB_set_font_weight(
                        this: &Style_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = view , js_class = "Style")]
                    fn view(this: &Style_Class) -> std::result::Result<View, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = view , js_class = "Style")]
                    fn set_view(
                        this: &Style_Class,
                        value: View,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = shadowColor , js_class = "Style")]
                    fn __TSB_shadow_color(
                        this: &Style_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = shadowColor , js_class = "Style")]
                    fn __TSB_set_shadow_color(
                        this: &Style_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[wasm_bindgen(constructor, js_class = "Style")]
                    pub fn new(style: JsValue) -> Style_Class;
                    # [wasm_bindgen (method , structural , catch , getter = fillRule , js_class = "Style")]
                    fn fill_rule(this: &Style_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = fillRule , js_class = "Style")]
                    fn set_fill_rule(
                        this: &Style_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = shadowBlur , js_class = "Style")]
                    fn shadow_blur(this: &Style_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = shadowBlur , js_class = "Style")]
                    fn set_shadow_blur(
                        this: &Style_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = leading , js_class = "Style")]
                    fn __TSB_leading(this: &Style_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = leading , js_class = "Style")]
                    fn __TSB_set_leading(
                        this: &Style_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = strokeJoin , js_class = "Style")]
                    fn stroke_join(this: &Style_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = strokeJoin , js_class = "Style")]
                    fn set_stroke_join(
                        this: &Style_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = dashArray , js_class = "Style")]
                    fn __TSB_dash_array(
                        this: &Style_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = dashArray , js_class = "Style")]
                    fn __TSB_set_dash_array(
                        this: &Style_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = strokeScaling , js_class = "Style")]
                    fn stroke_scaling(this: &Style_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = strokeScaling , js_class = "Style")]
                    fn set_stroke_scaling(
                        this: &Style_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = miterLimit , js_class = "Style")]
                    fn miter_limit(this: &Style_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = miterLimit , js_class = "Style")]
                    fn set_miter_limit(
                        this: &Style_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = selectedColor , js_class = "Style")]
                    fn __TSB_selected_color(
                        this: &Style_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = selectedColor , js_class = "Style")]
                    fn __TSB_set_selected_color(
                        this: &Style_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = strokeColor , js_class = "Style")]
                    fn __TSB_stroke_color(
                        this: &Style_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = strokeColor , js_class = "Style")]
                    fn __TSB_set_stroke_color(
                        this: &Style_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = shadowOffset , js_class = "Style")]
                    fn shadow_offset(this: &Style_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = shadowOffset , js_class = "Style")]
                    fn set_shadow_offset(
                        this: &Style_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = dashOffset , js_class = "Style")]
                    fn dash_offset(this: &Style_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = dashOffset , js_class = "Style")]
                    fn set_dash_offset(
                        this: &Style_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Style(pub Style_Class);
                impl std::convert::From<Style> for JsValue {
                    fn from(src: Style) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for Style {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for Style {
                    fn instanceof(val: &JsValue) -> bool {
                        Style_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        Style(Style_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(Style_Class::unchecked_from_js_ref(val) as *const Style_Class
                                as *const Self)
                        }
                    }
                }
                impl Style {
                    #[allow(dead_code, non_snake_case)]
                    pub fn justification(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.justification();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_justification(
                        &self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_justification(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.stroke_width();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_stroke_width(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_stroke_width(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.stroke_cap();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_stroke_cap(
                        &self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_stroke_cap(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn fill_color(&self) -> std::result::Result<StyleFillColor, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_fill_color()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_fill_color(
                        &self,
                        value: StyleFillColor,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_fill_color(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn font_family(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.font_family();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_font_family(
                        &self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_font_family(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn font_size(&self) -> std::result::Result<StyleFontSize, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_font_size()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_font_size(
                        &self,
                        value: StyleFontSize,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_font_size(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn font_weight(&self) -> std::result::Result<StyleFontWeight, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_font_weight()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_font_weight(
                        &self,
                        value: StyleFontWeight,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_font_weight(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn view(&self) -> std::result::Result<View, JsValue> {
                        let result = self.0.view();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_view(&self, value: View) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_view(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn shadow_color(&self) -> std::result::Result<StyleShadowColor, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_shadow_color()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_shadow_color(
                        &self,
                        value: StyleShadowColor,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_shadow_color(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new(style: JsValue) -> Style {
                        let result = Style_Class::new(style);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Style(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.fill_rule();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_fill_rule(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_fill_rule(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.shadow_blur();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_shadow_blur(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_shadow_blur(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn leading(&self) -> std::result::Result<StyleLeading, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_leading()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_leading(
                        &self,
                        value: StyleLeading,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_leading(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.stroke_join();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_stroke_join(
                        &self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_stroke_join(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_dash_array()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_dash_array(
                        &self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_dash_array({
                            let value_array = js_sys::Array::new();
                            for value_item in value {
                                value_array.push(&JsValue::from(value_item));
                            }
                            value_array.into()
                        });
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.stroke_scaling();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_stroke_scaling(
                        &self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_stroke_scaling(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.miter_limit();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_miter_limit(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_miter_limit(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn selected_color(
                        &self,
                    ) -> std::result::Result<StyleSelectedColor, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_selected_color()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_selected_color(
                        &self,
                        value: StyleSelectedColor,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_selected_color(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn stroke_color(&self) -> std::result::Result<StyleStrokeColor, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_stroke_color()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_stroke_color(
                        &self,
                        value: StyleStrokeColor,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_stroke_color(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn shadow_offset(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.shadow_offset();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_shadow_offset(
                        &self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_shadow_offset(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.dash_offset();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_dash_offset(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_dash_offset(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Style {
                    fn describe() {
                        <Style_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Style {
                    type Abi = <Style_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Style {
                    type Abi = <Style_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Style(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Style {
                    type Abi = <&'a Style_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Style {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Style {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Style_Class =
                            <Style_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait Style_Trait {
                    fn set_justification(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    fn justification(&self) -> std::result::Result<String, JsValue>;
                    fn set_stroke_width(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn stroke_width(&self) -> std::result::Result<f64, JsValue>;
                    fn set_stroke_cap(&mut self, value: String)
                        -> std::result::Result<(), JsValue>;
                    fn stroke_cap(&self) -> std::result::Result<String, JsValue>;
                    fn set_fill_color(
                        &mut self,
                        value: StyleFillColor,
                    ) -> std::result::Result<(), JsValue>;
                    fn fill_color(&self) -> std::result::Result<StyleFillColor, JsValue>;
                    fn set_font_family(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    fn font_family(&self) -> std::result::Result<String, JsValue>;
                    fn set_font_size(
                        &mut self,
                        value: StyleFontSize,
                    ) -> std::result::Result<(), JsValue>;
                    fn font_size(&self) -> std::result::Result<StyleFontSize, JsValue>;
                    fn set_font_weight(
                        &mut self,
                        value: StyleFontWeight,
                    ) -> std::result::Result<(), JsValue>;
                    fn font_weight(&self) -> std::result::Result<StyleFontWeight, JsValue>;
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue>;
                    fn view(&self) -> std::result::Result<View, JsValue>;
                    fn set_shadow_color(
                        &mut self,
                        value: StyleShadowColor,
                    ) -> std::result::Result<(), JsValue>;
                    fn shadow_color(&self) -> std::result::Result<StyleShadowColor, JsValue>;
                    fn set_fill_rule(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn fill_rule(&self) -> std::result::Result<String, JsValue>;
                    fn set_shadow_blur(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn shadow_blur(&self) -> std::result::Result<f64, JsValue>;
                    fn set_leading(
                        &mut self,
                        value: StyleLeading,
                    ) -> std::result::Result<(), JsValue>;
                    fn leading(&self) -> std::result::Result<StyleLeading, JsValue>;
                    fn set_stroke_join(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    fn stroke_join(&self) -> std::result::Result<String, JsValue>;
                    fn set_dash_array(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue>;
                    fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue>;
                    fn set_stroke_scaling(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    fn stroke_scaling(&self) -> std::result::Result<bool, JsValue>;
                    fn set_miter_limit(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn miter_limit(&self) -> std::result::Result<f64, JsValue>;
                    fn set_selected_color(
                        &mut self,
                        value: StyleSelectedColor,
                    ) -> std::result::Result<(), JsValue>;
                    fn selected_color(&self) -> std::result::Result<StyleSelectedColor, JsValue>;
                    fn set_stroke_color(
                        &mut self,
                        value: StyleStrokeColor,
                    ) -> std::result::Result<(), JsValue>;
                    fn stroke_color(&self) -> std::result::Result<StyleStrokeColor, JsValue>;
                    fn set_shadow_offset(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn shadow_offset(&self) -> std::result::Result<Point, JsValue>;
                    fn set_dash_offset(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn dash_offset(&self) -> std::result::Result<f64, JsValue>;
                }
                impl Style_Trait for Style {
                    fn set_justification(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Style::set_justification(target, value)
                    }
                    fn justification(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Style::justification(target)
                    }
                    fn set_stroke_width(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Style::set_stroke_width(target, value)
                    }
                    fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Style::stroke_width(target)
                    }
                    fn set_stroke_cap(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Style::set_stroke_cap(target, value)
                    }
                    fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Style::stroke_cap(target)
                    }
                    fn set_fill_color(
                        &mut self,
                        value: StyleFillColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Style::set_fill_color(target, value)
                    }
                    fn fill_color(&self) -> std::result::Result<StyleFillColor, JsValue> {
                        let target = self;
                        Style::fill_color(target)
                    }
                    fn set_font_family(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Style::set_font_family(target, value)
                    }
                    fn font_family(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Style::font_family(target)
                    }
                    fn set_font_size(
                        &mut self,
                        value: StyleFontSize,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Style::set_font_size(target, value)
                    }
                    fn font_size(&self) -> std::result::Result<StyleFontSize, JsValue> {
                        let target = self;
                        Style::font_size(target)
                    }
                    fn set_font_weight(
                        &mut self,
                        value: StyleFontWeight,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Style::set_font_weight(target, value)
                    }
                    fn font_weight(&self) -> std::result::Result<StyleFontWeight, JsValue> {
                        let target = self;
                        Style::font_weight(target)
                    }
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Style::set_view(target, value)
                    }
                    fn view(&self) -> std::result::Result<View, JsValue> {
                        let target = self;
                        Style::view(target)
                    }
                    fn set_shadow_color(
                        &mut self,
                        value: StyleShadowColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Style::set_shadow_color(target, value)
                    }
                    fn shadow_color(&self) -> std::result::Result<StyleShadowColor, JsValue> {
                        let target = self;
                        Style::shadow_color(target)
                    }
                    fn set_fill_rule(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Style::set_fill_rule(target, value)
                    }
                    fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Style::fill_rule(target)
                    }
                    fn set_shadow_blur(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Style::set_shadow_blur(target, value)
                    }
                    fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Style::shadow_blur(target)
                    }
                    fn set_leading(
                        &mut self,
                        value: StyleLeading,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Style::set_leading(target, value)
                    }
                    fn leading(&self) -> std::result::Result<StyleLeading, JsValue> {
                        let target = self;
                        Style::leading(target)
                    }
                    fn set_stroke_join(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Style::set_stroke_join(target, value)
                    }
                    fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Style::stroke_join(target)
                    }
                    fn set_dash_array(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Style::set_dash_array(target, value)
                    }
                    fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let target = self;
                        Style::dash_array(target)
                    }
                    fn set_stroke_scaling(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Style::set_stroke_scaling(target, value)
                    }
                    fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Style::stroke_scaling(target)
                    }
                    fn set_miter_limit(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Style::set_miter_limit(target, value)
                    }
                    fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Style::miter_limit(target)
                    }
                    fn set_selected_color(
                        &mut self,
                        value: StyleSelectedColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Style::set_selected_color(target, value)
                    }
                    fn selected_color(&self) -> std::result::Result<StyleSelectedColor, JsValue> {
                        let target = self;
                        Style::selected_color(target)
                    }
                    fn set_stroke_color(
                        &mut self,
                        value: StyleStrokeColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Style::set_stroke_color(target, value)
                    }
                    fn stroke_color(&self) -> std::result::Result<StyleStrokeColor, JsValue> {
                        let target = self;
                        Style::stroke_color(target)
                    }
                    fn set_shadow_offset(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Style::set_shadow_offset(target, value)
                    }
                    fn shadow_offset(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Style::shadow_offset(target)
                    }
                    fn set_dash_offset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Style::set_dash_offset(target, value)
                    }
                    fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Style::dash_offset(target)
                    }
                }
                impl std::clone::Clone for Style_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Style_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Style_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewSkewParamsCenter {
                    Point(Point),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum SizeModuloParamsValue {
                    Size(Size),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum RectangleExpandParamsAmount {
                    Point(Point),
                    Size(Size),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum SizeMultiplyParamsNumber {
                    Size(Size),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewScaleReturn {
                    __,
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum RectangleExpandReturn {
                    Rectangle(Rectangle),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum RasterSetPixelParamsY {
                    Color(Color),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum SizeSubtractReturn {
                    Size(Size),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemImportSvgReturn {
                    Item(Item),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemShearParamsShear {
                    Point(Point),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum CurveGetCurvatureAtParamsLocation {
                    CurveLocation(CurveLocation),
                    F64(f64),
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    #[wasm_bindgen(js_name = "PaperScope")]
                    pub type PaperScope_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = setup , method , js_class = "PaperScope" , catch)]
                    fn __TSB_setup_FnPaperScopeSetupParamsElementTo(
                        this: &PaperScope_Class,
                        element: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = install , method , js_class = "PaperScope" , catch)]
                    fn __TSB_install_FnJsValueTo(
                        this: &PaperScope_Class,
                        scope: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = tool , js_class = "PaperScope")]
                    fn tool(this: &PaperScope_Class) -> std::result::Result<Tool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = tool , js_class = "PaperScope")]
                    fn set_tool(
                        this: &PaperScope_Class,
                        value: Tool,
                    ) -> std::result::Result<(), JsValue>;
                    #[wasm_bindgen(constructor, js_class = "PaperScope")]
                    pub fn new() -> PaperScope_Class;
                    # [wasm_bindgen (method , structural , catch , getter = project , js_class = "PaperScope")]
                    fn project(this: &PaperScope_Class) -> std::result::Result<Project, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = project , js_class = "PaperScope")]
                    fn set_project(
                        this: &PaperScope_Class,
                        value: Project,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = get , method , js_class = "PaperScope" , catch)]
                    fn __TSB_get_FnJsValueToPaperScope(
                        this: &PaperScope_Class,
                        id: JsValue,
                    ) -> std::result::Result<PaperScope, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = version , js_class = "PaperScope")]
                    fn version(this: &PaperScope_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = version , js_class = "PaperScope")]
                    fn set_version(
                        this: &PaperScope_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = projects , js_class = "PaperScope")]
                    fn __TSB_projects(
                        this: &PaperScope_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = projects , js_class = "PaperScope")]
                    fn __TSB_set_projects(
                        this: &PaperScope_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = settings , js_class = "PaperScope")]
                    fn __TSB_settings(
                        this: &PaperScope_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = settings , js_class = "PaperScope")]
                    fn __TSB_set_settings(
                        this: &PaperScope_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = view , js_class = "PaperScope")]
                    fn view(this: &PaperScope_Class) -> std::result::Result<View, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = view , js_class = "PaperScope")]
                    fn set_view(
                        this: &PaperScope_Class,
                        value: View,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = execute , method , js_class = "PaperScope" , catch)]
                    fn __TSB_execute_FnStringAndJsValueTo(
                        this: &PaperScope_Class,
                        code: String,
                        options: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = tools , js_class = "PaperScope")]
                    fn __TSB_tools(
                        this: &PaperScope_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = tools , js_class = "PaperScope")]
                    fn __TSB_set_tools(
                        this: &PaperScope_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = activate , method , js_class = "PaperScope" , catch)]
                    fn __TSB_activate_FnTo(
                        this: &PaperScope_Class,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct PaperScope(pub PaperScope_Class);
                impl std::default::Default for PaperScope {
                    fn default() -> Self {
                        Self::new()
                    }
                }
                impl std::convert::From<PaperScope> for JsValue {
                    fn from(src: PaperScope) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for PaperScope {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for PaperScope {
                    fn instanceof(val: &JsValue) -> bool {
                        PaperScope_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        PaperScope(PaperScope_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(PaperScope_Class::unchecked_from_js_ref(val)
                                as *const PaperScope_Class
                                as *const Self)
                        }
                    }
                }
                impl PaperScope {
                    #[allow(dead_code, non_snake_case)]
                    pub fn setup(
                        &self,
                        element: PaperScopeSetupParamsElement,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_setup_FnPaperScopeSetupParamsElementTo(
                            ts_bindgen_rt::to_jsvalue(&element)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn install(&self, scope: JsValue) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_install_FnJsValueTo(scope);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn tool(&self) -> std::result::Result<Tool, JsValue> {
                        let result = self.0.tool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_tool(&self, value: Tool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_tool(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new() -> PaperScope {
                        let result = PaperScope_Class::new();
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        PaperScope(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn project(&self) -> std::result::Result<Project, JsValue> {
                        let result = self.0.project();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_project(&self, value: Project) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_project(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get(&self, id: JsValue) -> std::result::Result<PaperScope, JsValue> {
                        let result = self.0.__TSB_get_FnJsValueToPaperScope(id);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn version(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.version();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_version(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_version(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn projects(&self) -> std::result::Result<Vec<Project>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_projects()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_projects(
                        &self,
                        value: Vec<Project>,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_projects({
                            let value_array = js_sys::Array::new();
                            for value_item in value {
                                value_array.push(&JsValue::from(value_item));
                            }
                            value_array.into()
                        });
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn settings(&self) -> std::result::Result<JsValue, JsValue> {
                        let result = self.0.__TSB_settings();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_settings(&self, value: JsValue) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_settings(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn view(&self) -> std::result::Result<View, JsValue> {
                        let result = self.0.view();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_view(&self, value: View) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_view(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn execute(
                        &self,
                        code: String,
                        options: JsValue,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_execute_FnStringAndJsValueTo(code, options);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn tools(&self) -> std::result::Result<Vec<Tool>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_tools()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_tools(&self, value: Vec<Tool>) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_tools({
                            let value_array = js_sys::Array::new();
                            for value_item in value {
                                value_array.push(&JsValue::from(value_item));
                            }
                            value_array.into()
                        });
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn activate(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_activate_FnTo();
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for PaperScope {
                    fn describe() {
                        <PaperScope_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for PaperScope {
                    type Abi = <PaperScope_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for PaperScope {
                    type Abi = <PaperScope_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        PaperScope(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a PaperScope {
                    type Abi = <&'a PaperScope_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for PaperScope {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for PaperScope {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: PaperScope_Class =
                            <PaperScope_Class as serde::de::Deserialize>::deserialize(
                                deserializer,
                            )?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait PaperScope_Trait {
                    fn setup(
                        &self,
                        element: PaperScopeSetupParamsElement,
                    ) -> std::result::Result<(), JsValue>;
                    fn install(&self, scope: JsValue) -> std::result::Result<(), JsValue>;
                    fn set_tool(&mut self, value: Tool) -> std::result::Result<(), JsValue>;
                    fn tool(&self) -> std::result::Result<Tool, JsValue>;
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue>;
                    fn project(&self) -> std::result::Result<Project, JsValue>;
                    fn get(&self, id: JsValue) -> std::result::Result<PaperScope, JsValue>;
                    fn set_version(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn version(&self) -> std::result::Result<String, JsValue>;
                    fn set_projects(
                        &mut self,
                        value: Vec<Project>,
                    ) -> std::result::Result<(), JsValue>;
                    fn projects(&self) -> std::result::Result<Vec<Project>, JsValue>;
                    fn set_settings(&mut self, value: JsValue) -> std::result::Result<(), JsValue>;
                    fn settings(&self) -> std::result::Result<JsValue, JsValue>;
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue>;
                    fn view(&self) -> std::result::Result<View, JsValue>;
                    fn execute(
                        &self,
                        code: String,
                        options: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    fn set_tools(&mut self, value: Vec<Tool>) -> std::result::Result<(), JsValue>;
                    fn tools(&self) -> std::result::Result<Vec<Tool>, JsValue>;
                    fn activate(&self) -> std::result::Result<(), JsValue>;
                }
                impl PaperScope_Trait for PaperScope {
                    fn setup(
                        &self,
                        element: PaperScopeSetupParamsElement,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PaperScope::setup(target, element)
                    }
                    fn install(&self, scope: JsValue) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PaperScope::install(target, scope)
                    }
                    fn set_tool(&mut self, value: Tool) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PaperScope::set_tool(target, value)
                    }
                    fn tool(&self) -> std::result::Result<Tool, JsValue> {
                        let target = self;
                        PaperScope::tool(target)
                    }
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PaperScope::set_project(target, value)
                    }
                    fn project(&self) -> std::result::Result<Project, JsValue> {
                        let target = self;
                        PaperScope::project(target)
                    }
                    fn get(&self, id: JsValue) -> std::result::Result<PaperScope, JsValue> {
                        let target = self;
                        PaperScope::get(target, id)
                    }
                    fn set_version(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PaperScope::set_version(target, value)
                    }
                    fn version(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        PaperScope::version(target)
                    }
                    fn set_projects(
                        &mut self,
                        value: Vec<Project>,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PaperScope::set_projects(target, value)
                    }
                    fn projects(&self) -> std::result::Result<Vec<Project>, JsValue> {
                        let target = self;
                        PaperScope::projects(target)
                    }
                    fn set_settings(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PaperScope::set_settings(target, value)
                    }
                    fn settings(&self) -> std::result::Result<JsValue, JsValue> {
                        let target = self;
                        PaperScope::settings(target)
                    }
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PaperScope::set_view(target, value)
                    }
                    fn view(&self) -> std::result::Result<View, JsValue> {
                        let target = self;
                        PaperScope::view(target)
                    }
                    fn execute(
                        &self,
                        code: String,
                        options: JsValue,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PaperScope::execute(target, code, options)
                    }
                    fn set_tools(&mut self, value: Vec<Tool>) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PaperScope::set_tools(target, value)
                    }
                    fn tools(&self) -> std::result::Result<Vec<Tool>, JsValue> {
                        let target = self;
                        PaperScope::tools(target)
                    }
                    fn activate(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PaperScope::activate(target)
                    }
                }
                impl std::clone::Clone for PaperScope_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for PaperScope_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for PaperScope_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum MatrixTransformParamsPoint {
                    Point(Point),
                    VecOfF64(Vec<f64>),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemTweenParamsOptions {
                    F64(f64),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    JsValue(JsValue),
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    #[wasm_bindgen(js_name = "Rectangle")]
                    pub type Rectangle_Class;
                    # [wasm_bindgen (method , structural , catch , getter = area , js_class = "Rectangle")]
                    fn area(this: &Rectangle_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = area , js_class = "Rectangle")]
                    fn set_area(
                        this: &Rectangle_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = topRight , js_class = "Rectangle")]
                    fn top_right(this: &Rectangle_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = topRight , js_class = "Rectangle")]
                    fn set_top_right(
                        this: &Rectangle_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isEmpty , method , js_class = "Rectangle" , catch)]
                    fn __TSB_is_empty_FnToBool(
                        this: &Rectangle_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = left , js_class = "Rectangle")]
                    fn left(this: &Rectangle_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = left , js_class = "Rectangle")]
                    fn set_left(
                        this: &Rectangle_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = bottomRight , js_class = "Rectangle")]
                    fn bottom_right(this: &Rectangle_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = bottomRight , js_class = "Rectangle")]
                    fn set_bottom_right(
                        this: &Rectangle_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = scale , method , js_class = "Rectangle" , catch)]
                    fn __TSB_scale_FnF64ToRectangle(
                        this: &Rectangle_Class,
                        amount: f64,
                    ) -> std::result::Result<Rectangle, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = scale , method , js_class = "Rectangle" , catch)]
                    fn __TSB_scale_FnF64AndF64ToRectangle(
                        this: &Rectangle_Class,
                        hor: f64,
                        ver: f64,
                    ) -> std::result::Result<Rectangle, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = intersect , method , js_class = "Rectangle" , catch)]
                    fn __TSB_intersect_FnRectangleToRectangle(
                        this: &Rectangle_Class,
                        rect: Rectangle,
                    ) -> std::result::Result<Rectangle, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = bottom , js_class = "Rectangle")]
                    fn bottom(this: &Rectangle_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = bottom , js_class = "Rectangle")]
                    fn set_bottom(
                        this: &Rectangle_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = toString , method , js_class = "Rectangle" , catch)]
                    fn __TSB_to_string_FnToString(
                        this: &Rectangle_Class,
                    ) -> std::result::Result<String, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = intersects , method , js_class = "Rectangle" , catch)]
                    fn __TSB_intersects_FnRectangleAndF64ToBool(
                        this: &Rectangle_Class,
                        rect: Rectangle,
                        epsilon: f64,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = bottomLeft , js_class = "Rectangle")]
                    fn bottom_left(this: &Rectangle_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = bottomLeft , js_class = "Rectangle")]
                    fn set_bottom_left(
                        this: &Rectangle_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = selected , js_class = "Rectangle")]
                    fn selected(this: &Rectangle_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = selected , js_class = "Rectangle")]
                    fn set_selected(
                        this: &Rectangle_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = y , js_class = "Rectangle")]
                    fn y(this: &Rectangle_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = y , js_class = "Rectangle")]
                    fn set_y(
                        this: &Rectangle_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = topLeft , js_class = "Rectangle")]
                    fn top_left(this: &Rectangle_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = topLeft , js_class = "Rectangle")]
                    fn set_top_left(
                        this: &Rectangle_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = contains , method , js_class = "Rectangle" , catch)]
                    fn __TSB_contains_FnPointToBool(
                        this: &Rectangle_Class,
                        point: Point,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = contains , method , js_class = "Rectangle" , catch)]
                    fn __TSB_contains_FnRectangleToBool(
                        this: &Rectangle_Class,
                        rect: Rectangle,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = unite , method , js_class = "Rectangle" , catch)]
                    fn __TSB_unite_FnRectangleToRectangle(
                        this: &Rectangle_Class,
                        rect: Rectangle,
                    ) -> std::result::Result<Rectangle, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clone , method , js_class = "Rectangle" , catch)]
                    fn __TSB_clone_FnToRectangle(
                        this: &Rectangle_Class,
                    ) -> std::result::Result<Rectangle, JsValue>;
                    #[wasm_bindgen(constructor, js_class = "Rectangle")]
                    pub fn new_FnPointAndSizeToRectangle(
                        point: Point,
                        size: Size,
                    ) -> Rectangle_Class;
                    #[wasm_bindgen(constructor, js_class = "Rectangle")]
                    pub fn new_FnF64AndF64AndF64AndF64ToRectangle(
                        x: f64,
                        y: f64,
                        width: f64,
                        height: f64,
                    ) -> Rectangle_Class;
                    #[wasm_bindgen(constructor, js_class = "Rectangle")]
                    pub fn new_FnPointAndPointToRectangle(
                        from: Point,
                        to: Point,
                    ) -> Rectangle_Class;
                    #[wasm_bindgen(constructor, js_class = "Rectangle")]
                    pub fn new_FnRectangleToRectangle(rectangle: Rectangle) -> Rectangle_Class;
                    #[wasm_bindgen(constructor, js_class = "Rectangle")]
                    pub fn new_FnJsValueToRectangle(object: JsValue) -> Rectangle_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = set , method , js_class = "Rectangle" , catch , variadic)]
                    fn __TSB_set_FnVecOfJsValueToRectangle(
                        this: &Rectangle_Class,
                        values: Box<[JsValue]>,
                    ) -> std::result::Result<Rectangle, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = bottomCenter , js_class = "Rectangle")]
                    fn bottom_center(this: &Rectangle_Class)
                        -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = bottomCenter , js_class = "Rectangle")]
                    fn set_bottom_center(
                        this: &Rectangle_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = size , js_class = "Rectangle")]
                    fn size(this: &Rectangle_Class) -> std::result::Result<Size, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = size , js_class = "Rectangle")]
                    fn set_size(
                        this: &Rectangle_Class,
                        value: Size,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = leftCenter , js_class = "Rectangle")]
                    fn left_center(this: &Rectangle_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = leftCenter , js_class = "Rectangle")]
                    fn set_left_center(
                        this: &Rectangle_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = center , js_class = "Rectangle")]
                    fn center(this: &Rectangle_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = center , js_class = "Rectangle")]
                    fn set_center(
                        this: &Rectangle_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = right , js_class = "Rectangle")]
                    fn right(this: &Rectangle_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = right , js_class = "Rectangle")]
                    fn set_right(
                        this: &Rectangle_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = point , js_class = "Rectangle")]
                    fn point(this: &Rectangle_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = point , js_class = "Rectangle")]
                    fn set_point(
                        this: &Rectangle_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = topCenter , js_class = "Rectangle")]
                    fn top_center(this: &Rectangle_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = topCenter , js_class = "Rectangle")]
                    fn set_top_center(
                        this: &Rectangle_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = expand , method , js_class = "Rectangle" , catch)]
                    fn __TSB_expand_FnRectangleExpandParamsAmountToRectangle(
                        this: &Rectangle_Class,
                        amount: JsValue,
                    ) -> std::result::Result<Rectangle, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = expand , method , js_class = "Rectangle" , catch)]
                    fn __TSB_expand_FnF64AndF64ToRectangle(
                        this: &Rectangle_Class,
                        hor: f64,
                        ver: f64,
                    ) -> std::result::Result<Rectangle, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = rightCenter , js_class = "Rectangle")]
                    fn right_center(this: &Rectangle_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = rightCenter , js_class = "Rectangle")]
                    fn set_right_center(
                        this: &Rectangle_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = width , js_class = "Rectangle")]
                    fn width(this: &Rectangle_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = width , js_class = "Rectangle")]
                    fn set_width(
                        this: &Rectangle_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = top , js_class = "Rectangle")]
                    fn top(this: &Rectangle_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = top , js_class = "Rectangle")]
                    fn set_top(
                        this: &Rectangle_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = equals , method , js_class = "Rectangle" , catch)]
                    fn __TSB_equals_FnRectangleToBool(
                        this: &Rectangle_Class,
                        rect: Rectangle,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = include , method , js_class = "Rectangle" , catch)]
                    fn __TSB_include_FnPointToRectangle(
                        this: &Rectangle_Class,
                        point: Point,
                    ) -> std::result::Result<Rectangle, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = x , js_class = "Rectangle")]
                    fn x(this: &Rectangle_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = x , js_class = "Rectangle")]
                    fn set_x(
                        this: &Rectangle_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = height , js_class = "Rectangle")]
                    fn height(this: &Rectangle_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = height , js_class = "Rectangle")]
                    fn set_height(
                        this: &Rectangle_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Rectangle(pub Rectangle_Class);
                impl std::convert::From<Rectangle> for JsValue {
                    fn from(src: Rectangle) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for Rectangle {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for Rectangle {
                    fn instanceof(val: &JsValue) -> bool {
                        Rectangle_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        Rectangle(Rectangle_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(Rectangle_Class::unchecked_from_js_ref(val) as *const Rectangle_Class
                                as *const Self)
                        }
                    }
                }
                impl Rectangle {
                    #[allow(dead_code, non_snake_case)]
                    pub fn area(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.area();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_area(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_area(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn top_right(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.top_right();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_top_right(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_top_right(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_empty(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_empty_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn left(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.left();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_left(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_left(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn bottom_right(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.bottom_right();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_bottom_right(
                        &self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_bottom_right(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn scale_FnF64ToRectangle(
                        &self,
                        amount: f64,
                    ) -> std::result::Result<Rectangle, JsValue> {
                        let result = self.0.__TSB_scale_FnF64ToRectangle(amount);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn scale_FnF64AndF64ToRectangle(
                        &self,
                        hor: f64,
                        ver: f64,
                    ) -> std::result::Result<Rectangle, JsValue> {
                        let result = self.0.__TSB_scale_FnF64AndF64ToRectangle(hor, ver);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn intersect(
                        &self,
                        rect: Rectangle,
                    ) -> std::result::Result<Rectangle, JsValue> {
                        let result = self.0.__TSB_intersect_FnRectangleToRectangle(rect);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn bottom(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.bottom();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_bottom(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_bottom(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.__TSB_to_string_FnToString();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn intersects(
                        &self,
                        rect: Rectangle,
                        epsilon: f64,
                    ) -> std::result::Result<bool, JsValue> {
                        let result = self
                            .0
                            .__TSB_intersects_FnRectangleAndF64ToBool(rect, epsilon);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn bottom_left(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.bottom_left();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_bottom_left(
                        &self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_bottom_left(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.selected();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_selected(&self, value: bool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_selected(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn y(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.y();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_y(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_y(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn top_left(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.top_left();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_top_left(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_top_left(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn contains_FnPointToBool(
                        &self,
                        point: Point,
                    ) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_contains_FnPointToBool(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn contains_FnRectangleToBool(
                        &self,
                        rect: Rectangle,
                    ) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_contains_FnRectangleToBool(rect);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn unite(
                        &self,
                        rect: Rectangle,
                    ) -> std::result::Result<Rectangle, JsValue> {
                        let result = self.0.__TSB_unite_FnRectangleToRectangle(rect);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn clone(&self) -> std::result::Result<Rectangle, JsValue> {
                        let result = self.0.__TSB_clone_FnToRectangle();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnPointAndSizeToRectangle(point: Point, size: Size) -> Rectangle {
                        let result = Rectangle_Class::new_FnPointAndSizeToRectangle(point, size);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Rectangle(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnF64AndF64AndF64AndF64ToRectangle(
                        x: f64,
                        y: f64,
                        width: f64,
                        height: f64,
                    ) -> Rectangle {
                        let result = Rectangle_Class::new_FnF64AndF64AndF64AndF64ToRectangle(
                            x, y, width, height,
                        );
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Rectangle(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnPointAndPointToRectangle(from: Point, to: Point) -> Rectangle {
                        let result = Rectangle_Class::new_FnPointAndPointToRectangle(from, to);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Rectangle(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnRectangleToRectangle(rectangle: Rectangle) -> Rectangle {
                        let result = Rectangle_Class::new_FnRectangleToRectangle(rectangle);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Rectangle(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnJsValueToRectangle(object: JsValue) -> Rectangle {
                        let result = Rectangle_Class::new_FnJsValueToRectangle(object);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Rectangle(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set(
                        &self,
                        values: Vec<JsValue>,
                    ) -> std::result::Result<Rectangle, JsValue> {
                        let result = self.0.__TSB_set_FnVecOfJsValueToRectangle(
                            values
                                .into_iter()
                                .map(|values_item| JsValue::from(values_item))
                                .collect::<Vec<_>>()
                                .into_boxed_slice(),
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn bottom_center(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.bottom_center();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_bottom_center(
                        &self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_bottom_center(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn size(&self) -> std::result::Result<Size, JsValue> {
                        let result = self.0.size();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_size(&self, value: Size) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_size(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn left_center(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.left_center();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_left_center(
                        &self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_left_center(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn center(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.center();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_center(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_center(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn right(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.right();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_right(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_right(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn point(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.point();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_point(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_point(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn top_center(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.top_center();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_top_center(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_top_center(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn expand_FnRectangleExpandParamsAmountToRectangle(
                        &self,
                        amount: RectangleExpandParamsAmount,
                    ) -> std::result::Result<Rectangle, JsValue> {
                        let result = self
                            .0
                            .__TSB_expand_FnRectangleExpandParamsAmountToRectangle(
                                ts_bindgen_rt::to_jsvalue(&amount)
                                    .map_err(ts_bindgen_rt::Error::from)
                                    .map_err(JsValue::from)?,
                            );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn expand_FnF64AndF64ToRectangle(
                        &self,
                        hor: f64,
                        ver: f64,
                    ) -> std::result::Result<Rectangle, JsValue> {
                        let result = self.0.__TSB_expand_FnF64AndF64ToRectangle(hor, ver);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn right_center(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.right_center();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_right_center(
                        &self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_right_center(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn width(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.width();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_width(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_width(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn top(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.top();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_top(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_top(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn equals(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_equals_FnRectangleToBool(rect);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn include(&self, point: Point) -> std::result::Result<Rectangle, JsValue> {
                        let result = self.0.__TSB_include_FnPointToRectangle(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn x(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.x();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_x(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_x(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn height(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.height();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_height(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_height(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Rectangle {
                    fn describe() {
                        <Rectangle_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Rectangle {
                    type Abi = <Rectangle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Rectangle {
                    type Abi = <Rectangle_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Rectangle(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Rectangle {
                    type Abi = <&'a Rectangle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Rectangle {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Rectangle {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Rectangle_Class =
                            <Rectangle_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait Rectangle_Trait {
                    fn set_area(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn area(&self) -> std::result::Result<f64, JsValue>;
                    fn set_top_right(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn top_right(&self) -> std::result::Result<Point, JsValue>;
                    fn is_empty(&self) -> std::result::Result<bool, JsValue>;
                    fn set_left(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn left(&self) -> std::result::Result<f64, JsValue>;
                    fn set_bottom_right(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn bottom_right(&self) -> std::result::Result<Point, JsValue>;
                    fn scale_FnF64ToRectangle(
                        &self,
                        amount: f64,
                    ) -> std::result::Result<Rectangle, JsValue>;
                    fn scale_FnF64AndF64ToRectangle(
                        &self,
                        hor: f64,
                        ver: f64,
                    ) -> std::result::Result<Rectangle, JsValue>;
                    fn intersect(&self, rect: Rectangle)
                        -> std::result::Result<Rectangle, JsValue>;
                    fn set_bottom(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn bottom(&self) -> std::result::Result<f64, JsValue>;
                    fn to_string(&self) -> std::result::Result<String, JsValue>;
                    fn intersects(
                        &self,
                        rect: Rectangle,
                        epsilon: f64,
                    ) -> std::result::Result<bool, JsValue>;
                    fn set_bottom_left(&mut self, value: Point)
                        -> std::result::Result<(), JsValue>;
                    fn bottom_left(&self) -> std::result::Result<Point, JsValue>;
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue>;
                    fn selected(&self) -> std::result::Result<bool, JsValue>;
                    fn set_y(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn y(&self) -> std::result::Result<f64, JsValue>;
                    fn set_top_left(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn top_left(&self) -> std::result::Result<Point, JsValue>;
                    fn contains_FnPointToBool(
                        &self,
                        point: Point,
                    ) -> std::result::Result<bool, JsValue>;
                    fn contains_FnRectangleToBool(
                        &self,
                        rect: Rectangle,
                    ) -> std::result::Result<bool, JsValue>;
                    fn unite(&self, rect: Rectangle) -> std::result::Result<Rectangle, JsValue>;
                    fn clone(&self) -> std::result::Result<Rectangle, JsValue>;
                    fn set(&self, values: Vec<JsValue>) -> std::result::Result<Rectangle, JsValue>;
                    fn set_bottom_center(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn bottom_center(&self) -> std::result::Result<Point, JsValue>;
                    fn set_size(&mut self, value: Size) -> std::result::Result<(), JsValue>;
                    fn size(&self) -> std::result::Result<Size, JsValue>;
                    fn set_left_center(&mut self, value: Point)
                        -> std::result::Result<(), JsValue>;
                    fn left_center(&self) -> std::result::Result<Point, JsValue>;
                    fn set_center(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn center(&self) -> std::result::Result<Point, JsValue>;
                    fn set_right(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn right(&self) -> std::result::Result<f64, JsValue>;
                    fn set_point(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn point(&self) -> std::result::Result<Point, JsValue>;
                    fn set_top_center(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn top_center(&self) -> std::result::Result<Point, JsValue>;
                    fn expand_FnRectangleExpandParamsAmountToRectangle(
                        &self,
                        amount: RectangleExpandParamsAmount,
                    ) -> std::result::Result<Rectangle, JsValue>;
                    fn expand_FnF64AndF64ToRectangle(
                        &self,
                        hor: f64,
                        ver: f64,
                    ) -> std::result::Result<Rectangle, JsValue>;
                    fn set_right_center(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn right_center(&self) -> std::result::Result<Point, JsValue>;
                    fn set_width(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn width(&self) -> std::result::Result<f64, JsValue>;
                    fn set_top(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn top(&self) -> std::result::Result<f64, JsValue>;
                    fn equals(&self, rect: Rectangle) -> std::result::Result<bool, JsValue>;
                    fn include(&self, point: Point) -> std::result::Result<Rectangle, JsValue>;
                    fn set_x(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn x(&self) -> std::result::Result<f64, JsValue>;
                    fn set_height(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn height(&self) -> std::result::Result<f64, JsValue>;
                }
                impl Rectangle_Trait for Rectangle {
                    fn set_area(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Rectangle::set_area(target, value)
                    }
                    fn area(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Rectangle::area(target)
                    }
                    fn set_top_right(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Rectangle::set_top_right(target, value)
                    }
                    fn top_right(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Rectangle::top_right(target)
                    }
                    fn is_empty(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Rectangle::is_empty(target)
                    }
                    fn set_left(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Rectangle::set_left(target, value)
                    }
                    fn left(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Rectangle::left(target)
                    }
                    fn set_bottom_right(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Rectangle::set_bottom_right(target, value)
                    }
                    fn bottom_right(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Rectangle::bottom_right(target)
                    }
                    fn scale_FnF64ToRectangle(
                        &self,
                        amount: f64,
                    ) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        Rectangle::scale_FnF64ToRectangle(target, amount)
                    }
                    fn scale_FnF64AndF64ToRectangle(
                        &self,
                        hor: f64,
                        ver: f64,
                    ) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        Rectangle::scale_FnF64AndF64ToRectangle(target, hor, ver)
                    }
                    fn intersect(
                        &self,
                        rect: Rectangle,
                    ) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        Rectangle::intersect(target, rect)
                    }
                    fn set_bottom(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Rectangle::set_bottom(target, value)
                    }
                    fn bottom(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Rectangle::bottom(target)
                    }
                    fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Rectangle::to_string(target)
                    }
                    fn intersects(
                        &self,
                        rect: Rectangle,
                        epsilon: f64,
                    ) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Rectangle::intersects(target, rect, epsilon)
                    }
                    fn set_bottom_left(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Rectangle::set_bottom_left(target, value)
                    }
                    fn bottom_left(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Rectangle::bottom_left(target)
                    }
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Rectangle::set_selected(target, value)
                    }
                    fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Rectangle::selected(target)
                    }
                    fn set_y(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Rectangle::set_y(target, value)
                    }
                    fn y(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Rectangle::y(target)
                    }
                    fn set_top_left(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Rectangle::set_top_left(target, value)
                    }
                    fn top_left(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Rectangle::top_left(target)
                    }
                    fn contains_FnPointToBool(
                        &self,
                        point: Point,
                    ) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Rectangle::contains_FnPointToBool(target, point)
                    }
                    fn contains_FnRectangleToBool(
                        &self,
                        rect: Rectangle,
                    ) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Rectangle::contains_FnRectangleToBool(target, rect)
                    }
                    fn unite(&self, rect: Rectangle) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        Rectangle::unite(target, rect)
                    }
                    fn clone(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        Rectangle::clone(target)
                    }
                    fn set(&self, values: Vec<JsValue>) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        Rectangle::set(target, values)
                    }
                    fn set_bottom_center(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Rectangle::set_bottom_center(target, value)
                    }
                    fn bottom_center(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Rectangle::bottom_center(target)
                    }
                    fn set_size(&mut self, value: Size) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Rectangle::set_size(target, value)
                    }
                    fn size(&self) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Rectangle::size(target)
                    }
                    fn set_left_center(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Rectangle::set_left_center(target, value)
                    }
                    fn left_center(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Rectangle::left_center(target)
                    }
                    fn set_center(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Rectangle::set_center(target, value)
                    }
                    fn center(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Rectangle::center(target)
                    }
                    fn set_right(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Rectangle::set_right(target, value)
                    }
                    fn right(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Rectangle::right(target)
                    }
                    fn set_point(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Rectangle::set_point(target, value)
                    }
                    fn point(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Rectangle::point(target)
                    }
                    fn set_top_center(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Rectangle::set_top_center(target, value)
                    }
                    fn top_center(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Rectangle::top_center(target)
                    }
                    fn expand_FnRectangleExpandParamsAmountToRectangle(
                        &self,
                        amount: RectangleExpandParamsAmount,
                    ) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        Rectangle::expand_FnRectangleExpandParamsAmountToRectangle(target, amount)
                    }
                    fn expand_FnF64AndF64ToRectangle(
                        &self,
                        hor: f64,
                        ver: f64,
                    ) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        Rectangle::expand_FnF64AndF64ToRectangle(target, hor, ver)
                    }
                    fn set_right_center(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Rectangle::set_right_center(target, value)
                    }
                    fn right_center(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Rectangle::right_center(target)
                    }
                    fn set_width(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Rectangle::set_width(target, value)
                    }
                    fn width(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Rectangle::width(target)
                    }
                    fn set_top(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Rectangle::set_top(target, value)
                    }
                    fn top(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Rectangle::top(target)
                    }
                    fn equals(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Rectangle::equals(target, rect)
                    }
                    fn include(&self, point: Point) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        Rectangle::include(target, point)
                    }
                    fn set_x(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Rectangle::set_x(target, value)
                    }
                    fn x(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Rectangle::x(target)
                    }
                    fn set_height(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Rectangle::set_height(target, value)
                    }
                    fn height(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Rectangle::height(target)
                    }
                }
                impl std::clone::Clone for Rectangle_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Rectangle_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Rectangle_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PathAddParamsSegment {
                    Point(Point),
                    Segment(Segment),
                    VecOfF64(Vec<f64>),
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    #[wasm_bindgen(js_name = "SymbolDefinition")]
                    pub type SymbolDefinition_Class;
                    # [wasm_bindgen (method , structural , catch , getter = item , js_class = "SymbolDefinition")]
                    fn item(this: &SymbolDefinition_Class) -> std::result::Result<Item, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = item , js_class = "SymbolDefinition")]
                    fn set_item(
                        this: &SymbolDefinition_Class,
                        value: Item,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = place , method , js_class = "SymbolDefinition" , catch)]
                    fn __TSB_place_FnPointToSymbolItem(
                        this: &SymbolDefinition_Class,
                        position: Point,
                    ) -> std::result::Result<SymbolItem, JsValue>;
                    #[wasm_bindgen(constructor, js_class = "SymbolDefinition")]
                    pub fn new(item: Item, dont_center: bool) -> SymbolDefinition_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = equals , method , js_class = "SymbolDefinition" , catch)]
                    fn __TSB_equals_FnSymbolDefinitionToBool(
                        this: &SymbolDefinition_Class,
                        symbol: SymbolDefinition,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = project , js_class = "SymbolDefinition")]
                    fn project(
                        this: &SymbolDefinition_Class,
                    ) -> std::result::Result<Project, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = project , js_class = "SymbolDefinition")]
                    fn set_project(
                        this: &SymbolDefinition_Class,
                        value: Project,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clone , method , js_class = "SymbolDefinition" , catch)]
                    fn __TSB_clone_FnToSymbolDefinition(
                        this: &SymbolDefinition_Class,
                    ) -> std::result::Result<SymbolDefinition, JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct SymbolDefinition(pub SymbolDefinition_Class);
                impl std::convert::From<SymbolDefinition> for JsValue {
                    fn from(src: SymbolDefinition) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for SymbolDefinition {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for SymbolDefinition {
                    fn instanceof(val: &JsValue) -> bool {
                        SymbolDefinition_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        SymbolDefinition(SymbolDefinition_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(SymbolDefinition_Class::unchecked_from_js_ref(val)
                                as *const SymbolDefinition_Class
                                as *const Self)
                        }
                    }
                }
                impl SymbolDefinition {
                    #[allow(dead_code, non_snake_case)]
                    pub fn item(&self) -> std::result::Result<Item, JsValue> {
                        let result = self.0.item();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_item(&self, value: Item) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_item(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn place(
                        &self,
                        position: Point,
                    ) -> std::result::Result<SymbolItem, JsValue> {
                        let result = self.0.__TSB_place_FnPointToSymbolItem(position);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new(item: Item, dont_center: bool) -> SymbolDefinition {
                        let result = SymbolDefinition_Class::new(item, dont_center);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        SymbolDefinition(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn equals(
                        &self,
                        symbol: SymbolDefinition,
                    ) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_equals_FnSymbolDefinitionToBool(symbol);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn project(&self) -> std::result::Result<Project, JsValue> {
                        let result = self.0.project();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_project(&self, value: Project) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_project(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn clone(&self) -> std::result::Result<SymbolDefinition, JsValue> {
                        let result = self.0.__TSB_clone_FnToSymbolDefinition();
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for SymbolDefinition {
                    fn describe() {
                        <SymbolDefinition_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for SymbolDefinition {
                    type Abi = <SymbolDefinition_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for SymbolDefinition {
                    type Abi = <SymbolDefinition_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        SymbolDefinition(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a SymbolDefinition {
                    type Abi =
                        <&'a SymbolDefinition_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for SymbolDefinition {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for SymbolDefinition {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: SymbolDefinition_Class =
                            <SymbolDefinition_Class as serde::de::Deserialize>::deserialize(
                                deserializer,
                            )?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait SymbolDefinition_Trait {
                    fn set_item(&mut self, value: Item) -> std::result::Result<(), JsValue>;
                    fn item(&self) -> std::result::Result<Item, JsValue>;
                    fn place(&self, position: Point) -> std::result::Result<SymbolItem, JsValue>;
                    fn equals(
                        &self,
                        symbol: SymbolDefinition,
                    ) -> std::result::Result<bool, JsValue>;
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue>;
                    fn project(&self) -> std::result::Result<Project, JsValue>;
                    fn clone(&self) -> std::result::Result<SymbolDefinition, JsValue>;
                }
                impl SymbolDefinition_Trait for SymbolDefinition {
                    fn set_item(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target = self;
                        SymbolDefinition::set_item(target, value)
                    }
                    fn item(&self) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        SymbolDefinition::item(target)
                    }
                    fn place(&self, position: Point) -> std::result::Result<SymbolItem, JsValue> {
                        let target = self;
                        SymbolDefinition::place(target, position)
                    }
                    fn equals(
                        &self,
                        symbol: SymbolDefinition,
                    ) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        SymbolDefinition::equals(target, symbol)
                    }
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue> {
                        let target = self;
                        SymbolDefinition::set_project(target, value)
                    }
                    fn project(&self) -> std::result::Result<Project, JsValue> {
                        let target = self;
                        SymbolDefinition::project(target)
                    }
                    fn clone(&self) -> std::result::Result<SymbolDefinition, JsValue> {
                        let target = self;
                        SymbolDefinition::clone(target)
                    }
                }
                impl std::clone::Clone for SymbolDefinition_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for SymbolDefinition_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for SymbolDefinition_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PointModuloParamsValue {
                    Point(Point),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemTweenParamsFrom {
                    F64(f64),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    JsValue(JsValue),
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    # [wasm_bindgen (js_name = "TextItem" , extends = Item_Class)]
                    pub type TextItem_Class;
                    # [wasm_bindgen (method , structural , catch , getter = justification , js_class = "TextItem")]
                    fn justification(this: &TextItem_Class)
                        -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = justification , js_class = "TextItem")]
                    fn set_justification(
                        this: &TextItem_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = fontFamily , js_class = "TextItem")]
                    fn font_family(this: &TextItem_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = fontFamily , js_class = "TextItem")]
                    fn set_font_family(
                        this: &TextItem_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = fontWeight , js_class = "TextItem")]
                    fn __TSB_font_weight(
                        this: &TextItem_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = fontWeight , js_class = "TextItem")]
                    fn __TSB_set_font_weight(
                        this: &TextItem_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = fontSize , js_class = "TextItem")]
                    fn __TSB_font_size(
                        this: &TextItem_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = fontSize , js_class = "TextItem")]
                    fn __TSB_set_font_size(
                        this: &TextItem_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = content , js_class = "TextItem")]
                    fn content(this: &TextItem_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = content , js_class = "TextItem")]
                    fn set_content(
                        this: &TextItem_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = leading , js_class = "TextItem")]
                    fn __TSB_leading(
                        this: &TextItem_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = leading , js_class = "TextItem")]
                    fn __TSB_set_leading(
                        this: &TextItem_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct TextItem(pub TextItem_Class);
                impl std::convert::From<&TextItem> for Item {
                    fn from(src: &TextItem) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl std::convert::From<&mut TextItem> for Item {
                    fn from(src: &mut TextItem) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl std::convert::From<TextItem> for JsValue {
                    fn from(src: TextItem) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for TextItem {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for TextItem {
                    fn instanceof(val: &JsValue) -> bool {
                        TextItem_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        TextItem(TextItem_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(TextItem_Class::unchecked_from_js_ref(val) as *const TextItem_Class
                                as *const Self)
                        }
                    }
                }
                impl TextItem {
                    #[allow(dead_code, non_snake_case)]
                    pub fn justification(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.justification();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_justification(
                        &self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_justification(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn font_family(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.font_family();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_font_family(
                        &self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_font_family(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn font_weight(&self) -> std::result::Result<TextItemFontWeight, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_font_weight()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_font_weight(
                        &self,
                        value: TextItemFontWeight,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_font_weight(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn font_size(&self) -> std::result::Result<TextItemFontSize, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_font_size()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_font_size(
                        &self,
                        value: TextItemFontSize,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_font_size(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn content(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.content();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_content(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_content(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn leading(&self) -> std::result::Result<TextItemLeading, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_leading()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_leading(
                        &self,
                        value: TextItemLeading,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_leading(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for TextItem {
                    fn describe() {
                        <TextItem_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for TextItem {
                    type Abi = <TextItem_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for TextItem {
                    type Abi = <TextItem_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        TextItem(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a TextItem {
                    type Abi = <&'a TextItem_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for TextItem {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for TextItem {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: TextItem_Class =
                            <TextItem_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait TextItem_Trait: Item_Trait {
                    fn set_justification(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    fn justification(&self) -> std::result::Result<String, JsValue>;
                    fn set_font_family(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    fn font_family(&self) -> std::result::Result<String, JsValue>;
                    fn set_font_weight(
                        &mut self,
                        value: TextItemFontWeight,
                    ) -> std::result::Result<(), JsValue>;
                    fn font_weight(&self) -> std::result::Result<TextItemFontWeight, JsValue>;
                    fn set_font_size(
                        &mut self,
                        value: TextItemFontSize,
                    ) -> std::result::Result<(), JsValue>;
                    fn font_size(&self) -> std::result::Result<TextItemFontSize, JsValue>;
                    fn set_content(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn content(&self) -> std::result::Result<String, JsValue>;
                    fn set_leading(
                        &mut self,
                        value: TextItemLeading,
                    ) -> std::result::Result<(), JsValue>;
                    fn leading(&self) -> std::result::Result<TextItemLeading, JsValue>;
                }
                impl Item_Trait for TextItem {
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::responds(&target, type_)
                    }
                    fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_content(&target, source)
                    }
                    fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_opacity(&target, value)
                    }
                    fn opacity(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::opacity(&target)
                    }
                    fn set_on_frame(
                        &mut self,
                        value: ItemOnFrame,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_frame(&target, value)
                    }
                    fn on_frame(&self) -> std::result::Result<ItemOnFrame, JsValue> {
                        let target: Item = self.into();
                        Item::on_frame(&target)
                    }
                    fn remove_children_FnToVecOfItem(
                        &self,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::remove_children_FnToVecOfItem(&target)
                    }
                    fn remove_children_FnF64AndF64ToVecOfItem(
                        &self,
                        start: f64,
                        end: f64,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::remove_children_FnF64AndF64ToVecOfItem(&target, start, end)
                    }
                    fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_below(&target, item)
                    }
                    fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_stroke(&target)
                    }
                    fn set_global_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_global_matrix(&target, value)
                    }
                    fn global_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::global_matrix(&target)
                    }
                    fn copy_attributes(
                        &self,
                        source: Item,
                        exclude_matrix: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_attributes(&target, source, exclude_matrix)
                    }
                    fn set_on_mouse_move(
                        &mut self,
                        value: ItemOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_move(&target, value)
                    }
                    fn on_mouse_move(&self) -> std::result::Result<ItemOnMouseMove, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_move(&target)
                    }
                    fn set_position(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_position(&target, value)
                    }
                    fn position(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::position(&target)
                    }
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_bounds(&target, value)
                    }
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::bounds(&target)
                    }
                    fn set_shadow_blur(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_shadow_blur(&target, value)
                    }
                    fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_blur(&target)
                    }
                    fn set_selected_color(
                        &mut self,
                        value: ItemSelectedColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_selected_color(&target, value)
                    }
                    fn selected_color(&self) -> std::result::Result<ItemSelectedColor, JsValue> {
                        let target: Item = self.into();
                        Item::selected_color(&target)
                    }
                    fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::reverse_children(&target)
                    }
                    fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::bring_to_front(&target)
                    }
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_selected(&target, value)
                    }
                    fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::selected(&target)
                    }
                    fn add_children(
                        &self,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::add_children(&target, items)
                    }
                    fn tween_to(
                        &self,
                        to: JsValue,
                        options: ItemTweenToParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_to(&target, to, options)
                    }
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_project(&target, value)
                    }
                    fn project(&self) -> std::result::Result<Project, JsValue> {
                        let target: Item = self.into();
                        Item::project(&target)
                    }
                    fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_name(&target, value)
                    }
                    fn name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::name(&target)
                    }
                    fn set_stroke_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_bounds(&target, value)
                    }
                    fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_bounds(&target)
                    }
                    fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_below(&target, item)
                    }
                    fn set_blend_mode(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_blend_mode(&target, value)
                    }
                    fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::blend_mode(&target)
                    }
                    fn set_clip_mask(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_clip_mask(&target, value)
                    }
                    fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::clip_mask(&target)
                    }
                    fn set_fill_color(
                        &mut self,
                        value: ItemFillColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_fill_color(&target, value)
                    }
                    fn fill_color(&self) -> std::result::Result<ItemFillColor, JsValue> {
                        let target: Item = self.into();
                        Item::fill_color(&target)
                    }
                    fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_drag(&target)
                    }
                    fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::add_child(&target, item)
                    }
                    fn scale_FnF64AndPointTo(
                        &self,
                        scale: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::scale_FnF64AndPointTo(&target, scale, center)
                    }
                    fn scale_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::scale_FnF64AndF64AndPointTo(&target, hor, ver, center)
                    }
                    fn set_first_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_first_child(&target, value)
                    }
                    fn first_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::first_child(&target)
                    }
                    fn set_style(&mut self, value: Style) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_style(&target, value)
                    }
                    fn style(&self) -> std::result::Result<Style, JsValue> {
                        let target: Item = self.into();
                        Item::style(&target)
                    }
                    fn set_class_name(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_class_name(&target, value)
                    }
                    fn class_name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::class_name(&target)
                    }
                    fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_grouped_with(&target, item)
                    }
                    fn set_shadow_offset(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_shadow_offset(&target, value)
                    }
                    fn shadow_offset(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_offset(&target)
                    }
                    fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inside(&target, rect)
                    }
                    fn set_children(
                        &mut self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_children(&target, value)
                    }
                    fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::children(&target)
                    }
                    fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_fill(&target)
                    }
                    fn matches_FnItemMatchesParamsOptionsToBool(
                        &self,
                        options: ItemMatchesParamsOptions,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::matches_FnItemMatchesParamsOptionsToBool(&target, options)
                    }
                    fn matches_FnStringAndJsValueToBool(
                        &self,
                        name: String,
                        compare: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::matches_FnStringAndJsValueToBool(&target, name, compare)
                    }
                    fn set_on_double_click(
                        &mut self,
                        value: ItemOnDoubleClick,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_double_click(&target, value)
                    }
                    fn on_double_click(&self) -> std::result::Result<ItemOnDoubleClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_double_click(&target)
                    }
                    fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::intersects(&target, item)
                    }
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_rotation(&target, value)
                    }
                    fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::rotation(&target)
                    }
                    fn set_on_mouse_down(
                        &mut self,
                        value: ItemOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_down(&target, value)
                    }
                    fn on_mouse_down(&self) -> std::result::Result<ItemOnMouseDown, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_down(&target)
                    }
                    fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_sibling(&target, item)
                    }
                    fn tween_from(
                        &self,
                        from: JsValue,
                        options: ItemTweenFromParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_from(&target, from, options)
                    }
                    fn set_layer(&mut self, value: Layer) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_layer(&target, value)
                    }
                    fn layer(&self) -> std::result::Result<Layer, JsValue> {
                        let target: Item = self.into();
                        Item::layer(&target)
                    }
                    fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::contains(&target, point)
                    }
                    fn set_on_click(
                        &mut self,
                        value: ItemOnClick,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_click(&target, value)
                    }
                    fn on_click(&self) -> std::result::Result<ItemOnClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_click(&target)
                    }
                    fn set_last_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_last_child(&target, value)
                    }
                    fn last_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::last_child(&target)
                    }
                    fn set_dash_offset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_dash_offset(&target, value)
                    }
                    fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::dash_offset(&target)
                    }
                    fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_id(&target, value)
                    }
                    fn id(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::id(&target)
                    }
                    fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_shadow(&target)
                    }
                    fn tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                        &self,
                        from: JsValue,
                        to: JsValue,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                            &target, from, to, options,
                        )
                    }
                    fn tween_FnJsValueAndItemTweenParamsOptionsToTween(
                        &self,
                        to: JsValue,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_FnJsValueAndItemTweenParamsOptionsToTween(&target, to, options)
                    }
                    fn tween_FnItemTweenParamsOptionsToTween(
                        &self,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_FnItemTweenParamsOptionsToTween(&target, options)
                    }
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_scaling(&target, value)
                    }
                    fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::scaling(&target)
                    }
                    fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::send_to_back(&target)
                    }
                    fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::set(&target, props)
                    }
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_index(&target, value)
                    }
                    fn index(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::index(&target)
                    }
                    fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::reduce(&target, options)
                    }
                    fn set_pivot(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_pivot(&target, value)
                    }
                    fn pivot(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::pivot(&target)
                    }
                    fn insert_children(
                        &self,
                        index: f64,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::insert_children(&target, index, items)
                    }
                    fn set_on_mouse_up(
                        &mut self,
                        value: ItemOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_up(&target, value)
                    }
                    fn on_mouse_up(&self) -> std::result::Result<ItemOnMouseUp, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_up(&target)
                    }
                    fn set_stroke_width(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_width(&target, value)
                    }
                    fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_width(&target)
                    }
                    fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on(&target, options)
                    }
                    fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_up(&target)
                    }
                    fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_child(&target, item)
                    }
                    fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::replace_with(&target, item)
                    }
                    fn export_json(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::export_json(&target, options)
                    }
                    fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test_all(&target, point, options)
                    }
                    fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                        let target: Item = self.into();
                        Item::export_svg(&target, options)
                    }
                    fn copy_to(
                        &self,
                        owner: ItemCopyToParamsOwner,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::copy_to(&target, owner)
                    }
                    fn set_matrix(&mut self, value: Matrix) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_matrix(&target, value)
                    }
                    fn matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::matrix(&target)
                    }
                    fn add_to(
                        &self,
                        owner: ItemAddToParamsOwner,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::add_to(&target, owner)
                    }
                    fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::rotate(&target, angle, center)
                    }
                    fn set_view_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_view_matrix(&target, value)
                    }
                    fn view_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::view_matrix(&target)
                    }
                    fn set_previous_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_previous_sibling(&target, value)
                    }
                    fn previous_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::previous_sibling(&target)
                    }
                    fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_data(&target, value)
                    }
                    fn data(&self) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::data(&target)
                    }
                    fn off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item :: off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                    }
                    fn off_FnJsValueToJsValue(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::off_FnJsValueToJsValue(&target, object)
                    }
                    fn set_stroke_scaling(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_scaling(&target, value)
                    }
                    fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_scaling(&target)
                    }
                    fn insert_child(
                        &self,
                        index: f64,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_child(&target, index, item)
                    }
                    fn skew_FnPointAndPointTo(
                        &self,
                        skew: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::skew_FnPointAndPointTo(&target, skew, center)
                    }
                    fn skew_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::skew_FnF64AndF64AndPointTo(&target, hor, ver, center)
                    }
                    fn on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item :: on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                    }
                    fn on_FnJsValueToJsValue(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::on_FnJsValueToJsValue(&target, object)
                    }
                    fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::remove(&target)
                    }
                    fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::global_to_local(&target, point)
                    }
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::emit(&target, type_, event)
                    }
                    fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test(&target, point, options)
                    }
                    fn import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                        &self,
                        svg: ItemImportSvgParamsSvg,
                        options: JsValue,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                            &target, svg, options,
                        )
                    }
                    fn import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem(
                        &self,
                        svg: ItemImportSvgParamsSvg,
                        on_load: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item :: import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem (& target , svg , on_load)
                    }
                    fn set_dash_array(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_dash_array(&target, value)
                    }
                    fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let target: Item = self.into();
                        Item::dash_array(&target)
                    }
                    fn shear_FnPointAndPointTo(
                        &self,
                        shear: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::shear_FnPointAndPointTo(&target, shear, center)
                    }
                    fn shear_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::shear_FnF64AndF64AndPointTo(&target, hor, ver, center)
                    }
                    fn set_internal_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_internal_bounds(&target, value)
                    }
                    fn internal_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::internal_bounds(&target)
                    }
                    fn set_stroke_cap(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_cap(&target, value)
                    }
                    fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_cap(&target)
                    }
                    fn set_on_mouse_enter(
                        &mut self,
                        value: ItemOnMouseEnter,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_enter(&target, value)
                    }
                    fn on_mouse_enter(&self) -> std::result::Result<ItemOnMouseEnter, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_enter(&target)
                    }
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_view(&target, value)
                    }
                    fn view(&self) -> std::result::Result<View, JsValue> {
                        let target: Item = self.into();
                        Item::view(&target)
                    }
                    fn set_stroke_join(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_join(&target, value)
                    }
                    fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_join(&target)
                    }
                    fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_ancestor(&target, item)
                    }
                    fn set_fill_rule(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_fill_rule(&target, value)
                    }
                    fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::fill_rule(&target)
                    }
                    fn fit_bounds(
                        &self,
                        rectangle: Rectangle,
                        fill: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::fit_bounds(&target, rectangle, fill)
                    }
                    fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_parent(&target, point)
                    }
                    fn set_handle_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_handle_bounds(&target, value)
                    }
                    fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::handle_bounds(&target)
                    }
                    fn set_next_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_next_sibling(&target, value)
                    }
                    fn next_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::next_sibling(&target)
                    }
                    fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::clone(&target, options)
                    }
                    fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_descendant(&target, item)
                    }
                    fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_down(&target)
                    }
                    fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_parent(&target, item)
                    }
                    fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_move(&target)
                    }
                    fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_empty(&target, recursively)
                    }
                    fn rasterize(&self, options: JsValue) -> std::result::Result<Raster, JsValue> {
                        let target: Item = self.into();
                        Item::rasterize(&target, options)
                    }
                    fn set_shadow_color(
                        &mut self,
                        value: ItemShadowColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_shadow_color(&target, value)
                    }
                    fn shadow_color(&self) -> std::result::Result<ItemShadowColor, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_color(&target)
                    }
                    fn set_miter_limit(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_miter_limit(&target, value)
                    }
                    fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::miter_limit(&target)
                    }
                    fn get_item(
                        &self,
                        options: ItemGetItemParamsOptions,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::get_item(&target, options)
                    }
                    fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_json(&target, json)
                    }
                    fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_above(&target, item)
                    }
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ItemOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_drag(&target, value)
                    }
                    fn on_mouse_drag(&self) -> std::result::Result<ItemOnMouseDrag, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_drag(&target)
                    }
                    fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inserted(&target)
                    }
                    fn set_apply_matrix(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_apply_matrix(&target, value)
                    }
                    fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::apply_matrix(&target)
                    }
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::transform(&target, matrix)
                    }
                    fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_visible(&target, value)
                    }
                    fn visible(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::visible(&target)
                    }
                    fn set_stroke_color(
                        &mut self,
                        value: ItemStrokeColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_color(&target, value)
                    }
                    fn stroke_color(&self) -> std::result::Result<ItemStrokeColor, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_color(&target)
                    }
                    fn set_on_mouse_leave(
                        &mut self,
                        value: ItemOnMouseLeave,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_leave(&target, value)
                    }
                    fn on_mouse_leave(&self) -> std::result::Result<ItemOnMouseLeave, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_leave(&target)
                    }
                    fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::parent_to_local(&target, point)
                    }
                    fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_above(&target, item)
                    }
                    fn get_items(
                        &self,
                        options: ItemGetItemsParamsOptions,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::get_items(&target, options)
                    }
                    fn has_children(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_children(&target)
                    }
                    fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::translate(&target, delta)
                    }
                    fn set_parent(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_parent(&target, value)
                    }
                    fn parent(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::parent(&target)
                    }
                    fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_locked(&target, value)
                    }
                    fn locked(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::locked(&target)
                    }
                    fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_global(&target, point)
                    }
                }
                impl TextItem_Trait for TextItem
                where
                    TextItem: Item_Trait,
                {
                    fn set_justification(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        TextItem::set_justification(target, value)
                    }
                    fn justification(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        TextItem::justification(target)
                    }
                    fn set_font_family(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        TextItem::set_font_family(target, value)
                    }
                    fn font_family(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        TextItem::font_family(target)
                    }
                    fn set_font_weight(
                        &mut self,
                        value: TextItemFontWeight,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        TextItem::set_font_weight(target, value)
                    }
                    fn font_weight(&self) -> std::result::Result<TextItemFontWeight, JsValue> {
                        let target = self;
                        TextItem::font_weight(target)
                    }
                    fn set_font_size(
                        &mut self,
                        value: TextItemFontSize,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        TextItem::set_font_size(target, value)
                    }
                    fn font_size(&self) -> std::result::Result<TextItemFontSize, JsValue> {
                        let target = self;
                        TextItem::font_size(target)
                    }
                    fn set_content(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target = self;
                        TextItem::set_content(target, value)
                    }
                    fn content(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        TextItem::content(target)
                    }
                    fn set_leading(
                        &mut self,
                        value: TextItemLeading,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        TextItem::set_leading(target, value)
                    }
                    fn leading(&self) -> std::result::Result<TextItemLeading, JsValue> {
                        let target = self;
                        TextItem::leading(target)
                    }
                }
                impl std::clone::Clone for TextItem_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for TextItem_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for TextItem_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemOnDoubleClick {
                    TsBindgenRtNull,
                    #[serde(
                        serialize_with = "ItemOnDoubleClick::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ItemOnDoubleClick::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                }
                impl ItemOnDoubleClick {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum MatrixShearReturn {
                    Matrix(Matrix),
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    #[wasm_bindgen(js_name = "GradientStop")]
                    pub type GradientStop_Class;
                    #[wasm_bindgen(constructor, js_class = "GradientStop")]
                    pub fn new(color: Color, offset: f64) -> GradientStop_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clone , method , js_class = "GradientStop" , catch)]
                    fn __TSB_clone_FnToGradientStop(
                        this: &GradientStop_Class,
                    ) -> std::result::Result<GradientStop, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = color , js_class = "GradientStop")]
                    fn color(this: &GradientStop_Class) -> std::result::Result<Color, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = color , js_class = "GradientStop")]
                    fn set_color(
                        this: &GradientStop_Class,
                        value: Color,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = offset , js_class = "GradientStop")]
                    fn offset(this: &GradientStop_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = offset , js_class = "GradientStop")]
                    fn set_offset(
                        this: &GradientStop_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct GradientStop(pub GradientStop_Class);
                impl std::convert::From<GradientStop> for JsValue {
                    fn from(src: GradientStop) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for GradientStop {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for GradientStop {
                    fn instanceof(val: &JsValue) -> bool {
                        GradientStop_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        GradientStop(GradientStop_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(GradientStop_Class::unchecked_from_js_ref(val)
                                as *const GradientStop_Class
                                as *const Self)
                        }
                    }
                }
                impl GradientStop {
                    #[allow(dead_code, non_snake_case)]
                    pub fn new(color: Color, offset: f64) -> GradientStop {
                        let result = GradientStop_Class::new(color, offset);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        GradientStop(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn clone(&self) -> std::result::Result<GradientStop, JsValue> {
                        let result = self.0.__TSB_clone_FnToGradientStop();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn color(&self) -> std::result::Result<Color, JsValue> {
                        let result = self.0.color();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_color(&self, value: Color) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_color(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn offset(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.offset();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_offset(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_offset(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for GradientStop {
                    fn describe() {
                        <GradientStop_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for GradientStop {
                    type Abi = <GradientStop_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for GradientStop {
                    type Abi = <GradientStop_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        GradientStop(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a GradientStop {
                    type Abi = <&'a GradientStop_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for GradientStop {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for GradientStop {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: GradientStop_Class =
                            <GradientStop_Class as serde::de::Deserialize>::deserialize(
                                deserializer,
                            )?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait GradientStop_Trait {
                    fn clone(&self) -> std::result::Result<GradientStop, JsValue>;
                    fn set_color(&mut self, value: Color) -> std::result::Result<(), JsValue>;
                    fn color(&self) -> std::result::Result<Color, JsValue>;
                    fn set_offset(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn offset(&self) -> std::result::Result<f64, JsValue>;
                }
                impl GradientStop_Trait for GradientStop {
                    fn clone(&self) -> std::result::Result<GradientStop, JsValue> {
                        let target = self;
                        GradientStop::clone(target)
                    }
                    fn set_color(&mut self, value: Color) -> std::result::Result<(), JsValue> {
                        let target = self;
                        GradientStop::set_color(target, value)
                    }
                    fn color(&self) -> std::result::Result<Color, JsValue> {
                        let target = self;
                        GradientStop::color(target)
                    }
                    fn set_offset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        GradientStop::set_offset(target, value)
                    }
                    fn offset(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        GradientStop::offset(target)
                    }
                }
                impl std::clone::Clone for GradientStop_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for GradientStop_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for GradientStop_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PathDivideAtParamsLocation {
                    CurveLocation(CurveLocation),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum TextItemLeading {
                    String(String),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemSkewParamsSkew {
                    Point(Point),
                    F64(f64),
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    # [wasm_bindgen (js_name = "Path" , extends = PathItem_Class , extends = Item_Class)]
                    pub type Path_Class;
                    # [wasm_bindgen (method , structural , catch , getter = lastSegment , js_class = "Path")]
                    fn last_segment(this: &Path_Class) -> std::result::Result<Segment, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = lastSegment , js_class = "Path")]
                    fn set_last_segment(
                        this: &Path_Class,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = insertSegments , method , js_class = "Path" , catch)]
                    fn __TSB_insert_segments_FnF64AndVecOfSegmentToVecOfSegment(
                        this: &Path_Class,
                        index: f64,
                        segments: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = curves , js_class = "Path")]
                    fn __TSB_curves(this: &Path_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = curves , js_class = "Path")]
                    fn __TSB_set_curves(
                        this: &Path_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getWeightedTangentAt , method , js_class = "Path" , catch)]
                    fn __TSB_get_weighted_tangent_at_FnF64ToPoint(
                        this: &Path_Class,
                        offset: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = fullySelected , js_class = "Path")]
                    fn fully_selected(this: &Path_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = fullySelected , js_class = "Path")]
                    fn set_fully_selected(
                        this: &Path_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = closed , js_class = "Path")]
                    fn closed(this: &Path_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = closed , js_class = "Path")]
                    fn set_closed(
                        this: &Path_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = add , method , js_class = "Path" , catch , variadic)]
                    fn __TSB_add_FnVecOfPathAddParamsSegmentToPathAddReturn(
                        this: &Path_Class,
                        segment: Box<[JsValue]>,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getOffsetOf , method , js_class = "Path" , catch)]
                    fn __TSB_get_offset_of_FnPointToF64(
                        this: &Path_Class,
                        point: Point,
                    ) -> std::result::Result<f64, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = addSegments , method , js_class = "Path" , catch)]
                    fn __TSB_add_segments_FnVecOfSegmentToVecOfSegment(
                        this: &Path_Class,
                        segments: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = hasHandles , method , js_class = "Path" , catch)]
                    fn __TSB_has_handles_FnToBool(
                        this: &Path_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = firstSegment , js_class = "Path")]
                    fn first_segment(this: &Path_Class) -> std::result::Result<Segment, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = firstSegment , js_class = "Path")]
                    fn set_first_segment(
                        this: &Path_Class,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = lastCurve , js_class = "Path")]
                    fn last_curve(this: &Path_Class) -> std::result::Result<Curve, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = lastCurve , js_class = "Path")]
                    fn set_last_curve(
                        this: &Path_Class,
                        value: Curve,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = removeSegments , method , js_class = "Path" , catch)]
                    fn __TSB_remove_segments_FnToVecOfSegment(
                        this: &Path_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = removeSegments , method , js_class = "Path" , catch)]
                    fn __TSB_remove_segments_FnF64AndF64ToVecOfSegment(
                        this: &Path_Class,
                        from: f64,
                        to: f64,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = divideAt , method , js_class = "Path" , catch)]
                    fn __TSB_divide_at_FnPathDivideAtParamsLocationToSegment(
                        this: &Path_Class,
                        location: JsValue,
                    ) -> std::result::Result<Segment, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = length , js_class = "Path")]
                    fn length(this: &Path_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = length , js_class = "Path")]
                    fn set_length(
                        this: &Path_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = splitAt , method , js_class = "Path" , catch)]
                    fn __TSB_split_at_FnPathSplitAtParamsLocationToPath(
                        this: &Path_Class,
                        location: JsValue,
                    ) -> std::result::Result<Path, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = removeSegment , method , js_class = "Path" , catch)]
                    fn __TSB_remove_segment_FnF64ToSegment(
                        this: &Path_Class,
                        index: f64,
                    ) -> std::result::Result<Segment, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = insert , method , js_class = "Path" , catch)]
                    fn __TSB_insert_FnF64AndPathInsertParamsSegmentToSegment(
                        this: &Path_Class,
                        index: f64,
                        segment: JsValue,
                    ) -> std::result::Result<Segment, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getLocationAt , method , js_class = "Path" , catch)]
                    fn __TSB_get_location_at_FnF64ToCurveLocation(
                        this: &Path_Class,
                        offset: f64,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    #[wasm_bindgen(constructor, js_class = "Path")]
                    pub fn new_FnVecOfSegmentToPath(segments: JsValue) -> Path_Class;
                    #[wasm_bindgen(constructor, js_class = "Path")]
                    pub fn new_FnStringToPath(path_data: String) -> Path_Class;
                    #[wasm_bindgen(constructor, js_class = "Path")]
                    pub fn new_FnJsValueToPath(object: JsValue) -> Path_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = toShape , method , js_class = "Path" , catch)]
                    fn __TSB_to_shape_FnBoolToShape(
                        this: &Path_Class,
                        insert: bool,
                    ) -> std::result::Result<Shape, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = segments , js_class = "Path")]
                    fn __TSB_segments(this: &Path_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = segments , js_class = "Path")]
                    fn __TSB_set_segments(
                        this: &Path_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getOffsetsWithTangent , method , js_class = "Path" , catch)]
                    fn __TSB_get_offsets_with_tangent_FnPointToVecOfF64(
                        this: &Path_Class,
                        tangent: Point,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getWeightedNormalAt , method , js_class = "Path" , catch)]
                    fn __TSB_get_weighted_normal_at_FnF64ToPoint(
                        this: &Path_Class,
                        offset: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = join , method , js_class = "Path" , catch)]
                    fn __TSB_join_FnPathAndF64To(
                        this: &Path_Class,
                        path: Path,
                        tolerance: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = area , js_class = "Path")]
                    fn area(this: &Path_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = area , js_class = "Path")]
                    fn set_area(this: &Path_Class, value: f64) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getLocationOf , method , js_class = "Path" , catch)]
                    fn __TSB_get_location_of_FnPointToCurveLocation(
                        this: &Path_Class,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getCurvatureAt , method , js_class = "Path" , catch)]
                    fn __TSB_get_curvature_at_FnF64ToF64(
                        this: &Path_Class,
                        offset: f64,
                    ) -> std::result::Result<f64, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getNormalAt , method , js_class = "Path" , catch)]
                    fn __TSB_get_normal_at_FnF64ToPoint(
                        this: &Path_Class,
                        offset: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getTangentAt , method , js_class = "Path" , catch)]
                    fn __TSB_get_tangent_at_FnF64ToPoint(
                        this: &Path_Class,
                        offset: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clearHandles , method , js_class = "Path" , catch)]
                    fn __TSB_clear_handles_FnTo(
                        this: &Path_Class,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = reduce , method , js_class = "Path" , catch)]
                    fn __TSB_reduce_FnJsValueToPath(
                        this: &Path_Class,
                        options: JsValue,
                    ) -> std::result::Result<Path, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = firstCurve , js_class = "Path")]
                    fn first_curve(this: &Path_Class) -> std::result::Result<Curve, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = firstCurve , js_class = "Path")]
                    fn set_first_curve(
                        this: &Path_Class,
                        value: Curve,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getPointAt , method , js_class = "Path" , catch)]
                    fn __TSB_get_point_at_FnF64ToPoint(
                        this: &Path_Class,
                        offset: f64,
                    ) -> std::result::Result<Point, JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Path(pub Path_Class);
                impl std::convert::From<&Path> for PathItem {
                    fn from(src: &Path) -> PathItem {
                        let src: &PathItem_Class = src.0.as_ref();
                        PathItem(src.clone())
                    }
                }
                impl std::convert::From<&mut Path> for PathItem {
                    fn from(src: &mut Path) -> PathItem {
                        let src: &PathItem_Class = src.0.as_ref();
                        PathItem(src.clone())
                    }
                }
                impl std::convert::From<&Path> for Item {
                    fn from(src: &Path) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl std::convert::From<&mut Path> for Item {
                    fn from(src: &mut Path) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl std::convert::From<Path> for JsValue {
                    fn from(src: Path) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for Path {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for Path {
                    fn instanceof(val: &JsValue) -> bool {
                        Path_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        Path(Path_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(Path_Class::unchecked_from_js_ref(val) as *const Path_Class
                                as *const Self)
                        }
                    }
                }
                impl Path {
                    #[allow(dead_code, non_snake_case)]
                    pub fn last_segment(&self) -> std::result::Result<Segment, JsValue> {
                        let result = self.0.last_segment();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_last_segment(
                        &self,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_last_segment(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn insert_segments(
                        &self,
                        index: f64,
                        segments: Vec<Segment>,
                    ) -> std::result::Result<Vec<Segment>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self
                                .0
                                .__TSB_insert_segments_FnF64AndVecOfSegmentToVecOfSegment(
                                    index,
                                    {
                                        let segments_array = js_sys::Array::new();
                                        for segments_item in segments {
                                            segments_array.push(&JsValue::from(segments_item));
                                        }
                                        segments_array.into()
                                    },
                                )?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn curves(&self) -> std::result::Result<Vec<Curve>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_curves()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_curves(
                        &self,
                        value: Vec<Curve>,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_curves({
                            let value_array = js_sys::Array::new();
                            for value_item in value {
                                value_array.push(&JsValue::from(value_item));
                            }
                            value_array.into()
                        });
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_weighted_tangent_at(
                        &self,
                        offset: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_get_weighted_tangent_at_FnF64ToPoint(offset);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn fully_selected(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.fully_selected();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_fully_selected(
                        &self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_fully_selected(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn closed(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.closed();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_closed(&self, value: bool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_closed(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn add(
                        &self,
                        segment: Vec<PathAddParamsSegment>,
                    ) -> std::result::Result<PathAddReturn, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self
                                .0
                                .__TSB_add_FnVecOfPathAddParamsSegmentToPathAddReturn(
                                    segment
                                        .into_iter()
                                        .map(|segment_item| {
                                            ts_bindgen_rt::to_jsvalue(&segment_item)
                                                .map_err(ts_bindgen_rt::Error::from)
                                                .map_err(JsValue::from)
                                        })
                                        .collect::<std::result::Result<Vec<_>, _>>()
                                        .map_err(ts_bindgen_rt::Error::from)
                                        .map_err(JsValue::from)?
                                        .into_boxed_slice(),
                                )?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_offset_of(&self, point: Point) -> std::result::Result<f64, JsValue> {
                        let result = self.0.__TSB_get_offset_of_FnPointToF64(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn add_segments(
                        &self,
                        segments: Vec<Segment>,
                    ) -> std::result::Result<Vec<Segment>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self.0.__TSB_add_segments_FnVecOfSegmentToVecOfSegment({
                                let segments_array = js_sys::Array::new();
                                for segments_item in segments {
                                    segments_array.push(&JsValue::from(segments_item));
                                }
                                segments_array.into()
                            })?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_has_handles_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn first_segment(&self) -> std::result::Result<Segment, JsValue> {
                        let result = self.0.first_segment();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_first_segment(
                        &self,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_first_segment(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn last_curve(&self) -> std::result::Result<Curve, JsValue> {
                        let result = self.0.last_curve();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_last_curve(&self, value: Curve) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_last_curve(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn remove_segments_FnToVecOfSegment(
                        &self,
                    ) -> std::result::Result<Vec<Segment>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self.0.__TSB_remove_segments_FnToVecOfSegment()?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn remove_segments_FnF64AndF64ToVecOfSegment(
                        &self,
                        from: f64,
                        to: f64,
                    ) -> std::result::Result<Vec<Segment>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self
                                .0
                                .__TSB_remove_segments_FnF64AndF64ToVecOfSegment(from, to)?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn divide_at(
                        &self,
                        location: PathDivideAtParamsLocation,
                    ) -> std::result::Result<Segment, JsValue> {
                        let result = self
                            .0
                            .__TSB_divide_at_FnPathDivideAtParamsLocationToSegment(
                                ts_bindgen_rt::to_jsvalue(&location)
                                    .map_err(ts_bindgen_rt::Error::from)
                                    .map_err(JsValue::from)?,
                            );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn length(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.length();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_length(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_length(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn split_at(
                        &self,
                        location: PathSplitAtParamsLocation,
                    ) -> std::result::Result<Path, JsValue> {
                        let result = self.0.__TSB_split_at_FnPathSplitAtParamsLocationToPath(
                            ts_bindgen_rt::to_jsvalue(&location)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn remove_segment(
                        &self,
                        index: f64,
                    ) -> std::result::Result<Segment, JsValue> {
                        let result = self.0.__TSB_remove_segment_FnF64ToSegment(index);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn insert(
                        &self,
                        index: f64,
                        segment: PathInsertParamsSegment,
                    ) -> std::result::Result<Segment, JsValue> {
                        let result = self
                            .0
                            .__TSB_insert_FnF64AndPathInsertParamsSegmentToSegment(
                                index,
                                ts_bindgen_rt::to_jsvalue(&segment)
                                    .map_err(ts_bindgen_rt::Error::from)
                                    .map_err(JsValue::from)?,
                            );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_location_at(
                        &self,
                        offset: f64,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let result = self.0.__TSB_get_location_at_FnF64ToCurveLocation(offset);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnVecOfSegmentToPath(segments: Vec<Segment>) -> Path {
                        let result = Path_Class::new_FnVecOfSegmentToPath({
                            let segments_array = js_sys::Array::new();
                            for segments_item in segments {
                                segments_array.push(&JsValue::from(segments_item));
                            }
                            segments_array.into()
                        });
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Path(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnStringToPath(path_data: String) -> Path {
                        let result = Path_Class::new_FnStringToPath(path_data);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Path(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnJsValueToPath(object: JsValue) -> Path {
                        let result = Path_Class::new_FnJsValueToPath(object);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Path(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn to_shape(&self, insert: bool) -> std::result::Result<Shape, JsValue> {
                        let result = self.0.__TSB_to_shape_FnBoolToShape(insert);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn segments(&self) -> std::result::Result<Vec<Segment>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_segments()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_segments(
                        &self,
                        value: Vec<Segment>,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_segments({
                            let value_array = js_sys::Array::new();
                            for value_item in value {
                                value_array.push(&JsValue::from(value_item));
                            }
                            value_array.into()
                        });
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_offsets_with_tangent(
                        &self,
                        tangent: Point,
                    ) -> std::result::Result<Vec<f64>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self
                                .0
                                .__TSB_get_offsets_with_tangent_FnPointToVecOfF64(tangent)?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_weighted_normal_at(
                        &self,
                        offset: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_get_weighted_normal_at_FnF64ToPoint(offset);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn join(
                        &self,
                        path: Path,
                        tolerance: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_join_FnPathAndF64To(path, tolerance);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn area(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.area();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_area(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_area(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_location_of(
                        &self,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let result = self.0.__TSB_get_location_of_FnPointToCurveLocation(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_curvature_at(
                        &self,
                        offset: f64,
                    ) -> std::result::Result<f64, JsValue> {
                        let result = self.0.__TSB_get_curvature_at_FnF64ToF64(offset);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_normal_at(
                        &self,
                        offset: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_get_normal_at_FnF64ToPoint(offset);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_tangent_at(
                        &self,
                        offset: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_get_tangent_at_FnF64ToPoint(offset);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_clear_handles_FnTo();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn reduce(&self, options: JsValue) -> std::result::Result<Path, JsValue> {
                        let result = self.0.__TSB_reduce_FnJsValueToPath(options);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn first_curve(&self) -> std::result::Result<Curve, JsValue> {
                        let result = self.0.first_curve();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_first_curve(
                        &self,
                        value: Curve,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_first_curve(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_point_at(&self, offset: f64) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_get_point_at_FnF64ToPoint(offset);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Path {
                    fn describe() {
                        <Path_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Path {
                    type Abi = <Path_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Path {
                    type Abi = <Path_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Path(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Path {
                    type Abi = <&'a Path_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Path {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Path {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Path_Class =
                            <Path_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait Path_Trait: PathItem_Trait {
                    fn set_last_segment(
                        &mut self,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue>;
                    fn last_segment(&self) -> std::result::Result<Segment, JsValue>;
                    fn insert_segments(
                        &self,
                        index: f64,
                        segments: Vec<Segment>,
                    ) -> std::result::Result<Vec<Segment>, JsValue>;
                    fn set_curves(&mut self, value: Vec<Curve>)
                        -> std::result::Result<(), JsValue>;
                    fn curves(&self) -> std::result::Result<Vec<Curve>, JsValue>;
                    fn get_weighted_tangent_at(
                        &self,
                        offset: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    fn set_fully_selected(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    fn fully_selected(&self) -> std::result::Result<bool, JsValue>;
                    fn set_closed(&mut self, value: bool) -> std::result::Result<(), JsValue>;
                    fn closed(&self) -> std::result::Result<bool, JsValue>;
                    fn add(
                        &self,
                        segment: Vec<PathAddParamsSegment>,
                    ) -> std::result::Result<PathAddReturn, JsValue>;
                    fn get_offset_of(&self, point: Point) -> std::result::Result<f64, JsValue>;
                    fn add_segments(
                        &self,
                        segments: Vec<Segment>,
                    ) -> std::result::Result<Vec<Segment>, JsValue>;
                    fn has_handles(&self) -> std::result::Result<bool, JsValue>;
                    fn set_first_segment(
                        &mut self,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue>;
                    fn first_segment(&self) -> std::result::Result<Segment, JsValue>;
                    fn set_last_curve(&mut self, value: Curve) -> std::result::Result<(), JsValue>;
                    fn last_curve(&self) -> std::result::Result<Curve, JsValue>;
                    fn remove_segments_FnToVecOfSegment(
                        &self,
                    ) -> std::result::Result<Vec<Segment>, JsValue>;
                    fn remove_segments_FnF64AndF64ToVecOfSegment(
                        &self,
                        from: f64,
                        to: f64,
                    ) -> std::result::Result<Vec<Segment>, JsValue>;
                    fn divide_at(
                        &self,
                        location: PathDivideAtParamsLocation,
                    ) -> std::result::Result<Segment, JsValue>;
                    fn set_length(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn length(&self) -> std::result::Result<f64, JsValue>;
                    fn split_at(
                        &self,
                        location: PathSplitAtParamsLocation,
                    ) -> std::result::Result<Path, JsValue>;
                    fn remove_segment(&self, index: f64) -> std::result::Result<Segment, JsValue>;
                    fn insert(
                        &self,
                        index: f64,
                        segment: PathInsertParamsSegment,
                    ) -> std::result::Result<Segment, JsValue>;
                    fn get_location_at(
                        &self,
                        offset: f64,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    fn to_shape(&self, insert: bool) -> std::result::Result<Shape, JsValue>;
                    fn set_segments(
                        &mut self,
                        value: Vec<Segment>,
                    ) -> std::result::Result<(), JsValue>;
                    fn segments(&self) -> std::result::Result<Vec<Segment>, JsValue>;
                    fn get_offsets_with_tangent(
                        &self,
                        tangent: Point,
                    ) -> std::result::Result<Vec<f64>, JsValue>;
                    fn get_weighted_normal_at(
                        &self,
                        offset: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    fn join(&self, path: Path, tolerance: f64) -> std::result::Result<(), JsValue>;
                    fn set_area(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn area(&self) -> std::result::Result<f64, JsValue>;
                    fn get_location_of(
                        &self,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    fn get_curvature_at(&self, offset: f64) -> std::result::Result<f64, JsValue>;
                    fn get_normal_at(&self, offset: f64) -> std::result::Result<Point, JsValue>;
                    fn get_tangent_at(&self, offset: f64) -> std::result::Result<Point, JsValue>;
                    fn clear_handles(&self) -> std::result::Result<(), JsValue>;
                    fn reduce(&self, options: JsValue) -> std::result::Result<Path, JsValue>;
                    fn set_first_curve(&mut self, value: Curve)
                        -> std::result::Result<(), JsValue>;
                    fn first_curve(&self) -> std::result::Result<Curve, JsValue>;
                    fn get_point_at(&self, offset: f64) -> std::result::Result<Point, JsValue>;
                }
                impl PathItem_Trait for Path
                where
                    Path: Item_Trait,
                {
                    fn unite(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::unite(&target, path, options)
                    }
                    fn line_by(&self, point: Point) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::line_by(&target, point)
                    }
                    fn move_to(&self, point: Point) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::move_to(&target, point)
                    }
                    fn set_path_data(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::set_path_data(&target, value)
                    }
                    fn path_data(&self) -> std::result::Result<String, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::path_data(&target)
                    }
                    fn intersect(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::intersect(&target, path, options)
                    }
                    fn create_FnStringToPathItemCreateReturn(
                        &self,
                        path_data: String,
                    ) -> std::result::Result<PathItemCreateReturn, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::create_FnStringToPathItemCreateReturn(&target, path_data)
                    }
                    fn create_FnVecOfVecOfF64ToPathItemCreateReturn(
                        &self,
                        segments: Vec<Vec<f64>>,
                    ) -> std::result::Result<PathItemCreateReturn, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::create_FnVecOfVecOfF64ToPathItemCreateReturn(&target, segments)
                    }
                    fn create_FnJsValueToPathItemCreateReturn(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<PathItemCreateReturn, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::create_FnJsValueToPathItemCreateReturn(&target, object)
                    }
                    fn smooth(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::smooth(&target, options)
                    }
                    fn compare(&self, path: PathItem) -> std::result::Result<bool, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::compare(&target, path)
                    }
                    fn arc_to_FnPointAndPointTo(
                        &self,
                        through: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::arc_to_FnPointAndPointTo(&target, through, to)
                    }
                    fn arc_to_FnPointAndBoolTo(
                        &self,
                        to: Point,
                        clockwise: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::arc_to_FnPointAndBoolTo(&target, to, clockwise)
                    }
                    fn quadratic_curve_to(
                        &self,
                        handle: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::quadratic_curve_to(&target, handle, to)
                    }
                    fn set_interior_point(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::set_interior_point(&target, value)
                    }
                    fn interior_point(&self) -> std::result::Result<Point, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::interior_point(&target)
                    }
                    fn simplify(&self, tolerance: f64) -> std::result::Result<bool, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::simplify(&target, tolerance)
                    }
                    fn reorient(
                        &self,
                        non_zero: bool,
                        clockwise: bool,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::reorient(&target, non_zero, clockwise)
                    }
                    fn cubic_curve_by(
                        &self,
                        handle1: Point,
                        handle2: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::cubic_curve_by(&target, handle1, handle2, to)
                    }
                    fn close_path(&self) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::close_path(&target)
                    }
                    fn flatten(&self, flatness: f64) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::flatten(&target, flatness)
                    }
                    fn quadratic_curve_by(
                        &self,
                        handle: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::quadratic_curve_by(&target, handle, to)
                    }
                    fn cubic_curve_to(
                        &self,
                        handle1: Point,
                        handle2: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::cubic_curve_to(&target, handle1, handle2, to)
                    }
                    fn divide(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::divide(&target, path, options)
                    }
                    fn arc_by_FnPointAndPointTo(
                        &self,
                        through: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::arc_by_FnPointAndPointTo(&target, through, to)
                    }
                    fn arc_by_FnPointAndBoolTo(
                        &self,
                        to: Point,
                        clockwise: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::arc_by_FnPointAndBoolTo(&target, to, clockwise)
                    }
                    fn move_by(&self, to: Point) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::move_by(&target, to)
                    }
                    fn get_nearest_location(
                        &self,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::get_nearest_location(&target, point)
                    }
                    fn reverse(&self) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::reverse(&target)
                    }
                    fn line_to(&self, point: Point) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::line_to(&target, point)
                    }
                    fn get_nearest_point(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::get_nearest_point(&target, point)
                    }
                    fn interpolate(
                        &self,
                        from: PathItem,
                        to: PathItem,
                        factor: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::interpolate(&target, from, to, factor)
                    }
                    fn get_crossings(
                        &self,
                        path: PathItem,
                    ) -> std::result::Result<Vec<CurveLocation>, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::get_crossings(&target, path)
                    }
                    fn curve_by(
                        &self,
                        through: Point,
                        to: Point,
                        time: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::curve_by(&target, through, to, time)
                    }
                    fn curve_to(
                        &self,
                        through: Point,
                        to: Point,
                        time: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::curve_to(&target, through, to, time)
                    }
                    fn subtract(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::subtract(&target, path, options)
                    }
                    fn get_intersections(
                        &self,
                        path: PathItem,
                        include: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Vec<CurveLocation>, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::get_intersections(&target, path, include)
                    }
                    fn exclude(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::exclude(&target, path, options)
                    }
                    fn set_clockwise(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::set_clockwise(&target, value)
                    }
                    fn clockwise(&self) -> std::result::Result<bool, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::clockwise(&target)
                    }
                }
                impl Item_Trait for Path {
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::responds(&target, type_)
                    }
                    fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_content(&target, source)
                    }
                    fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_opacity(&target, value)
                    }
                    fn opacity(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::opacity(&target)
                    }
                    fn set_on_frame(
                        &mut self,
                        value: ItemOnFrame,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_frame(&target, value)
                    }
                    fn on_frame(&self) -> std::result::Result<ItemOnFrame, JsValue> {
                        let target: Item = self.into();
                        Item::on_frame(&target)
                    }
                    fn remove_children_FnToVecOfItem(
                        &self,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::remove_children_FnToVecOfItem(&target)
                    }
                    fn remove_children_FnF64AndF64ToVecOfItem(
                        &self,
                        start: f64,
                        end: f64,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::remove_children_FnF64AndF64ToVecOfItem(&target, start, end)
                    }
                    fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_below(&target, item)
                    }
                    fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_stroke(&target)
                    }
                    fn set_global_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_global_matrix(&target, value)
                    }
                    fn global_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::global_matrix(&target)
                    }
                    fn copy_attributes(
                        &self,
                        source: Item,
                        exclude_matrix: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_attributes(&target, source, exclude_matrix)
                    }
                    fn set_on_mouse_move(
                        &mut self,
                        value: ItemOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_move(&target, value)
                    }
                    fn on_mouse_move(&self) -> std::result::Result<ItemOnMouseMove, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_move(&target)
                    }
                    fn set_position(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_position(&target, value)
                    }
                    fn position(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::position(&target)
                    }
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_bounds(&target, value)
                    }
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::bounds(&target)
                    }
                    fn set_shadow_blur(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_shadow_blur(&target, value)
                    }
                    fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_blur(&target)
                    }
                    fn set_selected_color(
                        &mut self,
                        value: ItemSelectedColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_selected_color(&target, value)
                    }
                    fn selected_color(&self) -> std::result::Result<ItemSelectedColor, JsValue> {
                        let target: Item = self.into();
                        Item::selected_color(&target)
                    }
                    fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::reverse_children(&target)
                    }
                    fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::bring_to_front(&target)
                    }
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_selected(&target, value)
                    }
                    fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::selected(&target)
                    }
                    fn add_children(
                        &self,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::add_children(&target, items)
                    }
                    fn tween_to(
                        &self,
                        to: JsValue,
                        options: ItemTweenToParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_to(&target, to, options)
                    }
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_project(&target, value)
                    }
                    fn project(&self) -> std::result::Result<Project, JsValue> {
                        let target: Item = self.into();
                        Item::project(&target)
                    }
                    fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_name(&target, value)
                    }
                    fn name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::name(&target)
                    }
                    fn set_stroke_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_bounds(&target, value)
                    }
                    fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_bounds(&target)
                    }
                    fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_below(&target, item)
                    }
                    fn set_blend_mode(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_blend_mode(&target, value)
                    }
                    fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::blend_mode(&target)
                    }
                    fn set_clip_mask(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_clip_mask(&target, value)
                    }
                    fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::clip_mask(&target)
                    }
                    fn set_fill_color(
                        &mut self,
                        value: ItemFillColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_fill_color(&target, value)
                    }
                    fn fill_color(&self) -> std::result::Result<ItemFillColor, JsValue> {
                        let target: Item = self.into();
                        Item::fill_color(&target)
                    }
                    fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_drag(&target)
                    }
                    fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::add_child(&target, item)
                    }
                    fn scale_FnF64AndPointTo(
                        &self,
                        scale: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::scale_FnF64AndPointTo(&target, scale, center)
                    }
                    fn scale_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::scale_FnF64AndF64AndPointTo(&target, hor, ver, center)
                    }
                    fn set_first_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_first_child(&target, value)
                    }
                    fn first_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::first_child(&target)
                    }
                    fn set_style(&mut self, value: Style) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_style(&target, value)
                    }
                    fn style(&self) -> std::result::Result<Style, JsValue> {
                        let target: Item = self.into();
                        Item::style(&target)
                    }
                    fn set_class_name(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_class_name(&target, value)
                    }
                    fn class_name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::class_name(&target)
                    }
                    fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_grouped_with(&target, item)
                    }
                    fn set_shadow_offset(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_shadow_offset(&target, value)
                    }
                    fn shadow_offset(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_offset(&target)
                    }
                    fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inside(&target, rect)
                    }
                    fn set_children(
                        &mut self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_children(&target, value)
                    }
                    fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::children(&target)
                    }
                    fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_fill(&target)
                    }
                    fn matches_FnItemMatchesParamsOptionsToBool(
                        &self,
                        options: ItemMatchesParamsOptions,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::matches_FnItemMatchesParamsOptionsToBool(&target, options)
                    }
                    fn matches_FnStringAndJsValueToBool(
                        &self,
                        name: String,
                        compare: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::matches_FnStringAndJsValueToBool(&target, name, compare)
                    }
                    fn set_on_double_click(
                        &mut self,
                        value: ItemOnDoubleClick,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_double_click(&target, value)
                    }
                    fn on_double_click(&self) -> std::result::Result<ItemOnDoubleClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_double_click(&target)
                    }
                    fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::intersects(&target, item)
                    }
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_rotation(&target, value)
                    }
                    fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::rotation(&target)
                    }
                    fn set_on_mouse_down(
                        &mut self,
                        value: ItemOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_down(&target, value)
                    }
                    fn on_mouse_down(&self) -> std::result::Result<ItemOnMouseDown, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_down(&target)
                    }
                    fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_sibling(&target, item)
                    }
                    fn tween_from(
                        &self,
                        from: JsValue,
                        options: ItemTweenFromParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_from(&target, from, options)
                    }
                    fn set_layer(&mut self, value: Layer) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_layer(&target, value)
                    }
                    fn layer(&self) -> std::result::Result<Layer, JsValue> {
                        let target: Item = self.into();
                        Item::layer(&target)
                    }
                    fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::contains(&target, point)
                    }
                    fn set_on_click(
                        &mut self,
                        value: ItemOnClick,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_click(&target, value)
                    }
                    fn on_click(&self) -> std::result::Result<ItemOnClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_click(&target)
                    }
                    fn set_last_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_last_child(&target, value)
                    }
                    fn last_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::last_child(&target)
                    }
                    fn set_dash_offset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_dash_offset(&target, value)
                    }
                    fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::dash_offset(&target)
                    }
                    fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_id(&target, value)
                    }
                    fn id(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::id(&target)
                    }
                    fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_shadow(&target)
                    }
                    fn tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                        &self,
                        from: JsValue,
                        to: JsValue,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                            &target, from, to, options,
                        )
                    }
                    fn tween_FnJsValueAndItemTweenParamsOptionsToTween(
                        &self,
                        to: JsValue,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_FnJsValueAndItemTweenParamsOptionsToTween(&target, to, options)
                    }
                    fn tween_FnItemTweenParamsOptionsToTween(
                        &self,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_FnItemTweenParamsOptionsToTween(&target, options)
                    }
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_scaling(&target, value)
                    }
                    fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::scaling(&target)
                    }
                    fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::send_to_back(&target)
                    }
                    fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::set(&target, props)
                    }
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_index(&target, value)
                    }
                    fn index(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::index(&target)
                    }
                    fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::reduce(&target, options)
                    }
                    fn set_pivot(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_pivot(&target, value)
                    }
                    fn pivot(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::pivot(&target)
                    }
                    fn insert_children(
                        &self,
                        index: f64,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::insert_children(&target, index, items)
                    }
                    fn set_on_mouse_up(
                        &mut self,
                        value: ItemOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_up(&target, value)
                    }
                    fn on_mouse_up(&self) -> std::result::Result<ItemOnMouseUp, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_up(&target)
                    }
                    fn set_stroke_width(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_width(&target, value)
                    }
                    fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_width(&target)
                    }
                    fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on(&target, options)
                    }
                    fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_up(&target)
                    }
                    fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_child(&target, item)
                    }
                    fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::replace_with(&target, item)
                    }
                    fn export_json(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::export_json(&target, options)
                    }
                    fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test_all(&target, point, options)
                    }
                    fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                        let target: Item = self.into();
                        Item::export_svg(&target, options)
                    }
                    fn copy_to(
                        &self,
                        owner: ItemCopyToParamsOwner,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::copy_to(&target, owner)
                    }
                    fn set_matrix(&mut self, value: Matrix) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_matrix(&target, value)
                    }
                    fn matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::matrix(&target)
                    }
                    fn add_to(
                        &self,
                        owner: ItemAddToParamsOwner,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::add_to(&target, owner)
                    }
                    fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::rotate(&target, angle, center)
                    }
                    fn set_view_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_view_matrix(&target, value)
                    }
                    fn view_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::view_matrix(&target)
                    }
                    fn set_previous_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_previous_sibling(&target, value)
                    }
                    fn previous_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::previous_sibling(&target)
                    }
                    fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_data(&target, value)
                    }
                    fn data(&self) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::data(&target)
                    }
                    fn off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item :: off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                    }
                    fn off_FnJsValueToJsValue(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::off_FnJsValueToJsValue(&target, object)
                    }
                    fn set_stroke_scaling(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_scaling(&target, value)
                    }
                    fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_scaling(&target)
                    }
                    fn insert_child(
                        &self,
                        index: f64,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_child(&target, index, item)
                    }
                    fn skew_FnPointAndPointTo(
                        &self,
                        skew: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::skew_FnPointAndPointTo(&target, skew, center)
                    }
                    fn skew_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::skew_FnF64AndF64AndPointTo(&target, hor, ver, center)
                    }
                    fn on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item :: on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                    }
                    fn on_FnJsValueToJsValue(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::on_FnJsValueToJsValue(&target, object)
                    }
                    fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::remove(&target)
                    }
                    fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::global_to_local(&target, point)
                    }
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::emit(&target, type_, event)
                    }
                    fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test(&target, point, options)
                    }
                    fn import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                        &self,
                        svg: ItemImportSvgParamsSvg,
                        options: JsValue,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                            &target, svg, options,
                        )
                    }
                    fn import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem(
                        &self,
                        svg: ItemImportSvgParamsSvg,
                        on_load: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item :: import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem (& target , svg , on_load)
                    }
                    fn set_dash_array(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_dash_array(&target, value)
                    }
                    fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let target: Item = self.into();
                        Item::dash_array(&target)
                    }
                    fn shear_FnPointAndPointTo(
                        &self,
                        shear: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::shear_FnPointAndPointTo(&target, shear, center)
                    }
                    fn shear_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::shear_FnF64AndF64AndPointTo(&target, hor, ver, center)
                    }
                    fn set_internal_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_internal_bounds(&target, value)
                    }
                    fn internal_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::internal_bounds(&target)
                    }
                    fn set_stroke_cap(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_cap(&target, value)
                    }
                    fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_cap(&target)
                    }
                    fn set_on_mouse_enter(
                        &mut self,
                        value: ItemOnMouseEnter,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_enter(&target, value)
                    }
                    fn on_mouse_enter(&self) -> std::result::Result<ItemOnMouseEnter, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_enter(&target)
                    }
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_view(&target, value)
                    }
                    fn view(&self) -> std::result::Result<View, JsValue> {
                        let target: Item = self.into();
                        Item::view(&target)
                    }
                    fn set_stroke_join(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_join(&target, value)
                    }
                    fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_join(&target)
                    }
                    fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_ancestor(&target, item)
                    }
                    fn set_fill_rule(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_fill_rule(&target, value)
                    }
                    fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::fill_rule(&target)
                    }
                    fn fit_bounds(
                        &self,
                        rectangle: Rectangle,
                        fill: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::fit_bounds(&target, rectangle, fill)
                    }
                    fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_parent(&target, point)
                    }
                    fn set_handle_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_handle_bounds(&target, value)
                    }
                    fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::handle_bounds(&target)
                    }
                    fn set_next_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_next_sibling(&target, value)
                    }
                    fn next_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::next_sibling(&target)
                    }
                    fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::clone(&target, options)
                    }
                    fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_descendant(&target, item)
                    }
                    fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_down(&target)
                    }
                    fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_parent(&target, item)
                    }
                    fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_move(&target)
                    }
                    fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_empty(&target, recursively)
                    }
                    fn rasterize(&self, options: JsValue) -> std::result::Result<Raster, JsValue> {
                        let target: Item = self.into();
                        Item::rasterize(&target, options)
                    }
                    fn set_shadow_color(
                        &mut self,
                        value: ItemShadowColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_shadow_color(&target, value)
                    }
                    fn shadow_color(&self) -> std::result::Result<ItemShadowColor, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_color(&target)
                    }
                    fn set_miter_limit(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_miter_limit(&target, value)
                    }
                    fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::miter_limit(&target)
                    }
                    fn get_item(
                        &self,
                        options: ItemGetItemParamsOptions,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::get_item(&target, options)
                    }
                    fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_json(&target, json)
                    }
                    fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_above(&target, item)
                    }
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ItemOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_drag(&target, value)
                    }
                    fn on_mouse_drag(&self) -> std::result::Result<ItemOnMouseDrag, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_drag(&target)
                    }
                    fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inserted(&target)
                    }
                    fn set_apply_matrix(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_apply_matrix(&target, value)
                    }
                    fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::apply_matrix(&target)
                    }
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::transform(&target, matrix)
                    }
                    fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_visible(&target, value)
                    }
                    fn visible(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::visible(&target)
                    }
                    fn set_stroke_color(
                        &mut self,
                        value: ItemStrokeColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_color(&target, value)
                    }
                    fn stroke_color(&self) -> std::result::Result<ItemStrokeColor, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_color(&target)
                    }
                    fn set_on_mouse_leave(
                        &mut self,
                        value: ItemOnMouseLeave,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_leave(&target, value)
                    }
                    fn on_mouse_leave(&self) -> std::result::Result<ItemOnMouseLeave, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_leave(&target)
                    }
                    fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::parent_to_local(&target, point)
                    }
                    fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_above(&target, item)
                    }
                    fn get_items(
                        &self,
                        options: ItemGetItemsParamsOptions,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::get_items(&target, options)
                    }
                    fn has_children(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_children(&target)
                    }
                    fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::translate(&target, delta)
                    }
                    fn set_parent(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_parent(&target, value)
                    }
                    fn parent(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::parent(&target)
                    }
                    fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_locked(&target, value)
                    }
                    fn locked(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::locked(&target)
                    }
                    fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_global(&target, point)
                    }
                }
                impl Path_Trait for Path
                where
                    Path: PathItem_Trait,
                {
                    fn set_last_segment(
                        &mut self,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Path::set_last_segment(target, value)
                    }
                    fn last_segment(&self) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        Path::last_segment(target)
                    }
                    fn insert_segments(
                        &self,
                        index: f64,
                        segments: Vec<Segment>,
                    ) -> std::result::Result<Vec<Segment>, JsValue> {
                        let target = self;
                        Path::insert_segments(target, index, segments)
                    }
                    fn set_curves(
                        &mut self,
                        value: Vec<Curve>,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Path::set_curves(target, value)
                    }
                    fn curves(&self) -> std::result::Result<Vec<Curve>, JsValue> {
                        let target = self;
                        Path::curves(target)
                    }
                    fn get_weighted_tangent_at(
                        &self,
                        offset: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Path::get_weighted_tangent_at(target, offset)
                    }
                    fn set_fully_selected(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Path::set_fully_selected(target, value)
                    }
                    fn fully_selected(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Path::fully_selected(target)
                    }
                    fn set_closed(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Path::set_closed(target, value)
                    }
                    fn closed(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Path::closed(target)
                    }
                    fn add(
                        &self,
                        segment: Vec<PathAddParamsSegment>,
                    ) -> std::result::Result<PathAddReturn, JsValue> {
                        let target = self;
                        Path::add(target, segment)
                    }
                    fn get_offset_of(&self, point: Point) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Path::get_offset_of(target, point)
                    }
                    fn add_segments(
                        &self,
                        segments: Vec<Segment>,
                    ) -> std::result::Result<Vec<Segment>, JsValue> {
                        let target = self;
                        Path::add_segments(target, segments)
                    }
                    fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Path::has_handles(target)
                    }
                    fn set_first_segment(
                        &mut self,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Path::set_first_segment(target, value)
                    }
                    fn first_segment(&self) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        Path::first_segment(target)
                    }
                    fn set_last_curve(&mut self, value: Curve) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Path::set_last_curve(target, value)
                    }
                    fn last_curve(&self) -> std::result::Result<Curve, JsValue> {
                        let target = self;
                        Path::last_curve(target)
                    }
                    fn remove_segments_FnToVecOfSegment(
                        &self,
                    ) -> std::result::Result<Vec<Segment>, JsValue> {
                        let target = self;
                        Path::remove_segments_FnToVecOfSegment(target)
                    }
                    fn remove_segments_FnF64AndF64ToVecOfSegment(
                        &self,
                        from: f64,
                        to: f64,
                    ) -> std::result::Result<Vec<Segment>, JsValue> {
                        let target = self;
                        Path::remove_segments_FnF64AndF64ToVecOfSegment(target, from, to)
                    }
                    fn divide_at(
                        &self,
                        location: PathDivideAtParamsLocation,
                    ) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        Path::divide_at(target, location)
                    }
                    fn set_length(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Path::set_length(target, value)
                    }
                    fn length(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Path::length(target)
                    }
                    fn split_at(
                        &self,
                        location: PathSplitAtParamsLocation,
                    ) -> std::result::Result<Path, JsValue> {
                        let target = self;
                        Path::split_at(target, location)
                    }
                    fn remove_segment(&self, index: f64) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        Path::remove_segment(target, index)
                    }
                    fn insert(
                        &self,
                        index: f64,
                        segment: PathInsertParamsSegment,
                    ) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        Path::insert(target, index, segment)
                    }
                    fn get_location_at(
                        &self,
                        offset: f64,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let target = self;
                        Path::get_location_at(target, offset)
                    }
                    fn to_shape(&self, insert: bool) -> std::result::Result<Shape, JsValue> {
                        let target = self;
                        Path::to_shape(target, insert)
                    }
                    fn set_segments(
                        &mut self,
                        value: Vec<Segment>,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Path::set_segments(target, value)
                    }
                    fn segments(&self) -> std::result::Result<Vec<Segment>, JsValue> {
                        let target = self;
                        Path::segments(target)
                    }
                    fn get_offsets_with_tangent(
                        &self,
                        tangent: Point,
                    ) -> std::result::Result<Vec<f64>, JsValue> {
                        let target = self;
                        Path::get_offsets_with_tangent(target, tangent)
                    }
                    fn get_weighted_normal_at(
                        &self,
                        offset: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Path::get_weighted_normal_at(target, offset)
                    }
                    fn join(&self, path: Path, tolerance: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Path::join(target, path, tolerance)
                    }
                    fn set_area(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Path::set_area(target, value)
                    }
                    fn area(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Path::area(target)
                    }
                    fn get_location_of(
                        &self,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let target = self;
                        Path::get_location_of(target, point)
                    }
                    fn get_curvature_at(&self, offset: f64) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Path::get_curvature_at(target, offset)
                    }
                    fn get_normal_at(&self, offset: f64) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Path::get_normal_at(target, offset)
                    }
                    fn get_tangent_at(&self, offset: f64) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Path::get_tangent_at(target, offset)
                    }
                    fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Path::clear_handles(target)
                    }
                    fn reduce(&self, options: JsValue) -> std::result::Result<Path, JsValue> {
                        let target = self;
                        Path::reduce(target, options)
                    }
                    fn set_first_curve(
                        &mut self,
                        value: Curve,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Path::set_first_curve(target, value)
                    }
                    fn first_curve(&self) -> std::result::Result<Curve, JsValue> {
                        let target = self;
                        Path::first_curve(target)
                    }
                    fn get_point_at(&self, offset: f64) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Path::get_point_at(target, offset)
                    }
                }
                impl std::clone::Clone for Path_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Path_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Path_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemOnMouseUp {
                    TsBindgenRtNull,
                    #[serde(
                        serialize_with = "ItemOnMouseUp::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ItemOnMouseUp::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                }
                impl ItemOnMouseUp {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum MatrixScaleParamsCenter {
                    Point(Point),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemFillColor {
                    Color(Color),
                    TsBindgenRtNull,
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    # [wasm_bindgen (js_name = "KeyEvent" , extends = Event_Class)]
                    pub type KeyEvent_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = toString , method , js_class = "KeyEvent" , catch)]
                    fn __TSB_to_string_FnToString(
                        this: &KeyEvent_Class,
                    ) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = key , js_class = "KeyEvent")]
                    fn key(this: &KeyEvent_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = key , js_class = "KeyEvent")]
                    fn set_key(
                        this: &KeyEvent_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = type , js_class = "KeyEvent")]
                    fn type_(this: &KeyEvent_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = type , js_class = "KeyEvent")]
                    fn set_type_(
                        this: &KeyEvent_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = character , js_class = "KeyEvent")]
                    fn character(this: &KeyEvent_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = character , js_class = "KeyEvent")]
                    fn set_character(
                        this: &KeyEvent_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct KeyEvent(pub KeyEvent_Class);
                impl std::convert::From<&KeyEvent> for Event {
                    fn from(src: &KeyEvent) -> Event {
                        let src: &Event_Class = src.0.as_ref();
                        Event(src.clone())
                    }
                }
                impl std::convert::From<&mut KeyEvent> for Event {
                    fn from(src: &mut KeyEvent) -> Event {
                        let src: &Event_Class = src.0.as_ref();
                        Event(src.clone())
                    }
                }
                impl std::convert::From<KeyEvent> for JsValue {
                    fn from(src: KeyEvent) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for KeyEvent {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for KeyEvent {
                    fn instanceof(val: &JsValue) -> bool {
                        KeyEvent_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        KeyEvent(KeyEvent_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(KeyEvent_Class::unchecked_from_js_ref(val) as *const KeyEvent_Class
                                as *const Self)
                        }
                    }
                }
                impl KeyEvent {
                    #[allow(dead_code, non_snake_case)]
                    pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.__TSB_to_string_FnToString();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn key(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.key();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_key(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_key(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn type_(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.type_();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_type_(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_type_(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn character(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.character();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_character(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_character(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for KeyEvent {
                    fn describe() {
                        <KeyEvent_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for KeyEvent {
                    type Abi = <KeyEvent_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for KeyEvent {
                    type Abi = <KeyEvent_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        KeyEvent(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a KeyEvent {
                    type Abi = <&'a KeyEvent_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for KeyEvent {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for KeyEvent {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: KeyEvent_Class =
                            <KeyEvent_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait KeyEvent_Trait: Event_Trait {
                    fn to_string(&self) -> std::result::Result<String, JsValue>;
                    fn set_key(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn key(&self) -> std::result::Result<String, JsValue>;
                    fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn type_(&self) -> std::result::Result<String, JsValue>;
                    fn set_character(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn character(&self) -> std::result::Result<String, JsValue>;
                }
                impl Event_Trait for KeyEvent {
                    fn set_modifiers(
                        &mut self,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Event = self.into();
                        Event::set_modifiers(&target, value)
                    }
                    fn modifiers(&self) -> std::result::Result<JsValue, JsValue> {
                        let target: Event = self.into();
                        Event::modifiers(&target)
                    }
                    fn set_time_stamp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Event = self.into();
                        Event::set_time_stamp(&target, value)
                    }
                    fn time_stamp(&self) -> std::result::Result<f64, JsValue> {
                        let target: Event = self.into();
                        Event::time_stamp(&target)
                    }
                    fn stop(&self) -> std::result::Result<(), JsValue> {
                        let target: Event = self.into();
                        Event::stop(&target)
                    }
                    fn stop_propagation(&self) -> std::result::Result<(), JsValue> {
                        let target: Event = self.into();
                        Event::stop_propagation(&target)
                    }
                    fn prevent_default(&self) -> std::result::Result<(), JsValue> {
                        let target: Event = self.into();
                        Event::prevent_default(&target)
                    }
                }
                impl KeyEvent_Trait for KeyEvent
                where
                    KeyEvent: Event_Trait,
                {
                    fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        KeyEvent::to_string(target)
                    }
                    fn set_key(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target = self;
                        KeyEvent::set_key(target, value)
                    }
                    fn key(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        KeyEvent::key(target)
                    }
                    fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target = self;
                        KeyEvent::set_type_(target, value)
                    }
                    fn type_(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        KeyEvent::type_(target)
                    }
                    fn set_character(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target = self;
                        KeyEvent::set_character(target, value)
                    }
                    fn character(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        KeyEvent::character(target)
                    }
                }
                impl std::clone::Clone for KeyEvent_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for KeyEvent_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for KeyEvent_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewOnMouseMove {
                    TsBindgenRtNull,
                    #[serde(
                        serialize_with = "ViewOnMouseMove::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ViewOnMouseMove::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                }
                impl ViewOnMouseMove {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewOnClick {
                    TsBindgenRtNull,
                    #[serde(
                        serialize_with = "ViewOnClick::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ViewOnClick::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                }
                impl ViewOnClick {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemScaleReturn {
                    __,
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    #[wasm_bindgen(js_name = "Matrix")]
                    pub type Matrix_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = reset , method , js_class = "Matrix" , catch)]
                    fn __TSB_reset_FnTo(this: &Matrix_Class) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isInvertible , method , js_class = "Matrix" , catch)]
                    fn __TSB_is_invertible_FnToBool(
                        this: &Matrix_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clone , method , js_class = "Matrix" , catch)]
                    fn __TSB_clone_FnToMatrix(
                        this: &Matrix_Class,
                    ) -> std::result::Result<Matrix, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isIdentity , method , js_class = "Matrix" , catch)]
                    fn __TSB_is_identity_FnToBool(
                        this: &Matrix_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = c , js_class = "Matrix")]
                    fn c(this: &Matrix_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = c , js_class = "Matrix")]
                    fn set_c(this: &Matrix_Class, value: f64) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = scaling , js_class = "Matrix")]
                    fn scaling(this: &Matrix_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = scaling , js_class = "Matrix")]
                    fn set_scaling(
                        this: &Matrix_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[wasm_bindgen(constructor, js_class = "Matrix")]
                    pub fn new_FnToMatrix() -> Matrix_Class;
                    #[wasm_bindgen(constructor, js_class = "Matrix")]
                    pub fn new_FnF64AndF64AndF64AndF64AndF64AndF64ToMatrix(
                        a: f64,
                        b: f64,
                        c: f64,
                        d: f64,
                        tx: f64,
                        ty: f64,
                    ) -> Matrix_Class;
                    #[wasm_bindgen(constructor, js_class = "Matrix")]
                    pub fn new_FnVecOfF64ToMatrix(values: JsValue) -> Matrix_Class;
                    #[wasm_bindgen(constructor, js_class = "Matrix")]
                    pub fn new_FnMatrixToMatrix(matrix: Matrix) -> Matrix_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = toString , method , js_class = "Matrix" , catch)]
                    fn __TSB_to_string_FnToString(
                        this: &Matrix_Class,
                    ) -> std::result::Result<String, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = append , method , js_class = "Matrix" , catch)]
                    fn __TSB_append_FnMatrixToMatrix(
                        this: &Matrix_Class,
                        matrix: Matrix,
                    ) -> std::result::Result<Matrix, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = applyToContext , method , js_class = "Matrix" , catch)]
                    fn __TSB_apply_to_context_FnWebSysCanvasRenderingContext2dTo(
                        this: &Matrix_Class,
                        ctx: web_sys::CanvasRenderingContext2d,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = tx , js_class = "Matrix")]
                    fn tx(this: &Matrix_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = tx , js_class = "Matrix")]
                    fn set_tx(this: &Matrix_Class, value: f64) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = values , js_class = "Matrix")]
                    fn __TSB_values(this: &Matrix_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = values , js_class = "Matrix")]
                    fn __TSB_set_values(
                        this: &Matrix_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = translate , method , js_class = "Matrix" , catch)]
                    fn __TSB_translate_FnPointToMatrix(
                        this: &Matrix_Class,
                        point: Point,
                    ) -> std::result::Result<Matrix, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = translate , method , js_class = "Matrix" , catch)]
                    fn __TSB_translate_FnF64AndF64ToMatrix(
                        this: &Matrix_Class,
                        dx: f64,
                        dy: f64,
                    ) -> std::result::Result<Matrix, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = invert , method , js_class = "Matrix" , catch)]
                    fn __TSB_invert_FnToMatrix(
                        this: &Matrix_Class,
                    ) -> std::result::Result<Matrix, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = rotation , js_class = "Matrix")]
                    fn rotation(this: &Matrix_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = rotation , js_class = "Matrix")]
                    fn set_rotation(
                        this: &Matrix_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = apply , method , js_class = "Matrix" , catch)]
                    fn __TSB_apply_FnBoolToBool(
                        this: &Matrix_Class,
                        recursively: bool,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = inverted , method , js_class = "Matrix" , catch)]
                    fn __TSB_inverted_FnToMatrix(
                        this: &Matrix_Class,
                    ) -> std::result::Result<Matrix, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isSingular , method , js_class = "Matrix" , catch)]
                    fn __TSB_is_singular_FnToBool(
                        this: &Matrix_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = a , js_class = "Matrix")]
                    fn a(this: &Matrix_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = a , js_class = "Matrix")]
                    fn set_a(this: &Matrix_Class, value: f64) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = ty , js_class = "Matrix")]
                    fn ty(this: &Matrix_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = ty , js_class = "Matrix")]
                    fn set_ty(this: &Matrix_Class, value: f64) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = equals , method , js_class = "Matrix" , catch)]
                    fn __TSB_equals_FnMatrixToBool(
                        this: &Matrix_Class,
                        matrix: Matrix,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = d , js_class = "Matrix")]
                    fn d(this: &Matrix_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = d , js_class = "Matrix")]
                    fn set_d(this: &Matrix_Class, value: f64) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = transform , method , js_class = "Matrix" , catch)]
                    fn __TSB_transform_FnPointToPoint(
                        this: &Matrix_Class,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = transform , method , js_class = "Matrix" , catch)]
                    fn __TSB_transform_FnVecOfF64AndVecOfF64AndF64ToVecOfF64(
                        this: &Matrix_Class,
                        src: JsValue,
                        dst: JsValue,
                        count: f64,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = appended , method , js_class = "Matrix" , catch)]
                    fn __TSB_appended_FnMatrixToMatrix(
                        this: &Matrix_Class,
                        matrix: Matrix,
                    ) -> std::result::Result<Matrix, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = set , method , js_class = "Matrix" , catch , variadic)]
                    fn __TSB_set_FnVecOfJsValueToPoint(
                        this: &Matrix_Class,
                        values: Box<[JsValue]>,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = shear , method , js_class = "Matrix" , catch)]
                    fn __TSB_shear_FnPointAndPointToMatrix(
                        this: &Matrix_Class,
                        shear: Point,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = shear , method , js_class = "Matrix" , catch)]
                    fn __TSB_shear_FnF64AndF64AndPointToMatrix(
                        this: &Matrix_Class,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = scale , method , js_class = "Matrix" , catch)]
                    fn __TSB_scale_FnF64AndPointToMatrix(
                        this: &Matrix_Class,
                        scale: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = scale , method , js_class = "Matrix" , catch)]
                    fn __TSB_scale_FnF64AndF64AndPointToMatrix(
                        this: &Matrix_Class,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = prepend , method , js_class = "Matrix" , catch)]
                    fn __TSB_prepend_FnMatrixToMatrix(
                        this: &Matrix_Class,
                        matrix: Matrix,
                    ) -> std::result::Result<Matrix, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = b , js_class = "Matrix")]
                    fn b(this: &Matrix_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = b , js_class = "Matrix")]
                    fn set_b(this: &Matrix_Class, value: f64) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = prepended , method , js_class = "Matrix" , catch)]
                    fn __TSB_prepended_FnMatrixToMatrix(
                        this: &Matrix_Class,
                        matrix: Matrix,
                    ) -> std::result::Result<Matrix, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = rotate , method , js_class = "Matrix" , catch)]
                    fn __TSB_rotate_FnF64AndPointToMatrix(
                        this: &Matrix_Class,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = rotate , method , js_class = "Matrix" , catch)]
                    fn __TSB_rotate_FnF64AndF64AndF64ToMatrix(
                        this: &Matrix_Class,
                        angle: f64,
                        x: f64,
                        y: f64,
                    ) -> std::result::Result<Matrix, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = translation , js_class = "Matrix")]
                    fn translation(this: &Matrix_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = translation , js_class = "Matrix")]
                    fn set_translation(
                        this: &Matrix_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = decompose , method , js_class = "Matrix" , catch)]
                    fn __TSB_decompose_FnToJsValue(
                        this: &Matrix_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = skew , method , js_class = "Matrix" , catch)]
                    fn __TSB_skew_FnPointAndPointToMatrix(
                        this: &Matrix_Class,
                        skew: Point,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = skew , method , js_class = "Matrix" , catch)]
                    fn __TSB_skew_FnF64AndF64AndPointToMatrix(
                        this: &Matrix_Class,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = inverseTransform , method , js_class = "Matrix" , catch)]
                    fn __TSB_inverse_transform_FnPointToPoint(
                        this: &Matrix_Class,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Matrix(pub Matrix_Class);
                impl std::default::Default for Matrix {
                    fn default() -> Self {
                        Self::new_FnToMatrix()
                    }
                }
                impl std::convert::From<Matrix> for JsValue {
                    fn from(src: Matrix) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for Matrix {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for Matrix {
                    fn instanceof(val: &JsValue) -> bool {
                        Matrix_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        Matrix(Matrix_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(Matrix_Class::unchecked_from_js_ref(val) as *const Matrix_Class
                                as *const Self)
                        }
                    }
                }
                impl Matrix {
                    #[allow(dead_code, non_snake_case)]
                    pub fn reset(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_reset_FnTo();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_invertible(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_invertible_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn clone(&self) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.__TSB_clone_FnToMatrix();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_identity(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_identity_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn c(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.c();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_c(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_c(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.scaling();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_scaling(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_scaling(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnToMatrix() -> Matrix {
                        let result = Matrix_Class::new_FnToMatrix();
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Matrix(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnF64AndF64AndF64AndF64AndF64AndF64ToMatrix(
                        a: f64,
                        b: f64,
                        c: f64,
                        d: f64,
                        tx: f64,
                        ty: f64,
                    ) -> Matrix {
                        let result = Matrix_Class::new_FnF64AndF64AndF64AndF64AndF64AndF64ToMatrix(
                            a, b, c, d, tx, ty,
                        );
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Matrix(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnVecOfF64ToMatrix(values: Vec<f64>) -> Matrix {
                        let result = Matrix_Class::new_FnVecOfF64ToMatrix({
                            let values_array = js_sys::Array::new();
                            for values_item in values {
                                values_array.push(&JsValue::from(values_item));
                            }
                            values_array.into()
                        });
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Matrix(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnMatrixToMatrix(matrix: Matrix) -> Matrix {
                        let result = Matrix_Class::new_FnMatrixToMatrix(matrix);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Matrix(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.__TSB_to_string_FnToString();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn append(&self, matrix: Matrix) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.__TSB_append_FnMatrixToMatrix(matrix);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn apply_to_context(
                        &self,
                        ctx: web_sys::CanvasRenderingContext2d,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self
                            .0
                            .__TSB_apply_to_context_FnWebSysCanvasRenderingContext2dTo(ctx);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn tx(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.tx();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_tx(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_tx(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn values(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_values()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_values(&self, value: Vec<f64>) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_values({
                            let value_array = js_sys::Array::new();
                            for value_item in value {
                                value_array.push(&JsValue::from(value_item));
                            }
                            value_array.into()
                        });
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn translate_FnPointToMatrix(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.__TSB_translate_FnPointToMatrix(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn translate_FnF64AndF64ToMatrix(
                        &self,
                        dx: f64,
                        dy: f64,
                    ) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.__TSB_translate_FnF64AndF64ToMatrix(dx, dy);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn invert(&self) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.__TSB_invert_FnToMatrix();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.rotation();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_rotation(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_rotation(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn apply(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_apply_FnBoolToBool(recursively);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn inverted(&self) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.__TSB_inverted_FnToMatrix();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_singular(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_singular_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn a(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.a();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_a(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_a(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn ty(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.ty();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_ty(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_ty(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn equals(&self, matrix: Matrix) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_equals_FnMatrixToBool(matrix);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn d(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.d();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_d(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_d(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn transform_FnPointToPoint(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_transform_FnPointToPoint(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn transform_FnVecOfF64AndVecOfF64AndF64ToVecOfF64(
                        &self,
                        src: Vec<f64>,
                        dst: Vec<f64>,
                        count: f64,
                    ) -> std::result::Result<Vec<f64>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self
                                .0
                                .__TSB_transform_FnVecOfF64AndVecOfF64AndF64ToVecOfF64(
                                    {
                                        let src_array = js_sys::Array::new();
                                        for src_item in src {
                                            src_array.push(&JsValue::from(src_item));
                                        }
                                        src_array.into()
                                    },
                                    {
                                        let dst_array = js_sys::Array::new();
                                        for dst_item in dst {
                                            dst_array.push(&JsValue::from(dst_item));
                                        }
                                        dst_array.into()
                                    },
                                    count,
                                )?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn appended(&self, matrix: Matrix) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.__TSB_appended_FnMatrixToMatrix(matrix);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set(&self, values: Vec<JsValue>) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_set_FnVecOfJsValueToPoint(
                            values
                                .into_iter()
                                .map(|values_item| JsValue::from(values_item))
                                .collect::<Vec<_>>()
                                .into_boxed_slice(),
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn shear_FnPointAndPointToMatrix(
                        &self,
                        shear: Point,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.__TSB_shear_FnPointAndPointToMatrix(shear, center);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn shear_FnF64AndF64AndPointToMatrix(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue> {
                        let result = self
                            .0
                            .__TSB_shear_FnF64AndF64AndPointToMatrix(hor, ver, center);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn scale_FnF64AndPointToMatrix(
                        &self,
                        scale: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.__TSB_scale_FnF64AndPointToMatrix(scale, center);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn scale_FnF64AndF64AndPointToMatrix(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue> {
                        let result = self
                            .0
                            .__TSB_scale_FnF64AndF64AndPointToMatrix(hor, ver, center);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn prepend(&self, matrix: Matrix) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.__TSB_prepend_FnMatrixToMatrix(matrix);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn b(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.b();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_b(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_b(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn prepended(
                        &self,
                        matrix: Matrix,
                    ) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.__TSB_prepended_FnMatrixToMatrix(matrix);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn rotate_FnF64AndPointToMatrix(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.__TSB_rotate_FnF64AndPointToMatrix(angle, center);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn rotate_FnF64AndF64AndF64ToMatrix(
                        &self,
                        angle: f64,
                        x: f64,
                        y: f64,
                    ) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.__TSB_rotate_FnF64AndF64AndF64ToMatrix(angle, x, y);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn translation(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.translation();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_translation(
                        &self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_translation(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn decompose(&self) -> std::result::Result<JsValue, JsValue> {
                        let result = self.0.__TSB_decompose_FnToJsValue();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn skew_FnPointAndPointToMatrix(
                        &self,
                        skew: Point,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.__TSB_skew_FnPointAndPointToMatrix(skew, center);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn skew_FnF64AndF64AndPointToMatrix(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue> {
                        let result = self
                            .0
                            .__TSB_skew_FnF64AndF64AndPointToMatrix(hor, ver, center);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn inverse_transform(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_inverse_transform_FnPointToPoint(point);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Matrix {
                    fn describe() {
                        <Matrix_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Matrix {
                    type Abi = <Matrix_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Matrix {
                    type Abi = <Matrix_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Matrix(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Matrix {
                    type Abi = <&'a Matrix_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Matrix {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Matrix {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Matrix_Class =
                            <Matrix_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait Matrix_Trait {
                    fn reset(&self) -> std::result::Result<(), JsValue>;
                    fn is_invertible(&self) -> std::result::Result<bool, JsValue>;
                    fn clone(&self) -> std::result::Result<Matrix, JsValue>;
                    fn is_identity(&self) -> std::result::Result<bool, JsValue>;
                    fn set_c(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn c(&self) -> std::result::Result<f64, JsValue>;
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn scaling(&self) -> std::result::Result<Point, JsValue>;
                    fn to_string(&self) -> std::result::Result<String, JsValue>;
                    fn append(&self, matrix: Matrix) -> std::result::Result<Matrix, JsValue>;
                    fn apply_to_context(
                        &self,
                        ctx: web_sys::CanvasRenderingContext2d,
                    ) -> std::result::Result<(), JsValue>;
                    fn set_tx(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn tx(&self) -> std::result::Result<f64, JsValue>;
                    fn set_values(&mut self, value: Vec<f64>) -> std::result::Result<(), JsValue>;
                    fn values(&self) -> std::result::Result<Vec<f64>, JsValue>;
                    fn translate_FnPointToMatrix(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Matrix, JsValue>;
                    fn translate_FnF64AndF64ToMatrix(
                        &self,
                        dx: f64,
                        dy: f64,
                    ) -> std::result::Result<Matrix, JsValue>;
                    fn invert(&self) -> std::result::Result<Matrix, JsValue>;
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn rotation(&self) -> std::result::Result<f64, JsValue>;
                    fn apply(&self, recursively: bool) -> std::result::Result<bool, JsValue>;
                    fn inverted(&self) -> std::result::Result<Matrix, JsValue>;
                    fn is_singular(&self) -> std::result::Result<bool, JsValue>;
                    fn set_a(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn a(&self) -> std::result::Result<f64, JsValue>;
                    fn set_ty(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn ty(&self) -> std::result::Result<f64, JsValue>;
                    fn equals(&self, matrix: Matrix) -> std::result::Result<bool, JsValue>;
                    fn set_d(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn d(&self) -> std::result::Result<f64, JsValue>;
                    fn transform_FnPointToPoint(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    fn transform_FnVecOfF64AndVecOfF64AndF64ToVecOfF64(
                        &self,
                        src: Vec<f64>,
                        dst: Vec<f64>,
                        count: f64,
                    ) -> std::result::Result<Vec<f64>, JsValue>;
                    fn appended(&self, matrix: Matrix) -> std::result::Result<Matrix, JsValue>;
                    fn set(&self, values: Vec<JsValue>) -> std::result::Result<Point, JsValue>;
                    fn shear_FnPointAndPointToMatrix(
                        &self,
                        shear: Point,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue>;
                    fn shear_FnF64AndF64AndPointToMatrix(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue>;
                    fn scale_FnF64AndPointToMatrix(
                        &self,
                        scale: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue>;
                    fn scale_FnF64AndF64AndPointToMatrix(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue>;
                    fn prepend(&self, matrix: Matrix) -> std::result::Result<Matrix, JsValue>;
                    fn set_b(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn b(&self) -> std::result::Result<f64, JsValue>;
                    fn prepended(&self, matrix: Matrix) -> std::result::Result<Matrix, JsValue>;
                    fn rotate_FnF64AndPointToMatrix(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue>;
                    fn rotate_FnF64AndF64AndF64ToMatrix(
                        &self,
                        angle: f64,
                        x: f64,
                        y: f64,
                    ) -> std::result::Result<Matrix, JsValue>;
                    fn set_translation(&mut self, value: Point)
                        -> std::result::Result<(), JsValue>;
                    fn translation(&self) -> std::result::Result<Point, JsValue>;
                    fn decompose(&self) -> std::result::Result<JsValue, JsValue>;
                    fn skew_FnPointAndPointToMatrix(
                        &self,
                        skew: Point,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue>;
                    fn skew_FnF64AndF64AndPointToMatrix(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue>;
                    fn inverse_transform(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                }
                impl Matrix_Trait for Matrix {
                    fn reset(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Matrix::reset(target)
                    }
                    fn is_invertible(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Matrix::is_invertible(target)
                    }
                    fn clone(&self) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Matrix::clone(target)
                    }
                    fn is_identity(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Matrix::is_identity(target)
                    }
                    fn set_c(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Matrix::set_c(target, value)
                    }
                    fn c(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Matrix::c(target)
                    }
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Matrix::set_scaling(target, value)
                    }
                    fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Matrix::scaling(target)
                    }
                    fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Matrix::to_string(target)
                    }
                    fn append(&self, matrix: Matrix) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Matrix::append(target, matrix)
                    }
                    fn apply_to_context(
                        &self,
                        ctx: web_sys::CanvasRenderingContext2d,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Matrix::apply_to_context(target, ctx)
                    }
                    fn set_tx(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Matrix::set_tx(target, value)
                    }
                    fn tx(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Matrix::tx(target)
                    }
                    fn set_values(&mut self, value: Vec<f64>) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Matrix::set_values(target, value)
                    }
                    fn values(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let target = self;
                        Matrix::values(target)
                    }
                    fn translate_FnPointToMatrix(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Matrix::translate_FnPointToMatrix(target, point)
                    }
                    fn translate_FnF64AndF64ToMatrix(
                        &self,
                        dx: f64,
                        dy: f64,
                    ) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Matrix::translate_FnF64AndF64ToMatrix(target, dx, dy)
                    }
                    fn invert(&self) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Matrix::invert(target)
                    }
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Matrix::set_rotation(target, value)
                    }
                    fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Matrix::rotation(target)
                    }
                    fn apply(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Matrix::apply(target, recursively)
                    }
                    fn inverted(&self) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Matrix::inverted(target)
                    }
                    fn is_singular(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Matrix::is_singular(target)
                    }
                    fn set_a(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Matrix::set_a(target, value)
                    }
                    fn a(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Matrix::a(target)
                    }
                    fn set_ty(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Matrix::set_ty(target, value)
                    }
                    fn ty(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Matrix::ty(target)
                    }
                    fn equals(&self, matrix: Matrix) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Matrix::equals(target, matrix)
                    }
                    fn set_d(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Matrix::set_d(target, value)
                    }
                    fn d(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Matrix::d(target)
                    }
                    fn transform_FnPointToPoint(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Matrix::transform_FnPointToPoint(target, point)
                    }
                    fn transform_FnVecOfF64AndVecOfF64AndF64ToVecOfF64(
                        &self,
                        src: Vec<f64>,
                        dst: Vec<f64>,
                        count: f64,
                    ) -> std::result::Result<Vec<f64>, JsValue> {
                        let target = self;
                        Matrix::transform_FnVecOfF64AndVecOfF64AndF64ToVecOfF64(
                            target, src, dst, count,
                        )
                    }
                    fn appended(&self, matrix: Matrix) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Matrix::appended(target, matrix)
                    }
                    fn set(&self, values: Vec<JsValue>) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Matrix::set(target, values)
                    }
                    fn shear_FnPointAndPointToMatrix(
                        &self,
                        shear: Point,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Matrix::shear_FnPointAndPointToMatrix(target, shear, center)
                    }
                    fn shear_FnF64AndF64AndPointToMatrix(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Matrix::shear_FnF64AndF64AndPointToMatrix(target, hor, ver, center)
                    }
                    fn scale_FnF64AndPointToMatrix(
                        &self,
                        scale: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Matrix::scale_FnF64AndPointToMatrix(target, scale, center)
                    }
                    fn scale_FnF64AndF64AndPointToMatrix(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Matrix::scale_FnF64AndF64AndPointToMatrix(target, hor, ver, center)
                    }
                    fn prepend(&self, matrix: Matrix) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Matrix::prepend(target, matrix)
                    }
                    fn set_b(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Matrix::set_b(target, value)
                    }
                    fn b(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Matrix::b(target)
                    }
                    fn prepended(&self, matrix: Matrix) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Matrix::prepended(target, matrix)
                    }
                    fn rotate_FnF64AndPointToMatrix(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Matrix::rotate_FnF64AndPointToMatrix(target, angle, center)
                    }
                    fn rotate_FnF64AndF64AndF64ToMatrix(
                        &self,
                        angle: f64,
                        x: f64,
                        y: f64,
                    ) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Matrix::rotate_FnF64AndF64AndF64ToMatrix(target, angle, x, y)
                    }
                    fn set_translation(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Matrix::set_translation(target, value)
                    }
                    fn translation(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Matrix::translation(target)
                    }
                    fn decompose(&self) -> std::result::Result<JsValue, JsValue> {
                        let target = self;
                        Matrix::decompose(target)
                    }
                    fn skew_FnPointAndPointToMatrix(
                        &self,
                        skew: Point,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Matrix::skew_FnPointAndPointToMatrix(target, skew, center)
                    }
                    fn skew_FnF64AndF64AndPointToMatrix(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Matrix::skew_FnF64AndF64AndPointToMatrix(target, hor, ver, center)
                    }
                    fn inverse_transform(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Matrix::inverse_transform(target, point)
                    }
                }
                impl std::clone::Clone for Matrix_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Matrix_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Matrix_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PathItemArcToReturn {
                    __,
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PathItemArcByParamsTo {
                    Point(Point),
                    Bool(bool),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemSkewParamsCenter {
                    Point(Point),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemOffReturn {
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    JsValue(JsValue),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ToolOnMouseMove {
                    TsBindgenRtNull,
                    #[serde(
                        serialize_with = "ToolOnMouseMove::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ToolOnMouseMove::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                }
                impl ToolOnMouseMove {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    # [wasm_bindgen (js_name = "Group" , extends = Item_Class)]
                    pub type Group_Class;
                    # [wasm_bindgen (method , structural , catch , getter = clipped , js_class = "Group")]
                    fn clipped(this: &Group_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = clipped , js_class = "Group")]
                    fn set_clipped(
                        this: &Group_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    #[wasm_bindgen(constructor, js_class = "Group")]
                    pub fn new_FnVecOfItemToGroup(children: JsValue) -> Group_Class;
                    #[wasm_bindgen(constructor, js_class = "Group")]
                    pub fn new_FnJsValueToGroup(object: JsValue) -> Group_Class;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Group(pub Group_Class);
                impl std::convert::From<&Group> for Item {
                    fn from(src: &Group) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl std::convert::From<&mut Group> for Item {
                    fn from(src: &mut Group) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl std::convert::From<Group> for JsValue {
                    fn from(src: Group) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for Group {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for Group {
                    fn instanceof(val: &JsValue) -> bool {
                        Group_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        Group(Group_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(Group_Class::unchecked_from_js_ref(val) as *const Group_Class
                                as *const Self)
                        }
                    }
                }
                impl Group {
                    #[allow(dead_code, non_snake_case)]
                    pub fn clipped(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.clipped();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_clipped(&self, value: bool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_clipped(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnVecOfItemToGroup(children: Vec<Item>) -> Group {
                        let result = Group_Class::new_FnVecOfItemToGroup({
                            let children_array = js_sys::Array::new();
                            for children_item in children {
                                children_array.push(&JsValue::from(children_item));
                            }
                            children_array.into()
                        });
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Group(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnJsValueToGroup(object: JsValue) -> Group {
                        let result = Group_Class::new_FnJsValueToGroup(object);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Group(result)
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Group {
                    fn describe() {
                        <Group_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Group {
                    type Abi = <Group_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Group {
                    type Abi = <Group_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Group(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Group {
                    type Abi = <&'a Group_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Group {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Group {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Group_Class =
                            <Group_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait Group_Trait: Item_Trait {
                    fn set_clipped(&mut self, value: bool) -> std::result::Result<(), JsValue>;
                    fn clipped(&self) -> std::result::Result<bool, JsValue>;
                }
                impl Item_Trait for Group {
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::responds(&target, type_)
                    }
                    fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_content(&target, source)
                    }
                    fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_opacity(&target, value)
                    }
                    fn opacity(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::opacity(&target)
                    }
                    fn set_on_frame(
                        &mut self,
                        value: ItemOnFrame,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_frame(&target, value)
                    }
                    fn on_frame(&self) -> std::result::Result<ItemOnFrame, JsValue> {
                        let target: Item = self.into();
                        Item::on_frame(&target)
                    }
                    fn remove_children_FnToVecOfItem(
                        &self,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::remove_children_FnToVecOfItem(&target)
                    }
                    fn remove_children_FnF64AndF64ToVecOfItem(
                        &self,
                        start: f64,
                        end: f64,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::remove_children_FnF64AndF64ToVecOfItem(&target, start, end)
                    }
                    fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_below(&target, item)
                    }
                    fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_stroke(&target)
                    }
                    fn set_global_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_global_matrix(&target, value)
                    }
                    fn global_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::global_matrix(&target)
                    }
                    fn copy_attributes(
                        &self,
                        source: Item,
                        exclude_matrix: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_attributes(&target, source, exclude_matrix)
                    }
                    fn set_on_mouse_move(
                        &mut self,
                        value: ItemOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_move(&target, value)
                    }
                    fn on_mouse_move(&self) -> std::result::Result<ItemOnMouseMove, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_move(&target)
                    }
                    fn set_position(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_position(&target, value)
                    }
                    fn position(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::position(&target)
                    }
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_bounds(&target, value)
                    }
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::bounds(&target)
                    }
                    fn set_shadow_blur(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_shadow_blur(&target, value)
                    }
                    fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_blur(&target)
                    }
                    fn set_selected_color(
                        &mut self,
                        value: ItemSelectedColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_selected_color(&target, value)
                    }
                    fn selected_color(&self) -> std::result::Result<ItemSelectedColor, JsValue> {
                        let target: Item = self.into();
                        Item::selected_color(&target)
                    }
                    fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::reverse_children(&target)
                    }
                    fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::bring_to_front(&target)
                    }
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_selected(&target, value)
                    }
                    fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::selected(&target)
                    }
                    fn add_children(
                        &self,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::add_children(&target, items)
                    }
                    fn tween_to(
                        &self,
                        to: JsValue,
                        options: ItemTweenToParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_to(&target, to, options)
                    }
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_project(&target, value)
                    }
                    fn project(&self) -> std::result::Result<Project, JsValue> {
                        let target: Item = self.into();
                        Item::project(&target)
                    }
                    fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_name(&target, value)
                    }
                    fn name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::name(&target)
                    }
                    fn set_stroke_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_bounds(&target, value)
                    }
                    fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_bounds(&target)
                    }
                    fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_below(&target, item)
                    }
                    fn set_blend_mode(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_blend_mode(&target, value)
                    }
                    fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::blend_mode(&target)
                    }
                    fn set_clip_mask(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_clip_mask(&target, value)
                    }
                    fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::clip_mask(&target)
                    }
                    fn set_fill_color(
                        &mut self,
                        value: ItemFillColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_fill_color(&target, value)
                    }
                    fn fill_color(&self) -> std::result::Result<ItemFillColor, JsValue> {
                        let target: Item = self.into();
                        Item::fill_color(&target)
                    }
                    fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_drag(&target)
                    }
                    fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::add_child(&target, item)
                    }
                    fn scale_FnF64AndPointTo(
                        &self,
                        scale: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::scale_FnF64AndPointTo(&target, scale, center)
                    }
                    fn scale_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::scale_FnF64AndF64AndPointTo(&target, hor, ver, center)
                    }
                    fn set_first_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_first_child(&target, value)
                    }
                    fn first_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::first_child(&target)
                    }
                    fn set_style(&mut self, value: Style) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_style(&target, value)
                    }
                    fn style(&self) -> std::result::Result<Style, JsValue> {
                        let target: Item = self.into();
                        Item::style(&target)
                    }
                    fn set_class_name(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_class_name(&target, value)
                    }
                    fn class_name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::class_name(&target)
                    }
                    fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_grouped_with(&target, item)
                    }
                    fn set_shadow_offset(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_shadow_offset(&target, value)
                    }
                    fn shadow_offset(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_offset(&target)
                    }
                    fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inside(&target, rect)
                    }
                    fn set_children(
                        &mut self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_children(&target, value)
                    }
                    fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::children(&target)
                    }
                    fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_fill(&target)
                    }
                    fn matches_FnItemMatchesParamsOptionsToBool(
                        &self,
                        options: ItemMatchesParamsOptions,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::matches_FnItemMatchesParamsOptionsToBool(&target, options)
                    }
                    fn matches_FnStringAndJsValueToBool(
                        &self,
                        name: String,
                        compare: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::matches_FnStringAndJsValueToBool(&target, name, compare)
                    }
                    fn set_on_double_click(
                        &mut self,
                        value: ItemOnDoubleClick,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_double_click(&target, value)
                    }
                    fn on_double_click(&self) -> std::result::Result<ItemOnDoubleClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_double_click(&target)
                    }
                    fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::intersects(&target, item)
                    }
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_rotation(&target, value)
                    }
                    fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::rotation(&target)
                    }
                    fn set_on_mouse_down(
                        &mut self,
                        value: ItemOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_down(&target, value)
                    }
                    fn on_mouse_down(&self) -> std::result::Result<ItemOnMouseDown, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_down(&target)
                    }
                    fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_sibling(&target, item)
                    }
                    fn tween_from(
                        &self,
                        from: JsValue,
                        options: ItemTweenFromParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_from(&target, from, options)
                    }
                    fn set_layer(&mut self, value: Layer) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_layer(&target, value)
                    }
                    fn layer(&self) -> std::result::Result<Layer, JsValue> {
                        let target: Item = self.into();
                        Item::layer(&target)
                    }
                    fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::contains(&target, point)
                    }
                    fn set_on_click(
                        &mut self,
                        value: ItemOnClick,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_click(&target, value)
                    }
                    fn on_click(&self) -> std::result::Result<ItemOnClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_click(&target)
                    }
                    fn set_last_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_last_child(&target, value)
                    }
                    fn last_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::last_child(&target)
                    }
                    fn set_dash_offset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_dash_offset(&target, value)
                    }
                    fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::dash_offset(&target)
                    }
                    fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_id(&target, value)
                    }
                    fn id(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::id(&target)
                    }
                    fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_shadow(&target)
                    }
                    fn tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                        &self,
                        from: JsValue,
                        to: JsValue,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                            &target, from, to, options,
                        )
                    }
                    fn tween_FnJsValueAndItemTweenParamsOptionsToTween(
                        &self,
                        to: JsValue,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_FnJsValueAndItemTweenParamsOptionsToTween(&target, to, options)
                    }
                    fn tween_FnItemTweenParamsOptionsToTween(
                        &self,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_FnItemTweenParamsOptionsToTween(&target, options)
                    }
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_scaling(&target, value)
                    }
                    fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::scaling(&target)
                    }
                    fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::send_to_back(&target)
                    }
                    fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::set(&target, props)
                    }
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_index(&target, value)
                    }
                    fn index(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::index(&target)
                    }
                    fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::reduce(&target, options)
                    }
                    fn set_pivot(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_pivot(&target, value)
                    }
                    fn pivot(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::pivot(&target)
                    }
                    fn insert_children(
                        &self,
                        index: f64,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::insert_children(&target, index, items)
                    }
                    fn set_on_mouse_up(
                        &mut self,
                        value: ItemOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_up(&target, value)
                    }
                    fn on_mouse_up(&self) -> std::result::Result<ItemOnMouseUp, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_up(&target)
                    }
                    fn set_stroke_width(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_width(&target, value)
                    }
                    fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_width(&target)
                    }
                    fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on(&target, options)
                    }
                    fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_up(&target)
                    }
                    fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_child(&target, item)
                    }
                    fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::replace_with(&target, item)
                    }
                    fn export_json(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::export_json(&target, options)
                    }
                    fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test_all(&target, point, options)
                    }
                    fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                        let target: Item = self.into();
                        Item::export_svg(&target, options)
                    }
                    fn copy_to(
                        &self,
                        owner: ItemCopyToParamsOwner,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::copy_to(&target, owner)
                    }
                    fn set_matrix(&mut self, value: Matrix) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_matrix(&target, value)
                    }
                    fn matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::matrix(&target)
                    }
                    fn add_to(
                        &self,
                        owner: ItemAddToParamsOwner,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::add_to(&target, owner)
                    }
                    fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::rotate(&target, angle, center)
                    }
                    fn set_view_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_view_matrix(&target, value)
                    }
                    fn view_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::view_matrix(&target)
                    }
                    fn set_previous_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_previous_sibling(&target, value)
                    }
                    fn previous_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::previous_sibling(&target)
                    }
                    fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_data(&target, value)
                    }
                    fn data(&self) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::data(&target)
                    }
                    fn off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item :: off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                    }
                    fn off_FnJsValueToJsValue(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::off_FnJsValueToJsValue(&target, object)
                    }
                    fn set_stroke_scaling(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_scaling(&target, value)
                    }
                    fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_scaling(&target)
                    }
                    fn insert_child(
                        &self,
                        index: f64,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_child(&target, index, item)
                    }
                    fn skew_FnPointAndPointTo(
                        &self,
                        skew: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::skew_FnPointAndPointTo(&target, skew, center)
                    }
                    fn skew_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::skew_FnF64AndF64AndPointTo(&target, hor, ver, center)
                    }
                    fn on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item :: on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                    }
                    fn on_FnJsValueToJsValue(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::on_FnJsValueToJsValue(&target, object)
                    }
                    fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::remove(&target)
                    }
                    fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::global_to_local(&target, point)
                    }
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::emit(&target, type_, event)
                    }
                    fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test(&target, point, options)
                    }
                    fn import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                        &self,
                        svg: ItemImportSvgParamsSvg,
                        options: JsValue,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                            &target, svg, options,
                        )
                    }
                    fn import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem(
                        &self,
                        svg: ItemImportSvgParamsSvg,
                        on_load: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item :: import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem (& target , svg , on_load)
                    }
                    fn set_dash_array(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_dash_array(&target, value)
                    }
                    fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let target: Item = self.into();
                        Item::dash_array(&target)
                    }
                    fn shear_FnPointAndPointTo(
                        &self,
                        shear: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::shear_FnPointAndPointTo(&target, shear, center)
                    }
                    fn shear_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::shear_FnF64AndF64AndPointTo(&target, hor, ver, center)
                    }
                    fn set_internal_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_internal_bounds(&target, value)
                    }
                    fn internal_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::internal_bounds(&target)
                    }
                    fn set_stroke_cap(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_cap(&target, value)
                    }
                    fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_cap(&target)
                    }
                    fn set_on_mouse_enter(
                        &mut self,
                        value: ItemOnMouseEnter,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_enter(&target, value)
                    }
                    fn on_mouse_enter(&self) -> std::result::Result<ItemOnMouseEnter, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_enter(&target)
                    }
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_view(&target, value)
                    }
                    fn view(&self) -> std::result::Result<View, JsValue> {
                        let target: Item = self.into();
                        Item::view(&target)
                    }
                    fn set_stroke_join(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_join(&target, value)
                    }
                    fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_join(&target)
                    }
                    fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_ancestor(&target, item)
                    }
                    fn set_fill_rule(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_fill_rule(&target, value)
                    }
                    fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::fill_rule(&target)
                    }
                    fn fit_bounds(
                        &self,
                        rectangle: Rectangle,
                        fill: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::fit_bounds(&target, rectangle, fill)
                    }
                    fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_parent(&target, point)
                    }
                    fn set_handle_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_handle_bounds(&target, value)
                    }
                    fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::handle_bounds(&target)
                    }
                    fn set_next_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_next_sibling(&target, value)
                    }
                    fn next_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::next_sibling(&target)
                    }
                    fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::clone(&target, options)
                    }
                    fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_descendant(&target, item)
                    }
                    fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_down(&target)
                    }
                    fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_parent(&target, item)
                    }
                    fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_move(&target)
                    }
                    fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_empty(&target, recursively)
                    }
                    fn rasterize(&self, options: JsValue) -> std::result::Result<Raster, JsValue> {
                        let target: Item = self.into();
                        Item::rasterize(&target, options)
                    }
                    fn set_shadow_color(
                        &mut self,
                        value: ItemShadowColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_shadow_color(&target, value)
                    }
                    fn shadow_color(&self) -> std::result::Result<ItemShadowColor, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_color(&target)
                    }
                    fn set_miter_limit(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_miter_limit(&target, value)
                    }
                    fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::miter_limit(&target)
                    }
                    fn get_item(
                        &self,
                        options: ItemGetItemParamsOptions,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::get_item(&target, options)
                    }
                    fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_json(&target, json)
                    }
                    fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_above(&target, item)
                    }
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ItemOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_drag(&target, value)
                    }
                    fn on_mouse_drag(&self) -> std::result::Result<ItemOnMouseDrag, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_drag(&target)
                    }
                    fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inserted(&target)
                    }
                    fn set_apply_matrix(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_apply_matrix(&target, value)
                    }
                    fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::apply_matrix(&target)
                    }
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::transform(&target, matrix)
                    }
                    fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_visible(&target, value)
                    }
                    fn visible(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::visible(&target)
                    }
                    fn set_stroke_color(
                        &mut self,
                        value: ItemStrokeColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_color(&target, value)
                    }
                    fn stroke_color(&self) -> std::result::Result<ItemStrokeColor, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_color(&target)
                    }
                    fn set_on_mouse_leave(
                        &mut self,
                        value: ItemOnMouseLeave,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_leave(&target, value)
                    }
                    fn on_mouse_leave(&self) -> std::result::Result<ItemOnMouseLeave, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_leave(&target)
                    }
                    fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::parent_to_local(&target, point)
                    }
                    fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_above(&target, item)
                    }
                    fn get_items(
                        &self,
                        options: ItemGetItemsParamsOptions,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::get_items(&target, options)
                    }
                    fn has_children(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_children(&target)
                    }
                    fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::translate(&target, delta)
                    }
                    fn set_parent(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_parent(&target, value)
                    }
                    fn parent(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::parent(&target)
                    }
                    fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_locked(&target, value)
                    }
                    fn locked(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::locked(&target)
                    }
                    fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_global(&target, point)
                    }
                }
                impl Group_Trait for Group
                where
                    Group: Item_Trait,
                {
                    fn set_clipped(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Group::set_clipped(target, value)
                    }
                    fn clipped(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Group::clipped(target)
                    }
                }
                impl std::clone::Clone for Group_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Group_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Group_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ToolOnKeyUp {
                    TsBindgenRtNull,
                    #[serde(
                        serialize_with = "ToolOnKeyUp::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ToolOnKeyUp::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                }
                impl ToolOnKeyUp {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ToolOnMouseDrag {
                    TsBindgenRtNull,
                    #[serde(
                        serialize_with = "ToolOnMouseDrag::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ToolOnMouseDrag::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                }
                impl ToolOnMouseDrag {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ToolOnReturn {
                    Tool(Tool),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemScaleParamsScale {
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PathItemCreateParamsPathData {
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    JsValue(JsValue),
                    VecOfVecOfF64(Vec<Vec<f64>>),
                    String(String),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PathRemoveSegmentsReturn {
                    VecOfSegment(Vec<Segment>),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ColorMultiplyReturn {
                    Color(Color),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PathSplitAtParamsLocation {
                    CurveLocation(CurveLocation),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum TextItemFontWeight {
                    F64(f64),
                    String(String),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewScaleParamsScale {
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum StyleStrokeColor {
                    Color(Color),
                    TsBindgenRtNull,
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemMatchesReturn {
                    Bool(bool),
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    #[wasm_bindgen(js_name = "HitResult")]
                    pub type HitResult_Class;
                    # [wasm_bindgen (method , structural , catch , getter = point , js_class = "HitResult")]
                    fn point(this: &HitResult_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = point , js_class = "HitResult")]
                    fn set_point(
                        this: &HitResult_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = item , js_class = "HitResult")]
                    fn item(this: &HitResult_Class) -> std::result::Result<Item, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = item , js_class = "HitResult")]
                    fn set_item(
                        this: &HitResult_Class,
                        value: Item,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = type , js_class = "HitResult")]
                    fn type_(this: &HitResult_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = type , js_class = "HitResult")]
                    fn set_type_(
                        this: &HitResult_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = location , js_class = "HitResult")]
                    fn location(
                        this: &HitResult_Class,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = location , js_class = "HitResult")]
                    fn set_location(
                        this: &HitResult_Class,
                        value: CurveLocation,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = segment , js_class = "HitResult")]
                    fn segment(this: &HitResult_Class) -> std::result::Result<Segment, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = segment , js_class = "HitResult")]
                    fn set_segment(
                        this: &HitResult_Class,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = color , js_class = "HitResult")]
                    fn __TSB_color(this: &HitResult_Class)
                        -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = color , js_class = "HitResult")]
                    fn __TSB_set_color(
                        this: &HitResult_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = name , js_class = "HitResult")]
                    fn name(this: &HitResult_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = name , js_class = "HitResult")]
                    fn set_name(
                        this: &HitResult_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct HitResult(pub HitResult_Class);
                impl std::convert::From<HitResult> for JsValue {
                    fn from(src: HitResult) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for HitResult {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for HitResult {
                    fn instanceof(val: &JsValue) -> bool {
                        HitResult_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        HitResult(HitResult_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(HitResult_Class::unchecked_from_js_ref(val) as *const HitResult_Class
                                as *const Self)
                        }
                    }
                }
                impl HitResult {
                    #[allow(dead_code, non_snake_case)]
                    pub fn point(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.point();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_point(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_point(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn item(&self) -> std::result::Result<Item, JsValue> {
                        let result = self.0.item();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_item(&self, value: Item) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_item(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn type_(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.type_();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_type_(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_type_(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn location(&self) -> std::result::Result<CurveLocation, JsValue> {
                        let result = self.0.location();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_location(
                        &self,
                        value: CurveLocation,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_location(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn segment(&self) -> std::result::Result<Segment, JsValue> {
                        let result = self.0.segment();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_segment(&self, value: Segment) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_segment(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn color(&self) -> std::result::Result<HitResultColor, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_color()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_color(
                        &self,
                        value: HitResultColor,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_color(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn name(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.name();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_name(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_name(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for HitResult {
                    fn describe() {
                        <HitResult_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for HitResult {
                    type Abi = <HitResult_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for HitResult {
                    type Abi = <HitResult_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        HitResult(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a HitResult {
                    type Abi = <&'a HitResult_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for HitResult {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for HitResult {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: HitResult_Class =
                            <HitResult_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait HitResult_Trait {
                    fn set_point(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn point(&self) -> std::result::Result<Point, JsValue>;
                    fn set_item(&mut self, value: Item) -> std::result::Result<(), JsValue>;
                    fn item(&self) -> std::result::Result<Item, JsValue>;
                    fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn type_(&self) -> std::result::Result<String, JsValue>;
                    fn set_location(
                        &mut self,
                        value: CurveLocation,
                    ) -> std::result::Result<(), JsValue>;
                    fn location(&self) -> std::result::Result<CurveLocation, JsValue>;
                    fn set_segment(&mut self, value: Segment) -> std::result::Result<(), JsValue>;
                    fn segment(&self) -> std::result::Result<Segment, JsValue>;
                    fn set_color(
                        &mut self,
                        value: HitResultColor,
                    ) -> std::result::Result<(), JsValue>;
                    fn color(&self) -> std::result::Result<HitResultColor, JsValue>;
                    fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn name(&self) -> std::result::Result<String, JsValue>;
                }
                impl HitResult_Trait for HitResult {
                    fn set_point(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        HitResult::set_point(target, value)
                    }
                    fn point(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        HitResult::point(target)
                    }
                    fn set_item(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target = self;
                        HitResult::set_item(target, value)
                    }
                    fn item(&self) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        HitResult::item(target)
                    }
                    fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target = self;
                        HitResult::set_type_(target, value)
                    }
                    fn type_(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        HitResult::type_(target)
                    }
                    fn set_location(
                        &mut self,
                        value: CurveLocation,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        HitResult::set_location(target, value)
                    }
                    fn location(&self) -> std::result::Result<CurveLocation, JsValue> {
                        let target = self;
                        HitResult::location(target)
                    }
                    fn set_segment(&mut self, value: Segment) -> std::result::Result<(), JsValue> {
                        let target = self;
                        HitResult::set_segment(target, value)
                    }
                    fn segment(&self) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        HitResult::segment(target)
                    }
                    fn set_color(
                        &mut self,
                        value: HitResultColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        HitResult::set_color(target, value)
                    }
                    fn color(&self) -> std::result::Result<HitResultColor, JsValue> {
                        let target = self;
                        HitResult::color(target)
                    }
                    fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target = self;
                        HitResult::set_name(target, value)
                    }
                    fn name(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        HitResult::name(target)
                    }
                }
                impl std::clone::Clone for HitResult_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for HitResult_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for HitResult_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemSkewReturn {
                    __,
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    #[wasm_bindgen(js_name = "Key")]
                    pub type Key_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isDown , method , js_class = "Key" , catch)]
                    fn __TSB_is_down_FnStringToBool(
                        this: &Key_Class,
                        key: String,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = modifiers , js_class = "Key")]
                    fn __TSB_modifiers(this: &Key_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = modifiers , js_class = "Key")]
                    fn __TSB_set_modifiers(
                        this: &Key_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Key(pub Key_Class);
                impl std::convert::From<Key> for JsValue {
                    fn from(src: Key) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for Key {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for Key {
                    fn instanceof(val: &JsValue) -> bool {
                        Key_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        Key(Key_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(Key_Class::unchecked_from_js_ref(val) as *const Key_Class
                                as *const Self)
                        }
                    }
                }
                impl Key {
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_down(&self, key: String) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_down_FnStringToBool(key);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn modifiers(&self) -> std::result::Result<JsValue, JsValue> {
                        let result = self.0.__TSB_modifiers();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_modifiers(
                        &self,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_modifiers(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Key {
                    fn describe() {
                        <Key_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Key {
                    type Abi = <Key_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Key {
                    type Abi = <Key_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Key(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Key {
                    type Abi = <&'a Key_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Key {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Key {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Key_Class =
                            <Key_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait Key_Trait {
                    fn is_down(&self, key: String) -> std::result::Result<bool, JsValue>;
                    fn set_modifiers(&mut self, value: JsValue)
                        -> std::result::Result<(), JsValue>;
                    fn modifiers(&self) -> std::result::Result<JsValue, JsValue>;
                }
                impl Key_Trait for Key {
                    fn is_down(&self, key: String) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Key::is_down(target, key)
                    }
                    fn set_modifiers(
                        &mut self,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Key::set_modifiers(target, value)
                    }
                    fn modifiers(&self) -> std::result::Result<JsValue, JsValue> {
                        let target = self;
                        Key::modifiers(target)
                    }
                }
                impl std::clone::Clone for Key_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Key_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Key_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum SizeMultiplyReturn {
                    Size(Size),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemTweenReturn {
                    Tween(Tween),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum RectangleScaleReturn {
                    Rectangle(Rectangle),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum StyleLeading {
                    String(String),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ColorAddParamsNumber {
                    Color(Color),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum CurveGetTangentAtParamsLocation {
                    CurveLocation(CurveLocation),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ProjectExportSvgReturn {
                    String(String),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    WebSysSvgElement(web_sys::SvgElement),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum RasterImage {
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    WebSysHtmlCanvasElement(web_sys::HtmlCanvasElement),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    WebSysHtmlImageElement(web_sys::HtmlImageElement),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemOnReturn {
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    JsValue(JsValue),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewOffParamsType {
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    JsValue(JsValue),
                    String(String),
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    # [wasm_bindgen (js_name = "ToolEvent" , extends = Event_Class)]
                    pub type ToolEvent_Class;
                    # [wasm_bindgen (method , structural , catch , getter = point , js_class = "ToolEvent")]
                    fn point(this: &ToolEvent_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = point , js_class = "ToolEvent")]
                    fn set_point(
                        this: &ToolEvent_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = delta , js_class = "ToolEvent")]
                    fn delta(this: &ToolEvent_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = delta , js_class = "ToolEvent")]
                    fn set_delta(
                        this: &ToolEvent_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = middlePoint , js_class = "ToolEvent")]
                    fn middle_point(this: &ToolEvent_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = middlePoint , js_class = "ToolEvent")]
                    fn set_middle_point(
                        this: &ToolEvent_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = item , js_class = "ToolEvent")]
                    fn item(this: &ToolEvent_Class) -> std::result::Result<Item, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = item , js_class = "ToolEvent")]
                    fn set_item(
                        this: &ToolEvent_Class,
                        value: Item,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = count , js_class = "ToolEvent")]
                    fn count(this: &ToolEvent_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = count , js_class = "ToolEvent")]
                    fn set_count(
                        this: &ToolEvent_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = type , js_class = "ToolEvent")]
                    fn type_(this: &ToolEvent_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = type , js_class = "ToolEvent")]
                    fn set_type_(
                        this: &ToolEvent_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = toString , method , js_class = "ToolEvent" , catch)]
                    fn __TSB_to_string_FnToString(
                        this: &ToolEvent_Class,
                    ) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = downPoint , js_class = "ToolEvent")]
                    fn down_point(this: &ToolEvent_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = downPoint , js_class = "ToolEvent")]
                    fn set_down_point(
                        this: &ToolEvent_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = lastPoint , js_class = "ToolEvent")]
                    fn last_point(this: &ToolEvent_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = lastPoint , js_class = "ToolEvent")]
                    fn set_last_point(
                        this: &ToolEvent_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct ToolEvent(pub ToolEvent_Class);
                impl std::convert::From<&ToolEvent> for Event {
                    fn from(src: &ToolEvent) -> Event {
                        let src: &Event_Class = src.0.as_ref();
                        Event(src.clone())
                    }
                }
                impl std::convert::From<&mut ToolEvent> for Event {
                    fn from(src: &mut ToolEvent) -> Event {
                        let src: &Event_Class = src.0.as_ref();
                        Event(src.clone())
                    }
                }
                impl std::convert::From<ToolEvent> for JsValue {
                    fn from(src: ToolEvent) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for ToolEvent {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for ToolEvent {
                    fn instanceof(val: &JsValue) -> bool {
                        ToolEvent_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        ToolEvent(ToolEvent_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(ToolEvent_Class::unchecked_from_js_ref(val) as *const ToolEvent_Class
                                as *const Self)
                        }
                    }
                }
                impl ToolEvent {
                    #[allow(dead_code, non_snake_case)]
                    pub fn point(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.point();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_point(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_point(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn delta(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.delta();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_delta(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_delta(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn middle_point(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.middle_point();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_middle_point(
                        &self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_middle_point(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn item(&self) -> std::result::Result<Item, JsValue> {
                        let result = self.0.item();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_item(&self, value: Item) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_item(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn count(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.count();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_count(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_count(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn type_(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.type_();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_type_(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_type_(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.__TSB_to_string_FnToString();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn down_point(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.down_point();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_down_point(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_down_point(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn last_point(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.last_point();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_last_point(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_last_point(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for ToolEvent {
                    fn describe() {
                        <ToolEvent_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for ToolEvent {
                    type Abi = <ToolEvent_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for ToolEvent {
                    type Abi = <ToolEvent_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        ToolEvent(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a ToolEvent {
                    type Abi = <&'a ToolEvent_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for ToolEvent {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for ToolEvent {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: ToolEvent_Class =
                            <ToolEvent_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait ToolEvent_Trait: Event_Trait {
                    fn set_point(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn point(&self) -> std::result::Result<Point, JsValue>;
                    fn set_delta(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn delta(&self) -> std::result::Result<Point, JsValue>;
                    fn set_middle_point(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn middle_point(&self) -> std::result::Result<Point, JsValue>;
                    fn set_item(&mut self, value: Item) -> std::result::Result<(), JsValue>;
                    fn item(&self) -> std::result::Result<Item, JsValue>;
                    fn set_count(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn count(&self) -> std::result::Result<f64, JsValue>;
                    fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn type_(&self) -> std::result::Result<String, JsValue>;
                    fn to_string(&self) -> std::result::Result<String, JsValue>;
                    fn set_down_point(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn down_point(&self) -> std::result::Result<Point, JsValue>;
                    fn set_last_point(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn last_point(&self) -> std::result::Result<Point, JsValue>;
                }
                impl Event_Trait for ToolEvent {
                    fn set_modifiers(
                        &mut self,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Event = self.into();
                        Event::set_modifiers(&target, value)
                    }
                    fn modifiers(&self) -> std::result::Result<JsValue, JsValue> {
                        let target: Event = self.into();
                        Event::modifiers(&target)
                    }
                    fn set_time_stamp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Event = self.into();
                        Event::set_time_stamp(&target, value)
                    }
                    fn time_stamp(&self) -> std::result::Result<f64, JsValue> {
                        let target: Event = self.into();
                        Event::time_stamp(&target)
                    }
                    fn stop(&self) -> std::result::Result<(), JsValue> {
                        let target: Event = self.into();
                        Event::stop(&target)
                    }
                    fn stop_propagation(&self) -> std::result::Result<(), JsValue> {
                        let target: Event = self.into();
                        Event::stop_propagation(&target)
                    }
                    fn prevent_default(&self) -> std::result::Result<(), JsValue> {
                        let target: Event = self.into();
                        Event::prevent_default(&target)
                    }
                }
                impl ToolEvent_Trait for ToolEvent
                where
                    ToolEvent: Event_Trait,
                {
                    fn set_point(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        ToolEvent::set_point(target, value)
                    }
                    fn point(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        ToolEvent::point(target)
                    }
                    fn set_delta(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        ToolEvent::set_delta(target, value)
                    }
                    fn delta(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        ToolEvent::delta(target)
                    }
                    fn set_middle_point(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        ToolEvent::set_middle_point(target, value)
                    }
                    fn middle_point(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        ToolEvent::middle_point(target)
                    }
                    fn set_item(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target = self;
                        ToolEvent::set_item(target, value)
                    }
                    fn item(&self) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        ToolEvent::item(target)
                    }
                    fn set_count(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        ToolEvent::set_count(target, value)
                    }
                    fn count(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        ToolEvent::count(target)
                    }
                    fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target = self;
                        ToolEvent::set_type_(target, value)
                    }
                    fn type_(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        ToolEvent::type_(target)
                    }
                    fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        ToolEvent::to_string(target)
                    }
                    fn set_down_point(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        ToolEvent::set_down_point(target, value)
                    }
                    fn down_point(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        ToolEvent::down_point(target)
                    }
                    fn set_last_point(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        ToolEvent::set_last_point(target, value)
                    }
                    fn last_point(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        ToolEvent::last_point(target)
                    }
                }
                impl std::clone::Clone for ToolEvent_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for ToolEvent_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for ToolEvent_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemOnMouseDown {
                    TsBindgenRtNull,
                    #[serde(
                        serialize_with = "ItemOnMouseDown::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ItemOnMouseDown::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                }
                impl ItemOnMouseDown {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum RectangleScaleParamsAmount {
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum MatrixRotateParamsCenter {
                    Point(Point),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ProjectConstructorElement {
                    Size(Size),
                    String(String),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    WebSysHtmlCanvasElement(web_sys::HtmlCanvasElement),
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    # [wasm_bindgen (js_name = "Layer" , extends = Group_Class , extends = Item_Class)]
                    pub type Layer_Class;
                    #[wasm_bindgen(constructor, js_class = "Layer")]
                    pub fn new_FnVecOfItemToLayer(children: JsValue) -> Layer_Class;
                    #[wasm_bindgen(constructor, js_class = "Layer")]
                    pub fn new_FnJsValueToLayer(object: JsValue) -> Layer_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = activate , method , js_class = "Layer" , catch)]
                    fn __TSB_activate_FnTo(this: &Layer_Class) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Layer(pub Layer_Class);
                impl std::convert::From<&Layer> for Item {
                    fn from(src: &Layer) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl std::convert::From<&mut Layer> for Item {
                    fn from(src: &mut Layer) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl std::convert::From<&Layer> for Group {
                    fn from(src: &Layer) -> Group {
                        let src: &Group_Class = src.0.as_ref();
                        Group(src.clone())
                    }
                }
                impl std::convert::From<&mut Layer> for Group {
                    fn from(src: &mut Layer) -> Group {
                        let src: &Group_Class = src.0.as_ref();
                        Group(src.clone())
                    }
                }
                impl std::convert::From<Layer> for JsValue {
                    fn from(src: Layer) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for Layer {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for Layer {
                    fn instanceof(val: &JsValue) -> bool {
                        Layer_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        Layer(Layer_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(Layer_Class::unchecked_from_js_ref(val) as *const Layer_Class
                                as *const Self)
                        }
                    }
                }
                impl Layer {
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnVecOfItemToLayer(children: Vec<Item>) -> Layer {
                        let result = Layer_Class::new_FnVecOfItemToLayer({
                            let children_array = js_sys::Array::new();
                            for children_item in children {
                                children_array.push(&JsValue::from(children_item));
                            }
                            children_array.into()
                        });
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Layer(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnJsValueToLayer(object: JsValue) -> Layer {
                        let result = Layer_Class::new_FnJsValueToLayer(object);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Layer(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn activate(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_activate_FnTo();
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Layer {
                    fn describe() {
                        <Layer_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Layer {
                    type Abi = <Layer_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Layer {
                    type Abi = <Layer_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Layer(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Layer {
                    type Abi = <&'a Layer_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Layer {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Layer {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Layer_Class =
                            <Layer_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait Layer_Trait: Group_Trait {
                    fn activate(&self) -> std::result::Result<(), JsValue>;
                }
                impl Group_Trait for Layer
                where
                    Layer: Item_Trait,
                {
                    fn set_clipped(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Group = self.into();
                        Group::set_clipped(&target, value)
                    }
                    fn clipped(&self) -> std::result::Result<bool, JsValue> {
                        let target: Group = self.into();
                        Group::clipped(&target)
                    }
                }
                impl Item_Trait for Layer {
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::responds(&target, type_)
                    }
                    fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_content(&target, source)
                    }
                    fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_opacity(&target, value)
                    }
                    fn opacity(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::opacity(&target)
                    }
                    fn set_on_frame(
                        &mut self,
                        value: ItemOnFrame,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_frame(&target, value)
                    }
                    fn on_frame(&self) -> std::result::Result<ItemOnFrame, JsValue> {
                        let target: Item = self.into();
                        Item::on_frame(&target)
                    }
                    fn remove_children_FnToVecOfItem(
                        &self,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::remove_children_FnToVecOfItem(&target)
                    }
                    fn remove_children_FnF64AndF64ToVecOfItem(
                        &self,
                        start: f64,
                        end: f64,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::remove_children_FnF64AndF64ToVecOfItem(&target, start, end)
                    }
                    fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_below(&target, item)
                    }
                    fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_stroke(&target)
                    }
                    fn set_global_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_global_matrix(&target, value)
                    }
                    fn global_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::global_matrix(&target)
                    }
                    fn copy_attributes(
                        &self,
                        source: Item,
                        exclude_matrix: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_attributes(&target, source, exclude_matrix)
                    }
                    fn set_on_mouse_move(
                        &mut self,
                        value: ItemOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_move(&target, value)
                    }
                    fn on_mouse_move(&self) -> std::result::Result<ItemOnMouseMove, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_move(&target)
                    }
                    fn set_position(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_position(&target, value)
                    }
                    fn position(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::position(&target)
                    }
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_bounds(&target, value)
                    }
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::bounds(&target)
                    }
                    fn set_shadow_blur(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_shadow_blur(&target, value)
                    }
                    fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_blur(&target)
                    }
                    fn set_selected_color(
                        &mut self,
                        value: ItemSelectedColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_selected_color(&target, value)
                    }
                    fn selected_color(&self) -> std::result::Result<ItemSelectedColor, JsValue> {
                        let target: Item = self.into();
                        Item::selected_color(&target)
                    }
                    fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::reverse_children(&target)
                    }
                    fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::bring_to_front(&target)
                    }
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_selected(&target, value)
                    }
                    fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::selected(&target)
                    }
                    fn add_children(
                        &self,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::add_children(&target, items)
                    }
                    fn tween_to(
                        &self,
                        to: JsValue,
                        options: ItemTweenToParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_to(&target, to, options)
                    }
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_project(&target, value)
                    }
                    fn project(&self) -> std::result::Result<Project, JsValue> {
                        let target: Item = self.into();
                        Item::project(&target)
                    }
                    fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_name(&target, value)
                    }
                    fn name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::name(&target)
                    }
                    fn set_stroke_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_bounds(&target, value)
                    }
                    fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_bounds(&target)
                    }
                    fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_below(&target, item)
                    }
                    fn set_blend_mode(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_blend_mode(&target, value)
                    }
                    fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::blend_mode(&target)
                    }
                    fn set_clip_mask(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_clip_mask(&target, value)
                    }
                    fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::clip_mask(&target)
                    }
                    fn set_fill_color(
                        &mut self,
                        value: ItemFillColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_fill_color(&target, value)
                    }
                    fn fill_color(&self) -> std::result::Result<ItemFillColor, JsValue> {
                        let target: Item = self.into();
                        Item::fill_color(&target)
                    }
                    fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_drag(&target)
                    }
                    fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::add_child(&target, item)
                    }
                    fn scale_FnF64AndPointTo(
                        &self,
                        scale: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::scale_FnF64AndPointTo(&target, scale, center)
                    }
                    fn scale_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::scale_FnF64AndF64AndPointTo(&target, hor, ver, center)
                    }
                    fn set_first_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_first_child(&target, value)
                    }
                    fn first_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::first_child(&target)
                    }
                    fn set_style(&mut self, value: Style) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_style(&target, value)
                    }
                    fn style(&self) -> std::result::Result<Style, JsValue> {
                        let target: Item = self.into();
                        Item::style(&target)
                    }
                    fn set_class_name(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_class_name(&target, value)
                    }
                    fn class_name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::class_name(&target)
                    }
                    fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_grouped_with(&target, item)
                    }
                    fn set_shadow_offset(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_shadow_offset(&target, value)
                    }
                    fn shadow_offset(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_offset(&target)
                    }
                    fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inside(&target, rect)
                    }
                    fn set_children(
                        &mut self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_children(&target, value)
                    }
                    fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::children(&target)
                    }
                    fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_fill(&target)
                    }
                    fn matches_FnItemMatchesParamsOptionsToBool(
                        &self,
                        options: ItemMatchesParamsOptions,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::matches_FnItemMatchesParamsOptionsToBool(&target, options)
                    }
                    fn matches_FnStringAndJsValueToBool(
                        &self,
                        name: String,
                        compare: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::matches_FnStringAndJsValueToBool(&target, name, compare)
                    }
                    fn set_on_double_click(
                        &mut self,
                        value: ItemOnDoubleClick,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_double_click(&target, value)
                    }
                    fn on_double_click(&self) -> std::result::Result<ItemOnDoubleClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_double_click(&target)
                    }
                    fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::intersects(&target, item)
                    }
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_rotation(&target, value)
                    }
                    fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::rotation(&target)
                    }
                    fn set_on_mouse_down(
                        &mut self,
                        value: ItemOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_down(&target, value)
                    }
                    fn on_mouse_down(&self) -> std::result::Result<ItemOnMouseDown, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_down(&target)
                    }
                    fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_sibling(&target, item)
                    }
                    fn tween_from(
                        &self,
                        from: JsValue,
                        options: ItemTweenFromParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_from(&target, from, options)
                    }
                    fn set_layer(&mut self, value: Layer) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_layer(&target, value)
                    }
                    fn layer(&self) -> std::result::Result<Layer, JsValue> {
                        let target: Item = self.into();
                        Item::layer(&target)
                    }
                    fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::contains(&target, point)
                    }
                    fn set_on_click(
                        &mut self,
                        value: ItemOnClick,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_click(&target, value)
                    }
                    fn on_click(&self) -> std::result::Result<ItemOnClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_click(&target)
                    }
                    fn set_last_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_last_child(&target, value)
                    }
                    fn last_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::last_child(&target)
                    }
                    fn set_dash_offset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_dash_offset(&target, value)
                    }
                    fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::dash_offset(&target)
                    }
                    fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_id(&target, value)
                    }
                    fn id(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::id(&target)
                    }
                    fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_shadow(&target)
                    }
                    fn tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                        &self,
                        from: JsValue,
                        to: JsValue,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                            &target, from, to, options,
                        )
                    }
                    fn tween_FnJsValueAndItemTweenParamsOptionsToTween(
                        &self,
                        to: JsValue,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_FnJsValueAndItemTweenParamsOptionsToTween(&target, to, options)
                    }
                    fn tween_FnItemTweenParamsOptionsToTween(
                        &self,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_FnItemTweenParamsOptionsToTween(&target, options)
                    }
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_scaling(&target, value)
                    }
                    fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::scaling(&target)
                    }
                    fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::send_to_back(&target)
                    }
                    fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::set(&target, props)
                    }
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_index(&target, value)
                    }
                    fn index(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::index(&target)
                    }
                    fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::reduce(&target, options)
                    }
                    fn set_pivot(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_pivot(&target, value)
                    }
                    fn pivot(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::pivot(&target)
                    }
                    fn insert_children(
                        &self,
                        index: f64,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::insert_children(&target, index, items)
                    }
                    fn set_on_mouse_up(
                        &mut self,
                        value: ItemOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_up(&target, value)
                    }
                    fn on_mouse_up(&self) -> std::result::Result<ItemOnMouseUp, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_up(&target)
                    }
                    fn set_stroke_width(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_width(&target, value)
                    }
                    fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_width(&target)
                    }
                    fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on(&target, options)
                    }
                    fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_up(&target)
                    }
                    fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_child(&target, item)
                    }
                    fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::replace_with(&target, item)
                    }
                    fn export_json(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::export_json(&target, options)
                    }
                    fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test_all(&target, point, options)
                    }
                    fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                        let target: Item = self.into();
                        Item::export_svg(&target, options)
                    }
                    fn copy_to(
                        &self,
                        owner: ItemCopyToParamsOwner,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::copy_to(&target, owner)
                    }
                    fn set_matrix(&mut self, value: Matrix) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_matrix(&target, value)
                    }
                    fn matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::matrix(&target)
                    }
                    fn add_to(
                        &self,
                        owner: ItemAddToParamsOwner,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::add_to(&target, owner)
                    }
                    fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::rotate(&target, angle, center)
                    }
                    fn set_view_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_view_matrix(&target, value)
                    }
                    fn view_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::view_matrix(&target)
                    }
                    fn set_previous_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_previous_sibling(&target, value)
                    }
                    fn previous_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::previous_sibling(&target)
                    }
                    fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_data(&target, value)
                    }
                    fn data(&self) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::data(&target)
                    }
                    fn off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item :: off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                    }
                    fn off_FnJsValueToJsValue(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::off_FnJsValueToJsValue(&target, object)
                    }
                    fn set_stroke_scaling(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_scaling(&target, value)
                    }
                    fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_scaling(&target)
                    }
                    fn insert_child(
                        &self,
                        index: f64,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_child(&target, index, item)
                    }
                    fn skew_FnPointAndPointTo(
                        &self,
                        skew: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::skew_FnPointAndPointTo(&target, skew, center)
                    }
                    fn skew_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::skew_FnF64AndF64AndPointTo(&target, hor, ver, center)
                    }
                    fn on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item :: on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                    }
                    fn on_FnJsValueToJsValue(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::on_FnJsValueToJsValue(&target, object)
                    }
                    fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::remove(&target)
                    }
                    fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::global_to_local(&target, point)
                    }
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::emit(&target, type_, event)
                    }
                    fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test(&target, point, options)
                    }
                    fn import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                        &self,
                        svg: ItemImportSvgParamsSvg,
                        options: JsValue,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                            &target, svg, options,
                        )
                    }
                    fn import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem(
                        &self,
                        svg: ItemImportSvgParamsSvg,
                        on_load: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item :: import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem (& target , svg , on_load)
                    }
                    fn set_dash_array(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_dash_array(&target, value)
                    }
                    fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let target: Item = self.into();
                        Item::dash_array(&target)
                    }
                    fn shear_FnPointAndPointTo(
                        &self,
                        shear: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::shear_FnPointAndPointTo(&target, shear, center)
                    }
                    fn shear_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::shear_FnF64AndF64AndPointTo(&target, hor, ver, center)
                    }
                    fn set_internal_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_internal_bounds(&target, value)
                    }
                    fn internal_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::internal_bounds(&target)
                    }
                    fn set_stroke_cap(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_cap(&target, value)
                    }
                    fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_cap(&target)
                    }
                    fn set_on_mouse_enter(
                        &mut self,
                        value: ItemOnMouseEnter,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_enter(&target, value)
                    }
                    fn on_mouse_enter(&self) -> std::result::Result<ItemOnMouseEnter, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_enter(&target)
                    }
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_view(&target, value)
                    }
                    fn view(&self) -> std::result::Result<View, JsValue> {
                        let target: Item = self.into();
                        Item::view(&target)
                    }
                    fn set_stroke_join(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_join(&target, value)
                    }
                    fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_join(&target)
                    }
                    fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_ancestor(&target, item)
                    }
                    fn set_fill_rule(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_fill_rule(&target, value)
                    }
                    fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::fill_rule(&target)
                    }
                    fn fit_bounds(
                        &self,
                        rectangle: Rectangle,
                        fill: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::fit_bounds(&target, rectangle, fill)
                    }
                    fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_parent(&target, point)
                    }
                    fn set_handle_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_handle_bounds(&target, value)
                    }
                    fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::handle_bounds(&target)
                    }
                    fn set_next_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_next_sibling(&target, value)
                    }
                    fn next_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::next_sibling(&target)
                    }
                    fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::clone(&target, options)
                    }
                    fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_descendant(&target, item)
                    }
                    fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_down(&target)
                    }
                    fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_parent(&target, item)
                    }
                    fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_move(&target)
                    }
                    fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_empty(&target, recursively)
                    }
                    fn rasterize(&self, options: JsValue) -> std::result::Result<Raster, JsValue> {
                        let target: Item = self.into();
                        Item::rasterize(&target, options)
                    }
                    fn set_shadow_color(
                        &mut self,
                        value: ItemShadowColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_shadow_color(&target, value)
                    }
                    fn shadow_color(&self) -> std::result::Result<ItemShadowColor, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_color(&target)
                    }
                    fn set_miter_limit(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_miter_limit(&target, value)
                    }
                    fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::miter_limit(&target)
                    }
                    fn get_item(
                        &self,
                        options: ItemGetItemParamsOptions,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::get_item(&target, options)
                    }
                    fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_json(&target, json)
                    }
                    fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_above(&target, item)
                    }
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ItemOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_drag(&target, value)
                    }
                    fn on_mouse_drag(&self) -> std::result::Result<ItemOnMouseDrag, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_drag(&target)
                    }
                    fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inserted(&target)
                    }
                    fn set_apply_matrix(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_apply_matrix(&target, value)
                    }
                    fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::apply_matrix(&target)
                    }
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::transform(&target, matrix)
                    }
                    fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_visible(&target, value)
                    }
                    fn visible(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::visible(&target)
                    }
                    fn set_stroke_color(
                        &mut self,
                        value: ItemStrokeColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_color(&target, value)
                    }
                    fn stroke_color(&self) -> std::result::Result<ItemStrokeColor, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_color(&target)
                    }
                    fn set_on_mouse_leave(
                        &mut self,
                        value: ItemOnMouseLeave,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_leave(&target, value)
                    }
                    fn on_mouse_leave(&self) -> std::result::Result<ItemOnMouseLeave, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_leave(&target)
                    }
                    fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::parent_to_local(&target, point)
                    }
                    fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_above(&target, item)
                    }
                    fn get_items(
                        &self,
                        options: ItemGetItemsParamsOptions,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::get_items(&target, options)
                    }
                    fn has_children(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_children(&target)
                    }
                    fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::translate(&target, delta)
                    }
                    fn set_parent(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_parent(&target, value)
                    }
                    fn parent(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::parent(&target)
                    }
                    fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_locked(&target, value)
                    }
                    fn locked(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::locked(&target)
                    }
                    fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_global(&target, point)
                    }
                }
                impl Layer_Trait for Layer
                where
                    Layer: Group_Trait,
                {
                    fn activate(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Layer::activate(target)
                    }
                }
                impl std::clone::Clone for Layer_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Layer_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Layer_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum TextItemFontSize {
                    String(String),
                    F64(f64),
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    #[wasm_bindgen(js_name = "View")]
                    pub type View_Class;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseDrag , js_class = "View")]
                    fn __TSB_on_mouse_drag(
                        this: &View_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseDrag , js_class = "View")]
                    fn __TSB_set_on_mouse_drag(
                        this: &View_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isInserted , method , js_class = "View" , catch)]
                    fn __TSB_is_inserted_FnToBool(
                        this: &View_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = scale , method , js_class = "View" , catch)]
                    fn __TSB_scale_FnF64AndPointTo(
                        this: &View_Class,
                        scale: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = scale , method , js_class = "View" , catch)]
                    fn __TSB_scale_FnF64AndF64AndPointTo(
                        this: &View_Class,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getEventPoint , method , js_class = "View" , catch)]
                    fn __TSB_get_event_point_FnEventToPoint(
                        this: &View_Class,
                        event: Event,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = off , method , js_class = "View" , catch)]
                    fn __TSB_off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToView(
                        this: &View_Class,
                        type_: String,
                        callback: &Closure<
                            dyn Fn(
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        >,
                    ) -> std::result::Result<View, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = off , method , js_class = "View" , catch)]
                    fn __TSB_off_FnJsValueToView(
                        this: &View_Class,
                        param: JsValue,
                    ) -> std::result::Result<View, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = translate , method , js_class = "View" , catch)]
                    fn __TSB_translate_FnPointTo(
                        this: &View_Class,
                        delta: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = element , js_class = "View")]
                    fn __TSB_element(
                        this: &View_Class,
                    ) -> std::result::Result<web_sys::HtmlCanvasElement, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = element , js_class = "View")]
                    fn __TSB_set_element(
                        this: &View_Class,
                        value: web_sys::HtmlCanvasElement,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = shear , method , js_class = "View" , catch)]
                    fn __TSB_shear_FnPointAndPointTo(
                        this: &View_Class,
                        shear: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = shear , method , js_class = "View" , catch)]
                    fn __TSB_shear_FnF64AndF64AndPointTo(
                        this: &View_Class,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onFrame , js_class = "View")]
                    fn __TSB_on_frame(this: &View_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onFrame , js_class = "View")]
                    fn __TSB_set_on_frame(
                        this: &View_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = matrix , js_class = "View")]
                    fn matrix(this: &View_Class) -> std::result::Result<Matrix, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = matrix , js_class = "View")]
                    fn set_matrix(
                        this: &View_Class,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = projectToView , method , js_class = "View" , catch)]
                    fn __TSB_project_to_view_FnPointToPoint(
                        this: &View_Class,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onDoubleClick , js_class = "View")]
                    fn __TSB_on_double_click(
                        this: &View_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onDoubleClick , js_class = "View")]
                    fn __TSB_set_on_double_click(
                        this: &View_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = resolution , js_class = "View")]
                    fn resolution(this: &View_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = resolution , js_class = "View")]
                    fn set_resolution(
                        this: &View_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseLeave , js_class = "View")]
                    fn __TSB_on_mouse_leave(
                        this: &View_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseLeave , js_class = "View")]
                    fn __TSB_set_on_mouse_leave(
                        this: &View_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = rotation , js_class = "View")]
                    fn rotation(this: &View_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = rotation , js_class = "View")]
                    fn set_rotation(
                        this: &View_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = center , js_class = "View")]
                    fn center(this: &View_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = center , js_class = "View")]
                    fn set_center(
                        this: &View_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseUp , js_class = "View")]
                    fn __TSB_on_mouse_up(
                        this: &View_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseUp , js_class = "View")]
                    fn __TSB_set_on_mouse_up(
                        this: &View_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = remove , method , js_class = "View" , catch)]
                    fn __TSB_remove_FnTo(this: &View_Class) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onResize , js_class = "View")]
                    fn __TSB_on_resize(this: &View_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onResize , js_class = "View")]
                    fn __TSB_set_on_resize(
                        this: &View_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = bounds , js_class = "View")]
                    fn bounds(this: &View_Class) -> std::result::Result<Rectangle, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = bounds , js_class = "View")]
                    fn set_bounds(
                        this: &View_Class,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = play , method , js_class = "View" , catch)]
                    fn __TSB_play_FnTo(this: &View_Class) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = pixelRatio , js_class = "View")]
                    fn pixel_ratio(this: &View_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = pixelRatio , js_class = "View")]
                    fn set_pixel_ratio(
                        this: &View_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = on , method , js_class = "View" , catch)]
                    fn __TSB_on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToView(
                        this: &View_Class,
                        type_: String,
                        callback: &Closure<
                            dyn Fn(
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        >,
                    ) -> std::result::Result<View, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = on , method , js_class = "View" , catch)]
                    fn __TSB_on_FnJsValueToView(
                        this: &View_Class,
                        param: JsValue,
                    ) -> std::result::Result<View, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = skew , method , js_class = "View" , catch)]
                    fn __TSB_skew_FnPointAndPointTo(
                        this: &View_Class,
                        skew: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = skew , method , js_class = "View" , catch)]
                    fn __TSB_skew_FnF64AndF64AndPointTo(
                        this: &View_Class,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseDown , js_class = "View")]
                    fn __TSB_on_mouse_down(
                        this: &View_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseDown , js_class = "View")]
                    fn __TSB_set_on_mouse_down(
                        this: &View_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = size , js_class = "View")]
                    fn size(this: &View_Class) -> std::result::Result<Size, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = size , js_class = "View")]
                    fn set_size(this: &View_Class, value: Size)
                        -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = rotate , method , js_class = "View" , catch)]
                    fn __TSB_rotate_FnF64AndPointTo(
                        this: &View_Class,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseEnter , js_class = "View")]
                    fn __TSB_on_mouse_enter(
                        this: &View_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseEnter , js_class = "View")]
                    fn __TSB_set_on_mouse_enter(
                        this: &View_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = emit , method , js_class = "View" , catch)]
                    fn __TSB_emit_FnStringAndJsValueToBool(
                        this: &View_Class,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = pause , method , js_class = "View" , catch)]
                    fn __TSB_pause_FnTo(this: &View_Class) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = zoom , js_class = "View")]
                    fn zoom(this: &View_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = zoom , js_class = "View")]
                    fn set_zoom(this: &View_Class, value: f64) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = scaling , js_class = "View")]
                    fn scaling(this: &View_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = scaling , js_class = "View")]
                    fn set_scaling(
                        this: &View_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = responds , method , js_class = "View" , catch)]
                    fn __TSB_responds_FnStringToBool(
                        this: &View_Class,
                        type_: String,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseMove , js_class = "View")]
                    fn __TSB_on_mouse_move(
                        this: &View_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseMove , js_class = "View")]
                    fn __TSB_set_on_mouse_move(
                        this: &View_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isVisible , method , js_class = "View" , catch)]
                    fn __TSB_is_visible_FnToBool(
                        this: &View_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = requestUpdate , method , js_class = "View" , catch)]
                    fn __TSB_request_update_FnTo(
                        this: &View_Class,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = update , method , js_class = "View" , catch)]
                    fn __TSB_update_FnToBool(
                        this: &View_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = transform , method , js_class = "View" , catch)]
                    fn __TSB_transform_FnMatrixTo(
                        this: &View_Class,
                        matrix: Matrix,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onClick , js_class = "View")]
                    fn __TSB_on_click(this: &View_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onClick , js_class = "View")]
                    fn __TSB_set_on_click(
                        this: &View_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = autoUpdate , js_class = "View")]
                    fn auto_update(this: &View_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = autoUpdate , js_class = "View")]
                    fn set_auto_update(
                        this: &View_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = viewSize , js_class = "View")]
                    fn view_size(this: &View_Class) -> std::result::Result<Size, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = viewSize , js_class = "View")]
                    fn set_view_size(
                        this: &View_Class,
                        value: Size,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = viewToProject , method , js_class = "View" , catch)]
                    fn __TSB_view_to_project_FnPointToPoint(
                        this: &View_Class,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct View(pub View_Class);
                impl std::convert::From<View> for JsValue {
                    fn from(src: View) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for View {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for View {
                    fn instanceof(val: &JsValue) -> bool {
                        View_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        View(View_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(View_Class::unchecked_from_js_ref(val) as *const View_Class
                                as *const Self)
                        }
                    }
                }
                impl View {
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_mouse_drag(&self) -> std::result::Result<ViewOnMouseDrag, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_drag()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_on_mouse_drag(
                        &self,
                        value: ViewOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_drag(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_inserted_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn scale_FnF64AndPointTo(
                        &self,
                        scale: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_scale_FnF64AndPointTo(scale, center);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn scale_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_scale_FnF64AndF64AndPointTo(hor, ver, center);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_event_point(
                        &self,
                        event: Event,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_get_event_point_FnEventToPoint(event);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToView(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<View, JsValue> {
                        # [allow (non_snake_case)] let __TSB_Local_callback = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = callback ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let result = self . 0 . __TSB_off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToView (type_ , & __TSB_Local_callback) ;
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn off_FnJsValueToView(
                        &self,
                        param: JsValue,
                    ) -> std::result::Result<View, JsValue> {
                        let result = self.0.__TSB_off_FnJsValueToView(param);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_translate_FnPointTo(delta);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn element(
                        &self,
                    ) -> std::result::Result<web_sys::HtmlCanvasElement, JsValue>
                    {
                        let result = self.0.__TSB_element();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_element(
                        &self,
                        value: web_sys::HtmlCanvasElement,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_element(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn shear_FnPointAndPointTo(
                        &self,
                        shear: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_shear_FnPointAndPointTo(shear, center);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn shear_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_shear_FnF64AndF64AndPointTo(hor, ver, center);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_frame(&self) -> std::result::Result<ViewOnFrame, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_frame()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_on_frame(
                        &self,
                        value: ViewOnFrame,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_frame(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.matrix();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_matrix(&self, value: Matrix) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_matrix(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn project_to_view(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_project_to_view_FnPointToPoint(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_double_click(
                        &self,
                    ) -> std::result::Result<ViewOnDoubleClick, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_double_click()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_on_double_click(
                        &self,
                        value: ViewOnDoubleClick,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_double_click(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn resolution(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.resolution();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_resolution(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_resolution(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_mouse_leave(&self) -> std::result::Result<ViewOnMouseLeave, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_leave()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_on_mouse_leave(
                        &self,
                        value: ViewOnMouseLeave,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_leave(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.rotation();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_rotation(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_rotation(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn center(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.center();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_center(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_center(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_mouse_up(&self) -> std::result::Result<ViewOnMouseUp, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_up()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_on_mouse_up(
                        &self,
                        value: ViewOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_up(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn remove(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_remove_FnTo();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_resize(&self) -> std::result::Result<ViewOnResize, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_resize()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_on_resize(
                        &self,
                        value: ViewOnResize,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_resize(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let result = self.0.bounds();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_bounds(&self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_bounds(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn play(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_play_FnTo();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn pixel_ratio(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.pixel_ratio();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_pixel_ratio(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_pixel_ratio(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToView(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<View, JsValue> {
                        # [allow (non_snake_case)] let __TSB_Local_callback = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = callback ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let result = self . 0 . __TSB_on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToView (type_ , & __TSB_Local_callback) ;
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_FnJsValueToView(
                        &self,
                        param: JsValue,
                    ) -> std::result::Result<View, JsValue> {
                        let result = self.0.__TSB_on_FnJsValueToView(param);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn skew_FnPointAndPointTo(
                        &self,
                        skew: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_skew_FnPointAndPointTo(skew, center);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn skew_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_skew_FnF64AndF64AndPointTo(hor, ver, center);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_mouse_down(&self) -> std::result::Result<ViewOnMouseDown, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_down()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_on_mouse_down(
                        &self,
                        value: ViewOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_down(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn size(&self) -> std::result::Result<Size, JsValue> {
                        let result = self.0.size();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_size(&self, value: Size) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_size(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_rotate_FnF64AndPointTo(angle, center);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_mouse_enter(&self) -> std::result::Result<ViewOnMouseEnter, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_enter()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_on_mouse_enter(
                        &self,
                        value: ViewOnMouseEnter,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_enter(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_emit_FnStringAndJsValueToBool(type_, event);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn pause(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_pause_FnTo();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn zoom(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.zoom();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_zoom(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_zoom(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.scaling();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_scaling(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_scaling(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_responds_FnStringToBool(type_);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_mouse_move(&self) -> std::result::Result<ViewOnMouseMove, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_move()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_on_mouse_move(
                        &self,
                        value: ViewOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_move(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_visible(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_visible_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn request_update(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_request_update_FnTo();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn update(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_update_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_transform_FnMatrixTo(matrix);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_click(&self) -> std::result::Result<ViewOnClick, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_click()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_on_click(
                        &self,
                        value: ViewOnClick,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_click(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn auto_update(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.auto_update();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_auto_update(&self, value: bool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_auto_update(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn view_size(&self) -> std::result::Result<Size, JsValue> {
                        let result = self.0.view_size();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_view_size(&self, value: Size) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_view_size(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn view_to_project(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_view_to_project_FnPointToPoint(point);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for View {
                    fn describe() {
                        <View_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for View {
                    type Abi = <View_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for View {
                    type Abi = <View_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        View(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a View {
                    type Abi = <&'a View_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for View {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for View {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: View_Class =
                            <View_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait View_Trait {
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ViewOnMouseDrag,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_drag(&self) -> std::result::Result<ViewOnMouseDrag, JsValue>;
                    fn is_inserted(&self) -> std::result::Result<bool, JsValue>;
                    fn scale_FnF64AndPointTo(
                        &self,
                        scale: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn scale_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn get_event_point(&self, event: Event) -> std::result::Result<Point, JsValue>;
                    fn off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToView(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<View, JsValue>;
                    fn off_FnJsValueToView(
                        &self,
                        param: JsValue,
                    ) -> std::result::Result<View, JsValue>;
                    fn translate(&self, delta: Point) -> std::result::Result<(), JsValue>;
                    fn set_element(
                        &mut self,
                        value: web_sys::HtmlCanvasElement,
                    ) -> std::result::Result<(), JsValue>;
                    fn element(&self) -> std::result::Result<web_sys::HtmlCanvasElement, JsValue>;
                    fn shear_FnPointAndPointTo(
                        &self,
                        shear: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn shear_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn set_on_frame(
                        &mut self,
                        value: ViewOnFrame,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_frame(&self) -> std::result::Result<ViewOnFrame, JsValue>;
                    fn set_matrix(&mut self, value: Matrix) -> std::result::Result<(), JsValue>;
                    fn matrix(&self) -> std::result::Result<Matrix, JsValue>;
                    fn project_to_view(&self, point: Point) -> std::result::Result<Point, JsValue>;
                    fn set_on_double_click(
                        &mut self,
                        value: ViewOnDoubleClick,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_double_click(&self) -> std::result::Result<ViewOnDoubleClick, JsValue>;
                    fn set_resolution(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn resolution(&self) -> std::result::Result<f64, JsValue>;
                    fn set_on_mouse_leave(
                        &mut self,
                        value: ViewOnMouseLeave,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_leave(&self) -> std::result::Result<ViewOnMouseLeave, JsValue>;
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn rotation(&self) -> std::result::Result<f64, JsValue>;
                    fn set_center(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn center(&self) -> std::result::Result<Point, JsValue>;
                    fn set_on_mouse_up(
                        &mut self,
                        value: ViewOnMouseUp,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_up(&self) -> std::result::Result<ViewOnMouseUp, JsValue>;
                    fn remove(&self) -> std::result::Result<(), JsValue>;
                    fn set_on_resize(
                        &mut self,
                        value: ViewOnResize,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_resize(&self) -> std::result::Result<ViewOnResize, JsValue>;
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue>;
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue>;
                    fn play(&self) -> std::result::Result<(), JsValue>;
                    fn set_pixel_ratio(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn pixel_ratio(&self) -> std::result::Result<f64, JsValue>;
                    fn on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToView(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<View, JsValue>;
                    fn on_FnJsValueToView(
                        &self,
                        param: JsValue,
                    ) -> std::result::Result<View, JsValue>;
                    fn skew_FnPointAndPointTo(
                        &self,
                        skew: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn skew_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn set_on_mouse_down(
                        &mut self,
                        value: ViewOnMouseDown,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_down(&self) -> std::result::Result<ViewOnMouseDown, JsValue>;
                    fn set_size(&mut self, value: Size) -> std::result::Result<(), JsValue>;
                    fn size(&self) -> std::result::Result<Size, JsValue>;
                    fn rotate(&self, angle: f64, center: Point)
                        -> std::result::Result<(), JsValue>;
                    fn set_on_mouse_enter(
                        &mut self,
                        value: ViewOnMouseEnter,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_enter(&self) -> std::result::Result<ViewOnMouseEnter, JsValue>;
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue>;
                    fn pause(&self) -> std::result::Result<(), JsValue>;
                    fn set_zoom(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn zoom(&self) -> std::result::Result<f64, JsValue>;
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn scaling(&self) -> std::result::Result<Point, JsValue>;
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue>;
                    fn set_on_mouse_move(
                        &mut self,
                        value: ViewOnMouseMove,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_move(&self) -> std::result::Result<ViewOnMouseMove, JsValue>;
                    fn is_visible(&self) -> std::result::Result<bool, JsValue>;
                    fn request_update(&self) -> std::result::Result<(), JsValue>;
                    fn update(&self) -> std::result::Result<bool, JsValue>;
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue>;
                    fn set_on_click(
                        &mut self,
                        value: ViewOnClick,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_click(&self) -> std::result::Result<ViewOnClick, JsValue>;
                    fn set_auto_update(&mut self, value: bool) -> std::result::Result<(), JsValue>;
                    fn auto_update(&self) -> std::result::Result<bool, JsValue>;
                    fn set_view_size(&mut self, value: Size) -> std::result::Result<(), JsValue>;
                    fn view_size(&self) -> std::result::Result<Size, JsValue>;
                    fn view_to_project(&self, point: Point) -> std::result::Result<Point, JsValue>;
                }
                impl View_Trait for View {
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ViewOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::set_on_mouse_drag(target, value)
                    }
                    fn on_mouse_drag(&self) -> std::result::Result<ViewOnMouseDrag, JsValue> {
                        let target = self;
                        View::on_mouse_drag(target)
                    }
                    fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        View::is_inserted(target)
                    }
                    fn scale_FnF64AndPointTo(
                        &self,
                        scale: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::scale_FnF64AndPointTo(target, scale, center)
                    }
                    fn scale_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::scale_FnF64AndF64AndPointTo(target, hor, ver, center)
                    }
                    fn get_event_point(&self, event: Event) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        View::get_event_point(target, event)
                    }
                    fn off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToView(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<View, JsValue> {
                        let target = self;
                        View :: off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToView (target , type_ , callback)
                    }
                    fn off_FnJsValueToView(
                        &self,
                        param: JsValue,
                    ) -> std::result::Result<View, JsValue> {
                        let target = self;
                        View::off_FnJsValueToView(target, param)
                    }
                    fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::translate(target, delta)
                    }
                    fn set_element(
                        &mut self,
                        value: web_sys::HtmlCanvasElement,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::set_element(target, value)
                    }
                    fn element(&self) -> std::result::Result<web_sys::HtmlCanvasElement, JsValue> {
                        let target = self;
                        View::element(target)
                    }
                    fn shear_FnPointAndPointTo(
                        &self,
                        shear: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::shear_FnPointAndPointTo(target, shear, center)
                    }
                    fn shear_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::shear_FnF64AndF64AndPointTo(target, hor, ver, center)
                    }
                    fn set_on_frame(
                        &mut self,
                        value: ViewOnFrame,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::set_on_frame(target, value)
                    }
                    fn on_frame(&self) -> std::result::Result<ViewOnFrame, JsValue> {
                        let target = self;
                        View::on_frame(target)
                    }
                    fn set_matrix(&mut self, value: Matrix) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::set_matrix(target, value)
                    }
                    fn matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        View::matrix(target)
                    }
                    fn project_to_view(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        View::project_to_view(target, point)
                    }
                    fn set_on_double_click(
                        &mut self,
                        value: ViewOnDoubleClick,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::set_on_double_click(target, value)
                    }
                    fn on_double_click(&self) -> std::result::Result<ViewOnDoubleClick, JsValue> {
                        let target = self;
                        View::on_double_click(target)
                    }
                    fn set_resolution(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::set_resolution(target, value)
                    }
                    fn resolution(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        View::resolution(target)
                    }
                    fn set_on_mouse_leave(
                        &mut self,
                        value: ViewOnMouseLeave,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::set_on_mouse_leave(target, value)
                    }
                    fn on_mouse_leave(&self) -> std::result::Result<ViewOnMouseLeave, JsValue> {
                        let target = self;
                        View::on_mouse_leave(target)
                    }
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::set_rotation(target, value)
                    }
                    fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        View::rotation(target)
                    }
                    fn set_center(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::set_center(target, value)
                    }
                    fn center(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        View::center(target)
                    }
                    fn set_on_mouse_up(
                        &mut self,
                        value: ViewOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::set_on_mouse_up(target, value)
                    }
                    fn on_mouse_up(&self) -> std::result::Result<ViewOnMouseUp, JsValue> {
                        let target = self;
                        View::on_mouse_up(target)
                    }
                    fn remove(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::remove(target)
                    }
                    fn set_on_resize(
                        &mut self,
                        value: ViewOnResize,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::set_on_resize(target, value)
                    }
                    fn on_resize(&self) -> std::result::Result<ViewOnResize, JsValue> {
                        let target = self;
                        View::on_resize(target)
                    }
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::set_bounds(target, value)
                    }
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        View::bounds(target)
                    }
                    fn play(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::play(target)
                    }
                    fn set_pixel_ratio(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::set_pixel_ratio(target, value)
                    }
                    fn pixel_ratio(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        View::pixel_ratio(target)
                    }
                    fn on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToView(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<View, JsValue> {
                        let target = self;
                        View :: on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToView (target , type_ , callback)
                    }
                    fn on_FnJsValueToView(
                        &self,
                        param: JsValue,
                    ) -> std::result::Result<View, JsValue> {
                        let target = self;
                        View::on_FnJsValueToView(target, param)
                    }
                    fn skew_FnPointAndPointTo(
                        &self,
                        skew: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::skew_FnPointAndPointTo(target, skew, center)
                    }
                    fn skew_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::skew_FnF64AndF64AndPointTo(target, hor, ver, center)
                    }
                    fn set_on_mouse_down(
                        &mut self,
                        value: ViewOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::set_on_mouse_down(target, value)
                    }
                    fn on_mouse_down(&self) -> std::result::Result<ViewOnMouseDown, JsValue> {
                        let target = self;
                        View::on_mouse_down(target)
                    }
                    fn set_size(&mut self, value: Size) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::set_size(target, value)
                    }
                    fn size(&self) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        View::size(target)
                    }
                    fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::rotate(target, angle, center)
                    }
                    fn set_on_mouse_enter(
                        &mut self,
                        value: ViewOnMouseEnter,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::set_on_mouse_enter(target, value)
                    }
                    fn on_mouse_enter(&self) -> std::result::Result<ViewOnMouseEnter, JsValue> {
                        let target = self;
                        View::on_mouse_enter(target)
                    }
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        View::emit(target, type_, event)
                    }
                    fn pause(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::pause(target)
                    }
                    fn set_zoom(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::set_zoom(target, value)
                    }
                    fn zoom(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        View::zoom(target)
                    }
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::set_scaling(target, value)
                    }
                    fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        View::scaling(target)
                    }
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        View::responds(target, type_)
                    }
                    fn set_on_mouse_move(
                        &mut self,
                        value: ViewOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::set_on_mouse_move(target, value)
                    }
                    fn on_mouse_move(&self) -> std::result::Result<ViewOnMouseMove, JsValue> {
                        let target = self;
                        View::on_mouse_move(target)
                    }
                    fn is_visible(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        View::is_visible(target)
                    }
                    fn request_update(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::request_update(target)
                    }
                    fn update(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        View::update(target)
                    }
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::transform(target, matrix)
                    }
                    fn set_on_click(
                        &mut self,
                        value: ViewOnClick,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::set_on_click(target, value)
                    }
                    fn on_click(&self) -> std::result::Result<ViewOnClick, JsValue> {
                        let target = self;
                        View::on_click(target)
                    }
                    fn set_auto_update(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::set_auto_update(target, value)
                    }
                    fn auto_update(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        View::auto_update(target)
                    }
                    fn set_view_size(&mut self, value: Size) -> std::result::Result<(), JsValue> {
                        let target = self;
                        View::set_view_size(target, value)
                    }
                    fn view_size(&self) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        View::view_size(target)
                    }
                    fn view_to_project(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        View::view_to_project(target, point)
                    }
                }
                impl std::clone::Clone for View_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for View_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for View_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ToolOnMouseUp {
                    TsBindgenRtNull,
                    #[serde(
                        serialize_with = "ToolOnMouseUp::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ToolOnMouseUp::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                }
                impl ToolOnMouseUp {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum RasterSetPixelReturn {
                    __,
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemOnMouseDrag {
                    TsBindgenRtNull,
                    #[serde(
                        serialize_with = "ItemOnMouseDrag::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ItemOnMouseDrag::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                }
                impl ItemOnMouseDrag {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PathItemArcByReturn {
                    __,
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemShadowColor {
                    Color(Color),
                    TsBindgenRtNull,
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    # [wasm_bindgen (js_name = "CompoundPath" , extends = Item_Class , extends = PathItem_Class)]
                    pub type CompoundPath_Class;
                    # [wasm_bindgen (method , structural , catch , getter = area , js_class = "CompoundPath")]
                    fn area(this: &CompoundPath_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = area , js_class = "CompoundPath")]
                    fn set_area(
                        this: &CompoundPath_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = firstCurve , js_class = "CompoundPath")]
                    fn first_curve(
                        this: &CompoundPath_Class,
                    ) -> std::result::Result<Curve, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = firstCurve , js_class = "CompoundPath")]
                    fn set_first_curve(
                        this: &CompoundPath_Class,
                        value: Curve,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = closed , js_class = "CompoundPath")]
                    fn closed(this: &CompoundPath_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = closed , js_class = "CompoundPath")]
                    fn set_closed(
                        this: &CompoundPath_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = curves , js_class = "CompoundPath")]
                    fn __TSB_curves(
                        this: &CompoundPath_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = curves , js_class = "CompoundPath")]
                    fn __TSB_set_curves(
                        this: &CompoundPath_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = firstSegment , js_class = "CompoundPath")]
                    fn first_segment(
                        this: &CompoundPath_Class,
                    ) -> std::result::Result<Segment, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = firstSegment , js_class = "CompoundPath")]
                    fn set_first_segment(
                        this: &CompoundPath_Class,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue>;
                    #[wasm_bindgen(constructor, js_class = "CompoundPath")]
                    pub fn new_FnStringToCompoundPath(path_data: String) -> CompoundPath_Class;
                    #[wasm_bindgen(constructor, js_class = "CompoundPath")]
                    pub fn new_FnJsValueToCompoundPath(object: JsValue) -> CompoundPath_Class;
                    # [wasm_bindgen (method , structural , catch , getter = lastSegment , js_class = "CompoundPath")]
                    fn last_segment(
                        this: &CompoundPath_Class,
                    ) -> std::result::Result<Segment, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = lastSegment , js_class = "CompoundPath")]
                    fn set_last_segment(
                        this: &CompoundPath_Class,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = lastCurve , js_class = "CompoundPath")]
                    fn last_curve(this: &CompoundPath_Class)
                        -> std::result::Result<Curve, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = lastCurve , js_class = "CompoundPath")]
                    fn set_last_curve(
                        this: &CompoundPath_Class,
                        value: Curve,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = length , js_class = "CompoundPath")]
                    fn length(this: &CompoundPath_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = length , js_class = "CompoundPath")]
                    fn set_length(
                        this: &CompoundPath_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct CompoundPath(pub CompoundPath_Class);
                impl std::convert::From<&CompoundPath> for Item {
                    fn from(src: &CompoundPath) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl std::convert::From<&mut CompoundPath> for Item {
                    fn from(src: &mut CompoundPath) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl std::convert::From<&CompoundPath> for PathItem {
                    fn from(src: &CompoundPath) -> PathItem {
                        let src: &PathItem_Class = src.0.as_ref();
                        PathItem(src.clone())
                    }
                }
                impl std::convert::From<&mut CompoundPath> for PathItem {
                    fn from(src: &mut CompoundPath) -> PathItem {
                        let src: &PathItem_Class = src.0.as_ref();
                        PathItem(src.clone())
                    }
                }
                impl std::convert::From<CompoundPath> for JsValue {
                    fn from(src: CompoundPath) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for CompoundPath {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for CompoundPath {
                    fn instanceof(val: &JsValue) -> bool {
                        CompoundPath_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        CompoundPath(CompoundPath_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(CompoundPath_Class::unchecked_from_js_ref(val)
                                as *const CompoundPath_Class
                                as *const Self)
                        }
                    }
                }
                impl CompoundPath {
                    #[allow(dead_code, non_snake_case)]
                    pub fn area(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.area();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_area(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_area(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn first_curve(&self) -> std::result::Result<Curve, JsValue> {
                        let result = self.0.first_curve();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_first_curve(
                        &self,
                        value: Curve,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_first_curve(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn closed(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.closed();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_closed(&self, value: bool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_closed(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn curves(&self) -> std::result::Result<Vec<Curve>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_curves()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_curves(
                        &self,
                        value: Vec<Curve>,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_curves({
                            let value_array = js_sys::Array::new();
                            for value_item in value {
                                value_array.push(&JsValue::from(value_item));
                            }
                            value_array.into()
                        });
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn first_segment(&self) -> std::result::Result<Segment, JsValue> {
                        let result = self.0.first_segment();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_first_segment(
                        &self,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_first_segment(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnStringToCompoundPath(path_data: String) -> CompoundPath {
                        let result = CompoundPath_Class::new_FnStringToCompoundPath(path_data);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        CompoundPath(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnJsValueToCompoundPath(object: JsValue) -> CompoundPath {
                        let result = CompoundPath_Class::new_FnJsValueToCompoundPath(object);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        CompoundPath(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn last_segment(&self) -> std::result::Result<Segment, JsValue> {
                        let result = self.0.last_segment();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_last_segment(
                        &self,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_last_segment(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn last_curve(&self) -> std::result::Result<Curve, JsValue> {
                        let result = self.0.last_curve();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_last_curve(&self, value: Curve) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_last_curve(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn length(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.length();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_length(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_length(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for CompoundPath {
                    fn describe() {
                        <CompoundPath_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for CompoundPath {
                    type Abi = <CompoundPath_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for CompoundPath {
                    type Abi = <CompoundPath_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        CompoundPath(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a CompoundPath {
                    type Abi = <&'a CompoundPath_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for CompoundPath {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for CompoundPath {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: CompoundPath_Class =
                            <CompoundPath_Class as serde::de::Deserialize>::deserialize(
                                deserializer,
                            )?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait CompoundPath_Trait: PathItem_Trait {
                    fn set_area(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn area(&self) -> std::result::Result<f64, JsValue>;
                    fn set_first_curve(&mut self, value: Curve)
                        -> std::result::Result<(), JsValue>;
                    fn first_curve(&self) -> std::result::Result<Curve, JsValue>;
                    fn set_closed(&mut self, value: bool) -> std::result::Result<(), JsValue>;
                    fn closed(&self) -> std::result::Result<bool, JsValue>;
                    fn set_curves(&mut self, value: Vec<Curve>)
                        -> std::result::Result<(), JsValue>;
                    fn curves(&self) -> std::result::Result<Vec<Curve>, JsValue>;
                    fn set_first_segment(
                        &mut self,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue>;
                    fn first_segment(&self) -> std::result::Result<Segment, JsValue>;
                    fn set_last_segment(
                        &mut self,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue>;
                    fn last_segment(&self) -> std::result::Result<Segment, JsValue>;
                    fn set_last_curve(&mut self, value: Curve) -> std::result::Result<(), JsValue>;
                    fn last_curve(&self) -> std::result::Result<Curve, JsValue>;
                    fn set_length(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn length(&self) -> std::result::Result<f64, JsValue>;
                }
                impl PathItem_Trait for CompoundPath
                where
                    CompoundPath: Item_Trait,
                {
                    fn unite(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::unite(&target, path, options)
                    }
                    fn line_by(&self, point: Point) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::line_by(&target, point)
                    }
                    fn move_to(&self, point: Point) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::move_to(&target, point)
                    }
                    fn set_path_data(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::set_path_data(&target, value)
                    }
                    fn path_data(&self) -> std::result::Result<String, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::path_data(&target)
                    }
                    fn intersect(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::intersect(&target, path, options)
                    }
                    fn create_FnStringToPathItemCreateReturn(
                        &self,
                        path_data: String,
                    ) -> std::result::Result<PathItemCreateReturn, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::create_FnStringToPathItemCreateReturn(&target, path_data)
                    }
                    fn create_FnVecOfVecOfF64ToPathItemCreateReturn(
                        &self,
                        segments: Vec<Vec<f64>>,
                    ) -> std::result::Result<PathItemCreateReturn, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::create_FnVecOfVecOfF64ToPathItemCreateReturn(&target, segments)
                    }
                    fn create_FnJsValueToPathItemCreateReturn(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<PathItemCreateReturn, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::create_FnJsValueToPathItemCreateReturn(&target, object)
                    }
                    fn smooth(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::smooth(&target, options)
                    }
                    fn compare(&self, path: PathItem) -> std::result::Result<bool, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::compare(&target, path)
                    }
                    fn arc_to_FnPointAndPointTo(
                        &self,
                        through: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::arc_to_FnPointAndPointTo(&target, through, to)
                    }
                    fn arc_to_FnPointAndBoolTo(
                        &self,
                        to: Point,
                        clockwise: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::arc_to_FnPointAndBoolTo(&target, to, clockwise)
                    }
                    fn quadratic_curve_to(
                        &self,
                        handle: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::quadratic_curve_to(&target, handle, to)
                    }
                    fn set_interior_point(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::set_interior_point(&target, value)
                    }
                    fn interior_point(&self) -> std::result::Result<Point, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::interior_point(&target)
                    }
                    fn simplify(&self, tolerance: f64) -> std::result::Result<bool, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::simplify(&target, tolerance)
                    }
                    fn reorient(
                        &self,
                        non_zero: bool,
                        clockwise: bool,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::reorient(&target, non_zero, clockwise)
                    }
                    fn cubic_curve_by(
                        &self,
                        handle1: Point,
                        handle2: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::cubic_curve_by(&target, handle1, handle2, to)
                    }
                    fn close_path(&self) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::close_path(&target)
                    }
                    fn flatten(&self, flatness: f64) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::flatten(&target, flatness)
                    }
                    fn quadratic_curve_by(
                        &self,
                        handle: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::quadratic_curve_by(&target, handle, to)
                    }
                    fn cubic_curve_to(
                        &self,
                        handle1: Point,
                        handle2: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::cubic_curve_to(&target, handle1, handle2, to)
                    }
                    fn divide(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::divide(&target, path, options)
                    }
                    fn arc_by_FnPointAndPointTo(
                        &self,
                        through: Point,
                        to: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::arc_by_FnPointAndPointTo(&target, through, to)
                    }
                    fn arc_by_FnPointAndBoolTo(
                        &self,
                        to: Point,
                        clockwise: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::arc_by_FnPointAndBoolTo(&target, to, clockwise)
                    }
                    fn move_by(&self, to: Point) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::move_by(&target, to)
                    }
                    fn get_nearest_location(
                        &self,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::get_nearest_location(&target, point)
                    }
                    fn reverse(&self) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::reverse(&target)
                    }
                    fn line_to(&self, point: Point) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::line_to(&target, point)
                    }
                    fn get_nearest_point(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::get_nearest_point(&target, point)
                    }
                    fn interpolate(
                        &self,
                        from: PathItem,
                        to: PathItem,
                        factor: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::interpolate(&target, from, to, factor)
                    }
                    fn get_crossings(
                        &self,
                        path: PathItem,
                    ) -> std::result::Result<Vec<CurveLocation>, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::get_crossings(&target, path)
                    }
                    fn curve_by(
                        &self,
                        through: Point,
                        to: Point,
                        time: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::curve_by(&target, through, to, time)
                    }
                    fn curve_to(
                        &self,
                        through: Point,
                        to: Point,
                        time: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::curve_to(&target, through, to, time)
                    }
                    fn subtract(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::subtract(&target, path, options)
                    }
                    fn get_intersections(
                        &self,
                        path: PathItem,
                        include: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Vec<CurveLocation>, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::get_intersections(&target, path, include)
                    }
                    fn exclude(
                        &self,
                        path: PathItem,
                        options: JsValue,
                    ) -> std::result::Result<PathItem, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::exclude(&target, path, options)
                    }
                    fn set_clockwise(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: PathItem = self.into();
                        PathItem::set_clockwise(&target, value)
                    }
                    fn clockwise(&self) -> std::result::Result<bool, JsValue> {
                        let target: PathItem = self.into();
                        PathItem::clockwise(&target)
                    }
                }
                impl Item_Trait for CompoundPath {
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::responds(&target, type_)
                    }
                    fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_content(&target, source)
                    }
                    fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_opacity(&target, value)
                    }
                    fn opacity(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::opacity(&target)
                    }
                    fn set_on_frame(
                        &mut self,
                        value: ItemOnFrame,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_frame(&target, value)
                    }
                    fn on_frame(&self) -> std::result::Result<ItemOnFrame, JsValue> {
                        let target: Item = self.into();
                        Item::on_frame(&target)
                    }
                    fn remove_children_FnToVecOfItem(
                        &self,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::remove_children_FnToVecOfItem(&target)
                    }
                    fn remove_children_FnF64AndF64ToVecOfItem(
                        &self,
                        start: f64,
                        end: f64,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::remove_children_FnF64AndF64ToVecOfItem(&target, start, end)
                    }
                    fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_below(&target, item)
                    }
                    fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_stroke(&target)
                    }
                    fn set_global_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_global_matrix(&target, value)
                    }
                    fn global_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::global_matrix(&target)
                    }
                    fn copy_attributes(
                        &self,
                        source: Item,
                        exclude_matrix: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_attributes(&target, source, exclude_matrix)
                    }
                    fn set_on_mouse_move(
                        &mut self,
                        value: ItemOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_move(&target, value)
                    }
                    fn on_mouse_move(&self) -> std::result::Result<ItemOnMouseMove, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_move(&target)
                    }
                    fn set_position(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_position(&target, value)
                    }
                    fn position(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::position(&target)
                    }
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_bounds(&target, value)
                    }
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::bounds(&target)
                    }
                    fn set_shadow_blur(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_shadow_blur(&target, value)
                    }
                    fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_blur(&target)
                    }
                    fn set_selected_color(
                        &mut self,
                        value: ItemSelectedColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_selected_color(&target, value)
                    }
                    fn selected_color(&self) -> std::result::Result<ItemSelectedColor, JsValue> {
                        let target: Item = self.into();
                        Item::selected_color(&target)
                    }
                    fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::reverse_children(&target)
                    }
                    fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::bring_to_front(&target)
                    }
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_selected(&target, value)
                    }
                    fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::selected(&target)
                    }
                    fn add_children(
                        &self,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::add_children(&target, items)
                    }
                    fn tween_to(
                        &self,
                        to: JsValue,
                        options: ItemTweenToParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_to(&target, to, options)
                    }
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_project(&target, value)
                    }
                    fn project(&self) -> std::result::Result<Project, JsValue> {
                        let target: Item = self.into();
                        Item::project(&target)
                    }
                    fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_name(&target, value)
                    }
                    fn name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::name(&target)
                    }
                    fn set_stroke_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_bounds(&target, value)
                    }
                    fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_bounds(&target)
                    }
                    fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_below(&target, item)
                    }
                    fn set_blend_mode(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_blend_mode(&target, value)
                    }
                    fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::blend_mode(&target)
                    }
                    fn set_clip_mask(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_clip_mask(&target, value)
                    }
                    fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::clip_mask(&target)
                    }
                    fn set_fill_color(
                        &mut self,
                        value: ItemFillColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_fill_color(&target, value)
                    }
                    fn fill_color(&self) -> std::result::Result<ItemFillColor, JsValue> {
                        let target: Item = self.into();
                        Item::fill_color(&target)
                    }
                    fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_drag(&target)
                    }
                    fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::add_child(&target, item)
                    }
                    fn scale_FnF64AndPointTo(
                        &self,
                        scale: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::scale_FnF64AndPointTo(&target, scale, center)
                    }
                    fn scale_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::scale_FnF64AndF64AndPointTo(&target, hor, ver, center)
                    }
                    fn set_first_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_first_child(&target, value)
                    }
                    fn first_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::first_child(&target)
                    }
                    fn set_style(&mut self, value: Style) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_style(&target, value)
                    }
                    fn style(&self) -> std::result::Result<Style, JsValue> {
                        let target: Item = self.into();
                        Item::style(&target)
                    }
                    fn set_class_name(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_class_name(&target, value)
                    }
                    fn class_name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::class_name(&target)
                    }
                    fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_grouped_with(&target, item)
                    }
                    fn set_shadow_offset(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_shadow_offset(&target, value)
                    }
                    fn shadow_offset(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_offset(&target)
                    }
                    fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inside(&target, rect)
                    }
                    fn set_children(
                        &mut self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_children(&target, value)
                    }
                    fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::children(&target)
                    }
                    fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_fill(&target)
                    }
                    fn matches_FnItemMatchesParamsOptionsToBool(
                        &self,
                        options: ItemMatchesParamsOptions,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::matches_FnItemMatchesParamsOptionsToBool(&target, options)
                    }
                    fn matches_FnStringAndJsValueToBool(
                        &self,
                        name: String,
                        compare: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::matches_FnStringAndJsValueToBool(&target, name, compare)
                    }
                    fn set_on_double_click(
                        &mut self,
                        value: ItemOnDoubleClick,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_double_click(&target, value)
                    }
                    fn on_double_click(&self) -> std::result::Result<ItemOnDoubleClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_double_click(&target)
                    }
                    fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::intersects(&target, item)
                    }
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_rotation(&target, value)
                    }
                    fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::rotation(&target)
                    }
                    fn set_on_mouse_down(
                        &mut self,
                        value: ItemOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_down(&target, value)
                    }
                    fn on_mouse_down(&self) -> std::result::Result<ItemOnMouseDown, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_down(&target)
                    }
                    fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_sibling(&target, item)
                    }
                    fn tween_from(
                        &self,
                        from: JsValue,
                        options: ItemTweenFromParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_from(&target, from, options)
                    }
                    fn set_layer(&mut self, value: Layer) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_layer(&target, value)
                    }
                    fn layer(&self) -> std::result::Result<Layer, JsValue> {
                        let target: Item = self.into();
                        Item::layer(&target)
                    }
                    fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::contains(&target, point)
                    }
                    fn set_on_click(
                        &mut self,
                        value: ItemOnClick,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_click(&target, value)
                    }
                    fn on_click(&self) -> std::result::Result<ItemOnClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_click(&target)
                    }
                    fn set_last_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_last_child(&target, value)
                    }
                    fn last_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::last_child(&target)
                    }
                    fn set_dash_offset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_dash_offset(&target, value)
                    }
                    fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::dash_offset(&target)
                    }
                    fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_id(&target, value)
                    }
                    fn id(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::id(&target)
                    }
                    fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_shadow(&target)
                    }
                    fn tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                        &self,
                        from: JsValue,
                        to: JsValue,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                            &target, from, to, options,
                        )
                    }
                    fn tween_FnJsValueAndItemTweenParamsOptionsToTween(
                        &self,
                        to: JsValue,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_FnJsValueAndItemTweenParamsOptionsToTween(&target, to, options)
                    }
                    fn tween_FnItemTweenParamsOptionsToTween(
                        &self,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_FnItemTweenParamsOptionsToTween(&target, options)
                    }
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_scaling(&target, value)
                    }
                    fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::scaling(&target)
                    }
                    fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::send_to_back(&target)
                    }
                    fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::set(&target, props)
                    }
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_index(&target, value)
                    }
                    fn index(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::index(&target)
                    }
                    fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::reduce(&target, options)
                    }
                    fn set_pivot(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_pivot(&target, value)
                    }
                    fn pivot(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::pivot(&target)
                    }
                    fn insert_children(
                        &self,
                        index: f64,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::insert_children(&target, index, items)
                    }
                    fn set_on_mouse_up(
                        &mut self,
                        value: ItemOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_up(&target, value)
                    }
                    fn on_mouse_up(&self) -> std::result::Result<ItemOnMouseUp, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_up(&target)
                    }
                    fn set_stroke_width(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_width(&target, value)
                    }
                    fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_width(&target)
                    }
                    fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on(&target, options)
                    }
                    fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_up(&target)
                    }
                    fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_child(&target, item)
                    }
                    fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::replace_with(&target, item)
                    }
                    fn export_json(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::export_json(&target, options)
                    }
                    fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test_all(&target, point, options)
                    }
                    fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                        let target: Item = self.into();
                        Item::export_svg(&target, options)
                    }
                    fn copy_to(
                        &self,
                        owner: ItemCopyToParamsOwner,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::copy_to(&target, owner)
                    }
                    fn set_matrix(&mut self, value: Matrix) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_matrix(&target, value)
                    }
                    fn matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::matrix(&target)
                    }
                    fn add_to(
                        &self,
                        owner: ItemAddToParamsOwner,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::add_to(&target, owner)
                    }
                    fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::rotate(&target, angle, center)
                    }
                    fn set_view_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_view_matrix(&target, value)
                    }
                    fn view_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::view_matrix(&target)
                    }
                    fn set_previous_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_previous_sibling(&target, value)
                    }
                    fn previous_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::previous_sibling(&target)
                    }
                    fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_data(&target, value)
                    }
                    fn data(&self) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::data(&target)
                    }
                    fn off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item :: off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                    }
                    fn off_FnJsValueToJsValue(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::off_FnJsValueToJsValue(&target, object)
                    }
                    fn set_stroke_scaling(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_scaling(&target, value)
                    }
                    fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_scaling(&target)
                    }
                    fn insert_child(
                        &self,
                        index: f64,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_child(&target, index, item)
                    }
                    fn skew_FnPointAndPointTo(
                        &self,
                        skew: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::skew_FnPointAndPointTo(&target, skew, center)
                    }
                    fn skew_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::skew_FnF64AndF64AndPointTo(&target, hor, ver, center)
                    }
                    fn on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item :: on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                    }
                    fn on_FnJsValueToJsValue(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::on_FnJsValueToJsValue(&target, object)
                    }
                    fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::remove(&target)
                    }
                    fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::global_to_local(&target, point)
                    }
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::emit(&target, type_, event)
                    }
                    fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test(&target, point, options)
                    }
                    fn import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                        &self,
                        svg: ItemImportSvgParamsSvg,
                        options: JsValue,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                            &target, svg, options,
                        )
                    }
                    fn import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem(
                        &self,
                        svg: ItemImportSvgParamsSvg,
                        on_load: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item :: import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem (& target , svg , on_load)
                    }
                    fn set_dash_array(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_dash_array(&target, value)
                    }
                    fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let target: Item = self.into();
                        Item::dash_array(&target)
                    }
                    fn shear_FnPointAndPointTo(
                        &self,
                        shear: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::shear_FnPointAndPointTo(&target, shear, center)
                    }
                    fn shear_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::shear_FnF64AndF64AndPointTo(&target, hor, ver, center)
                    }
                    fn set_internal_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_internal_bounds(&target, value)
                    }
                    fn internal_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::internal_bounds(&target)
                    }
                    fn set_stroke_cap(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_cap(&target, value)
                    }
                    fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_cap(&target)
                    }
                    fn set_on_mouse_enter(
                        &mut self,
                        value: ItemOnMouseEnter,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_enter(&target, value)
                    }
                    fn on_mouse_enter(&self) -> std::result::Result<ItemOnMouseEnter, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_enter(&target)
                    }
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_view(&target, value)
                    }
                    fn view(&self) -> std::result::Result<View, JsValue> {
                        let target: Item = self.into();
                        Item::view(&target)
                    }
                    fn set_stroke_join(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_join(&target, value)
                    }
                    fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_join(&target)
                    }
                    fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_ancestor(&target, item)
                    }
                    fn set_fill_rule(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_fill_rule(&target, value)
                    }
                    fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::fill_rule(&target)
                    }
                    fn fit_bounds(
                        &self,
                        rectangle: Rectangle,
                        fill: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::fit_bounds(&target, rectangle, fill)
                    }
                    fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_parent(&target, point)
                    }
                    fn set_handle_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_handle_bounds(&target, value)
                    }
                    fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::handle_bounds(&target)
                    }
                    fn set_next_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_next_sibling(&target, value)
                    }
                    fn next_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::next_sibling(&target)
                    }
                    fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::clone(&target, options)
                    }
                    fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_descendant(&target, item)
                    }
                    fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_down(&target)
                    }
                    fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_parent(&target, item)
                    }
                    fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_move(&target)
                    }
                    fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_empty(&target, recursively)
                    }
                    fn rasterize(&self, options: JsValue) -> std::result::Result<Raster, JsValue> {
                        let target: Item = self.into();
                        Item::rasterize(&target, options)
                    }
                    fn set_shadow_color(
                        &mut self,
                        value: ItemShadowColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_shadow_color(&target, value)
                    }
                    fn shadow_color(&self) -> std::result::Result<ItemShadowColor, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_color(&target)
                    }
                    fn set_miter_limit(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_miter_limit(&target, value)
                    }
                    fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::miter_limit(&target)
                    }
                    fn get_item(
                        &self,
                        options: ItemGetItemParamsOptions,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::get_item(&target, options)
                    }
                    fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_json(&target, json)
                    }
                    fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_above(&target, item)
                    }
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ItemOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_drag(&target, value)
                    }
                    fn on_mouse_drag(&self) -> std::result::Result<ItemOnMouseDrag, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_drag(&target)
                    }
                    fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inserted(&target)
                    }
                    fn set_apply_matrix(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_apply_matrix(&target, value)
                    }
                    fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::apply_matrix(&target)
                    }
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::transform(&target, matrix)
                    }
                    fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_visible(&target, value)
                    }
                    fn visible(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::visible(&target)
                    }
                    fn set_stroke_color(
                        &mut self,
                        value: ItemStrokeColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_color(&target, value)
                    }
                    fn stroke_color(&self) -> std::result::Result<ItemStrokeColor, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_color(&target)
                    }
                    fn set_on_mouse_leave(
                        &mut self,
                        value: ItemOnMouseLeave,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_leave(&target, value)
                    }
                    fn on_mouse_leave(&self) -> std::result::Result<ItemOnMouseLeave, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_leave(&target)
                    }
                    fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::parent_to_local(&target, point)
                    }
                    fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_above(&target, item)
                    }
                    fn get_items(
                        &self,
                        options: ItemGetItemsParamsOptions,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::get_items(&target, options)
                    }
                    fn has_children(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_children(&target)
                    }
                    fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::translate(&target, delta)
                    }
                    fn set_parent(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_parent(&target, value)
                    }
                    fn parent(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::parent(&target)
                    }
                    fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_locked(&target, value)
                    }
                    fn locked(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::locked(&target)
                    }
                    fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_global(&target, point)
                    }
                }
                impl CompoundPath_Trait for CompoundPath
                where
                    CompoundPath: PathItem_Trait,
                {
                    fn set_area(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        CompoundPath::set_area(target, value)
                    }
                    fn area(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        CompoundPath::area(target)
                    }
                    fn set_first_curve(
                        &mut self,
                        value: Curve,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        CompoundPath::set_first_curve(target, value)
                    }
                    fn first_curve(&self) -> std::result::Result<Curve, JsValue> {
                        let target = self;
                        CompoundPath::first_curve(target)
                    }
                    fn set_closed(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target = self;
                        CompoundPath::set_closed(target, value)
                    }
                    fn closed(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        CompoundPath::closed(target)
                    }
                    fn set_curves(
                        &mut self,
                        value: Vec<Curve>,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        CompoundPath::set_curves(target, value)
                    }
                    fn curves(&self) -> std::result::Result<Vec<Curve>, JsValue> {
                        let target = self;
                        CompoundPath::curves(target)
                    }
                    fn set_first_segment(
                        &mut self,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        CompoundPath::set_first_segment(target, value)
                    }
                    fn first_segment(&self) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        CompoundPath::first_segment(target)
                    }
                    fn set_last_segment(
                        &mut self,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        CompoundPath::set_last_segment(target, value)
                    }
                    fn last_segment(&self) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        CompoundPath::last_segment(target)
                    }
                    fn set_last_curve(&mut self, value: Curve) -> std::result::Result<(), JsValue> {
                        let target = self;
                        CompoundPath::set_last_curve(target, value)
                    }
                    fn last_curve(&self) -> std::result::Result<Curve, JsValue> {
                        let target = self;
                        CompoundPath::last_curve(target)
                    }
                    fn set_length(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        CompoundPath::set_length(target, value)
                    }
                    fn length(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        CompoundPath::length(target)
                    }
                }
                impl std::clone::Clone for CompoundPath_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for CompoundPath_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for CompoundPath_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemShearReturn {
                    __,
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum MatrixScaleParamsScale {
                    F64(f64),
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    #[wasm_bindgen(js_name = "Gradient")]
                    pub type Gradient_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clone , method , js_class = "Gradient" , catch)]
                    fn __TSB_clone_FnToGradient(
                        this: &Gradient_Class,
                    ) -> std::result::Result<Gradient, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = stops , js_class = "Gradient")]
                    fn __TSB_stops(this: &Gradient_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = stops , js_class = "Gradient")]
                    fn __TSB_set_stops(
                        this: &Gradient_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = equals , method , js_class = "Gradient" , catch)]
                    fn __TSB_equals_FnGradientToBool(
                        this: &Gradient_Class,
                        gradient: Gradient,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = radial , js_class = "Gradient")]
                    fn radial(this: &Gradient_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = radial , js_class = "Gradient")]
                    fn set_radial(
                        this: &Gradient_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Gradient(pub Gradient_Class);
                impl std::convert::From<Gradient> for JsValue {
                    fn from(src: Gradient) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for Gradient {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for Gradient {
                    fn instanceof(val: &JsValue) -> bool {
                        Gradient_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        Gradient(Gradient_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(Gradient_Class::unchecked_from_js_ref(val) as *const Gradient_Class
                                as *const Self)
                        }
                    }
                }
                impl Gradient {
                    #[allow(dead_code, non_snake_case)]
                    pub fn clone(&self) -> std::result::Result<Gradient, JsValue> {
                        let result = self.0.__TSB_clone_FnToGradient();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn stops(&self) -> std::result::Result<Vec<GradientStop>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_stops()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_stops(
                        &self,
                        value: Vec<GradientStop>,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_stops({
                            let value_array = js_sys::Array::new();
                            for value_item in value {
                                value_array.push(&JsValue::from(value_item));
                            }
                            value_array.into()
                        });
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn equals(&self, gradient: Gradient) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_equals_FnGradientToBool(gradient);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn radial(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.radial();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_radial(&self, value: bool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_radial(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Gradient {
                    fn describe() {
                        <Gradient_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Gradient {
                    type Abi = <Gradient_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Gradient {
                    type Abi = <Gradient_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Gradient(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Gradient {
                    type Abi = <&'a Gradient_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Gradient {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Gradient {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Gradient_Class =
                            <Gradient_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait Gradient_Trait {
                    fn clone(&self) -> std::result::Result<Gradient, JsValue>;
                    fn set_stops(
                        &mut self,
                        value: Vec<GradientStop>,
                    ) -> std::result::Result<(), JsValue>;
                    fn stops(&self) -> std::result::Result<Vec<GradientStop>, JsValue>;
                    fn equals(&self, gradient: Gradient) -> std::result::Result<bool, JsValue>;
                    fn set_radial(&mut self, value: bool) -> std::result::Result<(), JsValue>;
                    fn radial(&self) -> std::result::Result<bool, JsValue>;
                }
                impl Gradient_Trait for Gradient {
                    fn clone(&self) -> std::result::Result<Gradient, JsValue> {
                        let target = self;
                        Gradient::clone(target)
                    }
                    fn set_stops(
                        &mut self,
                        value: Vec<GradientStop>,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Gradient::set_stops(target, value)
                    }
                    fn stops(&self) -> std::result::Result<Vec<GradientStop>, JsValue> {
                        let target = self;
                        Gradient::stops(target)
                    }
                    fn equals(&self, gradient: Gradient) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Gradient::equals(target, gradient)
                    }
                    fn set_radial(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Gradient::set_radial(target, value)
                    }
                    fn radial(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Gradient::radial(target)
                    }
                }
                impl std::clone::Clone for Gradient_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Gradient_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Gradient_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemOnMouseMove {
                    TsBindgenRtNull,
                    #[serde(
                        serialize_with = "ItemOnMouseMove::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ItemOnMouseMove::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                }
                impl ItemOnMouseMove {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PathItemArcToParamsTo {
                    Point(Point),
                    Bool(bool),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum SizeSubtractParamsNumber {
                    Size(Size),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum HitResultColor {
                    Color(Color),
                    TsBindgenRtNull,
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ColorSubtractReturn {
                    Color(Color),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemCopyToParamsOwner {
                    CompoundPath(CompoundPath),
                    Layer(Layer),
                    Group(Group),
                    Project(Project),
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    # [wasm_bindgen (js_name = "PointText" , extends = Item_Class , extends = TextItem_Class)]
                    pub type PointText_Class;
                    #[wasm_bindgen(constructor, js_class = "PointText")]
                    pub fn new_FnPointToPointText(point: Point) -> PointText_Class;
                    #[wasm_bindgen(constructor, js_class = "PointText")]
                    pub fn new_FnJsValueToPointText(object: JsValue) -> PointText_Class;
                    # [wasm_bindgen (method , structural , catch , getter = point , js_class = "PointText")]
                    fn point(this: &PointText_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = point , js_class = "PointText")]
                    fn set_point(
                        this: &PointText_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct PointText(pub PointText_Class);
                impl std::convert::From<&PointText> for Item {
                    fn from(src: &PointText) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl std::convert::From<&mut PointText> for Item {
                    fn from(src: &mut PointText) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl std::convert::From<&PointText> for TextItem {
                    fn from(src: &PointText) -> TextItem {
                        let src: &TextItem_Class = src.0.as_ref();
                        TextItem(src.clone())
                    }
                }
                impl std::convert::From<&mut PointText> for TextItem {
                    fn from(src: &mut PointText) -> TextItem {
                        let src: &TextItem_Class = src.0.as_ref();
                        TextItem(src.clone())
                    }
                }
                impl std::convert::From<PointText> for JsValue {
                    fn from(src: PointText) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for PointText {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for PointText {
                    fn instanceof(val: &JsValue) -> bool {
                        PointText_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        PointText(PointText_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(PointText_Class::unchecked_from_js_ref(val) as *const PointText_Class
                                as *const Self)
                        }
                    }
                }
                impl PointText {
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnPointToPointText(point: Point) -> PointText {
                        let result = PointText_Class::new_FnPointToPointText(point);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        PointText(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnJsValueToPointText(object: JsValue) -> PointText {
                        let result = PointText_Class::new_FnJsValueToPointText(object);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        PointText(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn point(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.point();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_point(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_point(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for PointText {
                    fn describe() {
                        <PointText_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for PointText {
                    type Abi = <PointText_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for PointText {
                    type Abi = <PointText_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        PointText(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a PointText {
                    type Abi = <&'a PointText_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for PointText {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for PointText {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: PointText_Class =
                            <PointText_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait PointText_Trait: TextItem_Trait {
                    fn set_point(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn point(&self) -> std::result::Result<Point, JsValue>;
                }
                impl TextItem_Trait for PointText
                where
                    PointText: Item_Trait,
                {
                    fn set_justification(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: TextItem = self.into();
                        TextItem::set_justification(&target, value)
                    }
                    fn justification(&self) -> std::result::Result<String, JsValue> {
                        let target: TextItem = self.into();
                        TextItem::justification(&target)
                    }
                    fn set_font_family(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: TextItem = self.into();
                        TextItem::set_font_family(&target, value)
                    }
                    fn font_family(&self) -> std::result::Result<String, JsValue> {
                        let target: TextItem = self.into();
                        TextItem::font_family(&target)
                    }
                    fn set_font_weight(
                        &mut self,
                        value: TextItemFontWeight,
                    ) -> std::result::Result<(), JsValue> {
                        let target: TextItem = self.into();
                        TextItem::set_font_weight(&target, value)
                    }
                    fn font_weight(&self) -> std::result::Result<TextItemFontWeight, JsValue> {
                        let target: TextItem = self.into();
                        TextItem::font_weight(&target)
                    }
                    fn set_font_size(
                        &mut self,
                        value: TextItemFontSize,
                    ) -> std::result::Result<(), JsValue> {
                        let target: TextItem = self.into();
                        TextItem::set_font_size(&target, value)
                    }
                    fn font_size(&self) -> std::result::Result<TextItemFontSize, JsValue> {
                        let target: TextItem = self.into();
                        TextItem::font_size(&target)
                    }
                    fn set_content(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target: TextItem = self.into();
                        TextItem::set_content(&target, value)
                    }
                    fn content(&self) -> std::result::Result<String, JsValue> {
                        let target: TextItem = self.into();
                        TextItem::content(&target)
                    }
                    fn set_leading(
                        &mut self,
                        value: TextItemLeading,
                    ) -> std::result::Result<(), JsValue> {
                        let target: TextItem = self.into();
                        TextItem::set_leading(&target, value)
                    }
                    fn leading(&self) -> std::result::Result<TextItemLeading, JsValue> {
                        let target: TextItem = self.into();
                        TextItem::leading(&target)
                    }
                }
                impl Item_Trait for PointText {
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::responds(&target, type_)
                    }
                    fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_content(&target, source)
                    }
                    fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_opacity(&target, value)
                    }
                    fn opacity(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::opacity(&target)
                    }
                    fn set_on_frame(
                        &mut self,
                        value: ItemOnFrame,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_frame(&target, value)
                    }
                    fn on_frame(&self) -> std::result::Result<ItemOnFrame, JsValue> {
                        let target: Item = self.into();
                        Item::on_frame(&target)
                    }
                    fn remove_children_FnToVecOfItem(
                        &self,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::remove_children_FnToVecOfItem(&target)
                    }
                    fn remove_children_FnF64AndF64ToVecOfItem(
                        &self,
                        start: f64,
                        end: f64,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::remove_children_FnF64AndF64ToVecOfItem(&target, start, end)
                    }
                    fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_below(&target, item)
                    }
                    fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_stroke(&target)
                    }
                    fn set_global_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_global_matrix(&target, value)
                    }
                    fn global_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::global_matrix(&target)
                    }
                    fn copy_attributes(
                        &self,
                        source: Item,
                        exclude_matrix: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_attributes(&target, source, exclude_matrix)
                    }
                    fn set_on_mouse_move(
                        &mut self,
                        value: ItemOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_move(&target, value)
                    }
                    fn on_mouse_move(&self) -> std::result::Result<ItemOnMouseMove, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_move(&target)
                    }
                    fn set_position(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_position(&target, value)
                    }
                    fn position(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::position(&target)
                    }
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_bounds(&target, value)
                    }
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::bounds(&target)
                    }
                    fn set_shadow_blur(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_shadow_blur(&target, value)
                    }
                    fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_blur(&target)
                    }
                    fn set_selected_color(
                        &mut self,
                        value: ItemSelectedColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_selected_color(&target, value)
                    }
                    fn selected_color(&self) -> std::result::Result<ItemSelectedColor, JsValue> {
                        let target: Item = self.into();
                        Item::selected_color(&target)
                    }
                    fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::reverse_children(&target)
                    }
                    fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::bring_to_front(&target)
                    }
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_selected(&target, value)
                    }
                    fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::selected(&target)
                    }
                    fn add_children(
                        &self,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::add_children(&target, items)
                    }
                    fn tween_to(
                        &self,
                        to: JsValue,
                        options: ItemTweenToParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_to(&target, to, options)
                    }
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_project(&target, value)
                    }
                    fn project(&self) -> std::result::Result<Project, JsValue> {
                        let target: Item = self.into();
                        Item::project(&target)
                    }
                    fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_name(&target, value)
                    }
                    fn name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::name(&target)
                    }
                    fn set_stroke_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_bounds(&target, value)
                    }
                    fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_bounds(&target)
                    }
                    fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_below(&target, item)
                    }
                    fn set_blend_mode(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_blend_mode(&target, value)
                    }
                    fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::blend_mode(&target)
                    }
                    fn set_clip_mask(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_clip_mask(&target, value)
                    }
                    fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::clip_mask(&target)
                    }
                    fn set_fill_color(
                        &mut self,
                        value: ItemFillColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_fill_color(&target, value)
                    }
                    fn fill_color(&self) -> std::result::Result<ItemFillColor, JsValue> {
                        let target: Item = self.into();
                        Item::fill_color(&target)
                    }
                    fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_drag(&target)
                    }
                    fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::add_child(&target, item)
                    }
                    fn scale_FnF64AndPointTo(
                        &self,
                        scale: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::scale_FnF64AndPointTo(&target, scale, center)
                    }
                    fn scale_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::scale_FnF64AndF64AndPointTo(&target, hor, ver, center)
                    }
                    fn set_first_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_first_child(&target, value)
                    }
                    fn first_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::first_child(&target)
                    }
                    fn set_style(&mut self, value: Style) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_style(&target, value)
                    }
                    fn style(&self) -> std::result::Result<Style, JsValue> {
                        let target: Item = self.into();
                        Item::style(&target)
                    }
                    fn set_class_name(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_class_name(&target, value)
                    }
                    fn class_name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::class_name(&target)
                    }
                    fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_grouped_with(&target, item)
                    }
                    fn set_shadow_offset(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_shadow_offset(&target, value)
                    }
                    fn shadow_offset(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_offset(&target)
                    }
                    fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inside(&target, rect)
                    }
                    fn set_children(
                        &mut self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_children(&target, value)
                    }
                    fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::children(&target)
                    }
                    fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_fill(&target)
                    }
                    fn matches_FnItemMatchesParamsOptionsToBool(
                        &self,
                        options: ItemMatchesParamsOptions,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::matches_FnItemMatchesParamsOptionsToBool(&target, options)
                    }
                    fn matches_FnStringAndJsValueToBool(
                        &self,
                        name: String,
                        compare: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::matches_FnStringAndJsValueToBool(&target, name, compare)
                    }
                    fn set_on_double_click(
                        &mut self,
                        value: ItemOnDoubleClick,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_double_click(&target, value)
                    }
                    fn on_double_click(&self) -> std::result::Result<ItemOnDoubleClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_double_click(&target)
                    }
                    fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::intersects(&target, item)
                    }
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_rotation(&target, value)
                    }
                    fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::rotation(&target)
                    }
                    fn set_on_mouse_down(
                        &mut self,
                        value: ItemOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_down(&target, value)
                    }
                    fn on_mouse_down(&self) -> std::result::Result<ItemOnMouseDown, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_down(&target)
                    }
                    fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_sibling(&target, item)
                    }
                    fn tween_from(
                        &self,
                        from: JsValue,
                        options: ItemTweenFromParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_from(&target, from, options)
                    }
                    fn set_layer(&mut self, value: Layer) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_layer(&target, value)
                    }
                    fn layer(&self) -> std::result::Result<Layer, JsValue> {
                        let target: Item = self.into();
                        Item::layer(&target)
                    }
                    fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::contains(&target, point)
                    }
                    fn set_on_click(
                        &mut self,
                        value: ItemOnClick,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_click(&target, value)
                    }
                    fn on_click(&self) -> std::result::Result<ItemOnClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_click(&target)
                    }
                    fn set_last_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_last_child(&target, value)
                    }
                    fn last_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::last_child(&target)
                    }
                    fn set_dash_offset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_dash_offset(&target, value)
                    }
                    fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::dash_offset(&target)
                    }
                    fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_id(&target, value)
                    }
                    fn id(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::id(&target)
                    }
                    fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_shadow(&target)
                    }
                    fn tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                        &self,
                        from: JsValue,
                        to: JsValue,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                            &target, from, to, options,
                        )
                    }
                    fn tween_FnJsValueAndItemTweenParamsOptionsToTween(
                        &self,
                        to: JsValue,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_FnJsValueAndItemTweenParamsOptionsToTween(&target, to, options)
                    }
                    fn tween_FnItemTweenParamsOptionsToTween(
                        &self,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_FnItemTweenParamsOptionsToTween(&target, options)
                    }
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_scaling(&target, value)
                    }
                    fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::scaling(&target)
                    }
                    fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::send_to_back(&target)
                    }
                    fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::set(&target, props)
                    }
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_index(&target, value)
                    }
                    fn index(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::index(&target)
                    }
                    fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::reduce(&target, options)
                    }
                    fn set_pivot(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_pivot(&target, value)
                    }
                    fn pivot(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::pivot(&target)
                    }
                    fn insert_children(
                        &self,
                        index: f64,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::insert_children(&target, index, items)
                    }
                    fn set_on_mouse_up(
                        &mut self,
                        value: ItemOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_up(&target, value)
                    }
                    fn on_mouse_up(&self) -> std::result::Result<ItemOnMouseUp, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_up(&target)
                    }
                    fn set_stroke_width(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_width(&target, value)
                    }
                    fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_width(&target)
                    }
                    fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on(&target, options)
                    }
                    fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_up(&target)
                    }
                    fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_child(&target, item)
                    }
                    fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::replace_with(&target, item)
                    }
                    fn export_json(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::export_json(&target, options)
                    }
                    fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test_all(&target, point, options)
                    }
                    fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                        let target: Item = self.into();
                        Item::export_svg(&target, options)
                    }
                    fn copy_to(
                        &self,
                        owner: ItemCopyToParamsOwner,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::copy_to(&target, owner)
                    }
                    fn set_matrix(&mut self, value: Matrix) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_matrix(&target, value)
                    }
                    fn matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::matrix(&target)
                    }
                    fn add_to(
                        &self,
                        owner: ItemAddToParamsOwner,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::add_to(&target, owner)
                    }
                    fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::rotate(&target, angle, center)
                    }
                    fn set_view_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_view_matrix(&target, value)
                    }
                    fn view_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::view_matrix(&target)
                    }
                    fn set_previous_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_previous_sibling(&target, value)
                    }
                    fn previous_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::previous_sibling(&target)
                    }
                    fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_data(&target, value)
                    }
                    fn data(&self) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::data(&target)
                    }
                    fn off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item :: off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                    }
                    fn off_FnJsValueToJsValue(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::off_FnJsValueToJsValue(&target, object)
                    }
                    fn set_stroke_scaling(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_scaling(&target, value)
                    }
                    fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_scaling(&target)
                    }
                    fn insert_child(
                        &self,
                        index: f64,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_child(&target, index, item)
                    }
                    fn skew_FnPointAndPointTo(
                        &self,
                        skew: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::skew_FnPointAndPointTo(&target, skew, center)
                    }
                    fn skew_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::skew_FnF64AndF64AndPointTo(&target, hor, ver, center)
                    }
                    fn on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item :: on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                    }
                    fn on_FnJsValueToJsValue(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::on_FnJsValueToJsValue(&target, object)
                    }
                    fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::remove(&target)
                    }
                    fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::global_to_local(&target, point)
                    }
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::emit(&target, type_, event)
                    }
                    fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test(&target, point, options)
                    }
                    fn import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                        &self,
                        svg: ItemImportSvgParamsSvg,
                        options: JsValue,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                            &target, svg, options,
                        )
                    }
                    fn import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem(
                        &self,
                        svg: ItemImportSvgParamsSvg,
                        on_load: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item :: import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem (& target , svg , on_load)
                    }
                    fn set_dash_array(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_dash_array(&target, value)
                    }
                    fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let target: Item = self.into();
                        Item::dash_array(&target)
                    }
                    fn shear_FnPointAndPointTo(
                        &self,
                        shear: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::shear_FnPointAndPointTo(&target, shear, center)
                    }
                    fn shear_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::shear_FnF64AndF64AndPointTo(&target, hor, ver, center)
                    }
                    fn set_internal_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_internal_bounds(&target, value)
                    }
                    fn internal_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::internal_bounds(&target)
                    }
                    fn set_stroke_cap(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_cap(&target, value)
                    }
                    fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_cap(&target)
                    }
                    fn set_on_mouse_enter(
                        &mut self,
                        value: ItemOnMouseEnter,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_enter(&target, value)
                    }
                    fn on_mouse_enter(&self) -> std::result::Result<ItemOnMouseEnter, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_enter(&target)
                    }
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_view(&target, value)
                    }
                    fn view(&self) -> std::result::Result<View, JsValue> {
                        let target: Item = self.into();
                        Item::view(&target)
                    }
                    fn set_stroke_join(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_join(&target, value)
                    }
                    fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_join(&target)
                    }
                    fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_ancestor(&target, item)
                    }
                    fn set_fill_rule(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_fill_rule(&target, value)
                    }
                    fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::fill_rule(&target)
                    }
                    fn fit_bounds(
                        &self,
                        rectangle: Rectangle,
                        fill: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::fit_bounds(&target, rectangle, fill)
                    }
                    fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_parent(&target, point)
                    }
                    fn set_handle_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_handle_bounds(&target, value)
                    }
                    fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::handle_bounds(&target)
                    }
                    fn set_next_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_next_sibling(&target, value)
                    }
                    fn next_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::next_sibling(&target)
                    }
                    fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::clone(&target, options)
                    }
                    fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_descendant(&target, item)
                    }
                    fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_down(&target)
                    }
                    fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_parent(&target, item)
                    }
                    fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_move(&target)
                    }
                    fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_empty(&target, recursively)
                    }
                    fn rasterize(&self, options: JsValue) -> std::result::Result<Raster, JsValue> {
                        let target: Item = self.into();
                        Item::rasterize(&target, options)
                    }
                    fn set_shadow_color(
                        &mut self,
                        value: ItemShadowColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_shadow_color(&target, value)
                    }
                    fn shadow_color(&self) -> std::result::Result<ItemShadowColor, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_color(&target)
                    }
                    fn set_miter_limit(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_miter_limit(&target, value)
                    }
                    fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::miter_limit(&target)
                    }
                    fn get_item(
                        &self,
                        options: ItemGetItemParamsOptions,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::get_item(&target, options)
                    }
                    fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_json(&target, json)
                    }
                    fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_above(&target, item)
                    }
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ItemOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_drag(&target, value)
                    }
                    fn on_mouse_drag(&self) -> std::result::Result<ItemOnMouseDrag, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_drag(&target)
                    }
                    fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inserted(&target)
                    }
                    fn set_apply_matrix(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_apply_matrix(&target, value)
                    }
                    fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::apply_matrix(&target)
                    }
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::transform(&target, matrix)
                    }
                    fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_visible(&target, value)
                    }
                    fn visible(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::visible(&target)
                    }
                    fn set_stroke_color(
                        &mut self,
                        value: ItemStrokeColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_color(&target, value)
                    }
                    fn stroke_color(&self) -> std::result::Result<ItemStrokeColor, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_color(&target)
                    }
                    fn set_on_mouse_leave(
                        &mut self,
                        value: ItemOnMouseLeave,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_leave(&target, value)
                    }
                    fn on_mouse_leave(&self) -> std::result::Result<ItemOnMouseLeave, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_leave(&target)
                    }
                    fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::parent_to_local(&target, point)
                    }
                    fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_above(&target, item)
                    }
                    fn get_items(
                        &self,
                        options: ItemGetItemsParamsOptions,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::get_items(&target, options)
                    }
                    fn has_children(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_children(&target)
                    }
                    fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::translate(&target, delta)
                    }
                    fn set_parent(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_parent(&target, value)
                    }
                    fn parent(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::parent(&target)
                    }
                    fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_locked(&target, value)
                    }
                    fn locked(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::locked(&target)
                    }
                    fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_global(&target, point)
                    }
                }
                impl PointText_Trait for PointText
                where
                    PointText: TextItem_Trait,
                {
                    fn set_point(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        PointText::set_point(target, value)
                    }
                    fn point(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        PointText::point(target)
                    }
                }
                impl std::clone::Clone for PointText_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for PointText_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for PointText_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PointSubtractReturn {
                    Point(Point),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PaperScopeSetupParamsElement {
                    Size(Size),
                    String(String),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    WebSysHtmlCanvasElement(web_sys::HtmlCanvasElement),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ToolOnMouseDown {
                    TsBindgenRtNull,
                    #[serde(
                        serialize_with = "ToolOnMouseDown::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ToolOnMouseDown::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                }
                impl ToolOnMouseDown {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemOffParamsType {
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    JsValue(JsValue),
                    String(String),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum CurveGetNormalAtParamsLocation {
                    CurveLocation(CurveLocation),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemScaleParamsCenter {
                    Point(Point),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum SizeAddReturn {
                    Size(Size),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PointMultiplyParamsNumber {
                    Point(Point),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum CurveGetWeightedTangentAtParamsLocation {
                    CurveLocation(CurveLocation),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PointAddParamsNumber {
                    Point(Point),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ProjectGetItemParamsOptions {
                    #[serde(
                        serialize_with = "ProjectGetItemParamsOptions::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ProjectGetItemParamsOptions::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    JsValue(JsValue),
                }
                impl ProjectGetItemParamsOptions {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ProjectGetItemsParamsOptions {
                    #[serde(
                        serialize_with = "ProjectGetItemsParamsOptions::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ProjectGetItemsParamsOptions::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    JsValue(JsValue),
                }
                impl ProjectGetItemsParamsOptions {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ColorMultiplyParamsNumber {
                    Color(Color),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum SymbolItemConstructorDefinition {
                    Item(Item),
                    SymbolDefinition(SymbolDefinition),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ToolOnParamsType {
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    JsValue(JsValue),
                    String(String),
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    # [wasm_bindgen (js_name = "Raster" , extends = Item_Class)]
                    pub type Raster_Class;
                    # [wasm_bindgen (method , structural , catch , getter = source , js_class = "Raster")]
                    fn __TSB_source(this: &Raster_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = source , js_class = "Raster")]
                    fn __TSB_set_source(
                        this: &Raster_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = crossOrigin , js_class = "Raster")]
                    fn cross_origin(this: &Raster_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = crossOrigin , js_class = "Raster")]
                    fn set_cross_origin(
                        this: &Raster_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getImageData , method , js_class = "Raster" , catch)]
                    fn __TSB_get_image_data_FnRectangleToWebSysImageData(
                        this: &Raster_Class,
                        rect: Rectangle,
                    ) -> std::result::Result<web_sys::ImageData, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getPixel , method , js_class = "Raster" , catch)]
                    fn __TSB_get_pixel_FnF64AndF64ToColor(
                        this: &Raster_Class,
                        x: f64,
                        y: f64,
                    ) -> std::result::Result<Color, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getPixel , method , js_class = "Raster" , catch)]
                    fn __TSB_get_pixel_FnPointToColor(
                        this: &Raster_Class,
                        point: Point,
                    ) -> std::result::Result<Color, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = width , js_class = "Raster")]
                    fn width(this: &Raster_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = width , js_class = "Raster")]
                    fn set_width(
                        this: &Raster_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = height , js_class = "Raster")]
                    fn height(this: &Raster_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = height , js_class = "Raster")]
                    fn set_height(
                        this: &Raster_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = toDataURL , method , js_class = "Raster" , catch)]
                    fn __TSB_to_data_url_FnToString(
                        this: &Raster_Class,
                    ) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = smoothing , js_class = "Raster")]
                    fn smoothing(this: &Raster_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = smoothing , js_class = "Raster")]
                    fn set_smoothing(
                        this: &Raster_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = image , js_class = "Raster")]
                    fn __TSB_image(this: &Raster_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = image , js_class = "Raster")]
                    fn __TSB_set_image(
                        this: &Raster_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = createImageData , method , js_class = "Raster" , catch)]
                    fn __TSB_create_image_data_FnSizeToWebSysImageData(
                        this: &Raster_Class,
                        size: Size,
                    ) -> std::result::Result<web_sys::ImageData, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = size , js_class = "Raster")]
                    fn size(this: &Raster_Class) -> std::result::Result<Size, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = size , js_class = "Raster")]
                    fn set_size(
                        this: &Raster_Class,
                        value: Size,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onError , js_class = "Raster")]
                    fn __TSB_on_error(this: &Raster_Class)
                        -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onError , js_class = "Raster")]
                    fn __TSB_set_on_error(
                        this: &Raster_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = setImageData , method , js_class = "Raster" , catch)]
                    fn __TSB_set_image_data_FnWebSysImageDataAndPointTo(
                        this: &Raster_Class,
                        data: web_sys::ImageData,
                        point: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onLoad , js_class = "Raster")]
                    fn __TSB_on_load(this: &Raster_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onLoad , js_class = "Raster")]
                    fn __TSB_set_on_load(
                        this: &Raster_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = canvas , js_class = "Raster")]
                    fn __TSB_canvas(
                        this: &Raster_Class,
                    ) -> std::result::Result<web_sys::HtmlCanvasElement, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = canvas , js_class = "Raster")]
                    fn __TSB_set_canvas(
                        this: &Raster_Class,
                        value: web_sys::HtmlCanvasElement,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = drawImage , method , js_class = "Raster" , catch)]
                    fn __TSB_draw_image_FnJsValueAndPointTo(
                        this: &Raster_Class,
                        image: JsValue,
                        point: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = context , js_class = "Raster")]
                    fn __TSB_context(
                        this: &Raster_Class,
                    ) -> std::result::Result<web_sys::CanvasRenderingContext2d, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = context , js_class = "Raster")]
                    fn __TSB_set_context(
                        this: &Raster_Class,
                        value: web_sys::CanvasRenderingContext2d,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = resolution , js_class = "Raster")]
                    fn resolution(this: &Raster_Class) -> std::result::Result<Size, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = resolution , js_class = "Raster")]
                    fn set_resolution(
                        this: &Raster_Class,
                        value: Size,
                    ) -> std::result::Result<(), JsValue>;
                    #[wasm_bindgen(constructor, js_class = "Raster")]
                    pub fn new_FnRasterConstructorSourceAndPointToRaster(
                        source: JsValue,
                        position: Point,
                    ) -> Raster_Class;
                    #[wasm_bindgen(constructor, js_class = "Raster")]
                    pub fn new_FnSizeAndPointToRaster(size: Size, position: Point) -> Raster_Class;
                    #[wasm_bindgen(constructor, js_class = "Raster")]
                    pub fn new_FnJsValueToRaster(object: JsValue) -> Raster_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clear , method , js_class = "Raster" , catch)]
                    fn __TSB_clear_FnTo(this: &Raster_Class) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getSubRaster , method , js_class = "Raster" , catch)]
                    fn __TSB_get_sub_raster_FnRectangleToRaster(
                        this: &Raster_Class,
                        rect: Rectangle,
                    ) -> std::result::Result<Raster, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getAverageColor , method , js_class = "Raster" , catch)]
                    fn __TSB_get_average_color_FnRasterGetAverageColorParamsObjectToColor(
                        this: &Raster_Class,
                        object: JsValue,
                    ) -> std::result::Result<Color, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getSubCanvas , method , js_class = "Raster" , catch)]
                    fn __TSB_get_sub_canvas_FnRectangleToWebSysHtmlCanvasElement(
                        this: &Raster_Class,
                        rect: Rectangle,
                    ) -> std::result::Result<web_sys::HtmlCanvasElement, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = loaded , js_class = "Raster")]
                    fn loaded(this: &Raster_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = loaded , js_class = "Raster")]
                    fn set_loaded(
                        this: &Raster_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = setPixel , method , js_class = "Raster" , catch)]
                    fn __TSB_set_pixel_FnF64AndF64AndColorTo(
                        this: &Raster_Class,
                        x: f64,
                        y: f64,
                        color: Color,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = setPixel , method , js_class = "Raster" , catch)]
                    fn __TSB_set_pixel_FnPointAndColorTo(
                        this: &Raster_Class,
                        point: Point,
                        color: Color,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Raster(pub Raster_Class);
                impl std::convert::From<&Raster> for Item {
                    fn from(src: &Raster) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl std::convert::From<&mut Raster> for Item {
                    fn from(src: &mut Raster) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl std::convert::From<Raster> for JsValue {
                    fn from(src: Raster) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for Raster {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for Raster {
                    fn instanceof(val: &JsValue) -> bool {
                        Raster_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        Raster(Raster_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(Raster_Class::unchecked_from_js_ref(val) as *const Raster_Class
                                as *const Self)
                        }
                    }
                }
                impl Raster {
                    #[allow(dead_code, non_snake_case)]
                    pub fn source(&self) -> std::result::Result<RasterSource, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_source()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_source(
                        &self,
                        value: RasterSource,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_source(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn cross_origin(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.cross_origin();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_cross_origin(
                        &self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_cross_origin(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_image_data(
                        &self,
                        rect: Rectangle,
                    ) -> std::result::Result<web_sys::ImageData, JsValue> {
                        let result = self
                            .0
                            .__TSB_get_image_data_FnRectangleToWebSysImageData(rect);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_pixel_FnF64AndF64ToColor(
                        &self,
                        x: f64,
                        y: f64,
                    ) -> std::result::Result<Color, JsValue> {
                        let result = self.0.__TSB_get_pixel_FnF64AndF64ToColor(x, y);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_pixel_FnPointToColor(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Color, JsValue> {
                        let result = self.0.__TSB_get_pixel_FnPointToColor(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn width(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.width();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_width(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_width(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn height(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.height();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_height(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_height(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn to_data_url(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.__TSB_to_data_url_FnToString();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn smoothing(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.smoothing();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_smoothing(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_smoothing(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn image(&self) -> std::result::Result<RasterImage, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_image()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_image(
                        &self,
                        value: RasterImage,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_image(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn create_image_data(
                        &self,
                        size: Size,
                    ) -> std::result::Result<web_sys::ImageData, JsValue> {
                        let result = self.0.__TSB_create_image_data_FnSizeToWebSysImageData(size);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn size(&self) -> std::result::Result<Size, JsValue> {
                        let result = self.0.size();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_size(&self, value: Size) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_size(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_error(&self) -> std::result::Result<RasterOnError, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_error()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_on_error(
                        &self,
                        value: RasterOnError,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_error(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_image_data(
                        &self,
                        data: web_sys::ImageData,
                        point: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self
                            .0
                            .__TSB_set_image_data_FnWebSysImageDataAndPointTo(data, point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_load(&self) -> std::result::Result<RasterOnLoad, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_load()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_on_load(
                        &self,
                        value: RasterOnLoad,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_load(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn canvas(
                        &self,
                    ) -> std::result::Result<web_sys::HtmlCanvasElement, JsValue>
                    {
                        let result = self.0.__TSB_canvas();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_canvas(
                        &self,
                        value: web_sys::HtmlCanvasElement,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_canvas(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn draw_image(
                        &self,
                        image: JsValue,
                        point: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_draw_image_FnJsValueAndPointTo(image, point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn context(
                        &self,
                    ) -> std::result::Result<web_sys::CanvasRenderingContext2d, JsValue>
                    {
                        let result = self.0.__TSB_context();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_context(
                        &self,
                        value: web_sys::CanvasRenderingContext2d,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_context(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn resolution(&self) -> std::result::Result<Size, JsValue> {
                        let result = self.0.resolution();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_resolution(&self, value: Size) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_resolution(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnRasterConstructorSourceAndPointToRaster(
                        source: RasterConstructorSource,
                        position: Point,
                    ) -> Raster {
                        let result = Raster_Class::new_FnRasterConstructorSourceAndPointToRaster(
                            ts_bindgen_rt::to_jsvalue(&source).unwrap(),
                            position,
                        );
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Raster(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnSizeAndPointToRaster(size: Size, position: Point) -> Raster {
                        let result = Raster_Class::new_FnSizeAndPointToRaster(size, position);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Raster(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnJsValueToRaster(object: JsValue) -> Raster {
                        let result = Raster_Class::new_FnJsValueToRaster(object);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Raster(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn clear(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_clear_FnTo();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_sub_raster(
                        &self,
                        rect: Rectangle,
                    ) -> std::result::Result<Raster, JsValue> {
                        let result = self.0.__TSB_get_sub_raster_FnRectangleToRaster(rect);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_average_color(
                        &self,
                        object: RasterGetAverageColorParamsObject,
                    ) -> std::result::Result<Color, JsValue> {
                        let result = self
                            .0
                            .__TSB_get_average_color_FnRasterGetAverageColorParamsObjectToColor(
                                ts_bindgen_rt::to_jsvalue(&object)
                                    .map_err(ts_bindgen_rt::Error::from)
                                    .map_err(JsValue::from)?,
                            );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_sub_canvas(
                        &self,
                        rect: Rectangle,
                    ) -> std::result::Result<web_sys::HtmlCanvasElement, JsValue>
                    {
                        let result = self
                            .0
                            .__TSB_get_sub_canvas_FnRectangleToWebSysHtmlCanvasElement(rect);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn loaded(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.loaded();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_loaded(&self, value: bool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_loaded(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_pixel_FnF64AndF64AndColorTo(
                        &self,
                        x: f64,
                        y: f64,
                        color: Color,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_pixel_FnF64AndF64AndColorTo(x, y, color);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_pixel_FnPointAndColorTo(
                        &self,
                        point: Point,
                        color: Color,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_pixel_FnPointAndColorTo(point, color);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Raster {
                    fn describe() {
                        <Raster_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Raster {
                    type Abi = <Raster_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Raster {
                    type Abi = <Raster_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Raster(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Raster {
                    type Abi = <&'a Raster_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Raster {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Raster {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Raster_Class =
                            <Raster_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait Raster_Trait: Item_Trait {
                    fn set_source(
                        &mut self,
                        value: RasterSource,
                    ) -> std::result::Result<(), JsValue>;
                    fn source(&self) -> std::result::Result<RasterSource, JsValue>;
                    fn set_cross_origin(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    fn cross_origin(&self) -> std::result::Result<String, JsValue>;
                    fn get_image_data(
                        &self,
                        rect: Rectangle,
                    ) -> std::result::Result<web_sys::ImageData, JsValue>;
                    fn get_pixel_FnF64AndF64ToColor(
                        &self,
                        x: f64,
                        y: f64,
                    ) -> std::result::Result<Color, JsValue>;
                    fn get_pixel_FnPointToColor(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Color, JsValue>;
                    fn set_width(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn width(&self) -> std::result::Result<f64, JsValue>;
                    fn set_height(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn height(&self) -> std::result::Result<f64, JsValue>;
                    fn to_data_url(&self) -> std::result::Result<String, JsValue>;
                    fn set_smoothing(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn smoothing(&self) -> std::result::Result<String, JsValue>;
                    fn set_image(&mut self, value: RasterImage)
                        -> std::result::Result<(), JsValue>;
                    fn image(&self) -> std::result::Result<RasterImage, JsValue>;
                    fn create_image_data(
                        &self,
                        size: Size,
                    ) -> std::result::Result<web_sys::ImageData, JsValue>;
                    fn set_size(&mut self, value: Size) -> std::result::Result<(), JsValue>;
                    fn size(&self) -> std::result::Result<Size, JsValue>;
                    fn set_on_error(
                        &mut self,
                        value: RasterOnError,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_error(&self) -> std::result::Result<RasterOnError, JsValue>;
                    fn set_image_data(
                        &self,
                        data: web_sys::ImageData,
                        point: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn set_on_load(
                        &mut self,
                        value: RasterOnLoad,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_load(&self) -> std::result::Result<RasterOnLoad, JsValue>;
                    fn set_canvas(
                        &mut self,
                        value: web_sys::HtmlCanvasElement,
                    ) -> std::result::Result<(), JsValue>;
                    fn canvas(&self) -> std::result::Result<web_sys::HtmlCanvasElement, JsValue>;
                    fn draw_image(
                        &self,
                        image: JsValue,
                        point: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn set_context(
                        &mut self,
                        value: web_sys::CanvasRenderingContext2d,
                    ) -> std::result::Result<(), JsValue>;
                    fn context(
                        &self,
                    ) -> std::result::Result<web_sys::CanvasRenderingContext2d, JsValue>;
                    fn set_resolution(&mut self, value: Size) -> std::result::Result<(), JsValue>;
                    fn resolution(&self) -> std::result::Result<Size, JsValue>;
                    fn clear(&self) -> std::result::Result<(), JsValue>;
                    fn get_sub_raster(
                        &self,
                        rect: Rectangle,
                    ) -> std::result::Result<Raster, JsValue>;
                    fn get_average_color(
                        &self,
                        object: RasterGetAverageColorParamsObject,
                    ) -> std::result::Result<Color, JsValue>;
                    fn get_sub_canvas(
                        &self,
                        rect: Rectangle,
                    ) -> std::result::Result<web_sys::HtmlCanvasElement, JsValue>;
                    fn set_loaded(&mut self, value: bool) -> std::result::Result<(), JsValue>;
                    fn loaded(&self) -> std::result::Result<bool, JsValue>;
                    fn set_pixel_FnF64AndF64AndColorTo(
                        &self,
                        x: f64,
                        y: f64,
                        color: Color,
                    ) -> std::result::Result<(), JsValue>;
                    fn set_pixel_FnPointAndColorTo(
                        &self,
                        point: Point,
                        color: Color,
                    ) -> std::result::Result<(), JsValue>;
                }
                impl Item_Trait for Raster {
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::responds(&target, type_)
                    }
                    fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_content(&target, source)
                    }
                    fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_opacity(&target, value)
                    }
                    fn opacity(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::opacity(&target)
                    }
                    fn set_on_frame(
                        &mut self,
                        value: ItemOnFrame,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_frame(&target, value)
                    }
                    fn on_frame(&self) -> std::result::Result<ItemOnFrame, JsValue> {
                        let target: Item = self.into();
                        Item::on_frame(&target)
                    }
                    fn remove_children_FnToVecOfItem(
                        &self,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::remove_children_FnToVecOfItem(&target)
                    }
                    fn remove_children_FnF64AndF64ToVecOfItem(
                        &self,
                        start: f64,
                        end: f64,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::remove_children_FnF64AndF64ToVecOfItem(&target, start, end)
                    }
                    fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_below(&target, item)
                    }
                    fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_stroke(&target)
                    }
                    fn set_global_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_global_matrix(&target, value)
                    }
                    fn global_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::global_matrix(&target)
                    }
                    fn copy_attributes(
                        &self,
                        source: Item,
                        exclude_matrix: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_attributes(&target, source, exclude_matrix)
                    }
                    fn set_on_mouse_move(
                        &mut self,
                        value: ItemOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_move(&target, value)
                    }
                    fn on_mouse_move(&self) -> std::result::Result<ItemOnMouseMove, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_move(&target)
                    }
                    fn set_position(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_position(&target, value)
                    }
                    fn position(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::position(&target)
                    }
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_bounds(&target, value)
                    }
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::bounds(&target)
                    }
                    fn set_shadow_blur(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_shadow_blur(&target, value)
                    }
                    fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_blur(&target)
                    }
                    fn set_selected_color(
                        &mut self,
                        value: ItemSelectedColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_selected_color(&target, value)
                    }
                    fn selected_color(&self) -> std::result::Result<ItemSelectedColor, JsValue> {
                        let target: Item = self.into();
                        Item::selected_color(&target)
                    }
                    fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::reverse_children(&target)
                    }
                    fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::bring_to_front(&target)
                    }
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_selected(&target, value)
                    }
                    fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::selected(&target)
                    }
                    fn add_children(
                        &self,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::add_children(&target, items)
                    }
                    fn tween_to(
                        &self,
                        to: JsValue,
                        options: ItemTweenToParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_to(&target, to, options)
                    }
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_project(&target, value)
                    }
                    fn project(&self) -> std::result::Result<Project, JsValue> {
                        let target: Item = self.into();
                        Item::project(&target)
                    }
                    fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_name(&target, value)
                    }
                    fn name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::name(&target)
                    }
                    fn set_stroke_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_bounds(&target, value)
                    }
                    fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_bounds(&target)
                    }
                    fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_below(&target, item)
                    }
                    fn set_blend_mode(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_blend_mode(&target, value)
                    }
                    fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::blend_mode(&target)
                    }
                    fn set_clip_mask(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_clip_mask(&target, value)
                    }
                    fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::clip_mask(&target)
                    }
                    fn set_fill_color(
                        &mut self,
                        value: ItemFillColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_fill_color(&target, value)
                    }
                    fn fill_color(&self) -> std::result::Result<ItemFillColor, JsValue> {
                        let target: Item = self.into();
                        Item::fill_color(&target)
                    }
                    fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_drag(&target)
                    }
                    fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::add_child(&target, item)
                    }
                    fn scale_FnF64AndPointTo(
                        &self,
                        scale: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::scale_FnF64AndPointTo(&target, scale, center)
                    }
                    fn scale_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::scale_FnF64AndF64AndPointTo(&target, hor, ver, center)
                    }
                    fn set_first_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_first_child(&target, value)
                    }
                    fn first_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::first_child(&target)
                    }
                    fn set_style(&mut self, value: Style) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_style(&target, value)
                    }
                    fn style(&self) -> std::result::Result<Style, JsValue> {
                        let target: Item = self.into();
                        Item::style(&target)
                    }
                    fn set_class_name(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_class_name(&target, value)
                    }
                    fn class_name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::class_name(&target)
                    }
                    fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_grouped_with(&target, item)
                    }
                    fn set_shadow_offset(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_shadow_offset(&target, value)
                    }
                    fn shadow_offset(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_offset(&target)
                    }
                    fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inside(&target, rect)
                    }
                    fn set_children(
                        &mut self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_children(&target, value)
                    }
                    fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::children(&target)
                    }
                    fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_fill(&target)
                    }
                    fn matches_FnItemMatchesParamsOptionsToBool(
                        &self,
                        options: ItemMatchesParamsOptions,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::matches_FnItemMatchesParamsOptionsToBool(&target, options)
                    }
                    fn matches_FnStringAndJsValueToBool(
                        &self,
                        name: String,
                        compare: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::matches_FnStringAndJsValueToBool(&target, name, compare)
                    }
                    fn set_on_double_click(
                        &mut self,
                        value: ItemOnDoubleClick,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_double_click(&target, value)
                    }
                    fn on_double_click(&self) -> std::result::Result<ItemOnDoubleClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_double_click(&target)
                    }
                    fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::intersects(&target, item)
                    }
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_rotation(&target, value)
                    }
                    fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::rotation(&target)
                    }
                    fn set_on_mouse_down(
                        &mut self,
                        value: ItemOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_down(&target, value)
                    }
                    fn on_mouse_down(&self) -> std::result::Result<ItemOnMouseDown, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_down(&target)
                    }
                    fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_sibling(&target, item)
                    }
                    fn tween_from(
                        &self,
                        from: JsValue,
                        options: ItemTweenFromParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_from(&target, from, options)
                    }
                    fn set_layer(&mut self, value: Layer) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_layer(&target, value)
                    }
                    fn layer(&self) -> std::result::Result<Layer, JsValue> {
                        let target: Item = self.into();
                        Item::layer(&target)
                    }
                    fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::contains(&target, point)
                    }
                    fn set_on_click(
                        &mut self,
                        value: ItemOnClick,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_click(&target, value)
                    }
                    fn on_click(&self) -> std::result::Result<ItemOnClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_click(&target)
                    }
                    fn set_last_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_last_child(&target, value)
                    }
                    fn last_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::last_child(&target)
                    }
                    fn set_dash_offset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_dash_offset(&target, value)
                    }
                    fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::dash_offset(&target)
                    }
                    fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_id(&target, value)
                    }
                    fn id(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::id(&target)
                    }
                    fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_shadow(&target)
                    }
                    fn tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                        &self,
                        from: JsValue,
                        to: JsValue,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                            &target, from, to, options,
                        )
                    }
                    fn tween_FnJsValueAndItemTweenParamsOptionsToTween(
                        &self,
                        to: JsValue,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_FnJsValueAndItemTweenParamsOptionsToTween(&target, to, options)
                    }
                    fn tween_FnItemTweenParamsOptionsToTween(
                        &self,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_FnItemTweenParamsOptionsToTween(&target, options)
                    }
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_scaling(&target, value)
                    }
                    fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::scaling(&target)
                    }
                    fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::send_to_back(&target)
                    }
                    fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::set(&target, props)
                    }
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_index(&target, value)
                    }
                    fn index(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::index(&target)
                    }
                    fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::reduce(&target, options)
                    }
                    fn set_pivot(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_pivot(&target, value)
                    }
                    fn pivot(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::pivot(&target)
                    }
                    fn insert_children(
                        &self,
                        index: f64,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::insert_children(&target, index, items)
                    }
                    fn set_on_mouse_up(
                        &mut self,
                        value: ItemOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_up(&target, value)
                    }
                    fn on_mouse_up(&self) -> std::result::Result<ItemOnMouseUp, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_up(&target)
                    }
                    fn set_stroke_width(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_width(&target, value)
                    }
                    fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_width(&target)
                    }
                    fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on(&target, options)
                    }
                    fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_up(&target)
                    }
                    fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_child(&target, item)
                    }
                    fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::replace_with(&target, item)
                    }
                    fn export_json(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::export_json(&target, options)
                    }
                    fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test_all(&target, point, options)
                    }
                    fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                        let target: Item = self.into();
                        Item::export_svg(&target, options)
                    }
                    fn copy_to(
                        &self,
                        owner: ItemCopyToParamsOwner,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::copy_to(&target, owner)
                    }
                    fn set_matrix(&mut self, value: Matrix) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_matrix(&target, value)
                    }
                    fn matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::matrix(&target)
                    }
                    fn add_to(
                        &self,
                        owner: ItemAddToParamsOwner,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::add_to(&target, owner)
                    }
                    fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::rotate(&target, angle, center)
                    }
                    fn set_view_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_view_matrix(&target, value)
                    }
                    fn view_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::view_matrix(&target)
                    }
                    fn set_previous_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_previous_sibling(&target, value)
                    }
                    fn previous_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::previous_sibling(&target)
                    }
                    fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_data(&target, value)
                    }
                    fn data(&self) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::data(&target)
                    }
                    fn off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item :: off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                    }
                    fn off_FnJsValueToJsValue(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::off_FnJsValueToJsValue(&target, object)
                    }
                    fn set_stroke_scaling(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_scaling(&target, value)
                    }
                    fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_scaling(&target)
                    }
                    fn insert_child(
                        &self,
                        index: f64,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_child(&target, index, item)
                    }
                    fn skew_FnPointAndPointTo(
                        &self,
                        skew: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::skew_FnPointAndPointTo(&target, skew, center)
                    }
                    fn skew_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::skew_FnF64AndF64AndPointTo(&target, hor, ver, center)
                    }
                    fn on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item :: on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                    }
                    fn on_FnJsValueToJsValue(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::on_FnJsValueToJsValue(&target, object)
                    }
                    fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::remove(&target)
                    }
                    fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::global_to_local(&target, point)
                    }
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::emit(&target, type_, event)
                    }
                    fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test(&target, point, options)
                    }
                    fn import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                        &self,
                        svg: ItemImportSvgParamsSvg,
                        options: JsValue,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                            &target, svg, options,
                        )
                    }
                    fn import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem(
                        &self,
                        svg: ItemImportSvgParamsSvg,
                        on_load: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item :: import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem (& target , svg , on_load)
                    }
                    fn set_dash_array(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_dash_array(&target, value)
                    }
                    fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let target: Item = self.into();
                        Item::dash_array(&target)
                    }
                    fn shear_FnPointAndPointTo(
                        &self,
                        shear: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::shear_FnPointAndPointTo(&target, shear, center)
                    }
                    fn shear_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::shear_FnF64AndF64AndPointTo(&target, hor, ver, center)
                    }
                    fn set_internal_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_internal_bounds(&target, value)
                    }
                    fn internal_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::internal_bounds(&target)
                    }
                    fn set_stroke_cap(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_cap(&target, value)
                    }
                    fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_cap(&target)
                    }
                    fn set_on_mouse_enter(
                        &mut self,
                        value: ItemOnMouseEnter,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_enter(&target, value)
                    }
                    fn on_mouse_enter(&self) -> std::result::Result<ItemOnMouseEnter, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_enter(&target)
                    }
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_view(&target, value)
                    }
                    fn view(&self) -> std::result::Result<View, JsValue> {
                        let target: Item = self.into();
                        Item::view(&target)
                    }
                    fn set_stroke_join(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_join(&target, value)
                    }
                    fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_join(&target)
                    }
                    fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_ancestor(&target, item)
                    }
                    fn set_fill_rule(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_fill_rule(&target, value)
                    }
                    fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::fill_rule(&target)
                    }
                    fn fit_bounds(
                        &self,
                        rectangle: Rectangle,
                        fill: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::fit_bounds(&target, rectangle, fill)
                    }
                    fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_parent(&target, point)
                    }
                    fn set_handle_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_handle_bounds(&target, value)
                    }
                    fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::handle_bounds(&target)
                    }
                    fn set_next_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_next_sibling(&target, value)
                    }
                    fn next_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::next_sibling(&target)
                    }
                    fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::clone(&target, options)
                    }
                    fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_descendant(&target, item)
                    }
                    fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_down(&target)
                    }
                    fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_parent(&target, item)
                    }
                    fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_move(&target)
                    }
                    fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_empty(&target, recursively)
                    }
                    fn rasterize(&self, options: JsValue) -> std::result::Result<Raster, JsValue> {
                        let target: Item = self.into();
                        Item::rasterize(&target, options)
                    }
                    fn set_shadow_color(
                        &mut self,
                        value: ItemShadowColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_shadow_color(&target, value)
                    }
                    fn shadow_color(&self) -> std::result::Result<ItemShadowColor, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_color(&target)
                    }
                    fn set_miter_limit(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_miter_limit(&target, value)
                    }
                    fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::miter_limit(&target)
                    }
                    fn get_item(
                        &self,
                        options: ItemGetItemParamsOptions,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::get_item(&target, options)
                    }
                    fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_json(&target, json)
                    }
                    fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_above(&target, item)
                    }
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ItemOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_drag(&target, value)
                    }
                    fn on_mouse_drag(&self) -> std::result::Result<ItemOnMouseDrag, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_drag(&target)
                    }
                    fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inserted(&target)
                    }
                    fn set_apply_matrix(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_apply_matrix(&target, value)
                    }
                    fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::apply_matrix(&target)
                    }
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::transform(&target, matrix)
                    }
                    fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_visible(&target, value)
                    }
                    fn visible(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::visible(&target)
                    }
                    fn set_stroke_color(
                        &mut self,
                        value: ItemStrokeColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_color(&target, value)
                    }
                    fn stroke_color(&self) -> std::result::Result<ItemStrokeColor, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_color(&target)
                    }
                    fn set_on_mouse_leave(
                        &mut self,
                        value: ItemOnMouseLeave,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_leave(&target, value)
                    }
                    fn on_mouse_leave(&self) -> std::result::Result<ItemOnMouseLeave, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_leave(&target)
                    }
                    fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::parent_to_local(&target, point)
                    }
                    fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_above(&target, item)
                    }
                    fn get_items(
                        &self,
                        options: ItemGetItemsParamsOptions,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::get_items(&target, options)
                    }
                    fn has_children(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_children(&target)
                    }
                    fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::translate(&target, delta)
                    }
                    fn set_parent(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_parent(&target, value)
                    }
                    fn parent(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::parent(&target)
                    }
                    fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_locked(&target, value)
                    }
                    fn locked(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::locked(&target)
                    }
                    fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_global(&target, point)
                    }
                }
                impl Raster_Trait for Raster
                where
                    Raster: Item_Trait,
                {
                    fn set_source(
                        &mut self,
                        value: RasterSource,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Raster::set_source(target, value)
                    }
                    fn source(&self) -> std::result::Result<RasterSource, JsValue> {
                        let target = self;
                        Raster::source(target)
                    }
                    fn set_cross_origin(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Raster::set_cross_origin(target, value)
                    }
                    fn cross_origin(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Raster::cross_origin(target)
                    }
                    fn get_image_data(
                        &self,
                        rect: Rectangle,
                    ) -> std::result::Result<web_sys::ImageData, JsValue> {
                        let target = self;
                        Raster::get_image_data(target, rect)
                    }
                    fn get_pixel_FnF64AndF64ToColor(
                        &self,
                        x: f64,
                        y: f64,
                    ) -> std::result::Result<Color, JsValue> {
                        let target = self;
                        Raster::get_pixel_FnF64AndF64ToColor(target, x, y)
                    }
                    fn get_pixel_FnPointToColor(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Color, JsValue> {
                        let target = self;
                        Raster::get_pixel_FnPointToColor(target, point)
                    }
                    fn set_width(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Raster::set_width(target, value)
                    }
                    fn width(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Raster::width(target)
                    }
                    fn set_height(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Raster::set_height(target, value)
                    }
                    fn height(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Raster::height(target)
                    }
                    fn to_data_url(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Raster::to_data_url(target)
                    }
                    fn set_smoothing(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Raster::set_smoothing(target, value)
                    }
                    fn smoothing(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Raster::smoothing(target)
                    }
                    fn set_image(
                        &mut self,
                        value: RasterImage,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Raster::set_image(target, value)
                    }
                    fn image(&self) -> std::result::Result<RasterImage, JsValue> {
                        let target = self;
                        Raster::image(target)
                    }
                    fn create_image_data(
                        &self,
                        size: Size,
                    ) -> std::result::Result<web_sys::ImageData, JsValue> {
                        let target = self;
                        Raster::create_image_data(target, size)
                    }
                    fn set_size(&mut self, value: Size) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Raster::set_size(target, value)
                    }
                    fn size(&self) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Raster::size(target)
                    }
                    fn set_on_error(
                        &mut self,
                        value: RasterOnError,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Raster::set_on_error(target, value)
                    }
                    fn on_error(&self) -> std::result::Result<RasterOnError, JsValue> {
                        let target = self;
                        Raster::on_error(target)
                    }
                    fn set_image_data(
                        &self,
                        data: web_sys::ImageData,
                        point: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Raster::set_image_data(target, data, point)
                    }
                    fn set_on_load(
                        &mut self,
                        value: RasterOnLoad,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Raster::set_on_load(target, value)
                    }
                    fn on_load(&self) -> std::result::Result<RasterOnLoad, JsValue> {
                        let target = self;
                        Raster::on_load(target)
                    }
                    fn set_canvas(
                        &mut self,
                        value: web_sys::HtmlCanvasElement,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Raster::set_canvas(target, value)
                    }
                    fn canvas(&self) -> std::result::Result<web_sys::HtmlCanvasElement, JsValue> {
                        let target = self;
                        Raster::canvas(target)
                    }
                    fn draw_image(
                        &self,
                        image: JsValue,
                        point: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Raster::draw_image(target, image, point)
                    }
                    fn set_context(
                        &mut self,
                        value: web_sys::CanvasRenderingContext2d,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Raster::set_context(target, value)
                    }
                    fn context(
                        &self,
                    ) -> std::result::Result<web_sys::CanvasRenderingContext2d, JsValue>
                    {
                        let target = self;
                        Raster::context(target)
                    }
                    fn set_resolution(&mut self, value: Size) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Raster::set_resolution(target, value)
                    }
                    fn resolution(&self) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Raster::resolution(target)
                    }
                    fn clear(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Raster::clear(target)
                    }
                    fn get_sub_raster(
                        &self,
                        rect: Rectangle,
                    ) -> std::result::Result<Raster, JsValue> {
                        let target = self;
                        Raster::get_sub_raster(target, rect)
                    }
                    fn get_average_color(
                        &self,
                        object: RasterGetAverageColorParamsObject,
                    ) -> std::result::Result<Color, JsValue> {
                        let target = self;
                        Raster::get_average_color(target, object)
                    }
                    fn get_sub_canvas(
                        &self,
                        rect: Rectangle,
                    ) -> std::result::Result<web_sys::HtmlCanvasElement, JsValue>
                    {
                        let target = self;
                        Raster::get_sub_canvas(target, rect)
                    }
                    fn set_loaded(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Raster::set_loaded(target, value)
                    }
                    fn loaded(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Raster::loaded(target)
                    }
                    fn set_pixel_FnF64AndF64AndColorTo(
                        &self,
                        x: f64,
                        y: f64,
                        color: Color,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Raster::set_pixel_FnF64AndF64AndColorTo(target, x, y, color)
                    }
                    fn set_pixel_FnPointAndColorTo(
                        &self,
                        point: Point,
                        color: Color,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Raster::set_pixel_FnPointAndColorTo(target, point, color)
                    }
                }
                impl std::clone::Clone for Raster_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Raster_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Raster_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum StyleShadowColor {
                    Color(Color),
                    TsBindgenRtNull,
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum TweenConstructorEasing {
                    #[serde(
                        serialize_with = "TweenConstructorEasing::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "TweenConstructorEasing::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                    String(String),
                }
                impl TweenConstructorEasing {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    #[wasm_bindgen(js_name = "Curve")]
                    pub type Curve_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = toString , method , js_class = "Curve" , catch)]
                    fn __TSB_to_string_FnToString(
                        this: &Curve_Class,
                    ) -> std::result::Result<String, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getTangentAt , method , js_class = "Curve" , catch)]
                    fn __TSB_get_tangent_at_FnCurveGetTangentAtParamsLocationToPoint(
                        this: &Curve_Class,
                        location: JsValue,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = divideAt , method , js_class = "Curve" , catch)]
                    fn __TSB_divide_at_FnCurveDivideAtParamsLocationToCurve(
                        this: &Curve_Class,
                        location: JsValue,
                    ) -> std::result::Result<Curve, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getPointAtTime , method , js_class = "Curve" , catch)]
                    fn __TSB_get_point_at_time_FnF64ToPoint(
                        this: &Curve_Class,
                        time: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getIntersections , method , js_class = "Curve" , catch)]
                    fn __TSB_get_intersections_FnCurveToVecOfCurveLocation(
                        this: &Curve_Class,
                        curve: Curve,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getWeightedNormalAt , method , js_class = "Curve" , catch)]
                    fn __TSB_get_weighted_normal_at_FnCurveGetWeightedNormalAtParamsLocationToPoint(
                        this: &Curve_Class,
                        location: JsValue,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getPointAt , method , js_class = "Curve" , catch)]
                    fn __TSB_get_point_at_FnCurveGetPointAtParamsLocationToPoint(
                        this: &Curve_Class,
                        location: JsValue,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clone , method , js_class = "Curve" , catch)]
                    fn __TSB_clone_FnToCurve(
                        this: &Curve_Class,
                    ) -> std::result::Result<Curve, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = index , js_class = "Curve")]
                    fn index(this: &Curve_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = index , js_class = "Curve")]
                    fn set_index(
                        this: &Curve_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = divideAtTime , method , js_class = "Curve" , catch)]
                    fn __TSB_divide_at_time_FnF64ToCurve(
                        this: &Curve_Class,
                        time: f64,
                    ) -> std::result::Result<Curve, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = segment1 , js_class = "Curve")]
                    fn segment1(this: &Curve_Class) -> std::result::Result<Segment, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = segment1 , js_class = "Curve")]
                    fn set_segment1(
                        this: &Curve_Class,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getNormalAt , method , js_class = "Curve" , catch)]
                    fn __TSB_get_normal_at_FnCurveGetNormalAtParamsLocationToPoint(
                        this: &Curve_Class,
                        location: JsValue,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isLinear , method , js_class = "Curve" , catch)]
                    fn __TSB_is_linear_FnToBool(
                        this: &Curve_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = handle1 , js_class = "Curve")]
                    fn handle1(this: &Curve_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = handle1 , js_class = "Curve")]
                    fn set_handle1(
                        this: &Curve_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = splitAtTime , method , js_class = "Curve" , catch)]
                    fn __TSB_split_at_time_FnF64ToPath(
                        this: &Curve_Class,
                        time: f64,
                    ) -> std::result::Result<Path, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = selected , js_class = "Curve")]
                    fn selected(this: &Curve_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = selected , js_class = "Curve")]
                    fn set_selected(
                        this: &Curve_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = hasLength , method , js_class = "Curve" , catch)]
                    fn __TSB_has_length_FnF64ToBool(
                        this: &Curve_Class,
                        epsilon: f64,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = segment2 , js_class = "Curve")]
                    fn segment2(this: &Curve_Class) -> std::result::Result<Segment, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = segment2 , js_class = "Curve")]
                    fn set_segment2(
                        this: &Curve_Class,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getNearestLocation , method , js_class = "Curve" , catch)]
                    fn __TSB_get_nearest_location_FnPointToCurveLocation(
                        this: &Curve_Class,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = remove , method , js_class = "Curve" , catch)]
                    fn __TSB_remove_FnToBool(
                        this: &Curve_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getWeightedNormalAtTime , method , js_class = "Curve" , catch)]
                    fn __TSB_get_weighted_normal_at_time_FnF64ToPoint(
                        this: &Curve_Class,
                        time: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getLocationAt , method , js_class = "Curve" , catch)]
                    fn __TSB_get_location_at_FnF64ToCurveLocation(
                        this: &Curve_Class,
                        offset: f64,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = handle2 , js_class = "Curve")]
                    fn handle2(this: &Curve_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = handle2 , js_class = "Curve")]
                    fn set_handle2(
                        this: &Curve_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = handleBounds , js_class = "Curve")]
                    fn handle_bounds(this: &Curve_Class)
                        -> std::result::Result<Rectangle, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = handleBounds , js_class = "Curve")]
                    fn set_handle_bounds(
                        this: &Curve_Class,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = points , js_class = "Curve")]
                    fn __TSB_points(this: &Curve_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = points , js_class = "Curve")]
                    fn __TSB_set_points(
                        this: &Curve_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getWeightedTangentAt , method , js_class = "Curve" , catch)]
                    fn __TSB_get_weighted_tangent_at_FnCurveGetWeightedTangentAtParamsLocationToPoint(
                        this: &Curve_Class,
                        location: JsValue,
                    ) -> std::result::Result<Point, JsValue>;
                    #[wasm_bindgen(constructor, js_class = "Curve")]
                    pub fn new_FnSegmentAndSegmentToCurve(
                        segment1: Segment,
                        segment2: Segment,
                    ) -> Curve_Class;
                    #[wasm_bindgen(constructor, js_class = "Curve")]
                    pub fn new_FnPointAndPointAndPointAndPointToCurve(
                        point1: Point,
                        handle1: Point,
                        handle2: Point,
                        point2: Point,
                    ) -> Curve_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getCurvatureAt , method , js_class = "Curve" , catch)]
                    fn __TSB_get_curvature_at_FnCurveGetCurvatureAtParamsLocationToF64(
                        this: &Curve_Class,
                        location: JsValue,
                    ) -> std::result::Result<f64, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getTimesWithTangent , method , js_class = "Curve" , catch)]
                    fn __TSB_get_times_with_tangent_FnPointToVecOfF64(
                        this: &Curve_Class,
                        tangent: Point,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getNormalAtTime , method , js_class = "Curve" , catch)]
                    fn __TSB_get_normal_at_time_FnF64ToPoint(
                        this: &Curve_Class,
                        time: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = path , js_class = "Curve")]
                    fn path(this: &Curve_Class) -> std::result::Result<Path, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = path , js_class = "Curve")]
                    fn set_path(
                        this: &Curve_Class,
                        value: Path,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = bounds , js_class = "Curve")]
                    fn bounds(this: &Curve_Class) -> std::result::Result<Rectangle, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = bounds , js_class = "Curve")]
                    fn set_bounds(
                        this: &Curve_Class,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isHorizontal , method , js_class = "Curve" , catch)]
                    fn __TSB_is_horizontal_FnToBool(
                        this: &Curve_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isLast , method , js_class = "Curve" , catch)]
                    fn __TSB_is_last_FnToBool(
                        this: &Curve_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = classify , method , js_class = "Curve" , catch)]
                    fn __TSB_classify_FnToJsValue(
                        this: &Curve_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clearHandles , method , js_class = "Curve" , catch)]
                    fn __TSB_clear_handles_FnTo(
                        this: &Curve_Class,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = reversed , method , js_class = "Curve" , catch)]
                    fn __TSB_reversed_FnToCurve(
                        this: &Curve_Class,
                    ) -> std::result::Result<Curve, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getOffsetOf , method , js_class = "Curve" , catch)]
                    fn __TSB_get_offset_of_FnPointToF64(
                        this: &Curve_Class,
                        point: Point,
                    ) -> std::result::Result<f64, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isFirst , method , js_class = "Curve" , catch)]
                    fn __TSB_is_first_FnToBool(
                        this: &Curve_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isStraight , method , js_class = "Curve" , catch)]
                    fn __TSB_is_straight_FnToBool(
                        this: &Curve_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = area , js_class = "Curve")]
                    fn area(this: &Curve_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = area , js_class = "Curve")]
                    fn set_area(this: &Curve_Class, value: f64)
                        -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getWeightedTangentAtTime , method , js_class = "Curve" , catch)]
                    fn __TSB_get_weighted_tangent_at_time_FnF64ToPoint(
                        this: &Curve_Class,
                        time: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = length , js_class = "Curve")]
                    fn length(this: &Curve_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = length , js_class = "Curve")]
                    fn set_length(
                        this: &Curve_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isVertical , method , js_class = "Curve" , catch)]
                    fn __TSB_is_vertical_FnToBool(
                        this: &Curve_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = point2 , js_class = "Curve")]
                    fn point2(this: &Curve_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = point2 , js_class = "Curve")]
                    fn set_point2(
                        this: &Curve_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = splitAt , method , js_class = "Curve" , catch)]
                    fn __TSB_split_at_FnCurveSplitAtParamsLocationToPath(
                        this: &Curve_Class,
                        location: JsValue,
                    ) -> std::result::Result<Path, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getTimeOf , method , js_class = "Curve" , catch)]
                    fn __TSB_get_time_of_FnPointToF64(
                        this: &Curve_Class,
                        point: Point,
                    ) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = values , js_class = "Curve")]
                    fn __TSB_values(this: &Curve_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = values , js_class = "Curve")]
                    fn __TSB_set_values(
                        this: &Curve_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getTimeAt , method , js_class = "Curve" , catch)]
                    fn __TSB_get_time_at_FnF64AndF64ToF64(
                        this: &Curve_Class,
                        offset: f64,
                        start: f64,
                    ) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = next , js_class = "Curve")]
                    fn next(this: &Curve_Class) -> std::result::Result<Curve, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = next , js_class = "Curve")]
                    fn set_next(
                        this: &Curve_Class,
                        value: Curve,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getOffsetAtTime , method , js_class = "Curve" , catch)]
                    fn __TSB_get_offset_at_time_FnF64ToF64(
                        this: &Curve_Class,
                        time: f64,
                    ) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = strokeBounds , js_class = "Curve")]
                    fn stroke_bounds(this: &Curve_Class)
                        -> std::result::Result<Rectangle, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = strokeBounds , js_class = "Curve")]
                    fn set_stroke_bounds(
                        this: &Curve_Class,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = hasHandles , method , js_class = "Curve" , catch)]
                    fn __TSB_has_handles_FnToBool(
                        this: &Curve_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isCollinear , method , js_class = "Curve" , catch)]
                    fn __TSB_is_collinear_FnCurveToBool(
                        this: &Curve_Class,
                        curve: Curve,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getPart , method , js_class = "Curve" , catch)]
                    fn __TSB_get_part_FnF64AndF64ToCurve(
                        this: &Curve_Class,
                        from: f64,
                        to: f64,
                    ) -> std::result::Result<Curve, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getLocationOf , method , js_class = "Curve" , catch)]
                    fn __TSB_get_location_of_FnPointToCurveLocation(
                        this: &Curve_Class,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getNearestPoint , method , js_class = "Curve" , catch)]
                    fn __TSB_get_nearest_point_FnPointToPoint(
                        this: &Curve_Class,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = previous , js_class = "Curve")]
                    fn previous(this: &Curve_Class) -> std::result::Result<Curve, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = previous , js_class = "Curve")]
                    fn set_previous(
                        this: &Curve_Class,
                        value: Curve,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getLocationAtTime , method , js_class = "Curve" , catch)]
                    fn __TSB_get_location_at_time_FnF64ToCurveLocation(
                        this: &Curve_Class,
                        time: f64,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getCurvatureAtTime , method , js_class = "Curve" , catch)]
                    fn __TSB_get_curvature_at_time_FnF64ToF64(
                        this: &Curve_Class,
                        time: f64,
                    ) -> std::result::Result<f64, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getTangentAtTime , method , js_class = "Curve" , catch)]
                    fn __TSB_get_tangent_at_time_FnF64ToPoint(
                        this: &Curve_Class,
                        time: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = point1 , js_class = "Curve")]
                    fn point1(this: &Curve_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = point1 , js_class = "Curve")]
                    fn set_point1(
                        this: &Curve_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Curve(pub Curve_Class);
                impl std::convert::From<Curve> for JsValue {
                    fn from(src: Curve) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for Curve {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for Curve {
                    fn instanceof(val: &JsValue) -> bool {
                        Curve_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        Curve(Curve_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(Curve_Class::unchecked_from_js_ref(val) as *const Curve_Class
                                as *const Self)
                        }
                    }
                }
                impl Curve {
                    #[allow(dead_code, non_snake_case)]
                    pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.__TSB_to_string_FnToString();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_tangent_at(
                        &self,
                        location: CurveGetTangentAtParamsLocation,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self
                            .0
                            .__TSB_get_tangent_at_FnCurveGetTangentAtParamsLocationToPoint(
                                ts_bindgen_rt::to_jsvalue(&location)
                                    .map_err(ts_bindgen_rt::Error::from)
                                    .map_err(JsValue::from)?,
                            );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn divide_at(
                        &self,
                        location: CurveDivideAtParamsLocation,
                    ) -> std::result::Result<Curve, JsValue> {
                        let result = self.0.__TSB_divide_at_FnCurveDivideAtParamsLocationToCurve(
                            ts_bindgen_rt::to_jsvalue(&location)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_point_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_get_point_at_time_FnF64ToPoint(time);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_intersections(
                        &self,
                        curve: Curve,
                    ) -> std::result::Result<Vec<CurveLocation>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self
                                .0
                                .__TSB_get_intersections_FnCurveToVecOfCurveLocation(curve)?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_weighted_normal_at(
                        &self,
                        location: CurveGetWeightedNormalAtParamsLocation,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self . 0 . __TSB_get_weighted_normal_at_FnCurveGetWeightedNormalAtParamsLocationToPoint (ts_bindgen_rt :: to_jsvalue (& location) . map_err (ts_bindgen_rt :: Error :: from) . map_err (JsValue :: from) ?) ;
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_point_at(
                        &self,
                        location: CurveGetPointAtParamsLocation,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self
                            .0
                            .__TSB_get_point_at_FnCurveGetPointAtParamsLocationToPoint(
                                ts_bindgen_rt::to_jsvalue(&location)
                                    .map_err(ts_bindgen_rt::Error::from)
                                    .map_err(JsValue::from)?,
                            );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn clone(&self) -> std::result::Result<Curve, JsValue> {
                        let result = self.0.__TSB_clone_FnToCurve();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn index(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.index();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_index(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_index(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn divide_at_time(&self, time: f64) -> std::result::Result<Curve, JsValue> {
                        let result = self.0.__TSB_divide_at_time_FnF64ToCurve(time);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn segment1(&self) -> std::result::Result<Segment, JsValue> {
                        let result = self.0.segment1();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_segment1(&self, value: Segment) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_segment1(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_normal_at(
                        &self,
                        location: CurveGetNormalAtParamsLocation,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self
                            .0
                            .__TSB_get_normal_at_FnCurveGetNormalAtParamsLocationToPoint(
                                ts_bindgen_rt::to_jsvalue(&location)
                                    .map_err(ts_bindgen_rt::Error::from)
                                    .map_err(JsValue::from)?,
                            );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_linear(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_linear_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn handle1(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.handle1();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_handle1(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_handle1(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn split_at_time(&self, time: f64) -> std::result::Result<Path, JsValue> {
                        let result = self.0.__TSB_split_at_time_FnF64ToPath(time);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.selected();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_selected(&self, value: bool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_selected(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn has_length(&self, epsilon: f64) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_has_length_FnF64ToBool(epsilon);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn segment2(&self) -> std::result::Result<Segment, JsValue> {
                        let result = self.0.segment2();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_segment2(&self, value: Segment) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_segment2(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_nearest_location(
                        &self,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let result = self
                            .0
                            .__TSB_get_nearest_location_FnPointToCurveLocation(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_remove_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_weighted_normal_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_get_weighted_normal_at_time_FnF64ToPoint(time);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_location_at(
                        &self,
                        offset: f64,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let result = self.0.__TSB_get_location_at_FnF64ToCurveLocation(offset);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn handle2(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.handle2();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_handle2(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_handle2(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let result = self.0.handle_bounds();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_handle_bounds(
                        &self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_handle_bounds(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn points(&self) -> std::result::Result<Vec<Point>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_points()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_points(
                        &self,
                        value: Vec<Point>,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_points({
                            let value_array = js_sys::Array::new();
                            for value_item in value {
                                value_array.push(&JsValue::from(value_item));
                            }
                            value_array.into()
                        });
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_weighted_tangent_at(
                        &self,
                        location: CurveGetWeightedTangentAtParamsLocation,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self . 0 . __TSB_get_weighted_tangent_at_FnCurveGetWeightedTangentAtParamsLocationToPoint (ts_bindgen_rt :: to_jsvalue (& location) . map_err (ts_bindgen_rt :: Error :: from) . map_err (JsValue :: from) ?) ;
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnSegmentAndSegmentToCurve(
                        segment1: Segment,
                        segment2: Segment,
                    ) -> Curve {
                        let result =
                            Curve_Class::new_FnSegmentAndSegmentToCurve(segment1, segment2);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Curve(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new_FnPointAndPointAndPointAndPointToCurve(
                        point1: Point,
                        handle1: Point,
                        handle2: Point,
                        point2: Point,
                    ) -> Curve {
                        let result = Curve_Class::new_FnPointAndPointAndPointAndPointToCurve(
                            point1, handle1, handle2, point2,
                        );
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Curve(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_curvature_at(
                        &self,
                        location: CurveGetCurvatureAtParamsLocation,
                    ) -> std::result::Result<f64, JsValue> {
                        let result = self
                            .0
                            .__TSB_get_curvature_at_FnCurveGetCurvatureAtParamsLocationToF64(
                                ts_bindgen_rt::to_jsvalue(&location)
                                    .map_err(ts_bindgen_rt::Error::from)
                                    .map_err(JsValue::from)?,
                            );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_times_with_tangent(
                        &self,
                        tangent: Point,
                    ) -> std::result::Result<Vec<f64>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self
                                .0
                                .__TSB_get_times_with_tangent_FnPointToVecOfF64(tangent)?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_normal_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_get_normal_at_time_FnF64ToPoint(time);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn path(&self) -> std::result::Result<Path, JsValue> {
                        let result = self.0.path();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_path(&self, value: Path) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_path(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let result = self.0.bounds();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_bounds(&self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_bounds(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_horizontal(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_horizontal_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_last(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_last_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn classify(&self) -> std::result::Result<JsValue, JsValue> {
                        let result = self.0.__TSB_classify_FnToJsValue();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_clear_handles_FnTo();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn reversed(&self) -> std::result::Result<Curve, JsValue> {
                        let result = self.0.__TSB_reversed_FnToCurve();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_offset_of(&self, point: Point) -> std::result::Result<f64, JsValue> {
                        let result = self.0.__TSB_get_offset_of_FnPointToF64(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_first(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_first_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_straight(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_straight_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn area(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.area();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_area(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_area(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_weighted_tangent_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_get_weighted_tangent_at_time_FnF64ToPoint(time);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn length(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.length();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_length(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_length(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_vertical(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_vertical_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn point2(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.point2();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_point2(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_point2(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn split_at(
                        &self,
                        location: CurveSplitAtParamsLocation,
                    ) -> std::result::Result<Path, JsValue> {
                        let result = self.0.__TSB_split_at_FnCurveSplitAtParamsLocationToPath(
                            ts_bindgen_rt::to_jsvalue(&location)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_time_of(&self, point: Point) -> std::result::Result<f64, JsValue> {
                        let result = self.0.__TSB_get_time_of_FnPointToF64(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn values(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_values()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_values(&self, value: Vec<f64>) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_values({
                            let value_array = js_sys::Array::new();
                            for value_item in value {
                                value_array.push(&JsValue::from(value_item));
                            }
                            value_array.into()
                        });
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_time_at(
                        &self,
                        offset: f64,
                        start: f64,
                    ) -> std::result::Result<f64, JsValue> {
                        let result = self.0.__TSB_get_time_at_FnF64AndF64ToF64(offset, start);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn next(&self) -> std::result::Result<Curve, JsValue> {
                        let result = self.0.next();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_next(&self, value: Curve) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_next(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_offset_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<f64, JsValue> {
                        let result = self.0.__TSB_get_offset_at_time_FnF64ToF64(time);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let result = self.0.stroke_bounds();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_stroke_bounds(
                        &self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_stroke_bounds(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_has_handles_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_collinear(&self, curve: Curve) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_collinear_FnCurveToBool(curve);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_part(
                        &self,
                        from: f64,
                        to: f64,
                    ) -> std::result::Result<Curve, JsValue> {
                        let result = self.0.__TSB_get_part_FnF64AndF64ToCurve(from, to);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_location_of(
                        &self,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let result = self.0.__TSB_get_location_of_FnPointToCurveLocation(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_nearest_point(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_get_nearest_point_FnPointToPoint(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn previous(&self) -> std::result::Result<Curve, JsValue> {
                        let result = self.0.previous();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_previous(&self, value: Curve) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_previous(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_location_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let result = self.0.__TSB_get_location_at_time_FnF64ToCurveLocation(time);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_curvature_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<f64, JsValue> {
                        let result = self.0.__TSB_get_curvature_at_time_FnF64ToF64(time);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_tangent_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_get_tangent_at_time_FnF64ToPoint(time);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn point1(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.point1();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_point1(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_point1(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Curve {
                    fn describe() {
                        <Curve_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Curve {
                    type Abi = <Curve_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Curve {
                    type Abi = <Curve_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Curve(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Curve {
                    type Abi = <&'a Curve_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Curve {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Curve {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Curve_Class =
                            <Curve_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait Curve_Trait {
                    fn to_string(&self) -> std::result::Result<String, JsValue>;
                    fn get_tangent_at(
                        &self,
                        location: CurveGetTangentAtParamsLocation,
                    ) -> std::result::Result<Point, JsValue>;
                    fn divide_at(
                        &self,
                        location: CurveDivideAtParamsLocation,
                    ) -> std::result::Result<Curve, JsValue>;
                    fn get_point_at_time(&self, time: f64) -> std::result::Result<Point, JsValue>;
                    fn get_intersections(
                        &self,
                        curve: Curve,
                    ) -> std::result::Result<Vec<CurveLocation>, JsValue>;
                    fn get_weighted_normal_at(
                        &self,
                        location: CurveGetWeightedNormalAtParamsLocation,
                    ) -> std::result::Result<Point, JsValue>;
                    fn get_point_at(
                        &self,
                        location: CurveGetPointAtParamsLocation,
                    ) -> std::result::Result<Point, JsValue>;
                    fn clone(&self) -> std::result::Result<Curve, JsValue>;
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn index(&self) -> std::result::Result<f64, JsValue>;
                    fn divide_at_time(&self, time: f64) -> std::result::Result<Curve, JsValue>;
                    fn set_segment1(&mut self, value: Segment) -> std::result::Result<(), JsValue>;
                    fn segment1(&self) -> std::result::Result<Segment, JsValue>;
                    fn get_normal_at(
                        &self,
                        location: CurveGetNormalAtParamsLocation,
                    ) -> std::result::Result<Point, JsValue>;
                    fn is_linear(&self) -> std::result::Result<bool, JsValue>;
                    fn set_handle1(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn handle1(&self) -> std::result::Result<Point, JsValue>;
                    fn split_at_time(&self, time: f64) -> std::result::Result<Path, JsValue>;
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue>;
                    fn selected(&self) -> std::result::Result<bool, JsValue>;
                    fn has_length(&self, epsilon: f64) -> std::result::Result<bool, JsValue>;
                    fn set_segment2(&mut self, value: Segment) -> std::result::Result<(), JsValue>;
                    fn segment2(&self) -> std::result::Result<Segment, JsValue>;
                    fn get_nearest_location(
                        &self,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    fn remove(&self) -> std::result::Result<bool, JsValue>;
                    fn get_weighted_normal_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    fn get_location_at(
                        &self,
                        offset: f64,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    fn set_handle2(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn handle2(&self) -> std::result::Result<Point, JsValue>;
                    fn set_handle_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue>;
                    fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue>;
                    fn set_points(&mut self, value: Vec<Point>)
                        -> std::result::Result<(), JsValue>;
                    fn points(&self) -> std::result::Result<Vec<Point>, JsValue>;
                    fn get_weighted_tangent_at(
                        &self,
                        location: CurveGetWeightedTangentAtParamsLocation,
                    ) -> std::result::Result<Point, JsValue>;
                    fn get_curvature_at(
                        &self,
                        location: CurveGetCurvatureAtParamsLocation,
                    ) -> std::result::Result<f64, JsValue>;
                    fn get_times_with_tangent(
                        &self,
                        tangent: Point,
                    ) -> std::result::Result<Vec<f64>, JsValue>;
                    fn get_normal_at_time(&self, time: f64) -> std::result::Result<Point, JsValue>;
                    fn set_path(&mut self, value: Path) -> std::result::Result<(), JsValue>;
                    fn path(&self) -> std::result::Result<Path, JsValue>;
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue>;
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue>;
                    fn is_horizontal(&self) -> std::result::Result<bool, JsValue>;
                    fn is_last(&self) -> std::result::Result<bool, JsValue>;
                    fn classify(&self) -> std::result::Result<JsValue, JsValue>;
                    fn clear_handles(&self) -> std::result::Result<(), JsValue>;
                    fn reversed(&self) -> std::result::Result<Curve, JsValue>;
                    fn get_offset_of(&self, point: Point) -> std::result::Result<f64, JsValue>;
                    fn is_first(&self) -> std::result::Result<bool, JsValue>;
                    fn is_straight(&self) -> std::result::Result<bool, JsValue>;
                    fn set_area(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn area(&self) -> std::result::Result<f64, JsValue>;
                    fn get_weighted_tangent_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<Point, JsValue>;
                    fn set_length(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn length(&self) -> std::result::Result<f64, JsValue>;
                    fn is_vertical(&self) -> std::result::Result<bool, JsValue>;
                    fn set_point2(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn point2(&self) -> std::result::Result<Point, JsValue>;
                    fn split_at(
                        &self,
                        location: CurveSplitAtParamsLocation,
                    ) -> std::result::Result<Path, JsValue>;
                    fn get_time_of(&self, point: Point) -> std::result::Result<f64, JsValue>;
                    fn set_values(&mut self, value: Vec<f64>) -> std::result::Result<(), JsValue>;
                    fn values(&self) -> std::result::Result<Vec<f64>, JsValue>;
                    fn get_time_at(
                        &self,
                        offset: f64,
                        start: f64,
                    ) -> std::result::Result<f64, JsValue>;
                    fn set_next(&mut self, value: Curve) -> std::result::Result<(), JsValue>;
                    fn next(&self) -> std::result::Result<Curve, JsValue>;
                    fn get_offset_at_time(&self, time: f64) -> std::result::Result<f64, JsValue>;
                    fn set_stroke_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue>;
                    fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue>;
                    fn has_handles(&self) -> std::result::Result<bool, JsValue>;
                    fn is_collinear(&self, curve: Curve) -> std::result::Result<bool, JsValue>;
                    fn get_part(&self, from: f64, to: f64) -> std::result::Result<Curve, JsValue>;
                    fn get_location_of(
                        &self,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    fn get_nearest_point(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    fn set_previous(&mut self, value: Curve) -> std::result::Result<(), JsValue>;
                    fn previous(&self) -> std::result::Result<Curve, JsValue>;
                    fn get_location_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    fn get_curvature_at_time(&self, time: f64)
                        -> std::result::Result<f64, JsValue>;
                    fn get_tangent_at_time(&self, time: f64)
                        -> std::result::Result<Point, JsValue>;
                    fn set_point1(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn point1(&self) -> std::result::Result<Point, JsValue>;
                }
                impl Curve_Trait for Curve {
                    fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Curve::to_string(target)
                    }
                    fn get_tangent_at(
                        &self,
                        location: CurveGetTangentAtParamsLocation,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Curve::get_tangent_at(target, location)
                    }
                    fn divide_at(
                        &self,
                        location: CurveDivideAtParamsLocation,
                    ) -> std::result::Result<Curve, JsValue> {
                        let target = self;
                        Curve::divide_at(target, location)
                    }
                    fn get_point_at_time(&self, time: f64) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Curve::get_point_at_time(target, time)
                    }
                    fn get_intersections(
                        &self,
                        curve: Curve,
                    ) -> std::result::Result<Vec<CurveLocation>, JsValue> {
                        let target = self;
                        Curve::get_intersections(target, curve)
                    }
                    fn get_weighted_normal_at(
                        &self,
                        location: CurveGetWeightedNormalAtParamsLocation,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Curve::get_weighted_normal_at(target, location)
                    }
                    fn get_point_at(
                        &self,
                        location: CurveGetPointAtParamsLocation,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Curve::get_point_at(target, location)
                    }
                    fn clone(&self) -> std::result::Result<Curve, JsValue> {
                        let target = self;
                        Curve::clone(target)
                    }
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Curve::set_index(target, value)
                    }
                    fn index(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Curve::index(target)
                    }
                    fn divide_at_time(&self, time: f64) -> std::result::Result<Curve, JsValue> {
                        let target = self;
                        Curve::divide_at_time(target, time)
                    }
                    fn set_segment1(&mut self, value: Segment) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Curve::set_segment1(target, value)
                    }
                    fn segment1(&self) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        Curve::segment1(target)
                    }
                    fn get_normal_at(
                        &self,
                        location: CurveGetNormalAtParamsLocation,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Curve::get_normal_at(target, location)
                    }
                    fn is_linear(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Curve::is_linear(target)
                    }
                    fn set_handle1(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Curve::set_handle1(target, value)
                    }
                    fn handle1(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Curve::handle1(target)
                    }
                    fn split_at_time(&self, time: f64) -> std::result::Result<Path, JsValue> {
                        let target = self;
                        Curve::split_at_time(target, time)
                    }
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Curve::set_selected(target, value)
                    }
                    fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Curve::selected(target)
                    }
                    fn has_length(&self, epsilon: f64) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Curve::has_length(target, epsilon)
                    }
                    fn set_segment2(&mut self, value: Segment) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Curve::set_segment2(target, value)
                    }
                    fn segment2(&self) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        Curve::segment2(target)
                    }
                    fn get_nearest_location(
                        &self,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let target = self;
                        Curve::get_nearest_location(target, point)
                    }
                    fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Curve::remove(target)
                    }
                    fn get_weighted_normal_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Curve::get_weighted_normal_at_time(target, time)
                    }
                    fn get_location_at(
                        &self,
                        offset: f64,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let target = self;
                        Curve::get_location_at(target, offset)
                    }
                    fn set_handle2(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Curve::set_handle2(target, value)
                    }
                    fn handle2(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Curve::handle2(target)
                    }
                    fn set_handle_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Curve::set_handle_bounds(target, value)
                    }
                    fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        Curve::handle_bounds(target)
                    }
                    fn set_points(
                        &mut self,
                        value: Vec<Point>,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Curve::set_points(target, value)
                    }
                    fn points(&self) -> std::result::Result<Vec<Point>, JsValue> {
                        let target = self;
                        Curve::points(target)
                    }
                    fn get_weighted_tangent_at(
                        &self,
                        location: CurveGetWeightedTangentAtParamsLocation,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Curve::get_weighted_tangent_at(target, location)
                    }
                    fn get_curvature_at(
                        &self,
                        location: CurveGetCurvatureAtParamsLocation,
                    ) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Curve::get_curvature_at(target, location)
                    }
                    fn get_times_with_tangent(
                        &self,
                        tangent: Point,
                    ) -> std::result::Result<Vec<f64>, JsValue> {
                        let target = self;
                        Curve::get_times_with_tangent(target, tangent)
                    }
                    fn get_normal_at_time(&self, time: f64) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Curve::get_normal_at_time(target, time)
                    }
                    fn set_path(&mut self, value: Path) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Curve::set_path(target, value)
                    }
                    fn path(&self) -> std::result::Result<Path, JsValue> {
                        let target = self;
                        Curve::path(target)
                    }
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Curve::set_bounds(target, value)
                    }
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        Curve::bounds(target)
                    }
                    fn is_horizontal(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Curve::is_horizontal(target)
                    }
                    fn is_last(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Curve::is_last(target)
                    }
                    fn classify(&self) -> std::result::Result<JsValue, JsValue> {
                        let target = self;
                        Curve::classify(target)
                    }
                    fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Curve::clear_handles(target)
                    }
                    fn reversed(&self) -> std::result::Result<Curve, JsValue> {
                        let target = self;
                        Curve::reversed(target)
                    }
                    fn get_offset_of(&self, point: Point) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Curve::get_offset_of(target, point)
                    }
                    fn is_first(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Curve::is_first(target)
                    }
                    fn is_straight(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Curve::is_straight(target)
                    }
                    fn set_area(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Curve::set_area(target, value)
                    }
                    fn area(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Curve::area(target)
                    }
                    fn get_weighted_tangent_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Curve::get_weighted_tangent_at_time(target, time)
                    }
                    fn set_length(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Curve::set_length(target, value)
                    }
                    fn length(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Curve::length(target)
                    }
                    fn is_vertical(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Curve::is_vertical(target)
                    }
                    fn set_point2(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Curve::set_point2(target, value)
                    }
                    fn point2(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Curve::point2(target)
                    }
                    fn split_at(
                        &self,
                        location: CurveSplitAtParamsLocation,
                    ) -> std::result::Result<Path, JsValue> {
                        let target = self;
                        Curve::split_at(target, location)
                    }
                    fn get_time_of(&self, point: Point) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Curve::get_time_of(target, point)
                    }
                    fn set_values(&mut self, value: Vec<f64>) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Curve::set_values(target, value)
                    }
                    fn values(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let target = self;
                        Curve::values(target)
                    }
                    fn get_time_at(
                        &self,
                        offset: f64,
                        start: f64,
                    ) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Curve::get_time_at(target, offset, start)
                    }
                    fn set_next(&mut self, value: Curve) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Curve::set_next(target, value)
                    }
                    fn next(&self) -> std::result::Result<Curve, JsValue> {
                        let target = self;
                        Curve::next(target)
                    }
                    fn get_offset_at_time(&self, time: f64) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Curve::get_offset_at_time(target, time)
                    }
                    fn set_stroke_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Curve::set_stroke_bounds(target, value)
                    }
                    fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        Curve::stroke_bounds(target)
                    }
                    fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Curve::has_handles(target)
                    }
                    fn is_collinear(&self, curve: Curve) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Curve::is_collinear(target, curve)
                    }
                    fn get_part(&self, from: f64, to: f64) -> std::result::Result<Curve, JsValue> {
                        let target = self;
                        Curve::get_part(target, from, to)
                    }
                    fn get_location_of(
                        &self,
                        point: Point,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let target = self;
                        Curve::get_location_of(target, point)
                    }
                    fn get_nearest_point(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Curve::get_nearest_point(target, point)
                    }
                    fn set_previous(&mut self, value: Curve) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Curve::set_previous(target, value)
                    }
                    fn previous(&self) -> std::result::Result<Curve, JsValue> {
                        let target = self;
                        Curve::previous(target)
                    }
                    fn get_location_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<CurveLocation, JsValue> {
                        let target = self;
                        Curve::get_location_at_time(target, time)
                    }
                    fn get_curvature_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Curve::get_curvature_at_time(target, time)
                    }
                    fn get_tangent_at_time(
                        &self,
                        time: f64,
                    ) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Curve::get_tangent_at_time(target, time)
                    }
                    fn set_point1(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Curve::set_point1(target, value)
                    }
                    fn point1(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Curve::point1(target)
                    }
                }
                impl std::clone::Clone for Curve_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Curve_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Curve_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    #[wasm_bindgen(js_name = "PaperScript")]
                    pub type PaperScript_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = compile , method , js_class = "PaperScript" , catch)]
                    fn __TSB_compile_FnStringAndJsValueToJsValue(
                        this: &PaperScript_Class,
                        code: String,
                        options: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = load , method , js_class = "PaperScript" , catch)]
                    fn __TSB_load_FnWebSysHtmlScriptElementToPaperScope(
                        this: &PaperScript_Class,
                        script: web_sys::HtmlScriptElement,
                    ) -> std::result::Result<PaperScope, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = execute , method , js_class = "PaperScript" , catch)]
                    fn __TSB_execute_FnStringAndPaperScopeAndJsValueToJsValue(
                        this: &PaperScript_Class,
                        code: String,
                        scope: PaperScope,
                        options: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct PaperScript(pub PaperScript_Class);
                impl std::convert::From<PaperScript> for JsValue {
                    fn from(src: PaperScript) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for PaperScript {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for PaperScript {
                    fn instanceof(val: &JsValue) -> bool {
                        PaperScript_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        PaperScript(PaperScript_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(PaperScript_Class::unchecked_from_js_ref(val)
                                as *const PaperScript_Class
                                as *const Self)
                        }
                    }
                }
                impl PaperScript {
                    #[allow(dead_code, non_snake_case)]
                    pub fn compile(
                        &self,
                        code: String,
                        options: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let result = self
                            .0
                            .__TSB_compile_FnStringAndJsValueToJsValue(code, options);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn load(
                        &self,
                        script: web_sys::HtmlScriptElement,
                    ) -> std::result::Result<PaperScope, JsValue> {
                        let result = self
                            .0
                            .__TSB_load_FnWebSysHtmlScriptElementToPaperScope(script);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn execute(
                        &self,
                        code: String,
                        scope: PaperScope,
                        options: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let result = self
                            .0
                            .__TSB_execute_FnStringAndPaperScopeAndJsValueToJsValue(
                                code, scope, options,
                            );
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for PaperScript {
                    fn describe() {
                        <PaperScript_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for PaperScript {
                    type Abi = <PaperScript_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for PaperScript {
                    type Abi = <PaperScript_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        PaperScript(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a PaperScript {
                    type Abi = <&'a PaperScript_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for PaperScript {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for PaperScript {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: PaperScript_Class =
                            <PaperScript_Class as serde::de::Deserialize>::deserialize(
                                deserializer,
                            )?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait PaperScript_Trait {
                    fn compile(
                        &self,
                        code: String,
                        options: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    fn load(
                        &self,
                        script: web_sys::HtmlScriptElement,
                    ) -> std::result::Result<PaperScope, JsValue>;
                    fn execute(
                        &self,
                        code: String,
                        scope: PaperScope,
                        options: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                }
                impl PaperScript_Trait for PaperScript {
                    fn compile(
                        &self,
                        code: String,
                        options: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target = self;
                        PaperScript::compile(target, code, options)
                    }
                    fn load(
                        &self,
                        script: web_sys::HtmlScriptElement,
                    ) -> std::result::Result<PaperScope, JsValue> {
                        let target = self;
                        PaperScript::load(target, script)
                    }
                    fn execute(
                        &self,
                        code: String,
                        scope: PaperScope,
                        options: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target = self;
                        PaperScript::execute(target, code, scope, options)
                    }
                }
                impl std::clone::Clone for PaperScript_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for PaperScript_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for PaperScript_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum MatrixSkewParamsCenter {
                    Point(Point),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewOnFrame {
                    TsBindgenRtNull,
                    #[serde(
                        serialize_with = "ViewOnFrame::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ViewOnFrame::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                }
                impl ViewOnFrame {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    #[wasm_bindgen(js_name = "Event")]
                    pub type Event_Class;
                    # [wasm_bindgen (method , structural , catch , getter = modifiers , js_class = "Event")]
                    fn __TSB_modifiers(this: &Event_Class)
                        -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = modifiers , js_class = "Event")]
                    fn __TSB_set_modifiers(
                        this: &Event_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = timeStamp , js_class = "Event")]
                    fn time_stamp(this: &Event_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = timeStamp , js_class = "Event")]
                    fn set_time_stamp(
                        this: &Event_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = stop , method , js_class = "Event" , catch)]
                    fn __TSB_stop_FnTo(this: &Event_Class) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = stopPropagation , method , js_class = "Event" , catch)]
                    fn __TSB_stop_propagation_FnTo(
                        this: &Event_Class,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = preventDefault , method , js_class = "Event" , catch)]
                    fn __TSB_prevent_default_FnTo(
                        this: &Event_Class,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Event(pub Event_Class);
                impl std::convert::From<Event> for JsValue {
                    fn from(src: Event) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for Event {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for Event {
                    fn instanceof(val: &JsValue) -> bool {
                        Event_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        Event(Event_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(Event_Class::unchecked_from_js_ref(val) as *const Event_Class
                                as *const Self)
                        }
                    }
                }
                impl Event {
                    #[allow(dead_code, non_snake_case)]
                    pub fn modifiers(&self) -> std::result::Result<JsValue, JsValue> {
                        let result = self.0.__TSB_modifiers();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_modifiers(
                        &self,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_modifiers(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn time_stamp(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.time_stamp();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_time_stamp(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_time_stamp(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn stop(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_stop_FnTo();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn stop_propagation(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_stop_propagation_FnTo();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn prevent_default(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_prevent_default_FnTo();
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Event {
                    fn describe() {
                        <Event_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Event {
                    type Abi = <Event_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Event {
                    type Abi = <Event_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Event(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Event {
                    type Abi = <&'a Event_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Event {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Event {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Event_Class =
                            <Event_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait Event_Trait {
                    fn set_modifiers(&mut self, value: JsValue)
                        -> std::result::Result<(), JsValue>;
                    fn modifiers(&self) -> std::result::Result<JsValue, JsValue>;
                    fn set_time_stamp(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn time_stamp(&self) -> std::result::Result<f64, JsValue>;
                    fn stop(&self) -> std::result::Result<(), JsValue>;
                    fn stop_propagation(&self) -> std::result::Result<(), JsValue>;
                    fn prevent_default(&self) -> std::result::Result<(), JsValue>;
                }
                impl Event_Trait for Event {
                    fn set_modifiers(
                        &mut self,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Event::set_modifiers(target, value)
                    }
                    fn modifiers(&self) -> std::result::Result<JsValue, JsValue> {
                        let target = self;
                        Event::modifiers(target)
                    }
                    fn set_time_stamp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Event::set_time_stamp(target, value)
                    }
                    fn time_stamp(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Event::time_stamp(target)
                    }
                    fn stop(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Event::stop(target)
                    }
                    fn stop_propagation(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Event::stop_propagation(target)
                    }
                    fn prevent_default(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Event::prevent_default(target)
                    }
                }
                impl std::clone::Clone for Event_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Event_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Event_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewOnDoubleClick {
                    TsBindgenRtNull,
                    #[serde(
                        serialize_with = "ViewOnDoubleClick::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ViewOnDoubleClick::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                }
                impl ViewOnDoubleClick {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemRemoveChildrenReturn {
                    VecOfItem(Vec<Item>),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum TweenOnUpdate {
                    TsBindgenRtNull,
                    #[serde(
                        serialize_with = "TweenOnUpdate::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "TweenOnUpdate::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                }
                impl TweenOnUpdate {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PointDivideReturn {
                    Point(Point),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum RasterGetPixelReturn {
                    Color(Color),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PathItemArcToParamsThrough {
                    Point(Point),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ColorSubtractParamsNumber {
                    Color(Color),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PointMultiplyReturn {
                    Point(Point),
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    # [wasm_bindgen (js_name = "MouseEvent" , extends = Event_Class)]
                    pub type MouseEvent_Class;
                    # [wasm_bindgen (method , structural , catch , getter = currentTarget , js_class = "MouseEvent")]
                    fn current_target(
                        this: &MouseEvent_Class,
                    ) -> std::result::Result<Item, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = currentTarget , js_class = "MouseEvent")]
                    fn set_current_target(
                        this: &MouseEvent_Class,
                        value: Item,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = target , js_class = "MouseEvent")]
                    fn target(this: &MouseEvent_Class) -> std::result::Result<Item, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = target , js_class = "MouseEvent")]
                    fn set_target(
                        this: &MouseEvent_Class,
                        value: Item,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = toString , method , js_class = "MouseEvent" , catch)]
                    fn __TSB_to_string_FnToString(
                        this: &MouseEvent_Class,
                    ) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = type , js_class = "MouseEvent")]
                    fn type_(this: &MouseEvent_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = type , js_class = "MouseEvent")]
                    fn set_type_(
                        this: &MouseEvent_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = delta , js_class = "MouseEvent")]
                    fn delta(this: &MouseEvent_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = delta , js_class = "MouseEvent")]
                    fn set_delta(
                        this: &MouseEvent_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = point , js_class = "MouseEvent")]
                    fn point(this: &MouseEvent_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = point , js_class = "MouseEvent")]
                    fn set_point(
                        this: &MouseEvent_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct MouseEvent(pub MouseEvent_Class);
                impl std::convert::From<&MouseEvent> for Event {
                    fn from(src: &MouseEvent) -> Event {
                        let src: &Event_Class = src.0.as_ref();
                        Event(src.clone())
                    }
                }
                impl std::convert::From<&mut MouseEvent> for Event {
                    fn from(src: &mut MouseEvent) -> Event {
                        let src: &Event_Class = src.0.as_ref();
                        Event(src.clone())
                    }
                }
                impl std::convert::From<MouseEvent> for JsValue {
                    fn from(src: MouseEvent) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for MouseEvent {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for MouseEvent {
                    fn instanceof(val: &JsValue) -> bool {
                        MouseEvent_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        MouseEvent(MouseEvent_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(MouseEvent_Class::unchecked_from_js_ref(val)
                                as *const MouseEvent_Class
                                as *const Self)
                        }
                    }
                }
                impl MouseEvent {
                    #[allow(dead_code, non_snake_case)]
                    pub fn current_target(&self) -> std::result::Result<Item, JsValue> {
                        let result = self.0.current_target();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_current_target(
                        &self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_current_target(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn target(&self) -> std::result::Result<Item, JsValue> {
                        let result = self.0.target();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_target(&self, value: Item) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_target(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.__TSB_to_string_FnToString();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn type_(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.type_();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_type_(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_type_(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn delta(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.delta();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_delta(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_delta(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn point(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.point();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_point(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_point(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for MouseEvent {
                    fn describe() {
                        <MouseEvent_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for MouseEvent {
                    type Abi = <MouseEvent_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for MouseEvent {
                    type Abi = <MouseEvent_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        MouseEvent(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a MouseEvent {
                    type Abi = <&'a MouseEvent_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for MouseEvent {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for MouseEvent {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: MouseEvent_Class =
                            <MouseEvent_Class as serde::de::Deserialize>::deserialize(
                                deserializer,
                            )?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait MouseEvent_Trait: Event_Trait {
                    fn set_current_target(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue>;
                    fn current_target(&self) -> std::result::Result<Item, JsValue>;
                    fn set_target(&mut self, value: Item) -> std::result::Result<(), JsValue>;
                    fn target(&self) -> std::result::Result<Item, JsValue>;
                    fn to_string(&self) -> std::result::Result<String, JsValue>;
                    fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn type_(&self) -> std::result::Result<String, JsValue>;
                    fn set_delta(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn delta(&self) -> std::result::Result<Point, JsValue>;
                    fn set_point(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn point(&self) -> std::result::Result<Point, JsValue>;
                }
                impl Event_Trait for MouseEvent {
                    fn set_modifiers(
                        &mut self,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Event = self.into();
                        Event::set_modifiers(&target, value)
                    }
                    fn modifiers(&self) -> std::result::Result<JsValue, JsValue> {
                        let target: Event = self.into();
                        Event::modifiers(&target)
                    }
                    fn set_time_stamp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Event = self.into();
                        Event::set_time_stamp(&target, value)
                    }
                    fn time_stamp(&self) -> std::result::Result<f64, JsValue> {
                        let target: Event = self.into();
                        Event::time_stamp(&target)
                    }
                    fn stop(&self) -> std::result::Result<(), JsValue> {
                        let target: Event = self.into();
                        Event::stop(&target)
                    }
                    fn stop_propagation(&self) -> std::result::Result<(), JsValue> {
                        let target: Event = self.into();
                        Event::stop_propagation(&target)
                    }
                    fn prevent_default(&self) -> std::result::Result<(), JsValue> {
                        let target: Event = self.into();
                        Event::prevent_default(&target)
                    }
                }
                impl MouseEvent_Trait for MouseEvent
                where
                    MouseEvent: Event_Trait,
                {
                    fn set_current_target(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        MouseEvent::set_current_target(target, value)
                    }
                    fn current_target(&self) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        MouseEvent::current_target(target)
                    }
                    fn set_target(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target = self;
                        MouseEvent::set_target(target, value)
                    }
                    fn target(&self) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        MouseEvent::target(target)
                    }
                    fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        MouseEvent::to_string(target)
                    }
                    fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target = self;
                        MouseEvent::set_type_(target, value)
                    }
                    fn type_(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        MouseEvent::type_(target)
                    }
                    fn set_delta(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        MouseEvent::set_delta(target, value)
                    }
                    fn delta(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        MouseEvent::delta(target)
                    }
                    fn set_point(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        MouseEvent::set_point(target, value)
                    }
                    fn point(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        MouseEvent::point(target)
                    }
                }
                impl std::clone::Clone for MouseEvent_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for MouseEvent_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for MouseEvent_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewOnMouseUp {
                    TsBindgenRtNull,
                    #[serde(
                        serialize_with = "ViewOnMouseUp::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ViewOnMouseUp::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                }
                impl ViewOnMouseUp {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum RasterGetAverageColorParamsObject {
                    Path(Path),
                    Point(Point),
                    Rectangle(Rectangle),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum StyleFontWeight {
                    F64(f64),
                    String(String),
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    #[wasm_bindgen(js_name = "Tool")]
                    pub type Tool_Class;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseDown , js_class = "Tool")]
                    fn __TSB_on_mouse_down(
                        this: &Tool_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseDown , js_class = "Tool")]
                    fn __TSB_set_on_mouse_down(
                        this: &Tool_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseMove , js_class = "Tool")]
                    fn __TSB_on_mouse_move(
                        this: &Tool_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseMove , js_class = "Tool")]
                    fn __TSB_set_on_mouse_move(
                        this: &Tool_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = activate , method , js_class = "Tool" , catch)]
                    fn __TSB_activate_FnTo(this: &Tool_Class) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = maxDistance , js_class = "Tool")]
                    fn max_distance(this: &Tool_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = maxDistance , js_class = "Tool")]
                    fn set_max_distance(
                        this: &Tool_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onKeyDown , js_class = "Tool")]
                    fn __TSB_on_key_down(
                        this: &Tool_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onKeyDown , js_class = "Tool")]
                    fn __TSB_set_on_key_down(
                        this: &Tool_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseDrag , js_class = "Tool")]
                    fn __TSB_on_mouse_drag(
                        this: &Tool_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseDrag , js_class = "Tool")]
                    fn __TSB_set_on_mouse_drag(
                        this: &Tool_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = responds , method , js_class = "Tool" , catch)]
                    fn __TSB_responds_FnStringToBool(
                        this: &Tool_Class,
                        type_: String,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = off , method , js_class = "Tool" , catch)]
                    fn __TSB_off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToTool(
                        this: &Tool_Class,
                        type_: String,
                        callback: &Closure<
                            dyn Fn(
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        >,
                    ) -> std::result::Result<Tool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = off , method , js_class = "Tool" , catch)]
                    fn __TSB_off_FnJsValueToTool(
                        this: &Tool_Class,
                        param: JsValue,
                    ) -> std::result::Result<Tool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = minDistance , js_class = "Tool")]
                    fn min_distance(this: &Tool_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = minDistance , js_class = "Tool")]
                    fn set_min_distance(
                        this: &Tool_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = emit , method , js_class = "Tool" , catch)]
                    fn __TSB_emit_FnStringAndJsValueToBool(
                        this: &Tool_Class,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = remove , method , js_class = "Tool" , catch)]
                    fn __TSB_remove_FnTo(this: &Tool_Class) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = fixedDistance , js_class = "Tool")]
                    fn fixed_distance(this: &Tool_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = fixedDistance , js_class = "Tool")]
                    fn set_fixed_distance(
                        this: &Tool_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = on , method , js_class = "Tool" , catch)]
                    fn __TSB_on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToTool(
                        this: &Tool_Class,
                        type_: String,
                        callback: &Closure<
                            dyn Fn(
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        >,
                    ) -> std::result::Result<Tool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = on , method , js_class = "Tool" , catch)]
                    fn __TSB_on_FnJsValueToTool(
                        this: &Tool_Class,
                        param: JsValue,
                    ) -> std::result::Result<Tool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseUp , js_class = "Tool")]
                    fn __TSB_on_mouse_up(
                        this: &Tool_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseUp , js_class = "Tool")]
                    fn __TSB_set_on_mouse_up(
                        this: &Tool_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onKeyUp , js_class = "Tool")]
                    fn __TSB_on_key_up(this: &Tool_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onKeyUp , js_class = "Tool")]
                    fn __TSB_set_on_key_up(
                        this: &Tool_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Tool(pub Tool_Class);
                impl std::convert::From<Tool> for JsValue {
                    fn from(src: Tool) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for Tool {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for Tool {
                    fn instanceof(val: &JsValue) -> bool {
                        Tool_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        Tool(Tool_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(Tool_Class::unchecked_from_js_ref(val) as *const Tool_Class
                                as *const Self)
                        }
                    }
                }
                impl Tool {
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_mouse_down(&self) -> std::result::Result<ToolOnMouseDown, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_down()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_on_mouse_down(
                        &self,
                        value: ToolOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_down(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_mouse_move(&self) -> std::result::Result<ToolOnMouseMove, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_move()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_on_mouse_move(
                        &self,
                        value: ToolOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_move(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn activate(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_activate_FnTo();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn max_distance(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.max_distance();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_max_distance(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_max_distance(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_key_down(&self) -> std::result::Result<ToolOnKeyDown, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_key_down()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_on_key_down(
                        &self,
                        value: ToolOnKeyDown,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_key_down(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_mouse_drag(&self) -> std::result::Result<ToolOnMouseDrag, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_drag()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_on_mouse_drag(
                        &self,
                        value: ToolOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_drag(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_responds_FnStringToBool(type_);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToTool(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Tool, JsValue> {
                        # [allow (non_snake_case)] let __TSB_Local_callback = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = callback ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let result = self . 0 . __TSB_off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToTool (type_ , & __TSB_Local_callback) ;
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn off_FnJsValueToTool(
                        &self,
                        param: JsValue,
                    ) -> std::result::Result<Tool, JsValue> {
                        let result = self.0.__TSB_off_FnJsValueToTool(param);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn min_distance(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.min_distance();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_min_distance(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_min_distance(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_emit_FnStringAndJsValueToBool(type_, event);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn remove(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_remove_FnTo();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn fixed_distance(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.fixed_distance();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_fixed_distance(
                        &self,
                        value: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_fixed_distance(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToTool(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Tool, JsValue> {
                        # [allow (non_snake_case)] let __TSB_Local_callback = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = callback ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let result = self . 0 . __TSB_on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToTool (type_ , & __TSB_Local_callback) ;
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_FnJsValueToTool(
                        &self,
                        param: JsValue,
                    ) -> std::result::Result<Tool, JsValue> {
                        let result = self.0.__TSB_on_FnJsValueToTool(param);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_mouse_up(&self) -> std::result::Result<ToolOnMouseUp, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_up()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_on_mouse_up(
                        &self,
                        value: ToolOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_up(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_key_up(&self) -> std::result::Result<ToolOnKeyUp, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_key_up()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_on_key_up(
                        &self,
                        value: ToolOnKeyUp,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_key_up(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Tool {
                    fn describe() {
                        <Tool_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Tool {
                    type Abi = <Tool_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Tool {
                    type Abi = <Tool_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Tool(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Tool {
                    type Abi = <&'a Tool_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Tool {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Tool {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Tool_Class =
                            <Tool_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait Tool_Trait {
                    fn set_on_mouse_down(
                        &mut self,
                        value: ToolOnMouseDown,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_down(&self) -> std::result::Result<ToolOnMouseDown, JsValue>;
                    fn set_on_mouse_move(
                        &mut self,
                        value: ToolOnMouseMove,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_move(&self) -> std::result::Result<ToolOnMouseMove, JsValue>;
                    fn activate(&self) -> std::result::Result<(), JsValue>;
                    fn set_max_distance(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn max_distance(&self) -> std::result::Result<f64, JsValue>;
                    fn set_on_key_down(
                        &mut self,
                        value: ToolOnKeyDown,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_key_down(&self) -> std::result::Result<ToolOnKeyDown, JsValue>;
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ToolOnMouseDrag,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_drag(&self) -> std::result::Result<ToolOnMouseDrag, JsValue>;
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue>;
                    fn off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToTool(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Tool, JsValue>;
                    fn off_FnJsValueToTool(
                        &self,
                        param: JsValue,
                    ) -> std::result::Result<Tool, JsValue>;
                    fn set_min_distance(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn min_distance(&self) -> std::result::Result<f64, JsValue>;
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue>;
                    fn remove(&self) -> std::result::Result<(), JsValue>;
                    fn set_fixed_distance(
                        &mut self,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    fn fixed_distance(&self) -> std::result::Result<f64, JsValue>;
                    fn on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToTool(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Tool, JsValue>;
                    fn on_FnJsValueToTool(
                        &self,
                        param: JsValue,
                    ) -> std::result::Result<Tool, JsValue>;
                    fn set_on_mouse_up(
                        &mut self,
                        value: ToolOnMouseUp,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_up(&self) -> std::result::Result<ToolOnMouseUp, JsValue>;
                    fn set_on_key_up(
                        &mut self,
                        value: ToolOnKeyUp,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_key_up(&self) -> std::result::Result<ToolOnKeyUp, JsValue>;
                }
                impl Tool_Trait for Tool {
                    fn set_on_mouse_down(
                        &mut self,
                        value: ToolOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Tool::set_on_mouse_down(target, value)
                    }
                    fn on_mouse_down(&self) -> std::result::Result<ToolOnMouseDown, JsValue> {
                        let target = self;
                        Tool::on_mouse_down(target)
                    }
                    fn set_on_mouse_move(
                        &mut self,
                        value: ToolOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Tool::set_on_mouse_move(target, value)
                    }
                    fn on_mouse_move(&self) -> std::result::Result<ToolOnMouseMove, JsValue> {
                        let target = self;
                        Tool::on_mouse_move(target)
                    }
                    fn activate(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Tool::activate(target)
                    }
                    fn set_max_distance(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Tool::set_max_distance(target, value)
                    }
                    fn max_distance(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Tool::max_distance(target)
                    }
                    fn set_on_key_down(
                        &mut self,
                        value: ToolOnKeyDown,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Tool::set_on_key_down(target, value)
                    }
                    fn on_key_down(&self) -> std::result::Result<ToolOnKeyDown, JsValue> {
                        let target = self;
                        Tool::on_key_down(target)
                    }
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ToolOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Tool::set_on_mouse_drag(target, value)
                    }
                    fn on_mouse_drag(&self) -> std::result::Result<ToolOnMouseDrag, JsValue> {
                        let target = self;
                        Tool::on_mouse_drag(target)
                    }
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Tool::responds(target, type_)
                    }
                    fn off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToTool(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Tool, JsValue> {
                        let target = self;
                        Tool :: off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToTool (target , type_ , callback)
                    }
                    fn off_FnJsValueToTool(
                        &self,
                        param: JsValue,
                    ) -> std::result::Result<Tool, JsValue> {
                        let target = self;
                        Tool::off_FnJsValueToTool(target, param)
                    }
                    fn set_min_distance(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Tool::set_min_distance(target, value)
                    }
                    fn min_distance(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Tool::min_distance(target)
                    }
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Tool::emit(target, type_, event)
                    }
                    fn remove(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Tool::remove(target)
                    }
                    fn set_fixed_distance(
                        &mut self,
                        value: f64,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Tool::set_fixed_distance(target, value)
                    }
                    fn fixed_distance(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Tool::fixed_distance(target)
                    }
                    fn on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToTool(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Tool, JsValue> {
                        let target = self;
                        Tool :: on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToTool (target , type_ , callback)
                    }
                    fn on_FnJsValueToTool(
                        &self,
                        param: JsValue,
                    ) -> std::result::Result<Tool, JsValue> {
                        let target = self;
                        Tool::on_FnJsValueToTool(target, param)
                    }
                    fn set_on_mouse_up(
                        &mut self,
                        value: ToolOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Tool::set_on_mouse_up(target, value)
                    }
                    fn on_mouse_up(&self) -> std::result::Result<ToolOnMouseUp, JsValue> {
                        let target = self;
                        Tool::on_mouse_up(target)
                    }
                    fn set_on_key_up(
                        &mut self,
                        value: ToolOnKeyUp,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Tool::set_on_key_up(target, value)
                    }
                    fn on_key_up(&self) -> std::result::Result<ToolOnKeyUp, JsValue> {
                        let target = self;
                        Tool::on_key_up(target)
                    }
                }
                impl std::clone::Clone for Tool_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Tool_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Tool_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PathInsertParamsSegment {
                    Point(Point),
                    Segment(Segment),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ColorAddReturn {
                    Color(Color),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PointDivideParamsNumber {
                    Point(Point),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemTweenParamsTo {
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    JsValue(JsValue),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum RasterSetPixelParamsX {
                    Point(Point),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ProjectImportSvgParamsOptions {
                    #[serde(
                        serialize_with = "ProjectImportSvgParamsOptions::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ProjectImportSvgParamsOptions::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    JsValue(JsValue),
                }
                impl ProjectImportSvgParamsOptions {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum SizeAddParamsNumber {
                    Size(Size),
                    F64(f64),
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    #[wasm_bindgen(js_name = "Project")]
                    pub type Project_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getItem , method , js_class = "Project" , catch)]
                    fn __TSB_get_item_FnProjectGetItemParamsOptionsToItem(
                        this: &Project_Class,
                        options: JsValue,
                    ) -> std::result::Result<Item, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = exportSVG , method , js_class = "Project" , catch)]
                    fn __TSB_export_svg_FnJsValueToProjectExportSvgReturn(
                        this: &Project_Class,
                        options: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = insertLayer , method , js_class = "Project" , catch)]
                    fn __TSB_insert_layer_FnF64AndLayerToLayer(
                        this: &Project_Class,
                        index: f64,
                        layer: Layer,
                    ) -> std::result::Result<Layer, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = activate , method , js_class = "Project" , catch)]
                    fn __TSB_activate_FnTo(
                        this: &Project_Class,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = remove , method , js_class = "Project" , catch)]
                    fn __TSB_remove_FnTo(this: &Project_Class) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = importJSON , method , js_class = "Project" , catch)]
                    fn __TSB_import_json_FnStringToItem(
                        this: &Project_Class,
                        json: String,
                    ) -> std::result::Result<Item, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clear , method , js_class = "Project" , catch)]
                    fn __TSB_clear_FnTo(this: &Project_Class) -> std::result::Result<(), JsValue>;
                    #[wasm_bindgen(constructor, js_class = "Project")]
                    pub fn new(element: JsValue) -> Project_Class;
                    # [wasm_bindgen (method , structural , catch , getter = layers , js_class = "Project")]
                    fn __TSB_layers(this: &Project_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = layers , js_class = "Project")]
                    fn __TSB_set_layers(
                        this: &Project_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = hitTest , method , js_class = "Project" , catch)]
                    fn __TSB_hit_test_FnPointAndJsValueToHitResult(
                        this: &Project_Class,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = selectAll , method , js_class = "Project" , catch)]
                    fn __TSB_select_all_FnTo(
                        this: &Project_Class,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = deselectAll , method , js_class = "Project" , catch)]
                    fn __TSB_deselect_all_FnTo(
                        this: &Project_Class,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = index , js_class = "Project")]
                    fn index(this: &Project_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = index , js_class = "Project")]
                    fn set_index(
                        this: &Project_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = addLayer , method , js_class = "Project" , catch)]
                    fn __TSB_add_layer_FnLayerToLayer(
                        this: &Project_Class,
                        layer: Layer,
                    ) -> std::result::Result<Layer, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = currentStyle , js_class = "Project")]
                    fn current_style(this: &Project_Class) -> std::result::Result<Style, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = currentStyle , js_class = "Project")]
                    fn set_current_style(
                        this: &Project_Class,
                        value: Style,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = symbolDefinitions , js_class = "Project")]
                    fn __TSB_symbol_definitions(
                        this: &Project_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = symbolDefinitions , js_class = "Project")]
                    fn __TSB_set_symbol_definitions(
                        this: &Project_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = view , js_class = "Project")]
                    fn view(this: &Project_Class) -> std::result::Result<View, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = view , js_class = "Project")]
                    fn set_view(
                        this: &Project_Class,
                        value: View,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isEmpty , method , js_class = "Project" , catch)]
                    fn __TSB_is_empty_FnToBool(
                        this: &Project_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = importSVG , method , js_class = "Project" , catch)]
                    fn __TSB_import_svg_FnProjectImportSvgParamsSvgAndJsValueToItem(
                        this: &Project_Class,
                        svg: JsValue,
                        options: JsValue,
                    ) -> std::result::Result<Item, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = importSVG , method , js_class = "Project" , catch)]
                    fn __TSB_import_svg_FnProjectImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem(
                        this: &Project_Class,
                        svg: JsValue,
                        on_load: &Closure<
                            dyn Fn(
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        >,
                    ) -> std::result::Result<Item, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = selectedItems , js_class = "Project")]
                    fn __TSB_selected_items(
                        this: &Project_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = selectedItems , js_class = "Project")]
                    fn __TSB_set_selected_items(
                        this: &Project_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getItems , method , js_class = "Project" , catch)]
                    fn __TSB_get_items_FnProjectGetItemsParamsOptionsToVecOfItem(
                        this: &Project_Class,
                        options: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = exportJSON , method , js_class = "Project" , catch)]
                    fn __TSB_export_json_FnJsValueToString(
                        this: &Project_Class,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = hitTestAll , method , js_class = "Project" , catch)]
                    fn __TSB_hit_test_all_FnPointAndJsValueToVecOfHitResult(
                        this: &Project_Class,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = activeLayer , js_class = "Project")]
                    fn active_layer(this: &Project_Class) -> std::result::Result<Layer, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = activeLayer , js_class = "Project")]
                    fn set_active_layer(
                        this: &Project_Class,
                        value: Layer,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Project(pub Project_Class);
                impl std::convert::From<Project> for JsValue {
                    fn from(src: Project) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for Project {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for Project {
                    fn instanceof(val: &JsValue) -> bool {
                        Project_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        Project(Project_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(Project_Class::unchecked_from_js_ref(val) as *const Project_Class
                                as *const Self)
                        }
                    }
                }
                impl Project {
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_item(
                        &self,
                        options: ProjectGetItemParamsOptions,
                    ) -> std::result::Result<Item, JsValue> {
                        let result = self.0.__TSB_get_item_FnProjectGetItemParamsOptionsToItem(
                            ts_bindgen_rt::to_jsvalue(&options)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ProjectExportSvgReturn, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self
                                .0
                                .__TSB_export_svg_FnJsValueToProjectExportSvgReturn(options)?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn insert_layer(
                        &self,
                        index: f64,
                        layer: Layer,
                    ) -> std::result::Result<Layer, JsValue> {
                        let result = self.0.__TSB_insert_layer_FnF64AndLayerToLayer(index, layer);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn activate(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_activate_FnTo();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn remove(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_remove_FnTo();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                        let result = self.0.__TSB_import_json_FnStringToItem(json);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn clear(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_clear_FnTo();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new(element: ProjectConstructorElement) -> Project {
                        let result =
                            Project_Class::new(ts_bindgen_rt::to_jsvalue(&element).unwrap());
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Project(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn layers(&self) -> std::result::Result<Vec<Layer>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_layers()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_layers(
                        &self,
                        value: Vec<Layer>,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_layers({
                            let value_array = js_sys::Array::new();
                            for value_item in value {
                                value_array.push(&JsValue::from(value_item));
                            }
                            value_array.into()
                        });
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue> {
                        let result = self
                            .0
                            .__TSB_hit_test_FnPointAndJsValueToHitResult(point, options);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn select_all(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_select_all_FnTo();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn deselect_all(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_deselect_all_FnTo();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn index(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.index();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_index(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_index(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn add_layer(&self, layer: Layer) -> std::result::Result<Layer, JsValue> {
                        let result = self.0.__TSB_add_layer_FnLayerToLayer(layer);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn current_style(&self) -> std::result::Result<Style, JsValue> {
                        let result = self.0.current_style();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_current_style(
                        &self,
                        value: Style,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_current_style(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn symbol_definitions(
                        &self,
                    ) -> std::result::Result<Vec<SymbolDefinition>, JsValue> {
                        let result =
                            ts_bindgen_rt::from_jsvalue(&self.0.__TSB_symbol_definitions()?)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_symbol_definitions(
                        &self,
                        value: Vec<SymbolDefinition>,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_symbol_definitions({
                            let value_array = js_sys::Array::new();
                            for value_item in value {
                                value_array.push(&JsValue::from(value_item));
                            }
                            value_array.into()
                        });
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn view(&self) -> std::result::Result<View, JsValue> {
                        let result = self.0.view();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_view(&self, value: View) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_view(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_empty(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_empty_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn import_svg_FnProjectImportSvgParamsSvgAndJsValueToItem(
                        &self,
                        svg: ProjectImportSvgParamsSvg,
                        options: JsValue,
                    ) -> std::result::Result<Item, JsValue> {
                        let result = self
                            .0
                            .__TSB_import_svg_FnProjectImportSvgParamsSvgAndJsValueToItem(
                                ts_bindgen_rt::to_jsvalue(&svg)
                                    .map_err(ts_bindgen_rt::Error::from)
                                    .map_err(JsValue::from)?,
                                options,
                            );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn import_svg_FnProjectImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem(
                        &self,
                        svg: ProjectImportSvgParamsSvg,
                        on_load: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue> {
                        # [allow (non_snake_case)] let __TSB_Local_on_load = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = on_load ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let result = self . 0 . __TSB_import_svg_FnProjectImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem (ts_bindgen_rt :: to_jsvalue (& svg) . map_err (ts_bindgen_rt :: Error :: from) . map_err (JsValue :: from) ? , & __TSB_Local_on_load) ;
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn selected_items(&self) -> std::result::Result<Vec<Item>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_selected_items()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_selected_items(
                        &self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_selected_items({
                            let value_array = js_sys::Array::new();
                            for value_item in value {
                                value_array.push(&JsValue::from(value_item));
                            }
                            value_array.into()
                        });
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_items(
                        &self,
                        options: ProjectGetItemsParamsOptions,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self
                                .0
                                .__TSB_get_items_FnProjectGetItemsParamsOptionsToVecOfItem(
                                    ts_bindgen_rt::to_jsvalue(&options)
                                        .map_err(ts_bindgen_rt::Error::from)
                                        .map_err(JsValue::from)?,
                                )?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn export_json(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue> {
                        let result = self.0.__TSB_export_json_FnJsValueToString(options);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self
                                .0
                                .__TSB_hit_test_all_FnPointAndJsValueToVecOfHitResult(
                                    point, options,
                                )?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn active_layer(&self) -> std::result::Result<Layer, JsValue> {
                        let result = self.0.active_layer();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_active_layer(
                        &self,
                        value: Layer,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_active_layer(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Project {
                    fn describe() {
                        <Project_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Project {
                    type Abi = <Project_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Project {
                    type Abi = <Project_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Project(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Project {
                    type Abi = <&'a Project_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Project {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Project {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Project_Class =
                            <Project_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait Project_Trait {
                    fn get_item(
                        &self,
                        options: ProjectGetItemParamsOptions,
                    ) -> std::result::Result<Item, JsValue>;
                    fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ProjectExportSvgReturn, JsValue>;
                    fn insert_layer(
                        &self,
                        index: f64,
                        layer: Layer,
                    ) -> std::result::Result<Layer, JsValue>;
                    fn activate(&self) -> std::result::Result<(), JsValue>;
                    fn remove(&self) -> std::result::Result<(), JsValue>;
                    fn import_json(&self, json: String) -> std::result::Result<Item, JsValue>;
                    fn clear(&self) -> std::result::Result<(), JsValue>;
                    fn set_layers(&mut self, value: Vec<Layer>)
                        -> std::result::Result<(), JsValue>;
                    fn layers(&self) -> std::result::Result<Vec<Layer>, JsValue>;
                    fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue>;
                    fn select_all(&self) -> std::result::Result<(), JsValue>;
                    fn deselect_all(&self) -> std::result::Result<(), JsValue>;
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn index(&self) -> std::result::Result<f64, JsValue>;
                    fn add_layer(&self, layer: Layer) -> std::result::Result<Layer, JsValue>;
                    fn set_current_style(
                        &mut self,
                        value: Style,
                    ) -> std::result::Result<(), JsValue>;
                    fn current_style(&self) -> std::result::Result<Style, JsValue>;
                    fn set_symbol_definitions(
                        &mut self,
                        value: Vec<SymbolDefinition>,
                    ) -> std::result::Result<(), JsValue>;
                    fn symbol_definitions(
                        &self,
                    ) -> std::result::Result<Vec<SymbolDefinition>, JsValue>;
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue>;
                    fn view(&self) -> std::result::Result<View, JsValue>;
                    fn is_empty(&self) -> std::result::Result<bool, JsValue>;
                    fn import_svg_FnProjectImportSvgParamsSvgAndJsValueToItem(
                        &self,
                        svg: ProjectImportSvgParamsSvg,
                        options: JsValue,
                    ) -> std::result::Result<Item, JsValue>;
                    fn import_svg_FnProjectImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem(
                        &self,
                        svg: ProjectImportSvgParamsSvg,
                        on_load: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue>;
                    fn set_selected_items(
                        &mut self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue>;
                    fn selected_items(&self) -> std::result::Result<Vec<Item>, JsValue>;
                    fn get_items(
                        &self,
                        options: ProjectGetItemsParamsOptions,
                    ) -> std::result::Result<Vec<Item>, JsValue>;
                    fn export_json(&self, options: JsValue)
                        -> std::result::Result<String, JsValue>;
                    fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue>;
                    fn set_active_layer(
                        &mut self,
                        value: Layer,
                    ) -> std::result::Result<(), JsValue>;
                    fn active_layer(&self) -> std::result::Result<Layer, JsValue>;
                }
                impl Project_Trait for Project {
                    fn get_item(
                        &self,
                        options: ProjectGetItemParamsOptions,
                    ) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Project::get_item(target, options)
                    }
                    fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ProjectExportSvgReturn, JsValue> {
                        let target = self;
                        Project::export_svg(target, options)
                    }
                    fn insert_layer(
                        &self,
                        index: f64,
                        layer: Layer,
                    ) -> std::result::Result<Layer, JsValue> {
                        let target = self;
                        Project::insert_layer(target, index, layer)
                    }
                    fn activate(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Project::activate(target)
                    }
                    fn remove(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Project::remove(target)
                    }
                    fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Project::import_json(target, json)
                    }
                    fn clear(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Project::clear(target)
                    }
                    fn set_layers(
                        &mut self,
                        value: Vec<Layer>,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Project::set_layers(target, value)
                    }
                    fn layers(&self) -> std::result::Result<Vec<Layer>, JsValue> {
                        let target = self;
                        Project::layers(target)
                    }
                    fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue> {
                        let target = self;
                        Project::hit_test(target, point, options)
                    }
                    fn select_all(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Project::select_all(target)
                    }
                    fn deselect_all(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Project::deselect_all(target)
                    }
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Project::set_index(target, value)
                    }
                    fn index(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Project::index(target)
                    }
                    fn add_layer(&self, layer: Layer) -> std::result::Result<Layer, JsValue> {
                        let target = self;
                        Project::add_layer(target, layer)
                    }
                    fn set_current_style(
                        &mut self,
                        value: Style,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Project::set_current_style(target, value)
                    }
                    fn current_style(&self) -> std::result::Result<Style, JsValue> {
                        let target = self;
                        Project::current_style(target)
                    }
                    fn set_symbol_definitions(
                        &mut self,
                        value: Vec<SymbolDefinition>,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Project::set_symbol_definitions(target, value)
                    }
                    fn symbol_definitions(
                        &self,
                    ) -> std::result::Result<Vec<SymbolDefinition>, JsValue> {
                        let target = self;
                        Project::symbol_definitions(target)
                    }
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Project::set_view(target, value)
                    }
                    fn view(&self) -> std::result::Result<View, JsValue> {
                        let target = self;
                        Project::view(target)
                    }
                    fn is_empty(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Project::is_empty(target)
                    }
                    fn import_svg_FnProjectImportSvgParamsSvgAndJsValueToItem(
                        &self,
                        svg: ProjectImportSvgParamsSvg,
                        options: JsValue,
                    ) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Project::import_svg_FnProjectImportSvgParamsSvgAndJsValueToItem(
                            target, svg, options,
                        )
                    }
                    fn import_svg_FnProjectImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem(
                        &self,
                        svg: ProjectImportSvgParamsSvg,
                        on_load: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Project :: import_svg_FnProjectImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem (target , svg , on_load)
                    }
                    fn set_selected_items(
                        &mut self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Project::set_selected_items(target, value)
                    }
                    fn selected_items(&self) -> std::result::Result<Vec<Item>, JsValue> {
                        let target = self;
                        Project::selected_items(target)
                    }
                    fn get_items(
                        &self,
                        options: ProjectGetItemsParamsOptions,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target = self;
                        Project::get_items(target, options)
                    }
                    fn export_json(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Project::export_json(target, options)
                    }
                    fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue> {
                        let target = self;
                        Project::hit_test_all(target, point, options)
                    }
                    fn set_active_layer(
                        &mut self,
                        value: Layer,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Project::set_active_layer(target, value)
                    }
                    fn active_layer(&self) -> std::result::Result<Layer, JsValue> {
                        let target = self;
                        Project::active_layer(target)
                    }
                }
                impl std::clone::Clone for Project_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Project_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Project_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    #[wasm_bindgen(js_name = "Item")]
                    pub type Item_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = responds , method , js_class = "Item" , catch)]
                    fn __TSB_responds_FnStringToBool(
                        this: &Item_Class,
                        type_: String,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = copyContent , method , js_class = "Item" , catch)]
                    fn __TSB_copy_content_FnItemTo(
                        this: &Item_Class,
                        source: Item,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = opacity , js_class = "Item")]
                    fn opacity(this: &Item_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = opacity , js_class = "Item")]
                    fn set_opacity(
                        this: &Item_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onFrame , js_class = "Item")]
                    fn __TSB_on_frame(this: &Item_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onFrame , js_class = "Item")]
                    fn __TSB_set_on_frame(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = removeChildren , method , js_class = "Item" , catch)]
                    fn __TSB_remove_children_FnToVecOfItem(
                        this: &Item_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = removeChildren , method , js_class = "Item" , catch)]
                    fn __TSB_remove_children_FnF64AndF64ToVecOfItem(
                        this: &Item_Class,
                        start: f64,
                        end: f64,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isBelow , method , js_class = "Item" , catch)]
                    fn __TSB_is_below_FnItemToBool(
                        this: &Item_Class,
                        item: Item,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = hasStroke , method , js_class = "Item" , catch)]
                    fn __TSB_has_stroke_FnToBool(
                        this: &Item_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = globalMatrix , js_class = "Item")]
                    fn global_matrix(this: &Item_Class) -> std::result::Result<Matrix, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = globalMatrix , js_class = "Item")]
                    fn set_global_matrix(
                        this: &Item_Class,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = copyAttributes , method , js_class = "Item" , catch)]
                    fn __TSB_copy_attributes_FnItemAndBoolTo(
                        this: &Item_Class,
                        source: Item,
                        exclude_matrix: bool,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseMove , js_class = "Item")]
                    fn __TSB_on_mouse_move(
                        this: &Item_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseMove , js_class = "Item")]
                    fn __TSB_set_on_mouse_move(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = position , js_class = "Item")]
                    fn position(this: &Item_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = position , js_class = "Item")]
                    fn set_position(
                        this: &Item_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = bounds , js_class = "Item")]
                    fn bounds(this: &Item_Class) -> std::result::Result<Rectangle, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = bounds , js_class = "Item")]
                    fn set_bounds(
                        this: &Item_Class,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = shadowBlur , js_class = "Item")]
                    fn shadow_blur(this: &Item_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = shadowBlur , js_class = "Item")]
                    fn set_shadow_blur(
                        this: &Item_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = selectedColor , js_class = "Item")]
                    fn __TSB_selected_color(
                        this: &Item_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = selectedColor , js_class = "Item")]
                    fn __TSB_set_selected_color(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = reverseChildren , method , js_class = "Item" , catch)]
                    fn __TSB_reverse_children_FnTo(
                        this: &Item_Class,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = bringToFront , method , js_class = "Item" , catch)]
                    fn __TSB_bring_to_front_FnTo(
                        this: &Item_Class,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = selected , js_class = "Item")]
                    fn selected(this: &Item_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = selected , js_class = "Item")]
                    fn set_selected(
                        this: &Item_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = addChildren , method , js_class = "Item" , catch)]
                    fn __TSB_add_children_FnVecOfItemToVecOfItem(
                        this: &Item_Class,
                        items: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = tweenTo , method , js_class = "Item" , catch)]
                    fn __TSB_tween_to_FnJsValueAndItemTweenToParamsOptionsToTween(
                        this: &Item_Class,
                        to: JsValue,
                        options: JsValue,
                    ) -> std::result::Result<Tween, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = project , js_class = "Item")]
                    fn project(this: &Item_Class) -> std::result::Result<Project, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = project , js_class = "Item")]
                    fn set_project(
                        this: &Item_Class,
                        value: Project,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = name , js_class = "Item")]
                    fn name(this: &Item_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = name , js_class = "Item")]
                    fn set_name(
                        this: &Item_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = strokeBounds , js_class = "Item")]
                    fn stroke_bounds(this: &Item_Class) -> std::result::Result<Rectangle, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = strokeBounds , js_class = "Item")]
                    fn set_stroke_bounds(
                        this: &Item_Class,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = insertBelow , method , js_class = "Item" , catch)]
                    fn __TSB_insert_below_FnItemToItem(
                        this: &Item_Class,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = blendMode , js_class = "Item")]
                    fn blend_mode(this: &Item_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = blendMode , js_class = "Item")]
                    fn set_blend_mode(
                        this: &Item_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = clipMask , js_class = "Item")]
                    fn clip_mask(this: &Item_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = clipMask , js_class = "Item")]
                    fn set_clip_mask(
                        this: &Item_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = fillColor , js_class = "Item")]
                    fn __TSB_fill_color(this: &Item_Class)
                        -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = fillColor , js_class = "Item")]
                    fn __TSB_set_fill_color(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = removeOnDrag , method , js_class = "Item" , catch)]
                    fn __TSB_remove_on_drag_FnTo(
                        this: &Item_Class,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = addChild , method , js_class = "Item" , catch)]
                    fn __TSB_add_child_FnItemToItem(
                        this: &Item_Class,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = scale , method , js_class = "Item" , catch)]
                    fn __TSB_scale_FnF64AndPointTo(
                        this: &Item_Class,
                        scale: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = scale , method , js_class = "Item" , catch)]
                    fn __TSB_scale_FnF64AndF64AndPointTo(
                        this: &Item_Class,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = firstChild , js_class = "Item")]
                    fn first_child(this: &Item_Class) -> std::result::Result<Item, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = firstChild , js_class = "Item")]
                    fn set_first_child(
                        this: &Item_Class,
                        value: Item,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = style , js_class = "Item")]
                    fn style(this: &Item_Class) -> std::result::Result<Style, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = style , js_class = "Item")]
                    fn set_style(
                        this: &Item_Class,
                        value: Style,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = className , js_class = "Item")]
                    fn class_name(this: &Item_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = className , js_class = "Item")]
                    fn set_class_name(
                        this: &Item_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isGroupedWith , method , js_class = "Item" , catch)]
                    fn __TSB_is_grouped_with_FnItemToBool(
                        this: &Item_Class,
                        item: Item,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = shadowOffset , js_class = "Item")]
                    fn shadow_offset(this: &Item_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = shadowOffset , js_class = "Item")]
                    fn set_shadow_offset(
                        this: &Item_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isInside , method , js_class = "Item" , catch)]
                    fn __TSB_is_inside_FnRectangleToBool(
                        this: &Item_Class,
                        rect: Rectangle,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = children , js_class = "Item")]
                    fn __TSB_children(this: &Item_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = children , js_class = "Item")]
                    fn __TSB_set_children(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = hasFill , method , js_class = "Item" , catch)]
                    fn __TSB_has_fill_FnToBool(
                        this: &Item_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = matches , method , js_class = "Item" , catch)]
                    fn __TSB_matches_FnItemMatchesParamsOptionsToBool(
                        this: &Item_Class,
                        options: JsValue,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = matches , method , js_class = "Item" , catch)]
                    fn __TSB_matches_FnStringAndJsValueToBool(
                        this: &Item_Class,
                        name: String,
                        compare: JsValue,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onDoubleClick , js_class = "Item")]
                    fn __TSB_on_double_click(
                        this: &Item_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onDoubleClick , js_class = "Item")]
                    fn __TSB_set_on_double_click(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = intersects , method , js_class = "Item" , catch)]
                    fn __TSB_intersects_FnItemToBool(
                        this: &Item_Class,
                        item: Item,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = rotation , js_class = "Item")]
                    fn rotation(this: &Item_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = rotation , js_class = "Item")]
                    fn set_rotation(
                        this: &Item_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseDown , js_class = "Item")]
                    fn __TSB_on_mouse_down(
                        this: &Item_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseDown , js_class = "Item")]
                    fn __TSB_set_on_mouse_down(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isSibling , method , js_class = "Item" , catch)]
                    fn __TSB_is_sibling_FnItemToBool(
                        this: &Item_Class,
                        item: Item,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = tweenFrom , method , js_class = "Item" , catch)]
                    fn __TSB_tween_from_FnJsValueAndItemTweenFromParamsOptionsToTween(
                        this: &Item_Class,
                        from: JsValue,
                        options: JsValue,
                    ) -> std::result::Result<Tween, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = layer , js_class = "Item")]
                    fn layer(this: &Item_Class) -> std::result::Result<Layer, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = layer , js_class = "Item")]
                    fn set_layer(
                        this: &Item_Class,
                        value: Layer,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = contains , method , js_class = "Item" , catch)]
                    fn __TSB_contains_FnPointToBool(
                        this: &Item_Class,
                        point: Point,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onClick , js_class = "Item")]
                    fn __TSB_on_click(this: &Item_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onClick , js_class = "Item")]
                    fn __TSB_set_on_click(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = lastChild , js_class = "Item")]
                    fn last_child(this: &Item_Class) -> std::result::Result<Item, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = lastChild , js_class = "Item")]
                    fn set_last_child(
                        this: &Item_Class,
                        value: Item,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = dashOffset , js_class = "Item")]
                    fn dash_offset(this: &Item_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = dashOffset , js_class = "Item")]
                    fn set_dash_offset(
                        this: &Item_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = id , js_class = "Item")]
                    fn id(this: &Item_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = id , js_class = "Item")]
                    fn set_id(this: &Item_Class, value: f64) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = hasShadow , method , js_class = "Item" , catch)]
                    fn __TSB_has_shadow_FnToBool(
                        this: &Item_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = tween , method , js_class = "Item" , catch)]
                    fn __TSB_tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                        this: &Item_Class,
                        from: JsValue,
                        to: JsValue,
                        options: JsValue,
                    ) -> std::result::Result<Tween, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = tween , method , js_class = "Item" , catch)]
                    fn __TSB_tween_FnJsValueAndItemTweenParamsOptionsToTween(
                        this: &Item_Class,
                        to: JsValue,
                        options: JsValue,
                    ) -> std::result::Result<Tween, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = tween , method , js_class = "Item" , catch)]
                    fn __TSB_tween_FnItemTweenParamsOptionsToTween(
                        this: &Item_Class,
                        options: JsValue,
                    ) -> std::result::Result<Tween, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = scaling , js_class = "Item")]
                    fn scaling(this: &Item_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = scaling , js_class = "Item")]
                    fn set_scaling(
                        this: &Item_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = sendToBack , method , js_class = "Item" , catch)]
                    fn __TSB_send_to_back_FnTo(
                        this: &Item_Class,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = set , method , js_class = "Item" , catch)]
                    fn __TSB_set_FnJsValueToJsValue(
                        this: &Item_Class,
                        props: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = index , js_class = "Item")]
                    fn index(this: &Item_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = index , js_class = "Item")]
                    fn set_index(this: &Item_Class, value: f64)
                        -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = reduce , method , js_class = "Item" , catch)]
                    fn __TSB_reduce_FnJsValueToItem(
                        this: &Item_Class,
                        options: JsValue,
                    ) -> std::result::Result<Item, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = pivot , js_class = "Item")]
                    fn pivot(this: &Item_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = pivot , js_class = "Item")]
                    fn set_pivot(
                        this: &Item_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = insertChildren , method , js_class = "Item" , catch)]
                    fn __TSB_insert_children_FnF64AndVecOfItemToVecOfItem(
                        this: &Item_Class,
                        index: f64,
                        items: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseUp , js_class = "Item")]
                    fn __TSB_on_mouse_up(
                        this: &Item_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseUp , js_class = "Item")]
                    fn __TSB_set_on_mouse_up(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = strokeWidth , js_class = "Item")]
                    fn stroke_width(this: &Item_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = strokeWidth , js_class = "Item")]
                    fn set_stroke_width(
                        this: &Item_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = removeOn , method , js_class = "Item" , catch)]
                    fn __TSB_remove_on_FnJsValueTo(
                        this: &Item_Class,
                        options: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = removeOnUp , method , js_class = "Item" , catch)]
                    fn __TSB_remove_on_up_FnTo(
                        this: &Item_Class,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isChild , method , js_class = "Item" , catch)]
                    fn __TSB_is_child_FnItemToBool(
                        this: &Item_Class,
                        item: Item,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = replaceWith , method , js_class = "Item" , catch)]
                    fn __TSB_replace_with_FnItemToBool(
                        this: &Item_Class,
                        item: Item,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = exportJSON , method , js_class = "Item" , catch)]
                    fn __TSB_export_json_FnJsValueToString(
                        this: &Item_Class,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = hitTestAll , method , js_class = "Item" , catch)]
                    fn __TSB_hit_test_all_FnPointAndJsValueToVecOfHitResult(
                        this: &Item_Class,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = exportSVG , method , js_class = "Item" , catch)]
                    fn __TSB_export_svg_FnJsValueToItemExportSvgReturn(
                        this: &Item_Class,
                        options: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = copyTo , method , js_class = "Item" , catch)]
                    fn __TSB_copy_to_FnItemCopyToParamsOwnerToJsValue(
                        this: &Item_Class,
                        owner: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = matrix , js_class = "Item")]
                    fn matrix(this: &Item_Class) -> std::result::Result<Matrix, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = matrix , js_class = "Item")]
                    fn set_matrix(
                        this: &Item_Class,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = addTo , method , js_class = "Item" , catch)]
                    fn __TSB_add_to_FnItemAddToParamsOwnerToJsValue(
                        this: &Item_Class,
                        owner: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = rotate , method , js_class = "Item" , catch)]
                    fn __TSB_rotate_FnF64AndPointTo(
                        this: &Item_Class,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = viewMatrix , js_class = "Item")]
                    fn view_matrix(this: &Item_Class) -> std::result::Result<Matrix, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = viewMatrix , js_class = "Item")]
                    fn set_view_matrix(
                        this: &Item_Class,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = previousSibling , js_class = "Item")]
                    fn previous_sibling(this: &Item_Class) -> std::result::Result<Item, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = previousSibling , js_class = "Item")]
                    fn set_previous_sibling(
                        this: &Item_Class,
                        value: Item,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = data , js_class = "Item")]
                    fn __TSB_data(this: &Item_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = data , js_class = "Item")]
                    fn __TSB_set_data(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = off , method , js_class = "Item" , catch)]
                    fn __TSB_off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                        this: &Item_Class,
                        type_: String,
                        callback: &Closure<
                            dyn Fn(
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        >,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = off , method , js_class = "Item" , catch)]
                    fn __TSB_off_FnJsValueToJsValue(
                        this: &Item_Class,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = strokeScaling , js_class = "Item")]
                    fn stroke_scaling(this: &Item_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = strokeScaling , js_class = "Item")]
                    fn set_stroke_scaling(
                        this: &Item_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = insertChild , method , js_class = "Item" , catch)]
                    fn __TSB_insert_child_FnF64AndItemToItem(
                        this: &Item_Class,
                        index: f64,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = skew , method , js_class = "Item" , catch)]
                    fn __TSB_skew_FnPointAndPointTo(
                        this: &Item_Class,
                        skew: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = skew , method , js_class = "Item" , catch)]
                    fn __TSB_skew_FnF64AndF64AndPointTo(
                        this: &Item_Class,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = on , method , js_class = "Item" , catch)]
                    fn __TSB_on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                        this: &Item_Class,
                        type_: String,
                        callback: &Closure<
                            dyn Fn(
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        >,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = on , method , js_class = "Item" , catch)]
                    fn __TSB_on_FnJsValueToJsValue(
                        this: &Item_Class,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = remove , method , js_class = "Item" , catch)]
                    fn __TSB_remove_FnToBool(
                        this: &Item_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = globalToLocal , method , js_class = "Item" , catch)]
                    fn __TSB_global_to_local_FnPointToPoint(
                        this: &Item_Class,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = emit , method , js_class = "Item" , catch)]
                    fn __TSB_emit_FnStringAndJsValueToBool(
                        this: &Item_Class,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = hitTest , method , js_class = "Item" , catch)]
                    fn __TSB_hit_test_FnPointAndJsValueToHitResult(
                        this: &Item_Class,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = importSVG , method , js_class = "Item" , catch)]
                    fn __TSB_import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                        this: &Item_Class,
                        svg: JsValue,
                        options: JsValue,
                    ) -> std::result::Result<Item, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = importSVG , method , js_class = "Item" , catch)]
                    fn __TSB_import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem(
                        this: &Item_Class,
                        svg: JsValue,
                        on_load: &Closure<
                            dyn Fn(
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        >,
                    ) -> std::result::Result<Item, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = dashArray , js_class = "Item")]
                    fn __TSB_dash_array(this: &Item_Class)
                        -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = dashArray , js_class = "Item")]
                    fn __TSB_set_dash_array(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = shear , method , js_class = "Item" , catch)]
                    fn __TSB_shear_FnPointAndPointTo(
                        this: &Item_Class,
                        shear: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = shear , method , js_class = "Item" , catch)]
                    fn __TSB_shear_FnF64AndF64AndPointTo(
                        this: &Item_Class,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = internalBounds , js_class = "Item")]
                    fn internal_bounds(
                        this: &Item_Class,
                    ) -> std::result::Result<Rectangle, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = internalBounds , js_class = "Item")]
                    fn set_internal_bounds(
                        this: &Item_Class,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = strokeCap , js_class = "Item")]
                    fn stroke_cap(this: &Item_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = strokeCap , js_class = "Item")]
                    fn set_stroke_cap(
                        this: &Item_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseEnter , js_class = "Item")]
                    fn __TSB_on_mouse_enter(
                        this: &Item_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseEnter , js_class = "Item")]
                    fn __TSB_set_on_mouse_enter(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = view , js_class = "Item")]
                    fn view(this: &Item_Class) -> std::result::Result<View, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = view , js_class = "Item")]
                    fn set_view(this: &Item_Class, value: View)
                        -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = strokeJoin , js_class = "Item")]
                    fn stroke_join(this: &Item_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = strokeJoin , js_class = "Item")]
                    fn set_stroke_join(
                        this: &Item_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isAncestor , method , js_class = "Item" , catch)]
                    fn __TSB_is_ancestor_FnItemToBool(
                        this: &Item_Class,
                        item: Item,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = fillRule , js_class = "Item")]
                    fn fill_rule(this: &Item_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = fillRule , js_class = "Item")]
                    fn set_fill_rule(
                        this: &Item_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = fitBounds , method , js_class = "Item" , catch)]
                    fn __TSB_fit_bounds_FnRectangleAndBoolTo(
                        this: &Item_Class,
                        rectangle: Rectangle,
                        fill: bool,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = localToParent , method , js_class = "Item" , catch)]
                    fn __TSB_local_to_parent_FnPointToPoint(
                        this: &Item_Class,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = handleBounds , js_class = "Item")]
                    fn handle_bounds(this: &Item_Class) -> std::result::Result<Rectangle, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = handleBounds , js_class = "Item")]
                    fn set_handle_bounds(
                        this: &Item_Class,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = nextSibling , js_class = "Item")]
                    fn next_sibling(this: &Item_Class) -> std::result::Result<Item, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = nextSibling , js_class = "Item")]
                    fn set_next_sibling(
                        this: &Item_Class,
                        value: Item,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = clone , method , js_class = "Item" , catch)]
                    fn __TSB_clone_FnJsValueToJsValue(
                        this: &Item_Class,
                        options: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isDescendant , method , js_class = "Item" , catch)]
                    fn __TSB_is_descendant_FnItemToBool(
                        this: &Item_Class,
                        item: Item,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = removeOnDown , method , js_class = "Item" , catch)]
                    fn __TSB_remove_on_down_FnTo(
                        this: &Item_Class,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isParent , method , js_class = "Item" , catch)]
                    fn __TSB_is_parent_FnItemToBool(
                        this: &Item_Class,
                        item: Item,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = removeOnMove , method , js_class = "Item" , catch)]
                    fn __TSB_remove_on_move_FnTo(
                        this: &Item_Class,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isEmpty , method , js_class = "Item" , catch)]
                    fn __TSB_is_empty_FnBoolToBool(
                        this: &Item_Class,
                        recursively: bool,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = rasterize , method , js_class = "Item" , catch)]
                    fn __TSB_rasterize_FnJsValueToRaster(
                        this: &Item_Class,
                        options: JsValue,
                    ) -> std::result::Result<Raster, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = shadowColor , js_class = "Item")]
                    fn __TSB_shadow_color(
                        this: &Item_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = shadowColor , js_class = "Item")]
                    fn __TSB_set_shadow_color(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = miterLimit , js_class = "Item")]
                    fn miter_limit(this: &Item_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = miterLimit , js_class = "Item")]
                    fn set_miter_limit(
                        this: &Item_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getItem , method , js_class = "Item" , catch)]
                    fn __TSB_get_item_FnItemGetItemParamsOptionsToItem(
                        this: &Item_Class,
                        options: JsValue,
                    ) -> std::result::Result<Item, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = importJSON , method , js_class = "Item" , catch)]
                    fn __TSB_import_json_FnStringToItem(
                        this: &Item_Class,
                        json: String,
                    ) -> std::result::Result<Item, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = insertAbove , method , js_class = "Item" , catch)]
                    fn __TSB_insert_above_FnItemToItem(
                        this: &Item_Class,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseDrag , js_class = "Item")]
                    fn __TSB_on_mouse_drag(
                        this: &Item_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseDrag , js_class = "Item")]
                    fn __TSB_set_on_mouse_drag(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isInserted , method , js_class = "Item" , catch)]
                    fn __TSB_is_inserted_FnToBool(
                        this: &Item_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = applyMatrix , js_class = "Item")]
                    fn apply_matrix(this: &Item_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = applyMatrix , js_class = "Item")]
                    fn set_apply_matrix(
                        this: &Item_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = transform , method , js_class = "Item" , catch)]
                    fn __TSB_transform_FnMatrixTo(
                        this: &Item_Class,
                        matrix: Matrix,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = visible , js_class = "Item")]
                    fn visible(this: &Item_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = visible , js_class = "Item")]
                    fn set_visible(
                        this: &Item_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = strokeColor , js_class = "Item")]
                    fn __TSB_stroke_color(
                        this: &Item_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = strokeColor , js_class = "Item")]
                    fn __TSB_set_stroke_color(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onMouseLeave , js_class = "Item")]
                    fn __TSB_on_mouse_leave(
                        this: &Item_Class,
                    ) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onMouseLeave , js_class = "Item")]
                    fn __TSB_set_on_mouse_leave(
                        this: &Item_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = parentToLocal , method , js_class = "Item" , catch)]
                    fn __TSB_parent_to_local_FnPointToPoint(
                        this: &Item_Class,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isAbove , method , js_class = "Item" , catch)]
                    fn __TSB_is_above_FnItemToBool(
                        this: &Item_Class,
                        item: Item,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = getItems , method , js_class = "Item" , catch)]
                    fn __TSB_get_items_FnItemGetItemsParamsOptionsToVecOfItem(
                        this: &Item_Class,
                        options: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = hasChildren , method , js_class = "Item" , catch)]
                    fn __TSB_has_children_FnToBool(
                        this: &Item_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = translate , method , js_class = "Item" , catch)]
                    fn __TSB_translate_FnPointTo(
                        this: &Item_Class,
                        delta: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = parent , js_class = "Item")]
                    fn parent(this: &Item_Class) -> std::result::Result<Item, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = parent , js_class = "Item")]
                    fn set_parent(
                        this: &Item_Class,
                        value: Item,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = locked , js_class = "Item")]
                    fn locked(this: &Item_Class) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = locked , js_class = "Item")]
                    fn set_locked(
                        this: &Item_Class,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = localToGlobal , method , js_class = "Item" , catch)]
                    fn __TSB_local_to_global_FnPointToPoint(
                        this: &Item_Class,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Item(pub Item_Class);
                impl std::convert::From<Item> for JsValue {
                    fn from(src: Item) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for Item {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for Item {
                    fn instanceof(val: &JsValue) -> bool {
                        Item_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        Item(Item_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(Item_Class::unchecked_from_js_ref(val) as *const Item_Class
                                as *const Self)
                        }
                    }
                }
                impl Item {
                    #[allow(dead_code, non_snake_case)]
                    pub fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_responds_FnStringToBool(type_);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_copy_content_FnItemTo(source);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn opacity(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.opacity();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_opacity(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_opacity(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_frame(&self) -> std::result::Result<ItemOnFrame, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_frame()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_on_frame(
                        &self,
                        value: ItemOnFrame,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_frame(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn remove_children_FnToVecOfItem(
                        &self,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self.0.__TSB_remove_children_FnToVecOfItem()?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn remove_children_FnF64AndF64ToVecOfItem(
                        &self,
                        start: f64,
                        end: f64,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self
                                .0
                                .__TSB_remove_children_FnF64AndF64ToVecOfItem(start, end)?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_below_FnItemToBool(item);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_has_stroke_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn global_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.global_matrix();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_global_matrix(
                        &self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_global_matrix(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn copy_attributes(
                        &self,
                        source: Item,
                        exclude_matrix: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self
                            .0
                            .__TSB_copy_attributes_FnItemAndBoolTo(source, exclude_matrix);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_mouse_move(&self) -> std::result::Result<ItemOnMouseMove, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_move()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_on_mouse_move(
                        &self,
                        value: ItemOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_move(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn position(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.position();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_position(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_position(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let result = self.0.bounds();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_bounds(&self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_bounds(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.shadow_blur();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_shadow_blur(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_shadow_blur(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn selected_color(
                        &self,
                    ) -> std::result::Result<ItemSelectedColor, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_selected_color()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_selected_color(
                        &self,
                        value: ItemSelectedColor,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_selected_color(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_reverse_children_FnTo();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_bring_to_front_FnTo();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.selected();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_selected(&self, value: bool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_selected(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn add_children(
                        &self,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self.0.__TSB_add_children_FnVecOfItemToVecOfItem({
                                let items_array = js_sys::Array::new();
                                for items_item in items {
                                    items_array.push(&JsValue::from(items_item));
                                }
                                items_array.into()
                            })?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn tween_to(
                        &self,
                        to: JsValue,
                        options: ItemTweenToParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let result = self
                            .0
                            .__TSB_tween_to_FnJsValueAndItemTweenToParamsOptionsToTween(
                                to,
                                ts_bindgen_rt::to_jsvalue(&options)
                                    .map_err(ts_bindgen_rt::Error::from)
                                    .map_err(JsValue::from)?,
                            );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn project(&self) -> std::result::Result<Project, JsValue> {
                        let result = self.0.project();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_project(&self, value: Project) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_project(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn name(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.name();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_name(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_name(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let result = self.0.stroke_bounds();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_stroke_bounds(
                        &self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_stroke_bounds(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let result = self.0.__TSB_insert_below_FnItemToItem(item);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.blend_mode();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_blend_mode(
                        &self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_blend_mode(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.clip_mask();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_clip_mask(&self, value: bool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_clip_mask(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn fill_color(&self) -> std::result::Result<ItemFillColor, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_fill_color()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_fill_color(
                        &self,
                        value: ItemFillColor,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_fill_color(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_remove_on_drag_FnTo();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let result = self.0.__TSB_add_child_FnItemToItem(item);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn scale_FnF64AndPointTo(
                        &self,
                        scale: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_scale_FnF64AndPointTo(scale, center);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn scale_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_scale_FnF64AndF64AndPointTo(hor, ver, center);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn first_child(&self) -> std::result::Result<Item, JsValue> {
                        let result = self.0.first_child();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_first_child(&self, value: Item) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_first_child(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn style(&self) -> std::result::Result<Style, JsValue> {
                        let result = self.0.style();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_style(&self, value: Style) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_style(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn class_name(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.class_name();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_class_name(
                        &self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_class_name(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_grouped_with(
                        &self,
                        item: Item,
                    ) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_grouped_with_FnItemToBool(item);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn shadow_offset(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.shadow_offset();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_shadow_offset(
                        &self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_shadow_offset(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_inside_FnRectangleToBool(rect);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_children()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_children(
                        &self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_children({
                            let value_array = js_sys::Array::new();
                            for value_item in value {
                                value_array.push(&JsValue::from(value_item));
                            }
                            value_array.into()
                        });
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_has_fill_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn matches_FnItemMatchesParamsOptionsToBool(
                        &self,
                        options: ItemMatchesParamsOptions,
                    ) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_matches_FnItemMatchesParamsOptionsToBool(
                            ts_bindgen_rt::to_jsvalue(&options)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn matches_FnStringAndJsValueToBool(
                        &self,
                        name: String,
                        compare: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_matches_FnStringAndJsValueToBool(name, compare);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_double_click(
                        &self,
                    ) -> std::result::Result<ItemOnDoubleClick, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_double_click()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_on_double_click(
                        &self,
                        value: ItemOnDoubleClick,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_double_click(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_intersects_FnItemToBool(item);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.rotation();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_rotation(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_rotation(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_mouse_down(&self) -> std::result::Result<ItemOnMouseDown, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_down()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_on_mouse_down(
                        &self,
                        value: ItemOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_down(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_sibling_FnItemToBool(item);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn tween_from(
                        &self,
                        from: JsValue,
                        options: ItemTweenFromParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let result = self
                            .0
                            .__TSB_tween_from_FnJsValueAndItemTweenFromParamsOptionsToTween(
                                from,
                                ts_bindgen_rt::to_jsvalue(&options)
                                    .map_err(ts_bindgen_rt::Error::from)
                                    .map_err(JsValue::from)?,
                            );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn layer(&self) -> std::result::Result<Layer, JsValue> {
                        let result = self.0.layer();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_layer(&self, value: Layer) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_layer(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_contains_FnPointToBool(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_click(&self) -> std::result::Result<ItemOnClick, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_click()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_on_click(
                        &self,
                        value: ItemOnClick,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_click(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn last_child(&self) -> std::result::Result<Item, JsValue> {
                        let result = self.0.last_child();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_last_child(&self, value: Item) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_last_child(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.dash_offset();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_dash_offset(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_dash_offset(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn id(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.id();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_id(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_id(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_has_shadow_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                        &self,
                        from: JsValue,
                        to: JsValue,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let result = self
                            .0
                            .__TSB_tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                                from,
                                to,
                                ts_bindgen_rt::to_jsvalue(&options)
                                    .map_err(ts_bindgen_rt::Error::from)
                                    .map_err(JsValue::from)?,
                            );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn tween_FnJsValueAndItemTweenParamsOptionsToTween(
                        &self,
                        to: JsValue,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let result = self
                            .0
                            .__TSB_tween_FnJsValueAndItemTweenParamsOptionsToTween(
                                to,
                                ts_bindgen_rt::to_jsvalue(&options)
                                    .map_err(ts_bindgen_rt::Error::from)
                                    .map_err(JsValue::from)?,
                            );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn tween_FnItemTweenParamsOptionsToTween(
                        &self,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let result = self.0.__TSB_tween_FnItemTweenParamsOptionsToTween(
                            ts_bindgen_rt::to_jsvalue(&options)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.scaling();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_scaling(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_scaling(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_send_to_back_FnTo();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let result = self.0.__TSB_set_FnJsValueToJsValue(props);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn index(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.index();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_index(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_index(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                        let result = self.0.__TSB_reduce_FnJsValueToItem(options);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn pivot(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.pivot();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_pivot(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_pivot(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn insert_children(
                        &self,
                        index: f64,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self
                                .0
                                .__TSB_insert_children_FnF64AndVecOfItemToVecOfItem(index, {
                                    let items_array = js_sys::Array::new();
                                    for items_item in items {
                                        items_array.push(&JsValue::from(items_item));
                                    }
                                    items_array.into()
                                })?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_mouse_up(&self) -> std::result::Result<ItemOnMouseUp, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_up()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_on_mouse_up(
                        &self,
                        value: ItemOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_up(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.stroke_width();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_stroke_width(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_stroke_width(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_remove_on_FnJsValueTo(options);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_remove_on_up_FnTo();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_child_FnItemToBool(item);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_replace_with_FnItemToBool(item);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn export_json(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue> {
                        let result = self.0.__TSB_export_json_FnJsValueToString(options);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self
                                .0
                                .__TSB_hit_test_all_FnPointAndJsValueToVecOfHitResult(
                                    point, options,
                                )?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self
                                .0
                                .__TSB_export_svg_FnJsValueToItemExportSvgReturn(options)?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn copy_to(
                        &self,
                        owner: ItemCopyToParamsOwner,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let result = self.0.__TSB_copy_to_FnItemCopyToParamsOwnerToJsValue(
                            ts_bindgen_rt::to_jsvalue(&owner)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.matrix();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_matrix(&self, value: Matrix) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_matrix(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn add_to(
                        &self,
                        owner: ItemAddToParamsOwner,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let result = self.0.__TSB_add_to_FnItemAddToParamsOwnerToJsValue(
                            ts_bindgen_rt::to_jsvalue(&owner)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_rotate_FnF64AndPointTo(angle, center);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn view_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let result = self.0.view_matrix();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_view_matrix(
                        &self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_view_matrix(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn previous_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let result = self.0.previous_sibling();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_previous_sibling(
                        &self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_previous_sibling(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn data(&self) -> std::result::Result<JsValue, JsValue> {
                        let result = self.0.__TSB_data();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_data(&self, value: JsValue) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_data(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<JsValue, JsValue> {
                        # [allow (non_snake_case)] let __TSB_Local_callback = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = callback ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let result = self . 0 . __TSB_off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (type_ , & __TSB_Local_callback) ;
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn off_FnJsValueToJsValue(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let result = self.0.__TSB_off_FnJsValueToJsValue(object);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.stroke_scaling();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_stroke_scaling(
                        &self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_stroke_scaling(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn insert_child(
                        &self,
                        index: f64,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue> {
                        let result = self.0.__TSB_insert_child_FnF64AndItemToItem(index, item);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn skew_FnPointAndPointTo(
                        &self,
                        skew: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_skew_FnPointAndPointTo(skew, center);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn skew_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_skew_FnF64AndF64AndPointTo(hor, ver, center);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<JsValue, JsValue> {
                        # [allow (non_snake_case)] let __TSB_Local_callback = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = callback ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let result = self . 0 . __TSB_on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (type_ , & __TSB_Local_callback) ;
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_FnJsValueToJsValue(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let result = self.0.__TSB_on_FnJsValueToJsValue(object);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_remove_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn global_to_local(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_global_to_local_FnPointToPoint(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_emit_FnStringAndJsValueToBool(type_, event);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue> {
                        let result = self
                            .0
                            .__TSB_hit_test_FnPointAndJsValueToHitResult(point, options);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                        &self,
                        svg: ItemImportSvgParamsSvg,
                        options: JsValue,
                    ) -> std::result::Result<Item, JsValue> {
                        let result = self
                            .0
                            .__TSB_import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                                ts_bindgen_rt::to_jsvalue(&svg)
                                    .map_err(ts_bindgen_rt::Error::from)
                                    .map_err(JsValue::from)?,
                                options,
                            );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem(
                        &self,
                        svg: ItemImportSvgParamsSvg,
                        on_load: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue> {
                        # [allow (non_snake_case)] let __TSB_Local_on_load = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = on_load ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let result = self . 0 . __TSB_import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem (ts_bindgen_rt :: to_jsvalue (& svg) . map_err (ts_bindgen_rt :: Error :: from) . map_err (JsValue :: from) ? , & __TSB_Local_on_load) ;
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_dash_array()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_dash_array(
                        &self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_dash_array({
                            let value_array = js_sys::Array::new();
                            for value_item in value {
                                value_array.push(&JsValue::from(value_item));
                            }
                            value_array.into()
                        });
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn shear_FnPointAndPointTo(
                        &self,
                        shear: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_shear_FnPointAndPointTo(shear, center);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn shear_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_shear_FnF64AndF64AndPointTo(hor, ver, center);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn internal_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let result = self.0.internal_bounds();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_internal_bounds(
                        &self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_internal_bounds(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.stroke_cap();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_stroke_cap(
                        &self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_stroke_cap(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_mouse_enter(&self) -> std::result::Result<ItemOnMouseEnter, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_enter()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_on_mouse_enter(
                        &self,
                        value: ItemOnMouseEnter,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_enter(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn view(&self) -> std::result::Result<View, JsValue> {
                        let result = self.0.view();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_view(&self, value: View) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_view(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.stroke_join();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_stroke_join(
                        &self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_stroke_join(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_ancestor_FnItemToBool(item);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.fill_rule();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_fill_rule(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_fill_rule(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn fit_bounds(
                        &self,
                        rectangle: Rectangle,
                        fill: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self
                            .0
                            .__TSB_fit_bounds_FnRectangleAndBoolTo(rectangle, fill);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn local_to_parent(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_local_to_parent_FnPointToPoint(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let result = self.0.handle_bounds();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_handle_bounds(
                        &self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_handle_bounds(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn next_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let result = self.0.next_sibling();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_next_sibling(
                        &self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_next_sibling(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let result = self.0.__TSB_clone_FnJsValueToJsValue(options);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_descendant_FnItemToBool(item);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_remove_on_down_FnTo();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_parent_FnItemToBool(item);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_remove_on_move_FnTo();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_empty(
                        &self,
                        recursively: bool,
                    ) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_empty_FnBoolToBool(recursively);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn rasterize(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<Raster, JsValue> {
                        let result = self.0.__TSB_rasterize_FnJsValueToRaster(options);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn shadow_color(&self) -> std::result::Result<ItemShadowColor, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_shadow_color()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_shadow_color(
                        &self,
                        value: ItemShadowColor,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_shadow_color(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.miter_limit();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_miter_limit(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_miter_limit(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_item(
                        &self,
                        options: ItemGetItemParamsOptions,
                    ) -> std::result::Result<Item, JsValue> {
                        let result = self.0.__TSB_get_item_FnItemGetItemParamsOptionsToItem(
                            ts_bindgen_rt::to_jsvalue(&options)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                        let result = self.0.__TSB_import_json_FnStringToItem(json);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let result = self.0.__TSB_insert_above_FnItemToItem(item);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_mouse_drag(&self) -> std::result::Result<ItemOnMouseDrag, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_drag()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_on_mouse_drag(
                        &self,
                        value: ItemOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_drag(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_inserted_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.apply_matrix();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_apply_matrix(
                        &self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_apply_matrix(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_transform_FnMatrixTo(matrix);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn visible(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.visible();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_visible(&self, value: bool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_visible(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn stroke_color(&self) -> std::result::Result<ItemStrokeColor, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_stroke_color()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_stroke_color(
                        &self,
                        value: ItemStrokeColor,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_stroke_color(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_mouse_leave(&self) -> std::result::Result<ItemOnMouseLeave, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_mouse_leave()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_on_mouse_leave(
                        &self,
                        value: ItemOnMouseLeave,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_mouse_leave(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn parent_to_local(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_parent_to_local_FnPointToPoint(point);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_above_FnItemToBool(item);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn get_items(
                        &self,
                        options: ItemGetItemsParamsOptions,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(
                            &self
                                .0
                                .__TSB_get_items_FnItemGetItemsParamsOptionsToVecOfItem(
                                    ts_bindgen_rt::to_jsvalue(&options)
                                        .map_err(ts_bindgen_rt::Error::from)
                                        .map_err(JsValue::from)?,
                                )?,
                        )
                        .map_err(ts_bindgen_rt::Error::from)
                        .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn has_children(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_has_children_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_translate_FnPointTo(delta);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn parent(&self) -> std::result::Result<Item, JsValue> {
                        let result = self.0.parent();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_parent(&self, value: Item) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_parent(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn locked(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.locked();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_locked(&self, value: bool) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_locked(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn local_to_global(
                        &self,
                        point: Point,
                    ) -> std::result::Result<Point, JsValue> {
                        let result = self.0.__TSB_local_to_global_FnPointToPoint(point);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Item {
                    fn describe() {
                        <Item_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Item {
                    type Abi = <Item_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Item {
                    type Abi = <Item_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Item(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Item {
                    type Abi = <&'a Item_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Item {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Item {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Item_Class =
                            <Item_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait Item_Trait {
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue>;
                    fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue>;
                    fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn opacity(&self) -> std::result::Result<f64, JsValue>;
                    fn set_on_frame(
                        &mut self,
                        value: ItemOnFrame,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_frame(&self) -> std::result::Result<ItemOnFrame, JsValue>;
                    fn remove_children_FnToVecOfItem(
                        &self,
                    ) -> std::result::Result<Vec<Item>, JsValue>;
                    fn remove_children_FnF64AndF64ToVecOfItem(
                        &self,
                        start: f64,
                        end: f64,
                    ) -> std::result::Result<Vec<Item>, JsValue>;
                    fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue>;
                    fn has_stroke(&self) -> std::result::Result<bool, JsValue>;
                    fn set_global_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue>;
                    fn global_matrix(&self) -> std::result::Result<Matrix, JsValue>;
                    fn copy_attributes(
                        &self,
                        source: Item,
                        exclude_matrix: bool,
                    ) -> std::result::Result<(), JsValue>;
                    fn set_on_mouse_move(
                        &mut self,
                        value: ItemOnMouseMove,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_move(&self) -> std::result::Result<ItemOnMouseMove, JsValue>;
                    fn set_position(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn position(&self) -> std::result::Result<Point, JsValue>;
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue>;
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue>;
                    fn set_shadow_blur(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn shadow_blur(&self) -> std::result::Result<f64, JsValue>;
                    fn set_selected_color(
                        &mut self,
                        value: ItemSelectedColor,
                    ) -> std::result::Result<(), JsValue>;
                    fn selected_color(&self) -> std::result::Result<ItemSelectedColor, JsValue>;
                    fn reverse_children(&self) -> std::result::Result<(), JsValue>;
                    fn bring_to_front(&self) -> std::result::Result<(), JsValue>;
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue>;
                    fn selected(&self) -> std::result::Result<bool, JsValue>;
                    fn add_children(
                        &self,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue>;
                    fn tween_to(
                        &self,
                        to: JsValue,
                        options: ItemTweenToParamsOptions,
                    ) -> std::result::Result<Tween, JsValue>;
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue>;
                    fn project(&self) -> std::result::Result<Project, JsValue>;
                    fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn name(&self) -> std::result::Result<String, JsValue>;
                    fn set_stroke_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue>;
                    fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue>;
                    fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue>;
                    fn set_blend_mode(&mut self, value: String)
                        -> std::result::Result<(), JsValue>;
                    fn blend_mode(&self) -> std::result::Result<String, JsValue>;
                    fn set_clip_mask(&mut self, value: bool) -> std::result::Result<(), JsValue>;
                    fn clip_mask(&self) -> std::result::Result<bool, JsValue>;
                    fn set_fill_color(
                        &mut self,
                        value: ItemFillColor,
                    ) -> std::result::Result<(), JsValue>;
                    fn fill_color(&self) -> std::result::Result<ItemFillColor, JsValue>;
                    fn remove_on_drag(&self) -> std::result::Result<(), JsValue>;
                    fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue>;
                    fn scale_FnF64AndPointTo(
                        &self,
                        scale: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn scale_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn set_first_child(&mut self, value: Item) -> std::result::Result<(), JsValue>;
                    fn first_child(&self) -> std::result::Result<Item, JsValue>;
                    fn set_style(&mut self, value: Style) -> std::result::Result<(), JsValue>;
                    fn style(&self) -> std::result::Result<Style, JsValue>;
                    fn set_class_name(&mut self, value: String)
                        -> std::result::Result<(), JsValue>;
                    fn class_name(&self) -> std::result::Result<String, JsValue>;
                    fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue>;
                    fn set_shadow_offset(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn shadow_offset(&self) -> std::result::Result<Point, JsValue>;
                    fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue>;
                    fn set_children(
                        &mut self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue>;
                    fn children(&self) -> std::result::Result<Vec<Item>, JsValue>;
                    fn has_fill(&self) -> std::result::Result<bool, JsValue>;
                    fn matches_FnItemMatchesParamsOptionsToBool(
                        &self,
                        options: ItemMatchesParamsOptions,
                    ) -> std::result::Result<bool, JsValue>;
                    fn matches_FnStringAndJsValueToBool(
                        &self,
                        name: String,
                        compare: JsValue,
                    ) -> std::result::Result<bool, JsValue>;
                    fn set_on_double_click(
                        &mut self,
                        value: ItemOnDoubleClick,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_double_click(&self) -> std::result::Result<ItemOnDoubleClick, JsValue>;
                    fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue>;
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn rotation(&self) -> std::result::Result<f64, JsValue>;
                    fn set_on_mouse_down(
                        &mut self,
                        value: ItemOnMouseDown,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_down(&self) -> std::result::Result<ItemOnMouseDown, JsValue>;
                    fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue>;
                    fn tween_from(
                        &self,
                        from: JsValue,
                        options: ItemTweenFromParamsOptions,
                    ) -> std::result::Result<Tween, JsValue>;
                    fn set_layer(&mut self, value: Layer) -> std::result::Result<(), JsValue>;
                    fn layer(&self) -> std::result::Result<Layer, JsValue>;
                    fn contains(&self, point: Point) -> std::result::Result<bool, JsValue>;
                    fn set_on_click(
                        &mut self,
                        value: ItemOnClick,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_click(&self) -> std::result::Result<ItemOnClick, JsValue>;
                    fn set_last_child(&mut self, value: Item) -> std::result::Result<(), JsValue>;
                    fn last_child(&self) -> std::result::Result<Item, JsValue>;
                    fn set_dash_offset(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn dash_offset(&self) -> std::result::Result<f64, JsValue>;
                    fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn id(&self) -> std::result::Result<f64, JsValue>;
                    fn has_shadow(&self) -> std::result::Result<bool, JsValue>;
                    fn tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                        &self,
                        from: JsValue,
                        to: JsValue,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue>;
                    fn tween_FnJsValueAndItemTweenParamsOptionsToTween(
                        &self,
                        to: JsValue,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue>;
                    fn tween_FnItemTweenParamsOptionsToTween(
                        &self,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue>;
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn scaling(&self) -> std::result::Result<Point, JsValue>;
                    fn send_to_back(&self) -> std::result::Result<(), JsValue>;
                    fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue>;
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn index(&self) -> std::result::Result<f64, JsValue>;
                    fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue>;
                    fn set_pivot(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn pivot(&self) -> std::result::Result<Point, JsValue>;
                    fn insert_children(
                        &self,
                        index: f64,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue>;
                    fn set_on_mouse_up(
                        &mut self,
                        value: ItemOnMouseUp,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_up(&self) -> std::result::Result<ItemOnMouseUp, JsValue>;
                    fn set_stroke_width(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn stroke_width(&self) -> std::result::Result<f64, JsValue>;
                    fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue>;
                    fn remove_on_up(&self) -> std::result::Result<(), JsValue>;
                    fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue>;
                    fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue>;
                    fn export_json(&self, options: JsValue)
                        -> std::result::Result<String, JsValue>;
                    fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue>;
                    fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ItemExportSvgReturn, JsValue>;
                    fn copy_to(
                        &self,
                        owner: ItemCopyToParamsOwner,
                    ) -> std::result::Result<JsValue, JsValue>;
                    fn set_matrix(&mut self, value: Matrix) -> std::result::Result<(), JsValue>;
                    fn matrix(&self) -> std::result::Result<Matrix, JsValue>;
                    fn add_to(
                        &self,
                        owner: ItemAddToParamsOwner,
                    ) -> std::result::Result<JsValue, JsValue>;
                    fn rotate(&self, angle: f64, center: Point)
                        -> std::result::Result<(), JsValue>;
                    fn set_view_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue>;
                    fn view_matrix(&self) -> std::result::Result<Matrix, JsValue>;
                    fn set_previous_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue>;
                    fn previous_sibling(&self) -> std::result::Result<Item, JsValue>;
                    fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue>;
                    fn data(&self) -> std::result::Result<JsValue, JsValue>;
                    fn off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<JsValue, JsValue>;
                    fn off_FnJsValueToJsValue(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    fn set_stroke_scaling(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue>;
                    fn stroke_scaling(&self) -> std::result::Result<bool, JsValue>;
                    fn insert_child(
                        &self,
                        index: f64,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue>;
                    fn skew_FnPointAndPointTo(
                        &self,
                        skew: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn skew_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<JsValue, JsValue>;
                    fn on_FnJsValueToJsValue(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue>;
                    fn remove(&self) -> std::result::Result<bool, JsValue>;
                    fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue>;
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue>;
                    fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue>;
                    fn import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                        &self,
                        svg: ItemImportSvgParamsSvg,
                        options: JsValue,
                    ) -> std::result::Result<Item, JsValue>;
                    fn import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem(
                        &self,
                        svg: ItemImportSvgParamsSvg,
                        on_load: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue>;
                    fn set_dash_array(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue>;
                    fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue>;
                    fn shear_FnPointAndPointTo(
                        &self,
                        shear: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn shear_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue>;
                    fn set_internal_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue>;
                    fn internal_bounds(&self) -> std::result::Result<Rectangle, JsValue>;
                    fn set_stroke_cap(&mut self, value: String)
                        -> std::result::Result<(), JsValue>;
                    fn stroke_cap(&self) -> std::result::Result<String, JsValue>;
                    fn set_on_mouse_enter(
                        &mut self,
                        value: ItemOnMouseEnter,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_enter(&self) -> std::result::Result<ItemOnMouseEnter, JsValue>;
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue>;
                    fn view(&self) -> std::result::Result<View, JsValue>;
                    fn set_stroke_join(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                    fn stroke_join(&self) -> std::result::Result<String, JsValue>;
                    fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue>;
                    fn set_fill_rule(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn fill_rule(&self) -> std::result::Result<String, JsValue>;
                    fn fit_bounds(
                        &self,
                        rectangle: Rectangle,
                        fill: bool,
                    ) -> std::result::Result<(), JsValue>;
                    fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue>;
                    fn set_handle_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue>;
                    fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue>;
                    fn set_next_sibling(&mut self, value: Item)
                        -> std::result::Result<(), JsValue>;
                    fn next_sibling(&self) -> std::result::Result<Item, JsValue>;
                    fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue>;
                    fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue>;
                    fn remove_on_down(&self) -> std::result::Result<(), JsValue>;
                    fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue>;
                    fn remove_on_move(&self) -> std::result::Result<(), JsValue>;
                    fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue>;
                    fn rasterize(&self, options: JsValue) -> std::result::Result<Raster, JsValue>;
                    fn set_shadow_color(
                        &mut self,
                        value: ItemShadowColor,
                    ) -> std::result::Result<(), JsValue>;
                    fn shadow_color(&self) -> std::result::Result<ItemShadowColor, JsValue>;
                    fn set_miter_limit(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn miter_limit(&self) -> std::result::Result<f64, JsValue>;
                    fn get_item(
                        &self,
                        options: ItemGetItemParamsOptions,
                    ) -> std::result::Result<Item, JsValue>;
                    fn import_json(&self, json: String) -> std::result::Result<Item, JsValue>;
                    fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue>;
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ItemOnMouseDrag,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_drag(&self) -> std::result::Result<ItemOnMouseDrag, JsValue>;
                    fn is_inserted(&self) -> std::result::Result<bool, JsValue>;
                    fn set_apply_matrix(&mut self, value: bool)
                        -> std::result::Result<(), JsValue>;
                    fn apply_matrix(&self) -> std::result::Result<bool, JsValue>;
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue>;
                    fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue>;
                    fn visible(&self) -> std::result::Result<bool, JsValue>;
                    fn set_stroke_color(
                        &mut self,
                        value: ItemStrokeColor,
                    ) -> std::result::Result<(), JsValue>;
                    fn stroke_color(&self) -> std::result::Result<ItemStrokeColor, JsValue>;
                    fn set_on_mouse_leave(
                        &mut self,
                        value: ItemOnMouseLeave,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_mouse_leave(&self) -> std::result::Result<ItemOnMouseLeave, JsValue>;
                    fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue>;
                    fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue>;
                    fn get_items(
                        &self,
                        options: ItemGetItemsParamsOptions,
                    ) -> std::result::Result<Vec<Item>, JsValue>;
                    fn has_children(&self) -> std::result::Result<bool, JsValue>;
                    fn translate(&self, delta: Point) -> std::result::Result<(), JsValue>;
                    fn set_parent(&mut self, value: Item) -> std::result::Result<(), JsValue>;
                    fn parent(&self) -> std::result::Result<Item, JsValue>;
                    fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue>;
                    fn locked(&self) -> std::result::Result<bool, JsValue>;
                    fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue>;
                }
                impl Item_Trait for Item {
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::responds(target, type_)
                    }
                    fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::copy_content(target, source)
                    }
                    fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_opacity(target, value)
                    }
                    fn opacity(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Item::opacity(target)
                    }
                    fn set_on_frame(
                        &mut self,
                        value: ItemOnFrame,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_on_frame(target, value)
                    }
                    fn on_frame(&self) -> std::result::Result<ItemOnFrame, JsValue> {
                        let target = self;
                        Item::on_frame(target)
                    }
                    fn remove_children_FnToVecOfItem(
                        &self,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target = self;
                        Item::remove_children_FnToVecOfItem(target)
                    }
                    fn remove_children_FnF64AndF64ToVecOfItem(
                        &self,
                        start: f64,
                        end: f64,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target = self;
                        Item::remove_children_FnF64AndF64ToVecOfItem(target, start, end)
                    }
                    fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::is_below(target, item)
                    }
                    fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::has_stroke(target)
                    }
                    fn set_global_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_global_matrix(target, value)
                    }
                    fn global_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Item::global_matrix(target)
                    }
                    fn copy_attributes(
                        &self,
                        source: Item,
                        exclude_matrix: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::copy_attributes(target, source, exclude_matrix)
                    }
                    fn set_on_mouse_move(
                        &mut self,
                        value: ItemOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_on_mouse_move(target, value)
                    }
                    fn on_mouse_move(&self) -> std::result::Result<ItemOnMouseMove, JsValue> {
                        let target = self;
                        Item::on_mouse_move(target)
                    }
                    fn set_position(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_position(target, value)
                    }
                    fn position(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Item::position(target)
                    }
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_bounds(target, value)
                    }
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        Item::bounds(target)
                    }
                    fn set_shadow_blur(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_shadow_blur(target, value)
                    }
                    fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Item::shadow_blur(target)
                    }
                    fn set_selected_color(
                        &mut self,
                        value: ItemSelectedColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_selected_color(target, value)
                    }
                    fn selected_color(&self) -> std::result::Result<ItemSelectedColor, JsValue> {
                        let target = self;
                        Item::selected_color(target)
                    }
                    fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::reverse_children(target)
                    }
                    fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::bring_to_front(target)
                    }
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_selected(target, value)
                    }
                    fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::selected(target)
                    }
                    fn add_children(
                        &self,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target = self;
                        Item::add_children(target, items)
                    }
                    fn tween_to(
                        &self,
                        to: JsValue,
                        options: ItemTweenToParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target = self;
                        Item::tween_to(target, to, options)
                    }
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_project(target, value)
                    }
                    fn project(&self) -> std::result::Result<Project, JsValue> {
                        let target = self;
                        Item::project(target)
                    }
                    fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_name(target, value)
                    }
                    fn name(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Item::name(target)
                    }
                    fn set_stroke_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_stroke_bounds(target, value)
                    }
                    fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        Item::stroke_bounds(target)
                    }
                    fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Item::insert_below(target, item)
                    }
                    fn set_blend_mode(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_blend_mode(target, value)
                    }
                    fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Item::blend_mode(target)
                    }
                    fn set_clip_mask(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_clip_mask(target, value)
                    }
                    fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::clip_mask(target)
                    }
                    fn set_fill_color(
                        &mut self,
                        value: ItemFillColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_fill_color(target, value)
                    }
                    fn fill_color(&self) -> std::result::Result<ItemFillColor, JsValue> {
                        let target = self;
                        Item::fill_color(target)
                    }
                    fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::remove_on_drag(target)
                    }
                    fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Item::add_child(target, item)
                    }
                    fn scale_FnF64AndPointTo(
                        &self,
                        scale: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::scale_FnF64AndPointTo(target, scale, center)
                    }
                    fn scale_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::scale_FnF64AndF64AndPointTo(target, hor, ver, center)
                    }
                    fn set_first_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_first_child(target, value)
                    }
                    fn first_child(&self) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Item::first_child(target)
                    }
                    fn set_style(&mut self, value: Style) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_style(target, value)
                    }
                    fn style(&self) -> std::result::Result<Style, JsValue> {
                        let target = self;
                        Item::style(target)
                    }
                    fn set_class_name(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_class_name(target, value)
                    }
                    fn class_name(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Item::class_name(target)
                    }
                    fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::is_grouped_with(target, item)
                    }
                    fn set_shadow_offset(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_shadow_offset(target, value)
                    }
                    fn shadow_offset(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Item::shadow_offset(target)
                    }
                    fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::is_inside(target, rect)
                    }
                    fn set_children(
                        &mut self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_children(target, value)
                    }
                    fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                        let target = self;
                        Item::children(target)
                    }
                    fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::has_fill(target)
                    }
                    fn matches_FnItemMatchesParamsOptionsToBool(
                        &self,
                        options: ItemMatchesParamsOptions,
                    ) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::matches_FnItemMatchesParamsOptionsToBool(target, options)
                    }
                    fn matches_FnStringAndJsValueToBool(
                        &self,
                        name: String,
                        compare: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::matches_FnStringAndJsValueToBool(target, name, compare)
                    }
                    fn set_on_double_click(
                        &mut self,
                        value: ItemOnDoubleClick,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_on_double_click(target, value)
                    }
                    fn on_double_click(&self) -> std::result::Result<ItemOnDoubleClick, JsValue> {
                        let target = self;
                        Item::on_double_click(target)
                    }
                    fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::intersects(target, item)
                    }
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_rotation(target, value)
                    }
                    fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Item::rotation(target)
                    }
                    fn set_on_mouse_down(
                        &mut self,
                        value: ItemOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_on_mouse_down(target, value)
                    }
                    fn on_mouse_down(&self) -> std::result::Result<ItemOnMouseDown, JsValue> {
                        let target = self;
                        Item::on_mouse_down(target)
                    }
                    fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::is_sibling(target, item)
                    }
                    fn tween_from(
                        &self,
                        from: JsValue,
                        options: ItemTweenFromParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target = self;
                        Item::tween_from(target, from, options)
                    }
                    fn set_layer(&mut self, value: Layer) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_layer(target, value)
                    }
                    fn layer(&self) -> std::result::Result<Layer, JsValue> {
                        let target = self;
                        Item::layer(target)
                    }
                    fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::contains(target, point)
                    }
                    fn set_on_click(
                        &mut self,
                        value: ItemOnClick,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_on_click(target, value)
                    }
                    fn on_click(&self) -> std::result::Result<ItemOnClick, JsValue> {
                        let target = self;
                        Item::on_click(target)
                    }
                    fn set_last_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_last_child(target, value)
                    }
                    fn last_child(&self) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Item::last_child(target)
                    }
                    fn set_dash_offset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_dash_offset(target, value)
                    }
                    fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Item::dash_offset(target)
                    }
                    fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_id(target, value)
                    }
                    fn id(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Item::id(target)
                    }
                    fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::has_shadow(target)
                    }
                    fn tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                        &self,
                        from: JsValue,
                        to: JsValue,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target = self;
                        Item::tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                            target, from, to, options,
                        )
                    }
                    fn tween_FnJsValueAndItemTweenParamsOptionsToTween(
                        &self,
                        to: JsValue,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target = self;
                        Item::tween_FnJsValueAndItemTweenParamsOptionsToTween(target, to, options)
                    }
                    fn tween_FnItemTweenParamsOptionsToTween(
                        &self,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target = self;
                        Item::tween_FnItemTweenParamsOptionsToTween(target, options)
                    }
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_scaling(target, value)
                    }
                    fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Item::scaling(target)
                    }
                    fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::send_to_back(target)
                    }
                    fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target = self;
                        Item::set(target, props)
                    }
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_index(target, value)
                    }
                    fn index(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Item::index(target)
                    }
                    fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Item::reduce(target, options)
                    }
                    fn set_pivot(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_pivot(target, value)
                    }
                    fn pivot(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Item::pivot(target)
                    }
                    fn insert_children(
                        &self,
                        index: f64,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target = self;
                        Item::insert_children(target, index, items)
                    }
                    fn set_on_mouse_up(
                        &mut self,
                        value: ItemOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_on_mouse_up(target, value)
                    }
                    fn on_mouse_up(&self) -> std::result::Result<ItemOnMouseUp, JsValue> {
                        let target = self;
                        Item::on_mouse_up(target)
                    }
                    fn set_stroke_width(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_stroke_width(target, value)
                    }
                    fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Item::stroke_width(target)
                    }
                    fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::remove_on(target, options)
                    }
                    fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::remove_on_up(target)
                    }
                    fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::is_child(target, item)
                    }
                    fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::replace_with(target, item)
                    }
                    fn export_json(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Item::export_json(target, options)
                    }
                    fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue> {
                        let target = self;
                        Item::hit_test_all(target, point, options)
                    }
                    fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                        let target = self;
                        Item::export_svg(target, options)
                    }
                    fn copy_to(
                        &self,
                        owner: ItemCopyToParamsOwner,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target = self;
                        Item::copy_to(target, owner)
                    }
                    fn set_matrix(&mut self, value: Matrix) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_matrix(target, value)
                    }
                    fn matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Item::matrix(target)
                    }
                    fn add_to(
                        &self,
                        owner: ItemAddToParamsOwner,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target = self;
                        Item::add_to(target, owner)
                    }
                    fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::rotate(target, angle, center)
                    }
                    fn set_view_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_view_matrix(target, value)
                    }
                    fn view_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target = self;
                        Item::view_matrix(target)
                    }
                    fn set_previous_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_previous_sibling(target, value)
                    }
                    fn previous_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Item::previous_sibling(target)
                    }
                    fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_data(target, value)
                    }
                    fn data(&self) -> std::result::Result<JsValue, JsValue> {
                        let target = self;
                        Item::data(target)
                    }
                    fn off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target = self;
                        Item :: off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (target , type_ , callback)
                    }
                    fn off_FnJsValueToJsValue(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target = self;
                        Item::off_FnJsValueToJsValue(target, object)
                    }
                    fn set_stroke_scaling(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_stroke_scaling(target, value)
                    }
                    fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::stroke_scaling(target)
                    }
                    fn insert_child(
                        &self,
                        index: f64,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Item::insert_child(target, index, item)
                    }
                    fn skew_FnPointAndPointTo(
                        &self,
                        skew: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::skew_FnPointAndPointTo(target, skew, center)
                    }
                    fn skew_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::skew_FnF64AndF64AndPointTo(target, hor, ver, center)
                    }
                    fn on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target = self;
                        Item :: on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (target , type_ , callback)
                    }
                    fn on_FnJsValueToJsValue(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target = self;
                        Item::on_FnJsValueToJsValue(target, object)
                    }
                    fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::remove(target)
                    }
                    fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Item::global_to_local(target, point)
                    }
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::emit(target, type_, event)
                    }
                    fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue> {
                        let target = self;
                        Item::hit_test(target, point, options)
                    }
                    fn import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                        &self,
                        svg: ItemImportSvgParamsSvg,
                        options: JsValue,
                    ) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Item::import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                            target, svg, options,
                        )
                    }
                    fn import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem(
                        &self,
                        svg: ItemImportSvgParamsSvg,
                        on_load: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Item :: import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem (target , svg , on_load)
                    }
                    fn set_dash_array(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_dash_array(target, value)
                    }
                    fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let target = self;
                        Item::dash_array(target)
                    }
                    fn shear_FnPointAndPointTo(
                        &self,
                        shear: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::shear_FnPointAndPointTo(target, shear, center)
                    }
                    fn shear_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::shear_FnF64AndF64AndPointTo(target, hor, ver, center)
                    }
                    fn set_internal_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_internal_bounds(target, value)
                    }
                    fn internal_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        Item::internal_bounds(target)
                    }
                    fn set_stroke_cap(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_stroke_cap(target, value)
                    }
                    fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Item::stroke_cap(target)
                    }
                    fn set_on_mouse_enter(
                        &mut self,
                        value: ItemOnMouseEnter,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_on_mouse_enter(target, value)
                    }
                    fn on_mouse_enter(&self) -> std::result::Result<ItemOnMouseEnter, JsValue> {
                        let target = self;
                        Item::on_mouse_enter(target)
                    }
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_view(target, value)
                    }
                    fn view(&self) -> std::result::Result<View, JsValue> {
                        let target = self;
                        Item::view(target)
                    }
                    fn set_stroke_join(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_stroke_join(target, value)
                    }
                    fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Item::stroke_join(target)
                    }
                    fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::is_ancestor(target, item)
                    }
                    fn set_fill_rule(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_fill_rule(target, value)
                    }
                    fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Item::fill_rule(target)
                    }
                    fn fit_bounds(
                        &self,
                        rectangle: Rectangle,
                        fill: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::fit_bounds(target, rectangle, fill)
                    }
                    fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Item::local_to_parent(target, point)
                    }
                    fn set_handle_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_handle_bounds(target, value)
                    }
                    fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target = self;
                        Item::handle_bounds(target)
                    }
                    fn set_next_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_next_sibling(target, value)
                    }
                    fn next_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Item::next_sibling(target)
                    }
                    fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target = self;
                        Item::clone(target, options)
                    }
                    fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::is_descendant(target, item)
                    }
                    fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::remove_on_down(target)
                    }
                    fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::is_parent(target, item)
                    }
                    fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::remove_on_move(target)
                    }
                    fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::is_empty(target, recursively)
                    }
                    fn rasterize(&self, options: JsValue) -> std::result::Result<Raster, JsValue> {
                        let target = self;
                        Item::rasterize(target, options)
                    }
                    fn set_shadow_color(
                        &mut self,
                        value: ItemShadowColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_shadow_color(target, value)
                    }
                    fn shadow_color(&self) -> std::result::Result<ItemShadowColor, JsValue> {
                        let target = self;
                        Item::shadow_color(target)
                    }
                    fn set_miter_limit(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_miter_limit(target, value)
                    }
                    fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        Item::miter_limit(target)
                    }
                    fn get_item(
                        &self,
                        options: ItemGetItemParamsOptions,
                    ) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Item::get_item(target, options)
                    }
                    fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Item::import_json(target, json)
                    }
                    fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Item::insert_above(target, item)
                    }
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ItemOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_on_mouse_drag(target, value)
                    }
                    fn on_mouse_drag(&self) -> std::result::Result<ItemOnMouseDrag, JsValue> {
                        let target = self;
                        Item::on_mouse_drag(target)
                    }
                    fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::is_inserted(target)
                    }
                    fn set_apply_matrix(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_apply_matrix(target, value)
                    }
                    fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::apply_matrix(target)
                    }
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::transform(target, matrix)
                    }
                    fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_visible(target, value)
                    }
                    fn visible(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::visible(target)
                    }
                    fn set_stroke_color(
                        &mut self,
                        value: ItemStrokeColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_stroke_color(target, value)
                    }
                    fn stroke_color(&self) -> std::result::Result<ItemStrokeColor, JsValue> {
                        let target = self;
                        Item::stroke_color(target)
                    }
                    fn set_on_mouse_leave(
                        &mut self,
                        value: ItemOnMouseLeave,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_on_mouse_leave(target, value)
                    }
                    fn on_mouse_leave(&self) -> std::result::Result<ItemOnMouseLeave, JsValue> {
                        let target = self;
                        Item::on_mouse_leave(target)
                    }
                    fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Item::parent_to_local(target, point)
                    }
                    fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::is_above(target, item)
                    }
                    fn get_items(
                        &self,
                        options: ItemGetItemsParamsOptions,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target = self;
                        Item::get_items(target, options)
                    }
                    fn has_children(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::has_children(target)
                    }
                    fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::translate(target, delta)
                    }
                    fn set_parent(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_parent(target, value)
                    }
                    fn parent(&self) -> std::result::Result<Item, JsValue> {
                        let target = self;
                        Item::parent(target)
                    }
                    fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Item::set_locked(target, value)
                    }
                    fn locked(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        Item::locked(target)
                    }
                    fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        Item::local_to_global(target, point)
                    }
                }
                impl std::clone::Clone for Item_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Item_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Item_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ProjectImportSvgParamsSvg {
                    String(String),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    WebSysSvgElement(web_sys::SvgElement),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ColorDivideParamsNumber {
                    Color(Color),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum MatrixScaleReturn {
                    Matrix(Matrix),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PathItemCreateReturn {
                    Path(Path),
                    CompoundPath(CompoundPath),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum StyleSelectedColor {
                    Color(Color),
                    TsBindgenRtNull,
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum StyleFontSize {
                    String(String),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewScaleParamsCenter {
                    Point(Point),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum RasterSource {
                    String(String),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    WebSysHtmlCanvasElement(web_sys::HtmlCanvasElement),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    WebSysHtmlImageElement(web_sys::HtmlImageElement),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemImportSvgParamsOptions {
                    #[serde(
                        serialize_with = "ItemImportSvgParamsOptions::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ItemImportSvgParamsOptions::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    JsValue(JsValue),
                }
                impl ItemImportSvgParamsOptions {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ProjectImportSvgReturn {
                    Item(Item),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemSelectedColor {
                    Color(Color),
                    TsBindgenRtNull,
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewOnMouseEnter {
                    TsBindgenRtNull,
                    #[serde(
                        serialize_with = "ViewOnMouseEnter::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ViewOnMouseEnter::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                }
                impl ViewOnMouseEnter {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum MatrixTranslateReturn {
                    Matrix(Matrix),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ToolOnKeyDown {
                    TsBindgenRtNull,
                    #[serde(
                        serialize_with = "ToolOnKeyDown::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ToolOnKeyDown::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                }
                impl ToolOnKeyDown {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewOnParamsType {
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    JsValue(JsValue),
                    String(String),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum RasterGetPixelParamsX {
                    Point(Point),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemOnMouseLeave {
                    TsBindgenRtNull,
                    #[serde(
                        serialize_with = "ItemOnMouseLeave::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ItemOnMouseLeave::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                }
                impl ItemOnMouseLeave {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum PointModuloReturn {
                    Point(Point),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum MatrixTranslateParamsPoint {
                    Point(Point),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ShapeRadius {
                    Size(Size),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum StyleFillColor {
                    Color(Color),
                    TsBindgenRtNull,
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewShearParamsShear {
                    Point(Point),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum RasterConstructorSource {
                    String(String),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    WebSysHtmlCanvasElement(web_sys::HtmlCanvasElement),
                    #[serde(
                        serialize_with = "ts_bindgen_rt::serialize_jsvalue",
                        deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
                    )]
                    WebSysHtmlImageElement(web_sys::HtmlImageElement),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum MatrixShearParamsShear {
                    Point(Point),
                    F64(f64),
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    # [wasm_bindgen (js_name = "Shape" , extends = Item_Class)]
                    pub type Shape_Class;
                    # [wasm_bindgen (method , structural , catch , getter = radius , js_class = "Shape")]
                    fn __TSB_radius(this: &Shape_Class) -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = radius , js_class = "Shape")]
                    fn __TSB_set_radius(
                        this: &Shape_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = toPath , method , js_class = "Shape" , catch)]
                    fn __TSB_to_path_FnBoolToPath(
                        this: &Shape_Class,
                        insert: bool,
                    ) -> std::result::Result<Path, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = size , js_class = "Shape")]
                    fn size(this: &Shape_Class) -> std::result::Result<Size, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = size , js_class = "Shape")]
                    fn set_size(
                        this: &Shape_Class,
                        value: Size,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = type , js_class = "Shape")]
                    fn type_(this: &Shape_Class) -> std::result::Result<String, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = type , js_class = "Shape")]
                    fn set_type_(
                        this: &Shape_Class,
                        value: String,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Shape(pub Shape_Class);
                impl std::convert::From<&Shape> for Item {
                    fn from(src: &Shape) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl std::convert::From<&mut Shape> for Item {
                    fn from(src: &mut Shape) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl std::convert::From<Shape> for JsValue {
                    fn from(src: Shape) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for Shape {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for Shape {
                    fn instanceof(val: &JsValue) -> bool {
                        Shape_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        Shape(Shape_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(Shape_Class::unchecked_from_js_ref(val) as *const Shape_Class
                                as *const Self)
                        }
                    }
                }
                impl Shape {
                    #[allow(dead_code, non_snake_case)]
                    pub fn radius(&self) -> std::result::Result<ShapeRadius, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_radius()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_radius(
                        &self,
                        value: ShapeRadius,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_radius(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn to_path(&self, insert: bool) -> std::result::Result<Path, JsValue> {
                        let result = self.0.__TSB_to_path_FnBoolToPath(insert);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn size(&self) -> std::result::Result<Size, JsValue> {
                        let result = self.0.size();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_size(&self, value: Size) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_size(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn type_(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.type_();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_type_(&self, value: String) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_type_(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Shape {
                    fn describe() {
                        <Shape_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Shape {
                    type Abi = <Shape_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Shape {
                    type Abi = <Shape_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Shape(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Shape {
                    type Abi = <&'a Shape_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Shape {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Shape {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Shape_Class =
                            <Shape_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait Shape_Trait: Item_Trait {
                    fn set_radius(
                        &mut self,
                        value: ShapeRadius,
                    ) -> std::result::Result<(), JsValue>;
                    fn radius(&self) -> std::result::Result<ShapeRadius, JsValue>;
                    fn to_path(&self, insert: bool) -> std::result::Result<Path, JsValue>;
                    fn set_size(&mut self, value: Size) -> std::result::Result<(), JsValue>;
                    fn size(&self) -> std::result::Result<Size, JsValue>;
                    fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue>;
                    fn type_(&self) -> std::result::Result<String, JsValue>;
                }
                impl Item_Trait for Shape {
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::responds(&target, type_)
                    }
                    fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_content(&target, source)
                    }
                    fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_opacity(&target, value)
                    }
                    fn opacity(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::opacity(&target)
                    }
                    fn set_on_frame(
                        &mut self,
                        value: ItemOnFrame,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_frame(&target, value)
                    }
                    fn on_frame(&self) -> std::result::Result<ItemOnFrame, JsValue> {
                        let target: Item = self.into();
                        Item::on_frame(&target)
                    }
                    fn remove_children_FnToVecOfItem(
                        &self,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::remove_children_FnToVecOfItem(&target)
                    }
                    fn remove_children_FnF64AndF64ToVecOfItem(
                        &self,
                        start: f64,
                        end: f64,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::remove_children_FnF64AndF64ToVecOfItem(&target, start, end)
                    }
                    fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_below(&target, item)
                    }
                    fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_stroke(&target)
                    }
                    fn set_global_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_global_matrix(&target, value)
                    }
                    fn global_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::global_matrix(&target)
                    }
                    fn copy_attributes(
                        &self,
                        source: Item,
                        exclude_matrix: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_attributes(&target, source, exclude_matrix)
                    }
                    fn set_on_mouse_move(
                        &mut self,
                        value: ItemOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_move(&target, value)
                    }
                    fn on_mouse_move(&self) -> std::result::Result<ItemOnMouseMove, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_move(&target)
                    }
                    fn set_position(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_position(&target, value)
                    }
                    fn position(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::position(&target)
                    }
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_bounds(&target, value)
                    }
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::bounds(&target)
                    }
                    fn set_shadow_blur(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_shadow_blur(&target, value)
                    }
                    fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_blur(&target)
                    }
                    fn set_selected_color(
                        &mut self,
                        value: ItemSelectedColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_selected_color(&target, value)
                    }
                    fn selected_color(&self) -> std::result::Result<ItemSelectedColor, JsValue> {
                        let target: Item = self.into();
                        Item::selected_color(&target)
                    }
                    fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::reverse_children(&target)
                    }
                    fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::bring_to_front(&target)
                    }
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_selected(&target, value)
                    }
                    fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::selected(&target)
                    }
                    fn add_children(
                        &self,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::add_children(&target, items)
                    }
                    fn tween_to(
                        &self,
                        to: JsValue,
                        options: ItemTweenToParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_to(&target, to, options)
                    }
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_project(&target, value)
                    }
                    fn project(&self) -> std::result::Result<Project, JsValue> {
                        let target: Item = self.into();
                        Item::project(&target)
                    }
                    fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_name(&target, value)
                    }
                    fn name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::name(&target)
                    }
                    fn set_stroke_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_bounds(&target, value)
                    }
                    fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_bounds(&target)
                    }
                    fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_below(&target, item)
                    }
                    fn set_blend_mode(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_blend_mode(&target, value)
                    }
                    fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::blend_mode(&target)
                    }
                    fn set_clip_mask(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_clip_mask(&target, value)
                    }
                    fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::clip_mask(&target)
                    }
                    fn set_fill_color(
                        &mut self,
                        value: ItemFillColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_fill_color(&target, value)
                    }
                    fn fill_color(&self) -> std::result::Result<ItemFillColor, JsValue> {
                        let target: Item = self.into();
                        Item::fill_color(&target)
                    }
                    fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_drag(&target)
                    }
                    fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::add_child(&target, item)
                    }
                    fn scale_FnF64AndPointTo(
                        &self,
                        scale: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::scale_FnF64AndPointTo(&target, scale, center)
                    }
                    fn scale_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::scale_FnF64AndF64AndPointTo(&target, hor, ver, center)
                    }
                    fn set_first_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_first_child(&target, value)
                    }
                    fn first_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::first_child(&target)
                    }
                    fn set_style(&mut self, value: Style) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_style(&target, value)
                    }
                    fn style(&self) -> std::result::Result<Style, JsValue> {
                        let target: Item = self.into();
                        Item::style(&target)
                    }
                    fn set_class_name(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_class_name(&target, value)
                    }
                    fn class_name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::class_name(&target)
                    }
                    fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_grouped_with(&target, item)
                    }
                    fn set_shadow_offset(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_shadow_offset(&target, value)
                    }
                    fn shadow_offset(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_offset(&target)
                    }
                    fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inside(&target, rect)
                    }
                    fn set_children(
                        &mut self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_children(&target, value)
                    }
                    fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::children(&target)
                    }
                    fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_fill(&target)
                    }
                    fn matches_FnItemMatchesParamsOptionsToBool(
                        &self,
                        options: ItemMatchesParamsOptions,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::matches_FnItemMatchesParamsOptionsToBool(&target, options)
                    }
                    fn matches_FnStringAndJsValueToBool(
                        &self,
                        name: String,
                        compare: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::matches_FnStringAndJsValueToBool(&target, name, compare)
                    }
                    fn set_on_double_click(
                        &mut self,
                        value: ItemOnDoubleClick,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_double_click(&target, value)
                    }
                    fn on_double_click(&self) -> std::result::Result<ItemOnDoubleClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_double_click(&target)
                    }
                    fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::intersects(&target, item)
                    }
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_rotation(&target, value)
                    }
                    fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::rotation(&target)
                    }
                    fn set_on_mouse_down(
                        &mut self,
                        value: ItemOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_down(&target, value)
                    }
                    fn on_mouse_down(&self) -> std::result::Result<ItemOnMouseDown, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_down(&target)
                    }
                    fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_sibling(&target, item)
                    }
                    fn tween_from(
                        &self,
                        from: JsValue,
                        options: ItemTweenFromParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_from(&target, from, options)
                    }
                    fn set_layer(&mut self, value: Layer) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_layer(&target, value)
                    }
                    fn layer(&self) -> std::result::Result<Layer, JsValue> {
                        let target: Item = self.into();
                        Item::layer(&target)
                    }
                    fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::contains(&target, point)
                    }
                    fn set_on_click(
                        &mut self,
                        value: ItemOnClick,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_click(&target, value)
                    }
                    fn on_click(&self) -> std::result::Result<ItemOnClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_click(&target)
                    }
                    fn set_last_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_last_child(&target, value)
                    }
                    fn last_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::last_child(&target)
                    }
                    fn set_dash_offset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_dash_offset(&target, value)
                    }
                    fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::dash_offset(&target)
                    }
                    fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_id(&target, value)
                    }
                    fn id(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::id(&target)
                    }
                    fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_shadow(&target)
                    }
                    fn tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                        &self,
                        from: JsValue,
                        to: JsValue,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                            &target, from, to, options,
                        )
                    }
                    fn tween_FnJsValueAndItemTweenParamsOptionsToTween(
                        &self,
                        to: JsValue,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_FnJsValueAndItemTweenParamsOptionsToTween(&target, to, options)
                    }
                    fn tween_FnItemTweenParamsOptionsToTween(
                        &self,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_FnItemTweenParamsOptionsToTween(&target, options)
                    }
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_scaling(&target, value)
                    }
                    fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::scaling(&target)
                    }
                    fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::send_to_back(&target)
                    }
                    fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::set(&target, props)
                    }
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_index(&target, value)
                    }
                    fn index(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::index(&target)
                    }
                    fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::reduce(&target, options)
                    }
                    fn set_pivot(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_pivot(&target, value)
                    }
                    fn pivot(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::pivot(&target)
                    }
                    fn insert_children(
                        &self,
                        index: f64,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::insert_children(&target, index, items)
                    }
                    fn set_on_mouse_up(
                        &mut self,
                        value: ItemOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_up(&target, value)
                    }
                    fn on_mouse_up(&self) -> std::result::Result<ItemOnMouseUp, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_up(&target)
                    }
                    fn set_stroke_width(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_width(&target, value)
                    }
                    fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_width(&target)
                    }
                    fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on(&target, options)
                    }
                    fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_up(&target)
                    }
                    fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_child(&target, item)
                    }
                    fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::replace_with(&target, item)
                    }
                    fn export_json(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::export_json(&target, options)
                    }
                    fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test_all(&target, point, options)
                    }
                    fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                        let target: Item = self.into();
                        Item::export_svg(&target, options)
                    }
                    fn copy_to(
                        &self,
                        owner: ItemCopyToParamsOwner,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::copy_to(&target, owner)
                    }
                    fn set_matrix(&mut self, value: Matrix) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_matrix(&target, value)
                    }
                    fn matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::matrix(&target)
                    }
                    fn add_to(
                        &self,
                        owner: ItemAddToParamsOwner,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::add_to(&target, owner)
                    }
                    fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::rotate(&target, angle, center)
                    }
                    fn set_view_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_view_matrix(&target, value)
                    }
                    fn view_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::view_matrix(&target)
                    }
                    fn set_previous_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_previous_sibling(&target, value)
                    }
                    fn previous_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::previous_sibling(&target)
                    }
                    fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_data(&target, value)
                    }
                    fn data(&self) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::data(&target)
                    }
                    fn off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item :: off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                    }
                    fn off_FnJsValueToJsValue(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::off_FnJsValueToJsValue(&target, object)
                    }
                    fn set_stroke_scaling(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_scaling(&target, value)
                    }
                    fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_scaling(&target)
                    }
                    fn insert_child(
                        &self,
                        index: f64,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_child(&target, index, item)
                    }
                    fn skew_FnPointAndPointTo(
                        &self,
                        skew: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::skew_FnPointAndPointTo(&target, skew, center)
                    }
                    fn skew_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::skew_FnF64AndF64AndPointTo(&target, hor, ver, center)
                    }
                    fn on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item :: on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                    }
                    fn on_FnJsValueToJsValue(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::on_FnJsValueToJsValue(&target, object)
                    }
                    fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::remove(&target)
                    }
                    fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::global_to_local(&target, point)
                    }
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::emit(&target, type_, event)
                    }
                    fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test(&target, point, options)
                    }
                    fn import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                        &self,
                        svg: ItemImportSvgParamsSvg,
                        options: JsValue,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                            &target, svg, options,
                        )
                    }
                    fn import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem(
                        &self,
                        svg: ItemImportSvgParamsSvg,
                        on_load: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item :: import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem (& target , svg , on_load)
                    }
                    fn set_dash_array(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_dash_array(&target, value)
                    }
                    fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let target: Item = self.into();
                        Item::dash_array(&target)
                    }
                    fn shear_FnPointAndPointTo(
                        &self,
                        shear: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::shear_FnPointAndPointTo(&target, shear, center)
                    }
                    fn shear_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::shear_FnF64AndF64AndPointTo(&target, hor, ver, center)
                    }
                    fn set_internal_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_internal_bounds(&target, value)
                    }
                    fn internal_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::internal_bounds(&target)
                    }
                    fn set_stroke_cap(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_cap(&target, value)
                    }
                    fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_cap(&target)
                    }
                    fn set_on_mouse_enter(
                        &mut self,
                        value: ItemOnMouseEnter,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_enter(&target, value)
                    }
                    fn on_mouse_enter(&self) -> std::result::Result<ItemOnMouseEnter, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_enter(&target)
                    }
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_view(&target, value)
                    }
                    fn view(&self) -> std::result::Result<View, JsValue> {
                        let target: Item = self.into();
                        Item::view(&target)
                    }
                    fn set_stroke_join(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_join(&target, value)
                    }
                    fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_join(&target)
                    }
                    fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_ancestor(&target, item)
                    }
                    fn set_fill_rule(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_fill_rule(&target, value)
                    }
                    fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::fill_rule(&target)
                    }
                    fn fit_bounds(
                        &self,
                        rectangle: Rectangle,
                        fill: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::fit_bounds(&target, rectangle, fill)
                    }
                    fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_parent(&target, point)
                    }
                    fn set_handle_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_handle_bounds(&target, value)
                    }
                    fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::handle_bounds(&target)
                    }
                    fn set_next_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_next_sibling(&target, value)
                    }
                    fn next_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::next_sibling(&target)
                    }
                    fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::clone(&target, options)
                    }
                    fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_descendant(&target, item)
                    }
                    fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_down(&target)
                    }
                    fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_parent(&target, item)
                    }
                    fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_move(&target)
                    }
                    fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_empty(&target, recursively)
                    }
                    fn rasterize(&self, options: JsValue) -> std::result::Result<Raster, JsValue> {
                        let target: Item = self.into();
                        Item::rasterize(&target, options)
                    }
                    fn set_shadow_color(
                        &mut self,
                        value: ItemShadowColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_shadow_color(&target, value)
                    }
                    fn shadow_color(&self) -> std::result::Result<ItemShadowColor, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_color(&target)
                    }
                    fn set_miter_limit(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_miter_limit(&target, value)
                    }
                    fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::miter_limit(&target)
                    }
                    fn get_item(
                        &self,
                        options: ItemGetItemParamsOptions,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::get_item(&target, options)
                    }
                    fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_json(&target, json)
                    }
                    fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_above(&target, item)
                    }
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ItemOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_drag(&target, value)
                    }
                    fn on_mouse_drag(&self) -> std::result::Result<ItemOnMouseDrag, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_drag(&target)
                    }
                    fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inserted(&target)
                    }
                    fn set_apply_matrix(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_apply_matrix(&target, value)
                    }
                    fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::apply_matrix(&target)
                    }
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::transform(&target, matrix)
                    }
                    fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_visible(&target, value)
                    }
                    fn visible(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::visible(&target)
                    }
                    fn set_stroke_color(
                        &mut self,
                        value: ItemStrokeColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_color(&target, value)
                    }
                    fn stroke_color(&self) -> std::result::Result<ItemStrokeColor, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_color(&target)
                    }
                    fn set_on_mouse_leave(
                        &mut self,
                        value: ItemOnMouseLeave,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_leave(&target, value)
                    }
                    fn on_mouse_leave(&self) -> std::result::Result<ItemOnMouseLeave, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_leave(&target)
                    }
                    fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::parent_to_local(&target, point)
                    }
                    fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_above(&target, item)
                    }
                    fn get_items(
                        &self,
                        options: ItemGetItemsParamsOptions,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::get_items(&target, options)
                    }
                    fn has_children(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_children(&target)
                    }
                    fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::translate(&target, delta)
                    }
                    fn set_parent(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_parent(&target, value)
                    }
                    fn parent(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::parent(&target)
                    }
                    fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_locked(&target, value)
                    }
                    fn locked(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::locked(&target)
                    }
                    fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_global(&target, point)
                    }
                }
                impl Shape_Trait for Shape
                where
                    Shape: Item_Trait,
                {
                    fn set_radius(
                        &mut self,
                        value: ShapeRadius,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Shape::set_radius(target, value)
                    }
                    fn radius(&self) -> std::result::Result<ShapeRadius, JsValue> {
                        let target = self;
                        Shape::radius(target)
                    }
                    fn to_path(&self, insert: bool) -> std::result::Result<Path, JsValue> {
                        let target = self;
                        Shape::to_path(target, insert)
                    }
                    fn set_size(&mut self, value: Size) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Shape::set_size(target, value)
                    }
                    fn size(&self) -> std::result::Result<Size, JsValue> {
                        let target = self;
                        Shape::size(target)
                    }
                    fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Shape::set_type_(target, value)
                    }
                    fn type_(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        Shape::type_(target)
                    }
                }
                impl std::clone::Clone for Shape_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Shape_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Shape_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum SizeDivideParamsNumber {
                    Size(Size),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ItemOnClick {
                    TsBindgenRtNull,
                    #[serde(
                        serialize_with = "ItemOnClick::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ItemOnClick::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                }
                impl ItemOnClick {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum MatrixTransformReturn {
                    Point(Point),
                    VecOfF64(Vec<f64>),
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    # [wasm_bindgen (js_name = "SymbolItem" , extends = Item_Class)]
                    pub type SymbolItem_Class;
                    #[wasm_bindgen(constructor, js_class = "SymbolItem")]
                    pub fn new(definition: JsValue, point: Point) -> SymbolItem_Class;
                    # [wasm_bindgen (method , structural , catch , getter = definition , js_class = "SymbolItem")]
                    fn definition(
                        this: &SymbolItem_Class,
                    ) -> std::result::Result<SymbolDefinition, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = definition , js_class = "SymbolItem")]
                    fn set_definition(
                        this: &SymbolItem_Class,
                        value: SymbolDefinition,
                    ) -> std::result::Result<(), JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct SymbolItem(pub SymbolItem_Class);
                impl std::convert::From<&SymbolItem> for Item {
                    fn from(src: &SymbolItem) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl std::convert::From<&mut SymbolItem> for Item {
                    fn from(src: &mut SymbolItem) -> Item {
                        let src: &Item_Class = src.0.as_ref();
                        Item(src.clone())
                    }
                }
                impl std::convert::From<SymbolItem> for JsValue {
                    fn from(src: SymbolItem) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for SymbolItem {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for SymbolItem {
                    fn instanceof(val: &JsValue) -> bool {
                        SymbolItem_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        SymbolItem(SymbolItem_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(SymbolItem_Class::unchecked_from_js_ref(val)
                                as *const SymbolItem_Class
                                as *const Self)
                        }
                    }
                }
                impl SymbolItem {
                    #[allow(dead_code, non_snake_case)]
                    pub fn new(
                        definition: SymbolItemConstructorDefinition,
                        point: Point,
                    ) -> SymbolItem {
                        let result = SymbolItem_Class::new(
                            ts_bindgen_rt::to_jsvalue(&definition).unwrap(),
                            point,
                        );
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        SymbolItem(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn definition(&self) -> std::result::Result<SymbolDefinition, JsValue> {
                        let result = self.0.definition();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_definition(
                        &self,
                        value: SymbolDefinition,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_definition(value);
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for SymbolItem {
                    fn describe() {
                        <SymbolItem_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for SymbolItem {
                    type Abi = <SymbolItem_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for SymbolItem {
                    type Abi = <SymbolItem_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        SymbolItem(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a SymbolItem {
                    type Abi = <&'a SymbolItem_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for SymbolItem {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for SymbolItem {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: SymbolItem_Class =
                            <SymbolItem_Class as serde::de::Deserialize>::deserialize(
                                deserializer,
                            )?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait SymbolItem_Trait: Item_Trait {
                    fn set_definition(
                        &mut self,
                        value: SymbolDefinition,
                    ) -> std::result::Result<(), JsValue>;
                    fn definition(&self) -> std::result::Result<SymbolDefinition, JsValue>;
                }
                impl Item_Trait for SymbolItem {
                    fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::responds(&target, type_)
                    }
                    fn copy_content(&self, source: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_content(&target, source)
                    }
                    fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_opacity(&target, value)
                    }
                    fn opacity(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::opacity(&target)
                    }
                    fn set_on_frame(
                        &mut self,
                        value: ItemOnFrame,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_frame(&target, value)
                    }
                    fn on_frame(&self) -> std::result::Result<ItemOnFrame, JsValue> {
                        let target: Item = self.into();
                        Item::on_frame(&target)
                    }
                    fn remove_children_FnToVecOfItem(
                        &self,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::remove_children_FnToVecOfItem(&target)
                    }
                    fn remove_children_FnF64AndF64ToVecOfItem(
                        &self,
                        start: f64,
                        end: f64,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::remove_children_FnF64AndF64ToVecOfItem(&target, start, end)
                    }
                    fn is_below(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_below(&target, item)
                    }
                    fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_stroke(&target)
                    }
                    fn set_global_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_global_matrix(&target, value)
                    }
                    fn global_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::global_matrix(&target)
                    }
                    fn copy_attributes(
                        &self,
                        source: Item,
                        exclude_matrix: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::copy_attributes(&target, source, exclude_matrix)
                    }
                    fn set_on_mouse_move(
                        &mut self,
                        value: ItemOnMouseMove,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_move(&target, value)
                    }
                    fn on_mouse_move(&self) -> std::result::Result<ItemOnMouseMove, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_move(&target)
                    }
                    fn set_position(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_position(&target, value)
                    }
                    fn position(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::position(&target)
                    }
                    fn set_bounds(&mut self, value: Rectangle) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_bounds(&target, value)
                    }
                    fn bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::bounds(&target)
                    }
                    fn set_shadow_blur(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_shadow_blur(&target, value)
                    }
                    fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_blur(&target)
                    }
                    fn set_selected_color(
                        &mut self,
                        value: ItemSelectedColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_selected_color(&target, value)
                    }
                    fn selected_color(&self) -> std::result::Result<ItemSelectedColor, JsValue> {
                        let target: Item = self.into();
                        Item::selected_color(&target)
                    }
                    fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::reverse_children(&target)
                    }
                    fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::bring_to_front(&target)
                    }
                    fn set_selected(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_selected(&target, value)
                    }
                    fn selected(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::selected(&target)
                    }
                    fn add_children(
                        &self,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::add_children(&target, items)
                    }
                    fn tween_to(
                        &self,
                        to: JsValue,
                        options: ItemTweenToParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_to(&target, to, options)
                    }
                    fn set_project(&mut self, value: Project) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_project(&target, value)
                    }
                    fn project(&self) -> std::result::Result<Project, JsValue> {
                        let target: Item = self.into();
                        Item::project(&target)
                    }
                    fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_name(&target, value)
                    }
                    fn name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::name(&target)
                    }
                    fn set_stroke_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_bounds(&target, value)
                    }
                    fn stroke_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_bounds(&target)
                    }
                    fn insert_below(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_below(&target, item)
                    }
                    fn set_blend_mode(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_blend_mode(&target, value)
                    }
                    fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::blend_mode(&target)
                    }
                    fn set_clip_mask(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_clip_mask(&target, value)
                    }
                    fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::clip_mask(&target)
                    }
                    fn set_fill_color(
                        &mut self,
                        value: ItemFillColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_fill_color(&target, value)
                    }
                    fn fill_color(&self) -> std::result::Result<ItemFillColor, JsValue> {
                        let target: Item = self.into();
                        Item::fill_color(&target)
                    }
                    fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_drag(&target)
                    }
                    fn add_child(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::add_child(&target, item)
                    }
                    fn scale_FnF64AndPointTo(
                        &self,
                        scale: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::scale_FnF64AndPointTo(&target, scale, center)
                    }
                    fn scale_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::scale_FnF64AndF64AndPointTo(&target, hor, ver, center)
                    }
                    fn set_first_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_first_child(&target, value)
                    }
                    fn first_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::first_child(&target)
                    }
                    fn set_style(&mut self, value: Style) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_style(&target, value)
                    }
                    fn style(&self) -> std::result::Result<Style, JsValue> {
                        let target: Item = self.into();
                        Item::style(&target)
                    }
                    fn set_class_name(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_class_name(&target, value)
                    }
                    fn class_name(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::class_name(&target)
                    }
                    fn is_grouped_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_grouped_with(&target, item)
                    }
                    fn set_shadow_offset(
                        &mut self,
                        value: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_shadow_offset(&target, value)
                    }
                    fn shadow_offset(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_offset(&target)
                    }
                    fn is_inside(&self, rect: Rectangle) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inside(&target, rect)
                    }
                    fn set_children(
                        &mut self,
                        value: Vec<Item>,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_children(&target, value)
                    }
                    fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::children(&target)
                    }
                    fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_fill(&target)
                    }
                    fn matches_FnItemMatchesParamsOptionsToBool(
                        &self,
                        options: ItemMatchesParamsOptions,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::matches_FnItemMatchesParamsOptionsToBool(&target, options)
                    }
                    fn matches_FnStringAndJsValueToBool(
                        &self,
                        name: String,
                        compare: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::matches_FnStringAndJsValueToBool(&target, name, compare)
                    }
                    fn set_on_double_click(
                        &mut self,
                        value: ItemOnDoubleClick,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_double_click(&target, value)
                    }
                    fn on_double_click(&self) -> std::result::Result<ItemOnDoubleClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_double_click(&target)
                    }
                    fn intersects(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::intersects(&target, item)
                    }
                    fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_rotation(&target, value)
                    }
                    fn rotation(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::rotation(&target)
                    }
                    fn set_on_mouse_down(
                        &mut self,
                        value: ItemOnMouseDown,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_down(&target, value)
                    }
                    fn on_mouse_down(&self) -> std::result::Result<ItemOnMouseDown, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_down(&target)
                    }
                    fn is_sibling(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_sibling(&target, item)
                    }
                    fn tween_from(
                        &self,
                        from: JsValue,
                        options: ItemTweenFromParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_from(&target, from, options)
                    }
                    fn set_layer(&mut self, value: Layer) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_layer(&target, value)
                    }
                    fn layer(&self) -> std::result::Result<Layer, JsValue> {
                        let target: Item = self.into();
                        Item::layer(&target)
                    }
                    fn contains(&self, point: Point) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::contains(&target, point)
                    }
                    fn set_on_click(
                        &mut self,
                        value: ItemOnClick,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_click(&target, value)
                    }
                    fn on_click(&self) -> std::result::Result<ItemOnClick, JsValue> {
                        let target: Item = self.into();
                        Item::on_click(&target)
                    }
                    fn set_last_child(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_last_child(&target, value)
                    }
                    fn last_child(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::last_child(&target)
                    }
                    fn set_dash_offset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_dash_offset(&target, value)
                    }
                    fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::dash_offset(&target)
                    }
                    fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_id(&target, value)
                    }
                    fn id(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::id(&target)
                    }
                    fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_shadow(&target)
                    }
                    fn tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                        &self,
                        from: JsValue,
                        to: JsValue,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                            &target, from, to, options,
                        )
                    }
                    fn tween_FnJsValueAndItemTweenParamsOptionsToTween(
                        &self,
                        to: JsValue,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_FnJsValueAndItemTweenParamsOptionsToTween(&target, to, options)
                    }
                    fn tween_FnItemTweenParamsOptionsToTween(
                        &self,
                        options: ItemTweenParamsOptions,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target: Item = self.into();
                        Item::tween_FnItemTweenParamsOptionsToTween(&target, options)
                    }
                    fn set_scaling(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_scaling(&target, value)
                    }
                    fn scaling(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::scaling(&target)
                    }
                    fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::send_to_back(&target)
                    }
                    fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::set(&target, props)
                    }
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_index(&target, value)
                    }
                    fn index(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::index(&target)
                    }
                    fn reduce(&self, options: JsValue) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::reduce(&target, options)
                    }
                    fn set_pivot(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_pivot(&target, value)
                    }
                    fn pivot(&self) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::pivot(&target)
                    }
                    fn insert_children(
                        &self,
                        index: f64,
                        items: Vec<Item>,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::insert_children(&target, index, items)
                    }
                    fn set_on_mouse_up(
                        &mut self,
                        value: ItemOnMouseUp,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_up(&target, value)
                    }
                    fn on_mouse_up(&self) -> std::result::Result<ItemOnMouseUp, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_up(&target)
                    }
                    fn set_stroke_width(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_width(&target, value)
                    }
                    fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_width(&target)
                    }
                    fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on(&target, options)
                    }
                    fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_up(&target)
                    }
                    fn is_child(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_child(&target, item)
                    }
                    fn replace_with(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::replace_with(&target, item)
                    }
                    fn export_json(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::export_json(&target, options)
                    }
                    fn hit_test_all(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<Vec<HitResult>, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test_all(&target, point, options)
                    }
                    fn export_svg(
                        &self,
                        options: JsValue,
                    ) -> std::result::Result<ItemExportSvgReturn, JsValue> {
                        let target: Item = self.into();
                        Item::export_svg(&target, options)
                    }
                    fn copy_to(
                        &self,
                        owner: ItemCopyToParamsOwner,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::copy_to(&target, owner)
                    }
                    fn set_matrix(&mut self, value: Matrix) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_matrix(&target, value)
                    }
                    fn matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::matrix(&target)
                    }
                    fn add_to(
                        &self,
                        owner: ItemAddToParamsOwner,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::add_to(&target, owner)
                    }
                    fn rotate(
                        &self,
                        angle: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::rotate(&target, angle, center)
                    }
                    fn set_view_matrix(
                        &mut self,
                        value: Matrix,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_view_matrix(&target, value)
                    }
                    fn view_matrix(&self) -> std::result::Result<Matrix, JsValue> {
                        let target: Item = self.into();
                        Item::view_matrix(&target)
                    }
                    fn set_previous_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_previous_sibling(&target, value)
                    }
                    fn previous_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::previous_sibling(&target)
                    }
                    fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_data(&target, value)
                    }
                    fn data(&self) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::data(&target)
                    }
                    fn off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item :: off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                    }
                    fn off_FnJsValueToJsValue(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::off_FnJsValueToJsValue(&target, object)
                    }
                    fn set_stroke_scaling(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_scaling(&target, value)
                    }
                    fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_scaling(&target)
                    }
                    fn insert_child(
                        &self,
                        index: f64,
                        item: Item,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_child(&target, index, item)
                    }
                    fn skew_FnPointAndPointTo(
                        &self,
                        skew: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::skew_FnPointAndPointTo(&target, skew, center)
                    }
                    fn skew_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::skew_FnF64AndF64AndPointTo(&target, hor, ver, center)
                    }
                    fn on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                        &self,
                        type_: String,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item :: on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                    }
                    fn on_FnJsValueToJsValue(
                        &self,
                        object: JsValue,
                    ) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::on_FnJsValueToJsValue(&target, object)
                    }
                    fn remove(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::remove(&target)
                    }
                    fn global_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::global_to_local(&target, point)
                    }
                    fn emit(
                        &self,
                        type_: String,
                        event: JsValue,
                    ) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::emit(&target, type_, event)
                    }
                    fn hit_test(
                        &self,
                        point: Point,
                        options: JsValue,
                    ) -> std::result::Result<HitResult, JsValue> {
                        let target: Item = self.into();
                        Item::hit_test(&target, point, options)
                    }
                    fn import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                        &self,
                        svg: ItemImportSvgParamsSvg,
                        options: JsValue,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                            &target, svg, options,
                        )
                    }
                    fn import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem(
                        &self,
                        svg: ItemImportSvgParamsSvg,
                        on_load: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item :: import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem (& target , svg , on_load)
                    }
                    fn set_dash_array(
                        &mut self,
                        value: Vec<f64>,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_dash_array(&target, value)
                    }
                    fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                        let target: Item = self.into();
                        Item::dash_array(&target)
                    }
                    fn shear_FnPointAndPointTo(
                        &self,
                        shear: Point,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::shear_FnPointAndPointTo(&target, shear, center)
                    }
                    fn shear_FnF64AndF64AndPointTo(
                        &self,
                        hor: f64,
                        ver: f64,
                        center: Point,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::shear_FnF64AndF64AndPointTo(&target, hor, ver, center)
                    }
                    fn set_internal_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_internal_bounds(&target, value)
                    }
                    fn internal_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::internal_bounds(&target)
                    }
                    fn set_stroke_cap(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_cap(&target, value)
                    }
                    fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_cap(&target)
                    }
                    fn set_on_mouse_enter(
                        &mut self,
                        value: ItemOnMouseEnter,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_enter(&target, value)
                    }
                    fn on_mouse_enter(&self) -> std::result::Result<ItemOnMouseEnter, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_enter(&target)
                    }
                    fn set_view(&mut self, value: View) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_view(&target, value)
                    }
                    fn view(&self) -> std::result::Result<View, JsValue> {
                        let target: Item = self.into();
                        Item::view(&target)
                    }
                    fn set_stroke_join(
                        &mut self,
                        value: String,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_join(&target, value)
                    }
                    fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_join(&target)
                    }
                    fn is_ancestor(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_ancestor(&target, item)
                    }
                    fn set_fill_rule(&mut self, value: String) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_fill_rule(&target, value)
                    }
                    fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                        let target: Item = self.into();
                        Item::fill_rule(&target)
                    }
                    fn fit_bounds(
                        &self,
                        rectangle: Rectangle,
                        fill: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::fit_bounds(&target, rectangle, fill)
                    }
                    fn local_to_parent(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_parent(&target, point)
                    }
                    fn set_handle_bounds(
                        &mut self,
                        value: Rectangle,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_handle_bounds(&target, value)
                    }
                    fn handle_bounds(&self) -> std::result::Result<Rectangle, JsValue> {
                        let target: Item = self.into();
                        Item::handle_bounds(&target)
                    }
                    fn set_next_sibling(
                        &mut self,
                        value: Item,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_next_sibling(&target, value)
                    }
                    fn next_sibling(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::next_sibling(&target)
                    }
                    fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                        let target: Item = self.into();
                        Item::clone(&target, options)
                    }
                    fn is_descendant(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_descendant(&target, item)
                    }
                    fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_down(&target)
                    }
                    fn is_parent(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_parent(&target, item)
                    }
                    fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::remove_on_move(&target)
                    }
                    fn is_empty(&self, recursively: bool) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_empty(&target, recursively)
                    }
                    fn rasterize(&self, options: JsValue) -> std::result::Result<Raster, JsValue> {
                        let target: Item = self.into();
                        Item::rasterize(&target, options)
                    }
                    fn set_shadow_color(
                        &mut self,
                        value: ItemShadowColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_shadow_color(&target, value)
                    }
                    fn shadow_color(&self) -> std::result::Result<ItemShadowColor, JsValue> {
                        let target: Item = self.into();
                        Item::shadow_color(&target)
                    }
                    fn set_miter_limit(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_miter_limit(&target, value)
                    }
                    fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                        let target: Item = self.into();
                        Item::miter_limit(&target)
                    }
                    fn get_item(
                        &self,
                        options: ItemGetItemParamsOptions,
                    ) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::get_item(&target, options)
                    }
                    fn import_json(&self, json: String) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::import_json(&target, json)
                    }
                    fn insert_above(&self, item: Item) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::insert_above(&target, item)
                    }
                    fn set_on_mouse_drag(
                        &mut self,
                        value: ItemOnMouseDrag,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_drag(&target, value)
                    }
                    fn on_mouse_drag(&self) -> std::result::Result<ItemOnMouseDrag, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_drag(&target)
                    }
                    fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_inserted(&target)
                    }
                    fn set_apply_matrix(
                        &mut self,
                        value: bool,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_apply_matrix(&target, value)
                    }
                    fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::apply_matrix(&target)
                    }
                    fn transform(&self, matrix: Matrix) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::transform(&target, matrix)
                    }
                    fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_visible(&target, value)
                    }
                    fn visible(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::visible(&target)
                    }
                    fn set_stroke_color(
                        &mut self,
                        value: ItemStrokeColor,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_stroke_color(&target, value)
                    }
                    fn stroke_color(&self) -> std::result::Result<ItemStrokeColor, JsValue> {
                        let target: Item = self.into();
                        Item::stroke_color(&target)
                    }
                    fn set_on_mouse_leave(
                        &mut self,
                        value: ItemOnMouseLeave,
                    ) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_on_mouse_leave(&target, value)
                    }
                    fn on_mouse_leave(&self) -> std::result::Result<ItemOnMouseLeave, JsValue> {
                        let target: Item = self.into();
                        Item::on_mouse_leave(&target)
                    }
                    fn parent_to_local(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::parent_to_local(&target, point)
                    }
                    fn is_above(&self, item: Item) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::is_above(&target, item)
                    }
                    fn get_items(
                        &self,
                        options: ItemGetItemsParamsOptions,
                    ) -> std::result::Result<Vec<Item>, JsValue> {
                        let target: Item = self.into();
                        Item::get_items(&target, options)
                    }
                    fn has_children(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::has_children(&target)
                    }
                    fn translate(&self, delta: Point) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::translate(&target, delta)
                    }
                    fn set_parent(&mut self, value: Item) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_parent(&target, value)
                    }
                    fn parent(&self) -> std::result::Result<Item, JsValue> {
                        let target: Item = self.into();
                        Item::parent(&target)
                    }
                    fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                        let target: Item = self.into();
                        Item::set_locked(&target, value)
                    }
                    fn locked(&self) -> std::result::Result<bool, JsValue> {
                        let target: Item = self.into();
                        Item::locked(&target)
                    }
                    fn local_to_global(&self, point: Point) -> std::result::Result<Point, JsValue> {
                        let target: Item = self.into();
                        Item::local_to_global(&target, point)
                    }
                }
                impl SymbolItem_Trait for SymbolItem
                where
                    SymbolItem: Item_Trait,
                {
                    fn set_definition(
                        &mut self,
                        value: SymbolDefinition,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        SymbolItem::set_definition(target, value)
                    }
                    fn definition(&self) -> std::result::Result<SymbolDefinition, JsValue> {
                        let target = self;
                        SymbolItem::definition(target)
                    }
                }
                impl std::clone::Clone for SymbolItem_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for SymbolItem_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for SymbolItem_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum CurveGetPointAtParamsLocation {
                    CurveLocation(CurveLocation),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum RasterOnError {
                    TsBindgenRtNull,
                    #[serde(
                        serialize_with = "RasterOnError::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "RasterOnError::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                }
                impl RasterOnError {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ColorDivideReturn {
                    Color(Color),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewOffReturn {
                    View(View),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum CurveGetWeightedNormalAtParamsLocation {
                    CurveLocation(CurveLocation),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum ViewOnMouseDrag {
                    TsBindgenRtNull,
                    #[serde(
                        serialize_with = "ViewOnMouseDrag::__TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value",
                        deserialize_with = "ViewOnMouseDrag::__TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value"
                    )]
                    DynFnVecOfJsValueToStdResultResultOfJsValueAndJsValue(
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                    ),
                }
                impl ViewOnMouseDrag {
                    #[allow(non_snake_case)]
                    fn __TSB__serialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        S,
                    >(
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : & std :: rc :: Rc < dyn Fn (Vec < JsValue >) -> std :: result :: Result < JsValue , JsValue > >,
                        serializer: S,
                    ) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value =
                            dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                                .clone();
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let jsv = ts_bindgen_rt :: serialize_as_jsvalue (serializer , & dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value_closure . into_js_value ()) ;
                        jsv
                    }
                    #[allow(non_snake_case)]
                    fn __TSB__deserialize_dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value<
                        'de,
                        D,
                    >(
                        deserializer: D,
                    ) -> std::result::Result<
                        std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<JsValue, JsValue>>,
                        D::Error,
                    >
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
                        let dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value : Option < & js_sys :: Function > = wasm_bindgen :: JsCast :: dyn_ref (& jsv) ;
                        dyn_fn_vec_of_js_value_to_std_result_result_of_js_value_and_js_value
                            .map(|f| {
                                let f = f.clone();
                                std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                                    let arg0 = arg0
                                        .into_iter()
                                        .map(|arg0_item| JsValue::from(arg0_item))
                                        .collect::<Vec<_>>()
                                        .into_boxed_slice();
                                    let _Args = js_sys::Array::new();
                                    for arg0 in arg0.into_iter() {
                                        _Args.push(&arg0);
                                    }
                                    let ret = f.apply(&JsValue::null(), &_Args)?;
                                    Ok(ret)
                                })
                                    as std::rc::Rc<
                                        dyn Fn(
                                            Vec<JsValue>,
                                        )
                                            -> std::result::Result<JsValue, JsValue>,
                                    >
                            })
                            .ok_or_else(|| {
                                ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                                    "expected function".to_string(),
                                )
                            })
                            .map_err(serde::de::Error::custom)
                    }
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    #[wasm_bindgen(js_name = "Tween")]
                    pub type Tween_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = then , method , js_class = "Tween" , catch)]
                    fn __TSB_then_FnDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToTween(
                        this: &Tween_Class,
                        callback: &Closure<
                            dyn Fn(
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                                JsValue,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        >,
                    ) -> std::result::Result<Tween, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = onUpdate , js_class = "Tween")]
                    fn __TSB_on_update(this: &Tween_Class)
                        -> std::result::Result<JsValue, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = onUpdate , js_class = "Tween")]
                    fn __TSB_set_on_update(
                        this: &Tween_Class,
                        value: JsValue,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = start , method , js_class = "Tween" , catch)]
                    fn __TSB_start_FnToTween(
                        this: &Tween_Class,
                    ) -> std::result::Result<Tween, JsValue>;
                    #[wasm_bindgen(constructor, js_class = "Tween")]
                    pub fn new(
                        object: JsValue,
                        from: JsValue,
                        to: JsValue,
                        duration: f64,
                        easing: JsValue,
                        start: bool,
                    ) -> Tween_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = stop , method , js_class = "Tween" , catch)]
                    fn __TSB_stop_FnToTween(
                        this: &Tween_Class,
                    ) -> std::result::Result<Tween, JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct Tween(pub Tween_Class);
                impl std::convert::From<Tween> for JsValue {
                    fn from(src: Tween) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for Tween {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for Tween {
                    fn instanceof(val: &JsValue) -> bool {
                        Tween_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        Tween(Tween_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(Tween_Class::unchecked_from_js_ref(val) as *const Tween_Class
                                as *const Self)
                        }
                    }
                }
                impl Tween {
                    #[allow(dead_code, non_snake_case)]
                    pub fn then(
                        &self,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Tween, JsValue> {
                        # [allow (non_snake_case)] let __TSB_Local_callback = Closure :: wrap (Box :: new (move | _Variadic0_arg0 : JsValue , _Variadic1_arg0 : JsValue , _Variadic2_arg0 : JsValue , _Variadic3_arg0 : JsValue , _Variadic4_arg0 : JsValue , _Variadic5_arg0 : JsValue , _Variadic6_arg0 : JsValue | -> std :: result :: Result < JsValue , JsValue > { let arg0 = { let arg0 = js_sys :: Array :: new () ; arg0 . push (& _Variadic0_arg0) ; arg0 . push (& _Variadic1_arg0) ; arg0 . push (& _Variadic2_arg0) ; arg0 . push (& _Variadic3_arg0) ; arg0 . push (& _Variadic4_arg0) ; arg0 . push (& _Variadic5_arg0) ; arg0 . push (& _Variadic6_arg0) ; arg0 } ; let result = callback ({ let mut arg0_vec = vec ! [] ; for arg0_item in arg0 . iter () { arg0_vec . push (arg0_item) ; } arg0_vec }) ? ; Ok (result) }) as Box < dyn Fn (JsValue , JsValue , JsValue , JsValue , JsValue , JsValue , JsValue) -> std :: result :: Result < JsValue , JsValue > >) ;
                        let result = self . 0 . __TSB_then_FnDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToTween (& __TSB_Local_callback) ;
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn on_update(&self) -> std::result::Result<TweenOnUpdate, JsValue> {
                        let result = ts_bindgen_rt::from_jsvalue(&self.0.__TSB_on_update()?)
                            .map_err(ts_bindgen_rt::Error::from)
                            .map_err(JsValue::from);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_on_update(
                        &self,
                        value: TweenOnUpdate,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.__TSB_set_on_update(
                            ts_bindgen_rt::to_jsvalue(&value)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)?,
                        );
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn start(&self) -> std::result::Result<Tween, JsValue> {
                        let result = self.0.__TSB_start_FnToTween();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new(
                        object: JsValue,
                        from: JsValue,
                        to: JsValue,
                        duration: f64,
                        easing: TweenConstructorEasing,
                        start: bool,
                    ) -> Tween {
                        let result = Tween_Class::new(
                            object,
                            from,
                            to,
                            duration,
                            ts_bindgen_rt::to_jsvalue(&easing).unwrap(),
                            start,
                        );
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        Tween(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn stop(&self) -> std::result::Result<Tween, JsValue> {
                        let result = self.0.__TSB_stop_FnToTween();
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for Tween {
                    fn describe() {
                        <Tween_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for Tween {
                    type Abi = <Tween_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for Tween {
                    type Abi = <Tween_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        Tween(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Tween {
                    type Abi = <&'a Tween_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for Tween {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Tween {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: Tween_Class =
                            <Tween_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait Tween_Trait {
                    fn then(
                        &self,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Tween, JsValue>;
                    fn set_on_update(
                        &mut self,
                        value: TweenOnUpdate,
                    ) -> std::result::Result<(), JsValue>;
                    fn on_update(&self) -> std::result::Result<TweenOnUpdate, JsValue>;
                    fn start(&self) -> std::result::Result<Tween, JsValue>;
                    fn stop(&self) -> std::result::Result<Tween, JsValue>;
                }
                impl Tween_Trait for Tween {
                    fn then(
                        &self,
                        callback: &'static dyn Fn(
                            Vec<JsValue>,
                        )
                            -> std::result::Result<JsValue, JsValue>,
                    ) -> std::result::Result<Tween, JsValue> {
                        let target = self;
                        Tween::then(target, callback)
                    }
                    fn set_on_update(
                        &mut self,
                        value: TweenOnUpdate,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        Tween::set_on_update(target, value)
                    }
                    fn on_update(&self) -> std::result::Result<TweenOnUpdate, JsValue> {
                        let target = self;
                        Tween::on_update(target)
                    }
                    fn start(&self) -> std::result::Result<Tween, JsValue> {
                        let target = self;
                        Tween::start(target)
                    }
                    fn stop(&self) -> std::result::Result<Tween, JsValue> {
                        let target = self;
                        Tween::stop(target)
                    }
                }
                impl std::clone::Clone for Tween_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for Tween_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for Tween_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum MatrixShearParamsCenter {
                    Point(Point),
                    F64(f64),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum MatrixSkewReturn {
                    Matrix(Matrix),
                }
                #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
                #[serde(untagged)]
                pub enum CurveDivideAtParamsLocation {
                    CurveLocation(CurveLocation),
                    F64(f64),
                }
                #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                extern "C" {
                    #[allow(non_camel_case_types)]
                    #[wasm_bindgen(js_name = "CurveLocation")]
                    pub type CurveLocation_Class;
                    # [wasm_bindgen (method , structural , catch , getter = distance , js_class = "CurveLocation")]
                    fn distance(this: &CurveLocation_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = distance , js_class = "CurveLocation")]
                    fn set_distance(
                        this: &CurveLocation_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = curve , js_class = "CurveLocation")]
                    fn curve(this: &CurveLocation_Class) -> std::result::Result<Curve, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = curve , js_class = "CurveLocation")]
                    fn set_curve(
                        this: &CurveLocation_Class,
                        value: Curve,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = intersection , js_class = "CurveLocation")]
                    fn intersection(
                        this: &CurveLocation_Class,
                    ) -> std::result::Result<CurveLocation, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = intersection , js_class = "CurveLocation")]
                    fn set_intersection(
                        this: &CurveLocation_Class,
                        value: CurveLocation,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = offset , js_class = "CurveLocation")]
                    fn offset(this: &CurveLocation_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = offset , js_class = "CurveLocation")]
                    fn set_offset(
                        this: &CurveLocation_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = tangent , js_class = "CurveLocation")]
                    fn tangent(this: &CurveLocation_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = tangent , js_class = "CurveLocation")]
                    fn set_tangent(
                        this: &CurveLocation_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = point , js_class = "CurveLocation")]
                    fn point(this: &CurveLocation_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = point , js_class = "CurveLocation")]
                    fn set_point(
                        this: &CurveLocation_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = equals , method , js_class = "CurveLocation" , catch)]
                    fn __TSB_equals_FnCurveLocationToBool(
                        this: &CurveLocation_Class,
                        location: CurveLocation,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = index , js_class = "CurveLocation")]
                    fn index(this: &CurveLocation_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = index , js_class = "CurveLocation")]
                    fn set_index(
                        this: &CurveLocation_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = toString , method , js_class = "CurveLocation" , catch)]
                    fn __TSB_to_string_FnToString(
                        this: &CurveLocation_Class,
                    ) -> std::result::Result<String, JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isTouching , method , js_class = "CurveLocation" , catch)]
                    fn __TSB_is_touching_FnToBool(
                        this: &CurveLocation_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = time , js_class = "CurveLocation")]
                    fn time(this: &CurveLocation_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = time , js_class = "CurveLocation")]
                    fn set_time(
                        this: &CurveLocation_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = curvature , js_class = "CurveLocation")]
                    fn curvature(this: &CurveLocation_Class) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = curvature , js_class = "CurveLocation")]
                    fn set_curvature(
                        this: &CurveLocation_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = path , js_class = "CurveLocation")]
                    fn path(this: &CurveLocation_Class) -> std::result::Result<Path, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = path , js_class = "CurveLocation")]
                    fn set_path(
                        this: &CurveLocation_Class,
                        value: Path,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = segment , js_class = "CurveLocation")]
                    fn segment(this: &CurveLocation_Class)
                        -> std::result::Result<Segment, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = segment , js_class = "CurveLocation")]
                    fn set_segment(
                        this: &CurveLocation_Class,
                        value: Segment,
                    ) -> std::result::Result<(), JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = curveOffset , js_class = "CurveLocation")]
                    fn curve_offset(
                        this: &CurveLocation_Class,
                    ) -> std::result::Result<f64, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = curveOffset , js_class = "CurveLocation")]
                    fn set_curve_offset(
                        this: &CurveLocation_Class,
                        value: f64,
                    ) -> std::result::Result<(), JsValue>;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = hasOverlap , method , js_class = "CurveLocation" , catch)]
                    fn __TSB_has_overlap_FnToBool(
                        this: &CurveLocation_Class,
                    ) -> std::result::Result<bool, JsValue>;
                    # [wasm_bindgen (method , structural , catch , getter = normal , js_class = "CurveLocation")]
                    fn normal(this: &CurveLocation_Class) -> std::result::Result<Point, JsValue>;
                    # [wasm_bindgen (method , structural , catch , setter = normal , js_class = "CurveLocation")]
                    fn set_normal(
                        this: &CurveLocation_Class,
                        value: Point,
                    ) -> std::result::Result<(), JsValue>;
                    #[wasm_bindgen(constructor, js_class = "CurveLocation")]
                    pub fn new(curve: Curve, time: f64, point: Point) -> CurveLocation_Class;
                    #[allow(non_snake_case)]
                    # [wasm_bindgen (js_name = isCrossing , method , js_class = "CurveLocation" , catch)]
                    fn __TSB_is_crossing_FnToBool(
                        this: &CurveLocation_Class,
                    ) -> std::result::Result<bool, JsValue>;
                }
                #[derive(std :: clone :: Clone)]
                pub struct CurveLocation(pub CurveLocation_Class);
                impl std::convert::From<CurveLocation> for JsValue {
                    fn from(src: CurveLocation) -> JsValue {
                        JsValue::from(src.0)
                    }
                }
                impl std::convert::AsRef<JsValue> for CurveLocation {
                    fn as_ref(&self) -> &JsValue {
                        self.0.as_ref()
                    }
                }
                impl wasm_bindgen::JsCast for CurveLocation {
                    fn instanceof(val: &JsValue) -> bool {
                        CurveLocation_Class::instanceof(val)
                    }
                    fn unchecked_from_js(val: JsValue) -> Self {
                        CurveLocation(CurveLocation_Class::unchecked_from_js(val))
                    }
                    fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                        unsafe {
                            &*(CurveLocation_Class::unchecked_from_js_ref(val)
                                as *const CurveLocation_Class
                                as *const Self)
                        }
                    }
                }
                impl CurveLocation {
                    #[allow(dead_code, non_snake_case)]
                    pub fn distance(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.distance();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_distance(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_distance(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn curve(&self) -> std::result::Result<Curve, JsValue> {
                        let result = self.0.curve();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_curve(&self, value: Curve) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_curve(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn intersection(&self) -> std::result::Result<CurveLocation, JsValue> {
                        let result = self.0.intersection();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_intersection(
                        &self,
                        value: CurveLocation,
                    ) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_intersection(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn offset(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.offset();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_offset(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_offset(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn tangent(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.tangent();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_tangent(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_tangent(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn point(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.point();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_point(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_point(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn equals(
                        &self,
                        location: CurveLocation,
                    ) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_equals_FnCurveLocationToBool(location);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn index(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.index();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_index(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_index(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let result = self.0.__TSB_to_string_FnToString();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_touching(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_touching_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn time(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.time();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_time(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_time(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn curvature(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.curvature();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_curvature(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_curvature(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn path(&self) -> std::result::Result<Path, JsValue> {
                        let result = self.0.path();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_path(&self, value: Path) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_path(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn segment(&self) -> std::result::Result<Segment, JsValue> {
                        let result = self.0.segment();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_segment(&self, value: Segment) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_segment(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn curve_offset(&self) -> std::result::Result<f64, JsValue> {
                        let result = self.0.curve_offset();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_curve_offset(&self, value: f64) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_curve_offset(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn has_overlap(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_has_overlap_FnToBool();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn normal(&self) -> std::result::Result<Point, JsValue> {
                        let result = self.0.normal();
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn set_normal(&self, value: Point) -> std::result::Result<(), JsValue> {
                        let result = self.0.set_normal(value);
                        result
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn new(curve: Curve, time: f64, point: Point) -> CurveLocation {
                        let result = CurveLocation_Class::new(curve, time, point);
                        let result = ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                        CurveLocation(result)
                    }
                    #[allow(dead_code, non_snake_case)]
                    pub fn is_crossing(&self) -> std::result::Result<bool, JsValue> {
                        let result = self.0.__TSB_is_crossing_FnToBool();
                        result
                    }
                }
                impl wasm_bindgen::describe::WasmDescribe for CurveLocation {
                    fn describe() {
                        <CurveLocation_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                    }
                }
                impl wasm_bindgen::convert::IntoWasmAbi for CurveLocation {
                    type Abi = <CurveLocation_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                    }
                }
                impl wasm_bindgen::convert::FromWasmAbi for CurveLocation {
                    type Abi = <CurveLocation_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                    unsafe fn from_abi(js: Self::Abi) -> Self {
                        CurveLocation(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                    }
                }
                impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a CurveLocation {
                    type Abi = <&'a CurveLocation_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                    fn into_abi(self) -> Self::Abi {
                        wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                    }
                }
                impl serde::ser::Serialize for CurveLocation {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde::ser::Serialize::serialize(&self.0, serializer)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for CurveLocation {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        let internal: CurveLocation_Class =
                            <CurveLocation_Class as serde::de::Deserialize>::deserialize(
                                deserializer,
                            )?;
                        std::result::Result::Ok(Self(internal))
                    }
                }
                #[allow(non_camel_case_types, non_snake_case)]
                pub trait CurveLocation_Trait {
                    fn set_distance(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn distance(&self) -> std::result::Result<f64, JsValue>;
                    fn set_curve(&mut self, value: Curve) -> std::result::Result<(), JsValue>;
                    fn curve(&self) -> std::result::Result<Curve, JsValue>;
                    fn set_intersection(
                        &mut self,
                        value: CurveLocation,
                    ) -> std::result::Result<(), JsValue>;
                    fn intersection(&self) -> std::result::Result<CurveLocation, JsValue>;
                    fn set_offset(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn offset(&self) -> std::result::Result<f64, JsValue>;
                    fn set_tangent(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn tangent(&self) -> std::result::Result<Point, JsValue>;
                    fn set_point(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn point(&self) -> std::result::Result<Point, JsValue>;
                    fn equals(&self, location: CurveLocation)
                        -> std::result::Result<bool, JsValue>;
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn index(&self) -> std::result::Result<f64, JsValue>;
                    fn to_string(&self) -> std::result::Result<String, JsValue>;
                    fn is_touching(&self) -> std::result::Result<bool, JsValue>;
                    fn set_time(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn time(&self) -> std::result::Result<f64, JsValue>;
                    fn set_curvature(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn curvature(&self) -> std::result::Result<f64, JsValue>;
                    fn set_path(&mut self, value: Path) -> std::result::Result<(), JsValue>;
                    fn path(&self) -> std::result::Result<Path, JsValue>;
                    fn set_segment(&mut self, value: Segment) -> std::result::Result<(), JsValue>;
                    fn segment(&self) -> std::result::Result<Segment, JsValue>;
                    fn set_curve_offset(&mut self, value: f64) -> std::result::Result<(), JsValue>;
                    fn curve_offset(&self) -> std::result::Result<f64, JsValue>;
                    fn has_overlap(&self) -> std::result::Result<bool, JsValue>;
                    fn set_normal(&mut self, value: Point) -> std::result::Result<(), JsValue>;
                    fn normal(&self) -> std::result::Result<Point, JsValue>;
                    fn is_crossing(&self) -> std::result::Result<bool, JsValue>;
                }
                impl CurveLocation_Trait for CurveLocation {
                    fn set_distance(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        CurveLocation::set_distance(target, value)
                    }
                    fn distance(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        CurveLocation::distance(target)
                    }
                    fn set_curve(&mut self, value: Curve) -> std::result::Result<(), JsValue> {
                        let target = self;
                        CurveLocation::set_curve(target, value)
                    }
                    fn curve(&self) -> std::result::Result<Curve, JsValue> {
                        let target = self;
                        CurveLocation::curve(target)
                    }
                    fn set_intersection(
                        &mut self,
                        value: CurveLocation,
                    ) -> std::result::Result<(), JsValue> {
                        let target = self;
                        CurveLocation::set_intersection(target, value)
                    }
                    fn intersection(&self) -> std::result::Result<CurveLocation, JsValue> {
                        let target = self;
                        CurveLocation::intersection(target)
                    }
                    fn set_offset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        CurveLocation::set_offset(target, value)
                    }
                    fn offset(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        CurveLocation::offset(target)
                    }
                    fn set_tangent(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        CurveLocation::set_tangent(target, value)
                    }
                    fn tangent(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        CurveLocation::tangent(target)
                    }
                    fn set_point(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        CurveLocation::set_point(target, value)
                    }
                    fn point(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        CurveLocation::point(target)
                    }
                    fn equals(
                        &self,
                        location: CurveLocation,
                    ) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        CurveLocation::equals(target, location)
                    }
                    fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        CurveLocation::set_index(target, value)
                    }
                    fn index(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        CurveLocation::index(target)
                    }
                    fn to_string(&self) -> std::result::Result<String, JsValue> {
                        let target = self;
                        CurveLocation::to_string(target)
                    }
                    fn is_touching(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        CurveLocation::is_touching(target)
                    }
                    fn set_time(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        CurveLocation::set_time(target, value)
                    }
                    fn time(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        CurveLocation::time(target)
                    }
                    fn set_curvature(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        CurveLocation::set_curvature(target, value)
                    }
                    fn curvature(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        CurveLocation::curvature(target)
                    }
                    fn set_path(&mut self, value: Path) -> std::result::Result<(), JsValue> {
                        let target = self;
                        CurveLocation::set_path(target, value)
                    }
                    fn path(&self) -> std::result::Result<Path, JsValue> {
                        let target = self;
                        CurveLocation::path(target)
                    }
                    fn set_segment(&mut self, value: Segment) -> std::result::Result<(), JsValue> {
                        let target = self;
                        CurveLocation::set_segment(target, value)
                    }
                    fn segment(&self) -> std::result::Result<Segment, JsValue> {
                        let target = self;
                        CurveLocation::segment(target)
                    }
                    fn set_curve_offset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                        let target = self;
                        CurveLocation::set_curve_offset(target, value)
                    }
                    fn curve_offset(&self) -> std::result::Result<f64, JsValue> {
                        let target = self;
                        CurveLocation::curve_offset(target)
                    }
                    fn has_overlap(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        CurveLocation::has_overlap(target)
                    }
                    fn set_normal(&mut self, value: Point) -> std::result::Result<(), JsValue> {
                        let target = self;
                        CurveLocation::set_normal(target, value)
                    }
                    fn normal(&self) -> std::result::Result<Point, JsValue> {
                        let target = self;
                        CurveLocation::normal(target)
                    }
                    fn is_crossing(&self) -> std::result::Result<bool, JsValue> {
                        let target = self;
                        CurveLocation::is_crossing(target)
                    }
                }
                impl std::clone::Clone for CurveLocation_Class {
                    fn clone(&self) -> Self {
                        Self {
                            obj: std::clone::Clone::clone(&self.obj),
                        }
                    }
                }
                impl serde::ser::Serialize for CurveLocation_Class {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                    }
                }
                impl<'de> serde::de::Deserialize<'de> for CurveLocation_Class {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::de::Deserializer<'de>,
                    {
                        ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                    }
                }
                #[cfg(target_family = "wasm")]
                pub mod path {
                    #[allow(unused)]
                    use super::*;
                    #[allow(unused)]
                    use wasm_bindgen::prelude::*;
                    #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                    extern "C" {
                        #[allow(non_camel_case_types)]
                        # [wasm_bindgen (js_name = "Line" , extends = Item_Class , extends = PathItem_Class , extends = Path_Class)]
                        pub type Line_Class;
                        #[wasm_bindgen(constructor, js_class = "Line")]
                        pub fn new_FnSuperPointAndSuperPointToLine(
                            from: super::Point,
                            to: super::Point,
                        ) -> Line_Class;
                        #[wasm_bindgen(constructor, js_class = "Line")]
                        pub fn new_FnJsValueToLine(object: JsValue) -> Line_Class;
                    }
                    #[derive(std :: clone :: Clone)]
                    pub struct Line(pub Line_Class);
                    impl std::convert::From<&Line> for super::PathItem {
                        fn from(src: &Line) -> super::PathItem {
                            let src: &super::PathItem_Class = src.0.as_ref();
                            super::PathItem(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Line> for super::PathItem {
                        fn from(src: &mut Line) -> super::PathItem {
                            let src: &super::PathItem_Class = src.0.as_ref();
                            super::PathItem(src.clone())
                        }
                    }
                    impl std::convert::From<&Line> for super::Path {
                        fn from(src: &Line) -> super::Path {
                            let src: &super::Path_Class = src.0.as_ref();
                            super::Path(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Line> for super::Path {
                        fn from(src: &mut Line) -> super::Path {
                            let src: &super::Path_Class = src.0.as_ref();
                            super::Path(src.clone())
                        }
                    }
                    impl std::convert::From<&Line> for super::Item {
                        fn from(src: &Line) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Line> for super::Item {
                        fn from(src: &mut Line) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<Line> for JsValue {
                        fn from(src: Line) -> JsValue {
                            JsValue::from(src.0)
                        }
                    }
                    impl std::convert::AsRef<JsValue> for Line {
                        fn as_ref(&self) -> &JsValue {
                            self.0.as_ref()
                        }
                    }
                    impl wasm_bindgen::JsCast for Line {
                        fn instanceof(val: &JsValue) -> bool {
                            Line_Class::instanceof(val)
                        }
                        fn unchecked_from_js(val: JsValue) -> Self {
                            Line(Line_Class::unchecked_from_js(val))
                        }
                        fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                            unsafe {
                                &*(Line_Class::unchecked_from_js_ref(val) as *const Line_Class
                                    as *const Self)
                            }
                        }
                    }
                    impl Line {
                        #[allow(dead_code, non_snake_case)]
                        pub fn new_FnSuperPointAndSuperPointToLine(
                            from: super::Point,
                            to: super::Point,
                        ) -> Line {
                            let result = Line_Class::new_FnSuperPointAndSuperPointToLine(from, to);
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            Line(result)
                        }
                        #[allow(dead_code, non_snake_case)]
                        pub fn new_FnJsValueToLine(object: JsValue) -> Line {
                            let result = Line_Class::new_FnJsValueToLine(object);
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            Line(result)
                        }
                    }
                    impl wasm_bindgen::describe::WasmDescribe for Line {
                        fn describe() {
                            <Line_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                        }
                    }
                    impl wasm_bindgen::convert::IntoWasmAbi for Line {
                        type Abi = <Line_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                        }
                    }
                    impl wasm_bindgen::convert::FromWasmAbi for Line {
                        type Abi = <Line_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                        unsafe fn from_abi(js: Self::Abi) -> Self {
                            Line(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                        }
                    }
                    impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Line {
                        type Abi = <&'a Line_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                        }
                    }
                    impl serde::ser::Serialize for Line {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde::ser::Serialize::serialize(&self.0, serializer)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Line {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            let internal: Line_Class =
                                <Line_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                            std::result::Result::Ok(Self(internal))
                        }
                    }
                    #[allow(non_camel_case_types, non_snake_case)]
                    pub trait Line_Trait: Path_Trait {}
                    impl Path_Trait for Line
                    where
                        Line: PathItem_Trait,
                    {
                        fn set_last_segment(
                            &mut self,
                            value: super::Segment,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_last_segment(&target, value)
                        }
                        fn last_segment(&self) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::last_segment(&target)
                        }
                        fn insert_segments(
                            &self,
                            index: f64,
                            segments: Vec<Segment>,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::insert_segments(&target, index, segments)
                        }
                        fn set_curves(
                            &mut self,
                            value: Vec<Curve>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_curves(&target, value)
                        }
                        fn curves(&self) -> std::result::Result<Vec<Curve>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::curves(&target)
                        }
                        fn get_weighted_tangent_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_weighted_tangent_at(&target, offset)
                        }
                        fn set_fully_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_fully_selected(&target, value)
                        }
                        fn fully_selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::fully_selected(&target)
                        }
                        fn set_closed(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_closed(&target, value)
                        }
                        fn closed(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::closed(&target)
                        }
                        fn add(
                            &self,
                            segment: Vec<PathAddParamsSegment>,
                        ) -> std::result::Result<super::PathAddReturn, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::add(&target, segment)
                        }
                        fn get_offset_of(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_offset_of(&target, point)
                        }
                        fn add_segments(
                            &self,
                            segments: Vec<Segment>,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::add_segments(&target, segments)
                        }
                        fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::has_handles(&target)
                        }
                        fn set_first_segment(
                            &mut self,
                            value: super::Segment,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_first_segment(&target, value)
                        }
                        fn first_segment(&self) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::first_segment(&target)
                        }
                        fn set_last_curve(
                            &mut self,
                            value: super::Curve,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_last_curve(&target, value)
                        }
                        fn last_curve(&self) -> std::result::Result<super::Curve, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::last_curve(&target)
                        }
                        fn remove_segments_FnToVecOfSegment(
                            &self,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segments_FnToVecOfSegment(&target)
                        }
                        fn remove_segments_FnF64AndF64ToVecOfSegment(
                            &self,
                            from: f64,
                            to: f64,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segments_FnF64AndF64ToVecOfSegment(
                                &target, from, to,
                            )
                        }
                        fn divide_at(
                            &self,
                            location: super::PathDivideAtParamsLocation,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::divide_at(&target, location)
                        }
                        fn set_length(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_length(&target, value)
                        }
                        fn length(&self) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::length(&target)
                        }
                        fn split_at(
                            &self,
                            location: super::PathSplitAtParamsLocation,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::split_at(&target, location)
                        }
                        fn remove_segment(
                            &self,
                            index: f64,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segment(&target, index)
                        }
                        fn insert(
                            &self,
                            index: f64,
                            segment: super::PathInsertParamsSegment,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::insert(&target, index, segment)
                        }
                        fn get_location_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::get_location_at(&target, offset)
                        }
                        fn to_shape(
                            &self,
                            insert: bool,
                        ) -> std::result::Result<super::Shape, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::to_shape(&target, insert)
                        }
                        fn set_segments(
                            &mut self,
                            value: Vec<Segment>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_segments(&target, value)
                        }
                        fn segments(&self) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::segments(&target)
                        }
                        fn get_offsets_with_tangent(
                            &self,
                            tangent: super::Point,
                        ) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_offsets_with_tangent(&target, tangent)
                        }
                        fn get_weighted_normal_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_weighted_normal_at(&target, offset)
                        }
                        fn join(
                            &self,
                            path: super::Path,
                            tolerance: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::join(&target, path, tolerance)
                        }
                        fn set_area(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_area(&target, value)
                        }
                        fn area(&self) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::area(&target)
                        }
                        fn get_location_of(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::get_location_of(&target, point)
                        }
                        fn get_curvature_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_curvature_at(&target, offset)
                        }
                        fn get_normal_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_normal_at(&target, offset)
                        }
                        fn get_tangent_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_tangent_at(&target, offset)
                        }
                        fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::clear_handles(&target)
                        }
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::reduce(&target, options)
                        }
                        fn set_first_curve(
                            &mut self,
                            value: super::Curve,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_first_curve(&target, value)
                        }
                        fn first_curve(&self) -> std::result::Result<super::Curve, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::first_curve(&target)
                        }
                        fn get_point_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_point_at(&target, offset)
                        }
                    }
                    impl PathItem_Trait for Line
                    where
                        Line: Item_Trait,
                    {
                        fn unite(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::unite(&target, path, options)
                        }
                        fn line_by(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::line_by(&target, point)
                        }
                        fn move_to(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::move_to(&target, point)
                        }
                        fn set_path_data(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::set_path_data(&target, value)
                        }
                        fn path_data(&self) -> std::result::Result<String, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::path_data(&target)
                        }
                        fn intersect(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::intersect(&target, path, options)
                        }
                        fn create_FnStringToPathItemCreateReturn(
                            &self,
                            path_data: String,
                        ) -> std::result::Result<super::PathItemCreateReturn, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::create_FnStringToPathItemCreateReturn(
                                &target, path_data,
                            )
                        }
                        fn create_FnVecOfVecOfF64ToPathItemCreateReturn(
                            &self,
                            segments: Vec<Vec<f64>>,
                        ) -> std::result::Result<super::PathItemCreateReturn, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::create_FnVecOfVecOfF64ToPathItemCreateReturn(
                                &target, segments,
                            )
                        }
                        fn create_FnJsValueToPathItemCreateReturn(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<super::PathItemCreateReturn, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::create_FnJsValueToPathItemCreateReturn(&target, object)
                        }
                        fn smooth(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::smooth(&target, options)
                        }
                        fn compare(
                            &self,
                            path: super::PathItem,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::compare(&target, path)
                        }
                        fn arc_to_FnPointAndPointTo(
                            &self,
                            through: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_to_FnPointAndPointTo(&target, through, to)
                        }
                        fn arc_to_FnPointAndBoolTo(
                            &self,
                            to: super::Point,
                            clockwise: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_to_FnPointAndBoolTo(&target, to, clockwise)
                        }
                        fn quadratic_curve_to(
                            &self,
                            handle: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::quadratic_curve_to(&target, handle, to)
                        }
                        fn set_interior_point(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::set_interior_point(&target, value)
                        }
                        fn interior_point(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::interior_point(&target)
                        }
                        fn simplify(&self, tolerance: f64) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::simplify(&target, tolerance)
                        }
                        fn reorient(
                            &self,
                            non_zero: bool,
                            clockwise: bool,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::reorient(&target, non_zero, clockwise)
                        }
                        fn cubic_curve_by(
                            &self,
                            handle1: super::Point,
                            handle2: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::cubic_curve_by(&target, handle1, handle2, to)
                        }
                        fn close_path(&self) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::close_path(&target)
                        }
                        fn flatten(&self, flatness: f64) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::flatten(&target, flatness)
                        }
                        fn quadratic_curve_by(
                            &self,
                            handle: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::quadratic_curve_by(&target, handle, to)
                        }
                        fn cubic_curve_to(
                            &self,
                            handle1: super::Point,
                            handle2: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::cubic_curve_to(&target, handle1, handle2, to)
                        }
                        fn divide(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::divide(&target, path, options)
                        }
                        fn arc_by_FnPointAndPointTo(
                            &self,
                            through: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_by_FnPointAndPointTo(&target, through, to)
                        }
                        fn arc_by_FnPointAndBoolTo(
                            &self,
                            to: super::Point,
                            clockwise: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_by_FnPointAndBoolTo(&target, to, clockwise)
                        }
                        fn move_by(&self, to: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::move_by(&target, to)
                        }
                        fn get_nearest_location(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_nearest_location(&target, point)
                        }
                        fn reverse(&self) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::reverse(&target)
                        }
                        fn line_to(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::line_to(&target, point)
                        }
                        fn get_nearest_point(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::get_nearest_point(&target, point)
                        }
                        fn interpolate(
                            &self,
                            from: super::PathItem,
                            to: super::PathItem,
                            factor: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::interpolate(&target, from, to, factor)
                        }
                        fn get_crossings(
                            &self,
                            path: super::PathItem,
                        ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_crossings(&target, path)
                        }
                        fn curve_by(
                            &self,
                            through: super::Point,
                            to: super::Point,
                            time: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::curve_by(&target, through, to, time)
                        }
                        fn curve_to(
                            &self,
                            through: super::Point,
                            to: super::Point,
                            time: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::curve_to(&target, through, to, time)
                        }
                        fn subtract(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::subtract(&target, path, options)
                        }
                        fn get_intersections(
                            &self,
                            path: super::PathItem,
                            include: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_intersections(&target, path, include)
                        }
                        fn exclude(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::exclude(&target, path, options)
                        }
                        fn set_clockwise(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::set_clockwise(&target, value)
                        }
                        fn clockwise(&self) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::clockwise(&target)
                        }
                    }
                    impl Item_Trait for Line {
                        fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::responds(&target, type_)
                        }
                        fn copy_content(
                            &self,
                            source: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_content(&target, source)
                        }
                        fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_opacity(&target, value)
                        }
                        fn opacity(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::opacity(&target)
                        }
                        fn set_on_frame(
                            &mut self,
                            value: super::ItemOnFrame,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_frame(&target, value)
                        }
                        fn on_frame(&self) -> std::result::Result<super::ItemOnFrame, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_frame(&target)
                        }
                        fn remove_children_FnToVecOfItem(
                            &self,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_children_FnToVecOfItem(&target)
                        }
                        fn remove_children_FnF64AndF64ToVecOfItem(
                            &self,
                            start: f64,
                            end: f64,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_children_FnF64AndF64ToVecOfItem(&target, start, end)
                        }
                        fn is_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_below(&target, item)
                        }
                        fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_stroke(&target)
                        }
                        fn set_global_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_global_matrix(&target, value)
                        }
                        fn global_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_matrix(&target)
                        }
                        fn copy_attributes(
                            &self,
                            source: super::Item,
                            exclude_matrix: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_attributes(&target, source, exclude_matrix)
                        }
                        fn set_on_mouse_move(
                            &mut self,
                            value: super::ItemOnMouseMove,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_move(&target, value)
                        }
                        fn on_mouse_move(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseMove, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_move(&target)
                        }
                        fn set_position(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_position(&target, value)
                        }
                        fn position(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::position(&target)
                        }
                        fn set_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_bounds(&target, value)
                        }
                        fn bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::bounds(&target)
                        }
                        fn set_shadow_blur(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_shadow_blur(&target, value)
                        }
                        fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_blur(&target)
                        }
                        fn set_selected_color(
                            &mut self,
                            value: super::ItemSelectedColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_selected_color(&target, value)
                        }
                        fn selected_color(
                            &self,
                        ) -> std::result::Result<super::ItemSelectedColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::selected_color(&target)
                        }
                        fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::reverse_children(&target)
                        }
                        fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::bring_to_front(&target)
                        }
                        fn set_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_selected(&target, value)
                        }
                        fn selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::selected(&target)
                        }
                        fn add_children(
                            &self,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_children(&target, items)
                        }
                        fn tween_to(
                            &self,
                            to: JsValue,
                            options: super::ItemTweenToParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_to(&target, to, options)
                        }
                        fn set_project(
                            &mut self,
                            value: super::Project,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_project(&target, value)
                        }
                        fn project(&self) -> std::result::Result<super::Project, JsValue> {
                            let target: Item = self.into();
                            super::Item::project(&target)
                        }
                        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_name(&target, value)
                        }
                        fn name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::name(&target)
                        }
                        fn set_stroke_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_bounds(&target, value)
                        }
                        fn stroke_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_bounds(&target)
                        }
                        fn insert_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_below(&target, item)
                        }
                        fn set_blend_mode(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_blend_mode(&target, value)
                        }
                        fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::blend_mode(&target)
                        }
                        fn set_clip_mask(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_clip_mask(&target, value)
                        }
                        fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::clip_mask(&target)
                        }
                        fn set_fill_color(
                            &mut self,
                            value: super::ItemFillColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_fill_color(&target, value)
                        }
                        fn fill_color(&self) -> std::result::Result<super::ItemFillColor, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_color(&target)
                        }
                        fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_drag(&target)
                        }
                        fn add_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_child(&target, item)
                        }
                        fn scale_FnF64AndPointTo(
                            &self,
                            scale: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::scale_FnF64AndPointTo(&target, scale, center)
                        }
                        fn scale_FnF64AndF64AndPointTo(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::scale_FnF64AndF64AndPointTo(&target, hor, ver, center)
                        }
                        fn set_first_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_first_child(&target, value)
                        }
                        fn first_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::first_child(&target)
                        }
                        fn set_style(
                            &mut self,
                            value: super::Style,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_style(&target, value)
                        }
                        fn style(&self) -> std::result::Result<super::Style, JsValue> {
                            let target: Item = self.into();
                            super::Item::style(&target)
                        }
                        fn set_class_name(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_class_name(&target, value)
                        }
                        fn class_name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::class_name(&target)
                        }
                        fn is_grouped_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_grouped_with(&target, item)
                        }
                        fn set_shadow_offset(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_shadow_offset(&target, value)
                        }
                        fn shadow_offset(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_offset(&target)
                        }
                        fn is_inside(
                            &self,
                            rect: super::Rectangle,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inside(&target, rect)
                        }
                        fn set_children(
                            &mut self,
                            value: Vec<Item>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_children(&target, value)
                        }
                        fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::children(&target)
                        }
                        fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_fill(&target)
                        }
                        fn matches_FnItemMatchesParamsOptionsToBool(
                            &self,
                            options: super::ItemMatchesParamsOptions,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::matches_FnItemMatchesParamsOptionsToBool(&target, options)
                        }
                        fn matches_FnStringAndJsValueToBool(
                            &self,
                            name: String,
                            compare: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::matches_FnStringAndJsValueToBool(&target, name, compare)
                        }
                        fn set_on_double_click(
                            &mut self,
                            value: super::ItemOnDoubleClick,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_double_click(&target, value)
                        }
                        fn on_double_click(
                            &self,
                        ) -> std::result::Result<super::ItemOnDoubleClick, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_double_click(&target)
                        }
                        fn intersects(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::intersects(&target, item)
                        }
                        fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_rotation(&target, value)
                        }
                        fn rotation(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::rotation(&target)
                        }
                        fn set_on_mouse_down(
                            &mut self,
                            value: super::ItemOnMouseDown,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_down(&target, value)
                        }
                        fn on_mouse_down(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDown, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_down(&target)
                        }
                        fn is_sibling(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_sibling(&target, item)
                        }
                        fn tween_from(
                            &self,
                            from: JsValue,
                            options: super::ItemTweenFromParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_from(&target, from, options)
                        }
                        fn set_layer(
                            &mut self,
                            value: super::Layer,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_layer(&target, value)
                        }
                        fn layer(&self) -> std::result::Result<super::Layer, JsValue> {
                            let target: Item = self.into();
                            super::Item::layer(&target)
                        }
                        fn contains(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::contains(&target, point)
                        }
                        fn set_on_click(
                            &mut self,
                            value: super::ItemOnClick,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_click(&target, value)
                        }
                        fn on_click(&self) -> std::result::Result<super::ItemOnClick, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_click(&target)
                        }
                        fn set_last_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_last_child(&target, value)
                        }
                        fn last_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::last_child(&target)
                        }
                        fn set_dash_offset(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_dash_offset(&target, value)
                        }
                        fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_offset(&target)
                        }
                        fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_id(&target, value)
                        }
                        fn id(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::id(&target)
                        }
                        fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_shadow(&target)
                        }
                        fn tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                            &self,
                            from: JsValue,
                            to: JsValue,
                            options: super::ItemTweenParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                                &target, from, to, options,
                            )
                        }
                        fn tween_FnJsValueAndItemTweenParamsOptionsToTween(
                            &self,
                            to: JsValue,
                            options: super::ItemTweenParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_FnJsValueAndItemTweenParamsOptionsToTween(
                                &target, to, options,
                            )
                        }
                        fn tween_FnItemTweenParamsOptionsToTween(
                            &self,
                            options: super::ItemTweenParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_FnItemTweenParamsOptionsToTween(&target, options)
                        }
                        fn set_scaling(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_scaling(&target, value)
                        }
                        fn scaling(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::scaling(&target)
                        }
                        fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::send_to_back(&target)
                        }
                        fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::set(&target, props)
                        }
                        fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_index(&target, value)
                        }
                        fn index(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::index(&target)
                        }
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::reduce(&target, options)
                        }
                        fn set_pivot(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_pivot(&target, value)
                        }
                        fn pivot(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::pivot(&target)
                        }
                        fn insert_children(
                            &self,
                            index: f64,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_children(&target, index, items)
                        }
                        fn set_on_mouse_up(
                            &mut self,
                            value: super::ItemOnMouseUp,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_up(&target, value)
                        }
                        fn on_mouse_up(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseUp, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_up(&target)
                        }
                        fn set_stroke_width(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_width(&target, value)
                        }
                        fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_width(&target)
                        }
                        fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on(&target, options)
                        }
                        fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_up(&target)
                        }
                        fn is_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_child(&target, item)
                        }
                        fn replace_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::replace_with(&target, item)
                        }
                        fn export_json(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::export_json(&target, options)
                        }
                        fn hit_test_all(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<Vec<HitResult>, JsValue> {
                            let target: Item = self.into();
                            super::Item::hit_test_all(&target, point, options)
                        }
                        fn export_svg(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::ItemExportSvgReturn, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::export_svg(&target, options)
                        }
                        fn copy_to(
                            &self,
                            owner: super::ItemCopyToParamsOwner,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_to(&target, owner)
                        }
                        fn set_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_matrix(&target, value)
                        }
                        fn matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::matrix(&target)
                        }
                        fn add_to(
                            &self,
                            owner: super::ItemAddToParamsOwner,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_to(&target, owner)
                        }
                        fn rotate(
                            &self,
                            angle: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::rotate(&target, angle, center)
                        }
                        fn set_view_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_view_matrix(&target, value)
                        }
                        fn view_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::view_matrix(&target)
                        }
                        fn set_previous_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_previous_sibling(&target, value)
                        }
                        fn previous_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::previous_sibling(&target)
                        }
                        fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_data(&target, value)
                        }
                        fn data(&self) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::data(&target)
                        }
                        fn off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                            &self,
                            type_: String,
                            callback: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super :: Item :: off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                        }
                        fn off_FnJsValueToJsValue(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::off_FnJsValueToJsValue(&target, object)
                        }
                        fn set_stroke_scaling(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_scaling(&target, value)
                        }
                        fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_scaling(&target)
                        }
                        fn insert_child(
                            &self,
                            index: f64,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_child(&target, index, item)
                        }
                        fn skew_FnPointAndPointTo(
                            &self,
                            skew: super::Point,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::skew_FnPointAndPointTo(&target, skew, center)
                        }
                        fn skew_FnF64AndF64AndPointTo(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::skew_FnF64AndF64AndPointTo(&target, hor, ver, center)
                        }
                        fn on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                            &self,
                            type_: String,
                            callback: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super :: Item :: on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                        }
                        fn on_FnJsValueToJsValue(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_FnJsValueToJsValue(&target, object)
                        }
                        fn remove(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove(&target)
                        }
                        fn global_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_to_local(&target, point)
                        }
                        fn emit(
                            &self,
                            type_: String,
                            event: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::emit(&target, type_, event)
                        }
                        fn hit_test(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<super::HitResult, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::hit_test(&target, point, options)
                        }
                        fn import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                            &self,
                            svg: super::ItemImportSvgParamsSvg,
                            options: JsValue,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                                &target, svg, options,
                            )
                        }
                        fn import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem(
                            &self,
                            svg: super::ItemImportSvgParamsSvg,
                            on_load: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super :: Item :: import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem (& target , svg , on_load)
                        }
                        fn set_dash_array(
                            &mut self,
                            value: Vec<f64>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_dash_array(&target, value)
                        }
                        fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_array(&target)
                        }
                        fn shear_FnPointAndPointTo(
                            &self,
                            shear: super::Point,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::shear_FnPointAndPointTo(&target, shear, center)
                        }
                        fn shear_FnF64AndF64AndPointTo(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::shear_FnF64AndF64AndPointTo(&target, hor, ver, center)
                        }
                        fn set_internal_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_internal_bounds(&target, value)
                        }
                        fn internal_bounds(
                            &self,
                        ) -> std::result::Result<super::Rectangle, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::internal_bounds(&target)
                        }
                        fn set_stroke_cap(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_cap(&target, value)
                        }
                        fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_cap(&target)
                        }
                        fn set_on_mouse_enter(
                            &mut self,
                            value: super::ItemOnMouseEnter,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_enter(&target, value)
                        }
                        fn on_mouse_enter(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseEnter, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_enter(&target)
                        }
                        fn set_view(
                            &mut self,
                            value: super::View,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_view(&target, value)
                        }
                        fn view(&self) -> std::result::Result<super::View, JsValue> {
                            let target: Item = self.into();
                            super::Item::view(&target)
                        }
                        fn set_stroke_join(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_join(&target, value)
                        }
                        fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_join(&target)
                        }
                        fn is_ancestor(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_ancestor(&target, item)
                        }
                        fn set_fill_rule(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_fill_rule(&target, value)
                        }
                        fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_rule(&target)
                        }
                        fn fit_bounds(
                            &self,
                            rectangle: super::Rectangle,
                            fill: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::fit_bounds(&target, rectangle, fill)
                        }
                        fn local_to_parent(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_parent(&target, point)
                        }
                        fn set_handle_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_handle_bounds(&target, value)
                        }
                        fn handle_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::handle_bounds(&target)
                        }
                        fn set_next_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_next_sibling(&target, value)
                        }
                        fn next_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::next_sibling(&target)
                        }
                        fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::clone(&target, options)
                        }
                        fn is_descendant(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_descendant(&target, item)
                        }
                        fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_down(&target)
                        }
                        fn is_parent(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_parent(&target, item)
                        }
                        fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_move(&target)
                        }
                        fn is_empty(
                            &self,
                            recursively: bool,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_empty(&target, recursively)
                        }
                        fn rasterize(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Raster, JsValue> {
                            let target: Item = self.into();
                            super::Item::rasterize(&target, options)
                        }
                        fn set_shadow_color(
                            &mut self,
                            value: super::ItemShadowColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_shadow_color(&target, value)
                        }
                        fn shadow_color(
                            &self,
                        ) -> std::result::Result<super::ItemShadowColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::shadow_color(&target)
                        }
                        fn set_miter_limit(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_miter_limit(&target, value)
                        }
                        fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::miter_limit(&target)
                        }
                        fn get_item(
                            &self,
                            options: super::ItemGetItemParamsOptions,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_item(&target, options)
                        }
                        fn import_json(
                            &self,
                            json: String,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_json(&target, json)
                        }
                        fn insert_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_above(&target, item)
                        }
                        fn set_on_mouse_drag(
                            &mut self,
                            value: super::ItemOnMouseDrag,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_drag(&target, value)
                        }
                        fn on_mouse_drag(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDrag, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_drag(&target)
                        }
                        fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inserted(&target)
                        }
                        fn set_apply_matrix(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_apply_matrix(&target, value)
                        }
                        fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::apply_matrix(&target)
                        }
                        fn transform(
                            &self,
                            matrix: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::transform(&target, matrix)
                        }
                        fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_visible(&target, value)
                        }
                        fn visible(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::visible(&target)
                        }
                        fn set_stroke_color(
                            &mut self,
                            value: super::ItemStrokeColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_color(&target, value)
                        }
                        fn stroke_color(
                            &self,
                        ) -> std::result::Result<super::ItemStrokeColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::stroke_color(&target)
                        }
                        fn set_on_mouse_leave(
                            &mut self,
                            value: super::ItemOnMouseLeave,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_leave(&target, value)
                        }
                        fn on_mouse_leave(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseLeave, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_leave(&target)
                        }
                        fn parent_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent_to_local(&target, point)
                        }
                        fn is_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_above(&target, item)
                        }
                        fn get_items(
                            &self,
                            options: super::ItemGetItemsParamsOptions,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_items(&target, options)
                        }
                        fn has_children(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_children(&target)
                        }
                        fn translate(
                            &self,
                            delta: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::translate(&target, delta)
                        }
                        fn set_parent(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_parent(&target, value)
                        }
                        fn parent(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent(&target)
                        }
                        fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_locked(&target, value)
                        }
                        fn locked(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::locked(&target)
                        }
                        fn local_to_global(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_global(&target, point)
                        }
                    }
                    impl Line_Trait for Line where Line: Path_Trait {}
                    impl std::clone::Clone for Line_Class {
                        fn clone(&self) -> Self {
                            Self {
                                obj: std::clone::Clone::clone(&self.obj),
                            }
                        }
                    }
                    impl serde::ser::Serialize for Line_Class {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Line_Class {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                        }
                    }
                    #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                    extern "C" {
                        #[allow(non_camel_case_types)]
                        # [wasm_bindgen (js_name = "Ellipse" , extends = PathItem_Class , extends = Path_Class , extends = Item_Class)]
                        pub type Ellipse_Class;
                        #[wasm_bindgen(constructor, js_class = "Ellipse")]
                        pub fn new_FnSuperRectangleToEllipse(
                            rectangle: super::Rectangle,
                        ) -> Ellipse_Class;
                        #[wasm_bindgen(constructor, js_class = "Ellipse")]
                        pub fn new_FnJsValueToEllipse(object: JsValue) -> Ellipse_Class;
                    }
                    #[derive(std :: clone :: Clone)]
                    pub struct Ellipse(pub Ellipse_Class);
                    impl std::convert::From<&Ellipse> for super::PathItem {
                        fn from(src: &Ellipse) -> super::PathItem {
                            let src: &super::PathItem_Class = src.0.as_ref();
                            super::PathItem(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Ellipse> for super::PathItem {
                        fn from(src: &mut Ellipse) -> super::PathItem {
                            let src: &super::PathItem_Class = src.0.as_ref();
                            super::PathItem(src.clone())
                        }
                    }
                    impl std::convert::From<&Ellipse> for super::Item {
                        fn from(src: &Ellipse) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Ellipse> for super::Item {
                        fn from(src: &mut Ellipse) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&Ellipse> for super::Path {
                        fn from(src: &Ellipse) -> super::Path {
                            let src: &super::Path_Class = src.0.as_ref();
                            super::Path(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Ellipse> for super::Path {
                        fn from(src: &mut Ellipse) -> super::Path {
                            let src: &super::Path_Class = src.0.as_ref();
                            super::Path(src.clone())
                        }
                    }
                    impl std::convert::From<Ellipse> for JsValue {
                        fn from(src: Ellipse) -> JsValue {
                            JsValue::from(src.0)
                        }
                    }
                    impl std::convert::AsRef<JsValue> for Ellipse {
                        fn as_ref(&self) -> &JsValue {
                            self.0.as_ref()
                        }
                    }
                    impl wasm_bindgen::JsCast for Ellipse {
                        fn instanceof(val: &JsValue) -> bool {
                            Ellipse_Class::instanceof(val)
                        }
                        fn unchecked_from_js(val: JsValue) -> Self {
                            Ellipse(Ellipse_Class::unchecked_from_js(val))
                        }
                        fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                            unsafe {
                                &*(Ellipse_Class::unchecked_from_js_ref(val) as *const Ellipse_Class
                                    as *const Self)
                            }
                        }
                    }
                    impl Ellipse {
                        #[allow(dead_code, non_snake_case)]
                        pub fn new_FnSuperRectangleToEllipse(
                            rectangle: super::Rectangle,
                        ) -> Ellipse {
                            let result = Ellipse_Class::new_FnSuperRectangleToEllipse(rectangle);
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            Ellipse(result)
                        }
                        #[allow(dead_code, non_snake_case)]
                        pub fn new_FnJsValueToEllipse(object: JsValue) -> Ellipse {
                            let result = Ellipse_Class::new_FnJsValueToEllipse(object);
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            Ellipse(result)
                        }
                    }
                    impl wasm_bindgen::describe::WasmDescribe for Ellipse {
                        fn describe() {
                            <Ellipse_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                        }
                    }
                    impl wasm_bindgen::convert::IntoWasmAbi for Ellipse {
                        type Abi = <Ellipse_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                        }
                    }
                    impl wasm_bindgen::convert::FromWasmAbi for Ellipse {
                        type Abi = <Ellipse_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                        unsafe fn from_abi(js: Self::Abi) -> Self {
                            Ellipse(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                        }
                    }
                    impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Ellipse {
                        type Abi = <&'a Ellipse_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                        }
                    }
                    impl serde::ser::Serialize for Ellipse {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde::ser::Serialize::serialize(&self.0, serializer)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Ellipse {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            let internal: Ellipse_Class =
                                <Ellipse_Class as serde::de::Deserialize>::deserialize(
                                    deserializer,
                                )?;
                            std::result::Result::Ok(Self(internal))
                        }
                    }
                    #[allow(non_camel_case_types, non_snake_case)]
                    pub trait Ellipse_Trait: Path_Trait {}
                    impl Path_Trait for Ellipse
                    where
                        Ellipse: PathItem_Trait,
                    {
                        fn set_last_segment(
                            &mut self,
                            value: super::Segment,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_last_segment(&target, value)
                        }
                        fn last_segment(&self) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::last_segment(&target)
                        }
                        fn insert_segments(
                            &self,
                            index: f64,
                            segments: Vec<Segment>,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::insert_segments(&target, index, segments)
                        }
                        fn set_curves(
                            &mut self,
                            value: Vec<Curve>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_curves(&target, value)
                        }
                        fn curves(&self) -> std::result::Result<Vec<Curve>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::curves(&target)
                        }
                        fn get_weighted_tangent_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_weighted_tangent_at(&target, offset)
                        }
                        fn set_fully_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_fully_selected(&target, value)
                        }
                        fn fully_selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::fully_selected(&target)
                        }
                        fn set_closed(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_closed(&target, value)
                        }
                        fn closed(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::closed(&target)
                        }
                        fn add(
                            &self,
                            segment: Vec<PathAddParamsSegment>,
                        ) -> std::result::Result<super::PathAddReturn, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::add(&target, segment)
                        }
                        fn get_offset_of(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_offset_of(&target, point)
                        }
                        fn add_segments(
                            &self,
                            segments: Vec<Segment>,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::add_segments(&target, segments)
                        }
                        fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::has_handles(&target)
                        }
                        fn set_first_segment(
                            &mut self,
                            value: super::Segment,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_first_segment(&target, value)
                        }
                        fn first_segment(&self) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::first_segment(&target)
                        }
                        fn set_last_curve(
                            &mut self,
                            value: super::Curve,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_last_curve(&target, value)
                        }
                        fn last_curve(&self) -> std::result::Result<super::Curve, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::last_curve(&target)
                        }
                        fn remove_segments_FnToVecOfSegment(
                            &self,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segments_FnToVecOfSegment(&target)
                        }
                        fn remove_segments_FnF64AndF64ToVecOfSegment(
                            &self,
                            from: f64,
                            to: f64,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segments_FnF64AndF64ToVecOfSegment(
                                &target, from, to,
                            )
                        }
                        fn divide_at(
                            &self,
                            location: super::PathDivideAtParamsLocation,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::divide_at(&target, location)
                        }
                        fn set_length(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_length(&target, value)
                        }
                        fn length(&self) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::length(&target)
                        }
                        fn split_at(
                            &self,
                            location: super::PathSplitAtParamsLocation,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::split_at(&target, location)
                        }
                        fn remove_segment(
                            &self,
                            index: f64,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segment(&target, index)
                        }
                        fn insert(
                            &self,
                            index: f64,
                            segment: super::PathInsertParamsSegment,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::insert(&target, index, segment)
                        }
                        fn get_location_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::get_location_at(&target, offset)
                        }
                        fn to_shape(
                            &self,
                            insert: bool,
                        ) -> std::result::Result<super::Shape, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::to_shape(&target, insert)
                        }
                        fn set_segments(
                            &mut self,
                            value: Vec<Segment>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_segments(&target, value)
                        }
                        fn segments(&self) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::segments(&target)
                        }
                        fn get_offsets_with_tangent(
                            &self,
                            tangent: super::Point,
                        ) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_offsets_with_tangent(&target, tangent)
                        }
                        fn get_weighted_normal_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_weighted_normal_at(&target, offset)
                        }
                        fn join(
                            &self,
                            path: super::Path,
                            tolerance: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::join(&target, path, tolerance)
                        }
                        fn set_area(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_area(&target, value)
                        }
                        fn area(&self) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::area(&target)
                        }
                        fn get_location_of(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::get_location_of(&target, point)
                        }
                        fn get_curvature_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_curvature_at(&target, offset)
                        }
                        fn get_normal_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_normal_at(&target, offset)
                        }
                        fn get_tangent_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_tangent_at(&target, offset)
                        }
                        fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::clear_handles(&target)
                        }
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::reduce(&target, options)
                        }
                        fn set_first_curve(
                            &mut self,
                            value: super::Curve,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_first_curve(&target, value)
                        }
                        fn first_curve(&self) -> std::result::Result<super::Curve, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::first_curve(&target)
                        }
                        fn get_point_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_point_at(&target, offset)
                        }
                    }
                    impl PathItem_Trait for Ellipse
                    where
                        Ellipse: Item_Trait,
                    {
                        fn unite(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::unite(&target, path, options)
                        }
                        fn line_by(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::line_by(&target, point)
                        }
                        fn move_to(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::move_to(&target, point)
                        }
                        fn set_path_data(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::set_path_data(&target, value)
                        }
                        fn path_data(&self) -> std::result::Result<String, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::path_data(&target)
                        }
                        fn intersect(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::intersect(&target, path, options)
                        }
                        fn create_FnStringToPathItemCreateReturn(
                            &self,
                            path_data: String,
                        ) -> std::result::Result<super::PathItemCreateReturn, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::create_FnStringToPathItemCreateReturn(
                                &target, path_data,
                            )
                        }
                        fn create_FnVecOfVecOfF64ToPathItemCreateReturn(
                            &self,
                            segments: Vec<Vec<f64>>,
                        ) -> std::result::Result<super::PathItemCreateReturn, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::create_FnVecOfVecOfF64ToPathItemCreateReturn(
                                &target, segments,
                            )
                        }
                        fn create_FnJsValueToPathItemCreateReturn(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<super::PathItemCreateReturn, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::create_FnJsValueToPathItemCreateReturn(&target, object)
                        }
                        fn smooth(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::smooth(&target, options)
                        }
                        fn compare(
                            &self,
                            path: super::PathItem,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::compare(&target, path)
                        }
                        fn arc_to_FnPointAndPointTo(
                            &self,
                            through: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_to_FnPointAndPointTo(&target, through, to)
                        }
                        fn arc_to_FnPointAndBoolTo(
                            &self,
                            to: super::Point,
                            clockwise: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_to_FnPointAndBoolTo(&target, to, clockwise)
                        }
                        fn quadratic_curve_to(
                            &self,
                            handle: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::quadratic_curve_to(&target, handle, to)
                        }
                        fn set_interior_point(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::set_interior_point(&target, value)
                        }
                        fn interior_point(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::interior_point(&target)
                        }
                        fn simplify(&self, tolerance: f64) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::simplify(&target, tolerance)
                        }
                        fn reorient(
                            &self,
                            non_zero: bool,
                            clockwise: bool,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::reorient(&target, non_zero, clockwise)
                        }
                        fn cubic_curve_by(
                            &self,
                            handle1: super::Point,
                            handle2: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::cubic_curve_by(&target, handle1, handle2, to)
                        }
                        fn close_path(&self) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::close_path(&target)
                        }
                        fn flatten(&self, flatness: f64) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::flatten(&target, flatness)
                        }
                        fn quadratic_curve_by(
                            &self,
                            handle: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::quadratic_curve_by(&target, handle, to)
                        }
                        fn cubic_curve_to(
                            &self,
                            handle1: super::Point,
                            handle2: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::cubic_curve_to(&target, handle1, handle2, to)
                        }
                        fn divide(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::divide(&target, path, options)
                        }
                        fn arc_by_FnPointAndPointTo(
                            &self,
                            through: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_by_FnPointAndPointTo(&target, through, to)
                        }
                        fn arc_by_FnPointAndBoolTo(
                            &self,
                            to: super::Point,
                            clockwise: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_by_FnPointAndBoolTo(&target, to, clockwise)
                        }
                        fn move_by(&self, to: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::move_by(&target, to)
                        }
                        fn get_nearest_location(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_nearest_location(&target, point)
                        }
                        fn reverse(&self) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::reverse(&target)
                        }
                        fn line_to(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::line_to(&target, point)
                        }
                        fn get_nearest_point(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::get_nearest_point(&target, point)
                        }
                        fn interpolate(
                            &self,
                            from: super::PathItem,
                            to: super::PathItem,
                            factor: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::interpolate(&target, from, to, factor)
                        }
                        fn get_crossings(
                            &self,
                            path: super::PathItem,
                        ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_crossings(&target, path)
                        }
                        fn curve_by(
                            &self,
                            through: super::Point,
                            to: super::Point,
                            time: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::curve_by(&target, through, to, time)
                        }
                        fn curve_to(
                            &self,
                            through: super::Point,
                            to: super::Point,
                            time: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::curve_to(&target, through, to, time)
                        }
                        fn subtract(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::subtract(&target, path, options)
                        }
                        fn get_intersections(
                            &self,
                            path: super::PathItem,
                            include: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_intersections(&target, path, include)
                        }
                        fn exclude(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::exclude(&target, path, options)
                        }
                        fn set_clockwise(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::set_clockwise(&target, value)
                        }
                        fn clockwise(&self) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::clockwise(&target)
                        }
                    }
                    impl Item_Trait for Ellipse {
                        fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::responds(&target, type_)
                        }
                        fn copy_content(
                            &self,
                            source: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_content(&target, source)
                        }
                        fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_opacity(&target, value)
                        }
                        fn opacity(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::opacity(&target)
                        }
                        fn set_on_frame(
                            &mut self,
                            value: super::ItemOnFrame,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_frame(&target, value)
                        }
                        fn on_frame(&self) -> std::result::Result<super::ItemOnFrame, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_frame(&target)
                        }
                        fn remove_children_FnToVecOfItem(
                            &self,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_children_FnToVecOfItem(&target)
                        }
                        fn remove_children_FnF64AndF64ToVecOfItem(
                            &self,
                            start: f64,
                            end: f64,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_children_FnF64AndF64ToVecOfItem(&target, start, end)
                        }
                        fn is_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_below(&target, item)
                        }
                        fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_stroke(&target)
                        }
                        fn set_global_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_global_matrix(&target, value)
                        }
                        fn global_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_matrix(&target)
                        }
                        fn copy_attributes(
                            &self,
                            source: super::Item,
                            exclude_matrix: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_attributes(&target, source, exclude_matrix)
                        }
                        fn set_on_mouse_move(
                            &mut self,
                            value: super::ItemOnMouseMove,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_move(&target, value)
                        }
                        fn on_mouse_move(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseMove, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_move(&target)
                        }
                        fn set_position(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_position(&target, value)
                        }
                        fn position(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::position(&target)
                        }
                        fn set_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_bounds(&target, value)
                        }
                        fn bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::bounds(&target)
                        }
                        fn set_shadow_blur(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_shadow_blur(&target, value)
                        }
                        fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_blur(&target)
                        }
                        fn set_selected_color(
                            &mut self,
                            value: super::ItemSelectedColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_selected_color(&target, value)
                        }
                        fn selected_color(
                            &self,
                        ) -> std::result::Result<super::ItemSelectedColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::selected_color(&target)
                        }
                        fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::reverse_children(&target)
                        }
                        fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::bring_to_front(&target)
                        }
                        fn set_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_selected(&target, value)
                        }
                        fn selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::selected(&target)
                        }
                        fn add_children(
                            &self,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_children(&target, items)
                        }
                        fn tween_to(
                            &self,
                            to: JsValue,
                            options: super::ItemTweenToParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_to(&target, to, options)
                        }
                        fn set_project(
                            &mut self,
                            value: super::Project,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_project(&target, value)
                        }
                        fn project(&self) -> std::result::Result<super::Project, JsValue> {
                            let target: Item = self.into();
                            super::Item::project(&target)
                        }
                        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_name(&target, value)
                        }
                        fn name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::name(&target)
                        }
                        fn set_stroke_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_bounds(&target, value)
                        }
                        fn stroke_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_bounds(&target)
                        }
                        fn insert_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_below(&target, item)
                        }
                        fn set_blend_mode(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_blend_mode(&target, value)
                        }
                        fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::blend_mode(&target)
                        }
                        fn set_clip_mask(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_clip_mask(&target, value)
                        }
                        fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::clip_mask(&target)
                        }
                        fn set_fill_color(
                            &mut self,
                            value: super::ItemFillColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_fill_color(&target, value)
                        }
                        fn fill_color(&self) -> std::result::Result<super::ItemFillColor, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_color(&target)
                        }
                        fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_drag(&target)
                        }
                        fn add_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_child(&target, item)
                        }
                        fn scale_FnF64AndPointTo(
                            &self,
                            scale: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::scale_FnF64AndPointTo(&target, scale, center)
                        }
                        fn scale_FnF64AndF64AndPointTo(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::scale_FnF64AndF64AndPointTo(&target, hor, ver, center)
                        }
                        fn set_first_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_first_child(&target, value)
                        }
                        fn first_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::first_child(&target)
                        }
                        fn set_style(
                            &mut self,
                            value: super::Style,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_style(&target, value)
                        }
                        fn style(&self) -> std::result::Result<super::Style, JsValue> {
                            let target: Item = self.into();
                            super::Item::style(&target)
                        }
                        fn set_class_name(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_class_name(&target, value)
                        }
                        fn class_name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::class_name(&target)
                        }
                        fn is_grouped_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_grouped_with(&target, item)
                        }
                        fn set_shadow_offset(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_shadow_offset(&target, value)
                        }
                        fn shadow_offset(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_offset(&target)
                        }
                        fn is_inside(
                            &self,
                            rect: super::Rectangle,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inside(&target, rect)
                        }
                        fn set_children(
                            &mut self,
                            value: Vec<Item>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_children(&target, value)
                        }
                        fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::children(&target)
                        }
                        fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_fill(&target)
                        }
                        fn matches_FnItemMatchesParamsOptionsToBool(
                            &self,
                            options: super::ItemMatchesParamsOptions,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::matches_FnItemMatchesParamsOptionsToBool(&target, options)
                        }
                        fn matches_FnStringAndJsValueToBool(
                            &self,
                            name: String,
                            compare: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::matches_FnStringAndJsValueToBool(&target, name, compare)
                        }
                        fn set_on_double_click(
                            &mut self,
                            value: super::ItemOnDoubleClick,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_double_click(&target, value)
                        }
                        fn on_double_click(
                            &self,
                        ) -> std::result::Result<super::ItemOnDoubleClick, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_double_click(&target)
                        }
                        fn intersects(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::intersects(&target, item)
                        }
                        fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_rotation(&target, value)
                        }
                        fn rotation(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::rotation(&target)
                        }
                        fn set_on_mouse_down(
                            &mut self,
                            value: super::ItemOnMouseDown,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_down(&target, value)
                        }
                        fn on_mouse_down(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDown, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_down(&target)
                        }
                        fn is_sibling(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_sibling(&target, item)
                        }
                        fn tween_from(
                            &self,
                            from: JsValue,
                            options: super::ItemTweenFromParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_from(&target, from, options)
                        }
                        fn set_layer(
                            &mut self,
                            value: super::Layer,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_layer(&target, value)
                        }
                        fn layer(&self) -> std::result::Result<super::Layer, JsValue> {
                            let target: Item = self.into();
                            super::Item::layer(&target)
                        }
                        fn contains(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::contains(&target, point)
                        }
                        fn set_on_click(
                            &mut self,
                            value: super::ItemOnClick,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_click(&target, value)
                        }
                        fn on_click(&self) -> std::result::Result<super::ItemOnClick, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_click(&target)
                        }
                        fn set_last_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_last_child(&target, value)
                        }
                        fn last_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::last_child(&target)
                        }
                        fn set_dash_offset(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_dash_offset(&target, value)
                        }
                        fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_offset(&target)
                        }
                        fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_id(&target, value)
                        }
                        fn id(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::id(&target)
                        }
                        fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_shadow(&target)
                        }
                        fn tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                            &self,
                            from: JsValue,
                            to: JsValue,
                            options: super::ItemTweenParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                                &target, from, to, options,
                            )
                        }
                        fn tween_FnJsValueAndItemTweenParamsOptionsToTween(
                            &self,
                            to: JsValue,
                            options: super::ItemTweenParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_FnJsValueAndItemTweenParamsOptionsToTween(
                                &target, to, options,
                            )
                        }
                        fn tween_FnItemTweenParamsOptionsToTween(
                            &self,
                            options: super::ItemTweenParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_FnItemTweenParamsOptionsToTween(&target, options)
                        }
                        fn set_scaling(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_scaling(&target, value)
                        }
                        fn scaling(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::scaling(&target)
                        }
                        fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::send_to_back(&target)
                        }
                        fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::set(&target, props)
                        }
                        fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_index(&target, value)
                        }
                        fn index(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::index(&target)
                        }
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::reduce(&target, options)
                        }
                        fn set_pivot(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_pivot(&target, value)
                        }
                        fn pivot(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::pivot(&target)
                        }
                        fn insert_children(
                            &self,
                            index: f64,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_children(&target, index, items)
                        }
                        fn set_on_mouse_up(
                            &mut self,
                            value: super::ItemOnMouseUp,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_up(&target, value)
                        }
                        fn on_mouse_up(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseUp, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_up(&target)
                        }
                        fn set_stroke_width(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_width(&target, value)
                        }
                        fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_width(&target)
                        }
                        fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on(&target, options)
                        }
                        fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_up(&target)
                        }
                        fn is_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_child(&target, item)
                        }
                        fn replace_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::replace_with(&target, item)
                        }
                        fn export_json(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::export_json(&target, options)
                        }
                        fn hit_test_all(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<Vec<HitResult>, JsValue> {
                            let target: Item = self.into();
                            super::Item::hit_test_all(&target, point, options)
                        }
                        fn export_svg(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::ItemExportSvgReturn, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::export_svg(&target, options)
                        }
                        fn copy_to(
                            &self,
                            owner: super::ItemCopyToParamsOwner,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_to(&target, owner)
                        }
                        fn set_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_matrix(&target, value)
                        }
                        fn matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::matrix(&target)
                        }
                        fn add_to(
                            &self,
                            owner: super::ItemAddToParamsOwner,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_to(&target, owner)
                        }
                        fn rotate(
                            &self,
                            angle: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::rotate(&target, angle, center)
                        }
                        fn set_view_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_view_matrix(&target, value)
                        }
                        fn view_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::view_matrix(&target)
                        }
                        fn set_previous_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_previous_sibling(&target, value)
                        }
                        fn previous_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::previous_sibling(&target)
                        }
                        fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_data(&target, value)
                        }
                        fn data(&self) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::data(&target)
                        }
                        fn off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                            &self,
                            type_: String,
                            callback: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super :: Item :: off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                        }
                        fn off_FnJsValueToJsValue(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::off_FnJsValueToJsValue(&target, object)
                        }
                        fn set_stroke_scaling(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_scaling(&target, value)
                        }
                        fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_scaling(&target)
                        }
                        fn insert_child(
                            &self,
                            index: f64,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_child(&target, index, item)
                        }
                        fn skew_FnPointAndPointTo(
                            &self,
                            skew: super::Point,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::skew_FnPointAndPointTo(&target, skew, center)
                        }
                        fn skew_FnF64AndF64AndPointTo(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::skew_FnF64AndF64AndPointTo(&target, hor, ver, center)
                        }
                        fn on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                            &self,
                            type_: String,
                            callback: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super :: Item :: on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                        }
                        fn on_FnJsValueToJsValue(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_FnJsValueToJsValue(&target, object)
                        }
                        fn remove(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove(&target)
                        }
                        fn global_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_to_local(&target, point)
                        }
                        fn emit(
                            &self,
                            type_: String,
                            event: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::emit(&target, type_, event)
                        }
                        fn hit_test(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<super::HitResult, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::hit_test(&target, point, options)
                        }
                        fn import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                            &self,
                            svg: super::ItemImportSvgParamsSvg,
                            options: JsValue,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                                &target, svg, options,
                            )
                        }
                        fn import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem(
                            &self,
                            svg: super::ItemImportSvgParamsSvg,
                            on_load: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super :: Item :: import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem (& target , svg , on_load)
                        }
                        fn set_dash_array(
                            &mut self,
                            value: Vec<f64>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_dash_array(&target, value)
                        }
                        fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_array(&target)
                        }
                        fn shear_FnPointAndPointTo(
                            &self,
                            shear: super::Point,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::shear_FnPointAndPointTo(&target, shear, center)
                        }
                        fn shear_FnF64AndF64AndPointTo(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::shear_FnF64AndF64AndPointTo(&target, hor, ver, center)
                        }
                        fn set_internal_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_internal_bounds(&target, value)
                        }
                        fn internal_bounds(
                            &self,
                        ) -> std::result::Result<super::Rectangle, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::internal_bounds(&target)
                        }
                        fn set_stroke_cap(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_cap(&target, value)
                        }
                        fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_cap(&target)
                        }
                        fn set_on_mouse_enter(
                            &mut self,
                            value: super::ItemOnMouseEnter,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_enter(&target, value)
                        }
                        fn on_mouse_enter(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseEnter, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_enter(&target)
                        }
                        fn set_view(
                            &mut self,
                            value: super::View,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_view(&target, value)
                        }
                        fn view(&self) -> std::result::Result<super::View, JsValue> {
                            let target: Item = self.into();
                            super::Item::view(&target)
                        }
                        fn set_stroke_join(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_join(&target, value)
                        }
                        fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_join(&target)
                        }
                        fn is_ancestor(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_ancestor(&target, item)
                        }
                        fn set_fill_rule(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_fill_rule(&target, value)
                        }
                        fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_rule(&target)
                        }
                        fn fit_bounds(
                            &self,
                            rectangle: super::Rectangle,
                            fill: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::fit_bounds(&target, rectangle, fill)
                        }
                        fn local_to_parent(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_parent(&target, point)
                        }
                        fn set_handle_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_handle_bounds(&target, value)
                        }
                        fn handle_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::handle_bounds(&target)
                        }
                        fn set_next_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_next_sibling(&target, value)
                        }
                        fn next_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::next_sibling(&target)
                        }
                        fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::clone(&target, options)
                        }
                        fn is_descendant(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_descendant(&target, item)
                        }
                        fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_down(&target)
                        }
                        fn is_parent(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_parent(&target, item)
                        }
                        fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_move(&target)
                        }
                        fn is_empty(
                            &self,
                            recursively: bool,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_empty(&target, recursively)
                        }
                        fn rasterize(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Raster, JsValue> {
                            let target: Item = self.into();
                            super::Item::rasterize(&target, options)
                        }
                        fn set_shadow_color(
                            &mut self,
                            value: super::ItemShadowColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_shadow_color(&target, value)
                        }
                        fn shadow_color(
                            &self,
                        ) -> std::result::Result<super::ItemShadowColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::shadow_color(&target)
                        }
                        fn set_miter_limit(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_miter_limit(&target, value)
                        }
                        fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::miter_limit(&target)
                        }
                        fn get_item(
                            &self,
                            options: super::ItemGetItemParamsOptions,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_item(&target, options)
                        }
                        fn import_json(
                            &self,
                            json: String,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_json(&target, json)
                        }
                        fn insert_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_above(&target, item)
                        }
                        fn set_on_mouse_drag(
                            &mut self,
                            value: super::ItemOnMouseDrag,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_drag(&target, value)
                        }
                        fn on_mouse_drag(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDrag, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_drag(&target)
                        }
                        fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inserted(&target)
                        }
                        fn set_apply_matrix(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_apply_matrix(&target, value)
                        }
                        fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::apply_matrix(&target)
                        }
                        fn transform(
                            &self,
                            matrix: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::transform(&target, matrix)
                        }
                        fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_visible(&target, value)
                        }
                        fn visible(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::visible(&target)
                        }
                        fn set_stroke_color(
                            &mut self,
                            value: super::ItemStrokeColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_color(&target, value)
                        }
                        fn stroke_color(
                            &self,
                        ) -> std::result::Result<super::ItemStrokeColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::stroke_color(&target)
                        }
                        fn set_on_mouse_leave(
                            &mut self,
                            value: super::ItemOnMouseLeave,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_leave(&target, value)
                        }
                        fn on_mouse_leave(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseLeave, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_leave(&target)
                        }
                        fn parent_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent_to_local(&target, point)
                        }
                        fn is_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_above(&target, item)
                        }
                        fn get_items(
                            &self,
                            options: super::ItemGetItemsParamsOptions,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_items(&target, options)
                        }
                        fn has_children(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_children(&target)
                        }
                        fn translate(
                            &self,
                            delta: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::translate(&target, delta)
                        }
                        fn set_parent(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_parent(&target, value)
                        }
                        fn parent(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent(&target)
                        }
                        fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_locked(&target, value)
                        }
                        fn locked(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::locked(&target)
                        }
                        fn local_to_global(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_global(&target, point)
                        }
                    }
                    impl Ellipse_Trait for Ellipse where Ellipse: Path_Trait {}
                    impl std::clone::Clone for Ellipse_Class {
                        fn clone(&self) -> Self {
                            Self {
                                obj: std::clone::Clone::clone(&self.obj),
                            }
                        }
                    }
                    impl serde::ser::Serialize for Ellipse_Class {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Ellipse_Class {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                        }
                    }
                    #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                    extern "C" {
                        #[allow(non_camel_case_types)]
                        # [wasm_bindgen (js_name = "RegularPolygon" , extends = Item_Class , extends = Path_Class , extends = PathItem_Class)]
                        pub type RegularPolygon_Class;
                        #[wasm_bindgen(constructor, js_class = "RegularPolygon")]
                        pub fn new_FnSuperPointAndF64AndF64ToRegularPolygon(
                            center: super::Point,
                            sides: f64,
                            radius: f64,
                        ) -> RegularPolygon_Class;
                        #[wasm_bindgen(constructor, js_class = "RegularPolygon")]
                        pub fn new_FnJsValueToRegularPolygon(
                            object: JsValue,
                        ) -> RegularPolygon_Class;
                    }
                    #[derive(std :: clone :: Clone)]
                    pub struct RegularPolygon(pub RegularPolygon_Class);
                    impl std::convert::From<&RegularPolygon> for super::Path {
                        fn from(src: &RegularPolygon) -> super::Path {
                            let src: &super::Path_Class = src.0.as_ref();
                            super::Path(src.clone())
                        }
                    }
                    impl std::convert::From<&mut RegularPolygon> for super::Path {
                        fn from(src: &mut RegularPolygon) -> super::Path {
                            let src: &super::Path_Class = src.0.as_ref();
                            super::Path(src.clone())
                        }
                    }
                    impl std::convert::From<&RegularPolygon> for super::PathItem {
                        fn from(src: &RegularPolygon) -> super::PathItem {
                            let src: &super::PathItem_Class = src.0.as_ref();
                            super::PathItem(src.clone())
                        }
                    }
                    impl std::convert::From<&mut RegularPolygon> for super::PathItem {
                        fn from(src: &mut RegularPolygon) -> super::PathItem {
                            let src: &super::PathItem_Class = src.0.as_ref();
                            super::PathItem(src.clone())
                        }
                    }
                    impl std::convert::From<&RegularPolygon> for super::Item {
                        fn from(src: &RegularPolygon) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&mut RegularPolygon> for super::Item {
                        fn from(src: &mut RegularPolygon) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<RegularPolygon> for JsValue {
                        fn from(src: RegularPolygon) -> JsValue {
                            JsValue::from(src.0)
                        }
                    }
                    impl std::convert::AsRef<JsValue> for RegularPolygon {
                        fn as_ref(&self) -> &JsValue {
                            self.0.as_ref()
                        }
                    }
                    impl wasm_bindgen::JsCast for RegularPolygon {
                        fn instanceof(val: &JsValue) -> bool {
                            RegularPolygon_Class::instanceof(val)
                        }
                        fn unchecked_from_js(val: JsValue) -> Self {
                            RegularPolygon(RegularPolygon_Class::unchecked_from_js(val))
                        }
                        fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                            unsafe {
                                &*(RegularPolygon_Class::unchecked_from_js_ref(val)
                                    as *const RegularPolygon_Class
                                    as *const Self)
                            }
                        }
                    }
                    impl RegularPolygon {
                        #[allow(dead_code, non_snake_case)]
                        pub fn new_FnSuperPointAndF64AndF64ToRegularPolygon(
                            center: super::Point,
                            sides: f64,
                            radius: f64,
                        ) -> RegularPolygon {
                            let result =
                                RegularPolygon_Class::new_FnSuperPointAndF64AndF64ToRegularPolygon(
                                    center, sides, radius,
                                );
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            RegularPolygon(result)
                        }
                        #[allow(dead_code, non_snake_case)]
                        pub fn new_FnJsValueToRegularPolygon(object: JsValue) -> RegularPolygon {
                            let result =
                                RegularPolygon_Class::new_FnJsValueToRegularPolygon(object);
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            RegularPolygon(result)
                        }
                    }
                    impl wasm_bindgen::describe::WasmDescribe for RegularPolygon {
                        fn describe() {
                            <RegularPolygon_Class as wasm_bindgen::describe::WasmDescribe>::describe(
                            )
                        }
                    }
                    impl wasm_bindgen::convert::IntoWasmAbi for RegularPolygon {
                        type Abi =
                            <RegularPolygon_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                        }
                    }
                    impl wasm_bindgen::convert::FromWasmAbi for RegularPolygon {
                        type Abi =
                            <RegularPolygon_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                        unsafe fn from_abi(js: Self::Abi) -> Self {
                            RegularPolygon(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                        }
                    }
                    impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a RegularPolygon {
                        type Abi =
                            <&'a RegularPolygon_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                        }
                    }
                    impl serde::ser::Serialize for RegularPolygon {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde::ser::Serialize::serialize(&self.0, serializer)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for RegularPolygon {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            let internal: RegularPolygon_Class =
                                <RegularPolygon_Class as serde::de::Deserialize>::deserialize(
                                    deserializer,
                                )?;
                            std::result::Result::Ok(Self(internal))
                        }
                    }
                    #[allow(non_camel_case_types, non_snake_case)]
                    pub trait RegularPolygon_Trait: Path_Trait {}
                    impl Path_Trait for RegularPolygon
                    where
                        RegularPolygon: PathItem_Trait,
                    {
                        fn set_last_segment(
                            &mut self,
                            value: super::Segment,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_last_segment(&target, value)
                        }
                        fn last_segment(&self) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::last_segment(&target)
                        }
                        fn insert_segments(
                            &self,
                            index: f64,
                            segments: Vec<Segment>,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::insert_segments(&target, index, segments)
                        }
                        fn set_curves(
                            &mut self,
                            value: Vec<Curve>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_curves(&target, value)
                        }
                        fn curves(&self) -> std::result::Result<Vec<Curve>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::curves(&target)
                        }
                        fn get_weighted_tangent_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_weighted_tangent_at(&target, offset)
                        }
                        fn set_fully_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_fully_selected(&target, value)
                        }
                        fn fully_selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::fully_selected(&target)
                        }
                        fn set_closed(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_closed(&target, value)
                        }
                        fn closed(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::closed(&target)
                        }
                        fn add(
                            &self,
                            segment: Vec<PathAddParamsSegment>,
                        ) -> std::result::Result<super::PathAddReturn, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::add(&target, segment)
                        }
                        fn get_offset_of(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_offset_of(&target, point)
                        }
                        fn add_segments(
                            &self,
                            segments: Vec<Segment>,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::add_segments(&target, segments)
                        }
                        fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::has_handles(&target)
                        }
                        fn set_first_segment(
                            &mut self,
                            value: super::Segment,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_first_segment(&target, value)
                        }
                        fn first_segment(&self) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::first_segment(&target)
                        }
                        fn set_last_curve(
                            &mut self,
                            value: super::Curve,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_last_curve(&target, value)
                        }
                        fn last_curve(&self) -> std::result::Result<super::Curve, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::last_curve(&target)
                        }
                        fn remove_segments_FnToVecOfSegment(
                            &self,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segments_FnToVecOfSegment(&target)
                        }
                        fn remove_segments_FnF64AndF64ToVecOfSegment(
                            &self,
                            from: f64,
                            to: f64,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segments_FnF64AndF64ToVecOfSegment(
                                &target, from, to,
                            )
                        }
                        fn divide_at(
                            &self,
                            location: super::PathDivideAtParamsLocation,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::divide_at(&target, location)
                        }
                        fn set_length(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_length(&target, value)
                        }
                        fn length(&self) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::length(&target)
                        }
                        fn split_at(
                            &self,
                            location: super::PathSplitAtParamsLocation,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::split_at(&target, location)
                        }
                        fn remove_segment(
                            &self,
                            index: f64,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segment(&target, index)
                        }
                        fn insert(
                            &self,
                            index: f64,
                            segment: super::PathInsertParamsSegment,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::insert(&target, index, segment)
                        }
                        fn get_location_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::get_location_at(&target, offset)
                        }
                        fn to_shape(
                            &self,
                            insert: bool,
                        ) -> std::result::Result<super::Shape, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::to_shape(&target, insert)
                        }
                        fn set_segments(
                            &mut self,
                            value: Vec<Segment>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_segments(&target, value)
                        }
                        fn segments(&self) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::segments(&target)
                        }
                        fn get_offsets_with_tangent(
                            &self,
                            tangent: super::Point,
                        ) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_offsets_with_tangent(&target, tangent)
                        }
                        fn get_weighted_normal_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_weighted_normal_at(&target, offset)
                        }
                        fn join(
                            &self,
                            path: super::Path,
                            tolerance: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::join(&target, path, tolerance)
                        }
                        fn set_area(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_area(&target, value)
                        }
                        fn area(&self) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::area(&target)
                        }
                        fn get_location_of(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::get_location_of(&target, point)
                        }
                        fn get_curvature_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_curvature_at(&target, offset)
                        }
                        fn get_normal_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_normal_at(&target, offset)
                        }
                        fn get_tangent_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_tangent_at(&target, offset)
                        }
                        fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::clear_handles(&target)
                        }
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::reduce(&target, options)
                        }
                        fn set_first_curve(
                            &mut self,
                            value: super::Curve,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_first_curve(&target, value)
                        }
                        fn first_curve(&self) -> std::result::Result<super::Curve, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::first_curve(&target)
                        }
                        fn get_point_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_point_at(&target, offset)
                        }
                    }
                    impl PathItem_Trait for RegularPolygon
                    where
                        RegularPolygon: Item_Trait,
                    {
                        fn unite(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::unite(&target, path, options)
                        }
                        fn line_by(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::line_by(&target, point)
                        }
                        fn move_to(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::move_to(&target, point)
                        }
                        fn set_path_data(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::set_path_data(&target, value)
                        }
                        fn path_data(&self) -> std::result::Result<String, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::path_data(&target)
                        }
                        fn intersect(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::intersect(&target, path, options)
                        }
                        fn create_FnStringToPathItemCreateReturn(
                            &self,
                            path_data: String,
                        ) -> std::result::Result<super::PathItemCreateReturn, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::create_FnStringToPathItemCreateReturn(
                                &target, path_data,
                            )
                        }
                        fn create_FnVecOfVecOfF64ToPathItemCreateReturn(
                            &self,
                            segments: Vec<Vec<f64>>,
                        ) -> std::result::Result<super::PathItemCreateReturn, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::create_FnVecOfVecOfF64ToPathItemCreateReturn(
                                &target, segments,
                            )
                        }
                        fn create_FnJsValueToPathItemCreateReturn(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<super::PathItemCreateReturn, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::create_FnJsValueToPathItemCreateReturn(&target, object)
                        }
                        fn smooth(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::smooth(&target, options)
                        }
                        fn compare(
                            &self,
                            path: super::PathItem,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::compare(&target, path)
                        }
                        fn arc_to_FnPointAndPointTo(
                            &self,
                            through: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_to_FnPointAndPointTo(&target, through, to)
                        }
                        fn arc_to_FnPointAndBoolTo(
                            &self,
                            to: super::Point,
                            clockwise: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_to_FnPointAndBoolTo(&target, to, clockwise)
                        }
                        fn quadratic_curve_to(
                            &self,
                            handle: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::quadratic_curve_to(&target, handle, to)
                        }
                        fn set_interior_point(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::set_interior_point(&target, value)
                        }
                        fn interior_point(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::interior_point(&target)
                        }
                        fn simplify(&self, tolerance: f64) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::simplify(&target, tolerance)
                        }
                        fn reorient(
                            &self,
                            non_zero: bool,
                            clockwise: bool,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::reorient(&target, non_zero, clockwise)
                        }
                        fn cubic_curve_by(
                            &self,
                            handle1: super::Point,
                            handle2: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::cubic_curve_by(&target, handle1, handle2, to)
                        }
                        fn close_path(&self) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::close_path(&target)
                        }
                        fn flatten(&self, flatness: f64) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::flatten(&target, flatness)
                        }
                        fn quadratic_curve_by(
                            &self,
                            handle: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::quadratic_curve_by(&target, handle, to)
                        }
                        fn cubic_curve_to(
                            &self,
                            handle1: super::Point,
                            handle2: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::cubic_curve_to(&target, handle1, handle2, to)
                        }
                        fn divide(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::divide(&target, path, options)
                        }
                        fn arc_by_FnPointAndPointTo(
                            &self,
                            through: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_by_FnPointAndPointTo(&target, through, to)
                        }
                        fn arc_by_FnPointAndBoolTo(
                            &self,
                            to: super::Point,
                            clockwise: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_by_FnPointAndBoolTo(&target, to, clockwise)
                        }
                        fn move_by(&self, to: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::move_by(&target, to)
                        }
                        fn get_nearest_location(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_nearest_location(&target, point)
                        }
                        fn reverse(&self) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::reverse(&target)
                        }
                        fn line_to(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::line_to(&target, point)
                        }
                        fn get_nearest_point(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::get_nearest_point(&target, point)
                        }
                        fn interpolate(
                            &self,
                            from: super::PathItem,
                            to: super::PathItem,
                            factor: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::interpolate(&target, from, to, factor)
                        }
                        fn get_crossings(
                            &self,
                            path: super::PathItem,
                        ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_crossings(&target, path)
                        }
                        fn curve_by(
                            &self,
                            through: super::Point,
                            to: super::Point,
                            time: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::curve_by(&target, through, to, time)
                        }
                        fn curve_to(
                            &self,
                            through: super::Point,
                            to: super::Point,
                            time: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::curve_to(&target, through, to, time)
                        }
                        fn subtract(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::subtract(&target, path, options)
                        }
                        fn get_intersections(
                            &self,
                            path: super::PathItem,
                            include: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_intersections(&target, path, include)
                        }
                        fn exclude(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::exclude(&target, path, options)
                        }
                        fn set_clockwise(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::set_clockwise(&target, value)
                        }
                        fn clockwise(&self) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::clockwise(&target)
                        }
                    }
                    impl Item_Trait for RegularPolygon {
                        fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::responds(&target, type_)
                        }
                        fn copy_content(
                            &self,
                            source: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_content(&target, source)
                        }
                        fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_opacity(&target, value)
                        }
                        fn opacity(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::opacity(&target)
                        }
                        fn set_on_frame(
                            &mut self,
                            value: super::ItemOnFrame,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_frame(&target, value)
                        }
                        fn on_frame(&self) -> std::result::Result<super::ItemOnFrame, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_frame(&target)
                        }
                        fn remove_children_FnToVecOfItem(
                            &self,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_children_FnToVecOfItem(&target)
                        }
                        fn remove_children_FnF64AndF64ToVecOfItem(
                            &self,
                            start: f64,
                            end: f64,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_children_FnF64AndF64ToVecOfItem(&target, start, end)
                        }
                        fn is_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_below(&target, item)
                        }
                        fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_stroke(&target)
                        }
                        fn set_global_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_global_matrix(&target, value)
                        }
                        fn global_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_matrix(&target)
                        }
                        fn copy_attributes(
                            &self,
                            source: super::Item,
                            exclude_matrix: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_attributes(&target, source, exclude_matrix)
                        }
                        fn set_on_mouse_move(
                            &mut self,
                            value: super::ItemOnMouseMove,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_move(&target, value)
                        }
                        fn on_mouse_move(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseMove, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_move(&target)
                        }
                        fn set_position(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_position(&target, value)
                        }
                        fn position(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::position(&target)
                        }
                        fn set_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_bounds(&target, value)
                        }
                        fn bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::bounds(&target)
                        }
                        fn set_shadow_blur(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_shadow_blur(&target, value)
                        }
                        fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_blur(&target)
                        }
                        fn set_selected_color(
                            &mut self,
                            value: super::ItemSelectedColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_selected_color(&target, value)
                        }
                        fn selected_color(
                            &self,
                        ) -> std::result::Result<super::ItemSelectedColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::selected_color(&target)
                        }
                        fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::reverse_children(&target)
                        }
                        fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::bring_to_front(&target)
                        }
                        fn set_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_selected(&target, value)
                        }
                        fn selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::selected(&target)
                        }
                        fn add_children(
                            &self,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_children(&target, items)
                        }
                        fn tween_to(
                            &self,
                            to: JsValue,
                            options: super::ItemTweenToParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_to(&target, to, options)
                        }
                        fn set_project(
                            &mut self,
                            value: super::Project,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_project(&target, value)
                        }
                        fn project(&self) -> std::result::Result<super::Project, JsValue> {
                            let target: Item = self.into();
                            super::Item::project(&target)
                        }
                        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_name(&target, value)
                        }
                        fn name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::name(&target)
                        }
                        fn set_stroke_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_bounds(&target, value)
                        }
                        fn stroke_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_bounds(&target)
                        }
                        fn insert_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_below(&target, item)
                        }
                        fn set_blend_mode(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_blend_mode(&target, value)
                        }
                        fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::blend_mode(&target)
                        }
                        fn set_clip_mask(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_clip_mask(&target, value)
                        }
                        fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::clip_mask(&target)
                        }
                        fn set_fill_color(
                            &mut self,
                            value: super::ItemFillColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_fill_color(&target, value)
                        }
                        fn fill_color(&self) -> std::result::Result<super::ItemFillColor, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_color(&target)
                        }
                        fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_drag(&target)
                        }
                        fn add_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_child(&target, item)
                        }
                        fn scale_FnF64AndPointTo(
                            &self,
                            scale: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::scale_FnF64AndPointTo(&target, scale, center)
                        }
                        fn scale_FnF64AndF64AndPointTo(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::scale_FnF64AndF64AndPointTo(&target, hor, ver, center)
                        }
                        fn set_first_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_first_child(&target, value)
                        }
                        fn first_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::first_child(&target)
                        }
                        fn set_style(
                            &mut self,
                            value: super::Style,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_style(&target, value)
                        }
                        fn style(&self) -> std::result::Result<super::Style, JsValue> {
                            let target: Item = self.into();
                            super::Item::style(&target)
                        }
                        fn set_class_name(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_class_name(&target, value)
                        }
                        fn class_name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::class_name(&target)
                        }
                        fn is_grouped_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_grouped_with(&target, item)
                        }
                        fn set_shadow_offset(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_shadow_offset(&target, value)
                        }
                        fn shadow_offset(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_offset(&target)
                        }
                        fn is_inside(
                            &self,
                            rect: super::Rectangle,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inside(&target, rect)
                        }
                        fn set_children(
                            &mut self,
                            value: Vec<Item>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_children(&target, value)
                        }
                        fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::children(&target)
                        }
                        fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_fill(&target)
                        }
                        fn matches_FnItemMatchesParamsOptionsToBool(
                            &self,
                            options: super::ItemMatchesParamsOptions,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::matches_FnItemMatchesParamsOptionsToBool(&target, options)
                        }
                        fn matches_FnStringAndJsValueToBool(
                            &self,
                            name: String,
                            compare: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::matches_FnStringAndJsValueToBool(&target, name, compare)
                        }
                        fn set_on_double_click(
                            &mut self,
                            value: super::ItemOnDoubleClick,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_double_click(&target, value)
                        }
                        fn on_double_click(
                            &self,
                        ) -> std::result::Result<super::ItemOnDoubleClick, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_double_click(&target)
                        }
                        fn intersects(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::intersects(&target, item)
                        }
                        fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_rotation(&target, value)
                        }
                        fn rotation(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::rotation(&target)
                        }
                        fn set_on_mouse_down(
                            &mut self,
                            value: super::ItemOnMouseDown,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_down(&target, value)
                        }
                        fn on_mouse_down(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDown, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_down(&target)
                        }
                        fn is_sibling(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_sibling(&target, item)
                        }
                        fn tween_from(
                            &self,
                            from: JsValue,
                            options: super::ItemTweenFromParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_from(&target, from, options)
                        }
                        fn set_layer(
                            &mut self,
                            value: super::Layer,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_layer(&target, value)
                        }
                        fn layer(&self) -> std::result::Result<super::Layer, JsValue> {
                            let target: Item = self.into();
                            super::Item::layer(&target)
                        }
                        fn contains(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::contains(&target, point)
                        }
                        fn set_on_click(
                            &mut self,
                            value: super::ItemOnClick,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_click(&target, value)
                        }
                        fn on_click(&self) -> std::result::Result<super::ItemOnClick, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_click(&target)
                        }
                        fn set_last_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_last_child(&target, value)
                        }
                        fn last_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::last_child(&target)
                        }
                        fn set_dash_offset(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_dash_offset(&target, value)
                        }
                        fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_offset(&target)
                        }
                        fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_id(&target, value)
                        }
                        fn id(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::id(&target)
                        }
                        fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_shadow(&target)
                        }
                        fn tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                            &self,
                            from: JsValue,
                            to: JsValue,
                            options: super::ItemTweenParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                                &target, from, to, options,
                            )
                        }
                        fn tween_FnJsValueAndItemTweenParamsOptionsToTween(
                            &self,
                            to: JsValue,
                            options: super::ItemTweenParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_FnJsValueAndItemTweenParamsOptionsToTween(
                                &target, to, options,
                            )
                        }
                        fn tween_FnItemTweenParamsOptionsToTween(
                            &self,
                            options: super::ItemTweenParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_FnItemTweenParamsOptionsToTween(&target, options)
                        }
                        fn set_scaling(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_scaling(&target, value)
                        }
                        fn scaling(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::scaling(&target)
                        }
                        fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::send_to_back(&target)
                        }
                        fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::set(&target, props)
                        }
                        fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_index(&target, value)
                        }
                        fn index(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::index(&target)
                        }
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::reduce(&target, options)
                        }
                        fn set_pivot(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_pivot(&target, value)
                        }
                        fn pivot(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::pivot(&target)
                        }
                        fn insert_children(
                            &self,
                            index: f64,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_children(&target, index, items)
                        }
                        fn set_on_mouse_up(
                            &mut self,
                            value: super::ItemOnMouseUp,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_up(&target, value)
                        }
                        fn on_mouse_up(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseUp, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_up(&target)
                        }
                        fn set_stroke_width(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_width(&target, value)
                        }
                        fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_width(&target)
                        }
                        fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on(&target, options)
                        }
                        fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_up(&target)
                        }
                        fn is_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_child(&target, item)
                        }
                        fn replace_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::replace_with(&target, item)
                        }
                        fn export_json(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::export_json(&target, options)
                        }
                        fn hit_test_all(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<Vec<HitResult>, JsValue> {
                            let target: Item = self.into();
                            super::Item::hit_test_all(&target, point, options)
                        }
                        fn export_svg(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::ItemExportSvgReturn, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::export_svg(&target, options)
                        }
                        fn copy_to(
                            &self,
                            owner: super::ItemCopyToParamsOwner,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_to(&target, owner)
                        }
                        fn set_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_matrix(&target, value)
                        }
                        fn matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::matrix(&target)
                        }
                        fn add_to(
                            &self,
                            owner: super::ItemAddToParamsOwner,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_to(&target, owner)
                        }
                        fn rotate(
                            &self,
                            angle: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::rotate(&target, angle, center)
                        }
                        fn set_view_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_view_matrix(&target, value)
                        }
                        fn view_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::view_matrix(&target)
                        }
                        fn set_previous_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_previous_sibling(&target, value)
                        }
                        fn previous_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::previous_sibling(&target)
                        }
                        fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_data(&target, value)
                        }
                        fn data(&self) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::data(&target)
                        }
                        fn off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                            &self,
                            type_: String,
                            callback: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super :: Item :: off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                        }
                        fn off_FnJsValueToJsValue(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::off_FnJsValueToJsValue(&target, object)
                        }
                        fn set_stroke_scaling(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_scaling(&target, value)
                        }
                        fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_scaling(&target)
                        }
                        fn insert_child(
                            &self,
                            index: f64,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_child(&target, index, item)
                        }
                        fn skew_FnPointAndPointTo(
                            &self,
                            skew: super::Point,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::skew_FnPointAndPointTo(&target, skew, center)
                        }
                        fn skew_FnF64AndF64AndPointTo(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::skew_FnF64AndF64AndPointTo(&target, hor, ver, center)
                        }
                        fn on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                            &self,
                            type_: String,
                            callback: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super :: Item :: on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                        }
                        fn on_FnJsValueToJsValue(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_FnJsValueToJsValue(&target, object)
                        }
                        fn remove(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove(&target)
                        }
                        fn global_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_to_local(&target, point)
                        }
                        fn emit(
                            &self,
                            type_: String,
                            event: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::emit(&target, type_, event)
                        }
                        fn hit_test(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<super::HitResult, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::hit_test(&target, point, options)
                        }
                        fn import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                            &self,
                            svg: super::ItemImportSvgParamsSvg,
                            options: JsValue,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                                &target, svg, options,
                            )
                        }
                        fn import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem(
                            &self,
                            svg: super::ItemImportSvgParamsSvg,
                            on_load: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super :: Item :: import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem (& target , svg , on_load)
                        }
                        fn set_dash_array(
                            &mut self,
                            value: Vec<f64>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_dash_array(&target, value)
                        }
                        fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_array(&target)
                        }
                        fn shear_FnPointAndPointTo(
                            &self,
                            shear: super::Point,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::shear_FnPointAndPointTo(&target, shear, center)
                        }
                        fn shear_FnF64AndF64AndPointTo(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::shear_FnF64AndF64AndPointTo(&target, hor, ver, center)
                        }
                        fn set_internal_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_internal_bounds(&target, value)
                        }
                        fn internal_bounds(
                            &self,
                        ) -> std::result::Result<super::Rectangle, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::internal_bounds(&target)
                        }
                        fn set_stroke_cap(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_cap(&target, value)
                        }
                        fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_cap(&target)
                        }
                        fn set_on_mouse_enter(
                            &mut self,
                            value: super::ItemOnMouseEnter,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_enter(&target, value)
                        }
                        fn on_mouse_enter(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseEnter, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_enter(&target)
                        }
                        fn set_view(
                            &mut self,
                            value: super::View,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_view(&target, value)
                        }
                        fn view(&self) -> std::result::Result<super::View, JsValue> {
                            let target: Item = self.into();
                            super::Item::view(&target)
                        }
                        fn set_stroke_join(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_join(&target, value)
                        }
                        fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_join(&target)
                        }
                        fn is_ancestor(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_ancestor(&target, item)
                        }
                        fn set_fill_rule(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_fill_rule(&target, value)
                        }
                        fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_rule(&target)
                        }
                        fn fit_bounds(
                            &self,
                            rectangle: super::Rectangle,
                            fill: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::fit_bounds(&target, rectangle, fill)
                        }
                        fn local_to_parent(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_parent(&target, point)
                        }
                        fn set_handle_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_handle_bounds(&target, value)
                        }
                        fn handle_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::handle_bounds(&target)
                        }
                        fn set_next_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_next_sibling(&target, value)
                        }
                        fn next_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::next_sibling(&target)
                        }
                        fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::clone(&target, options)
                        }
                        fn is_descendant(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_descendant(&target, item)
                        }
                        fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_down(&target)
                        }
                        fn is_parent(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_parent(&target, item)
                        }
                        fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_move(&target)
                        }
                        fn is_empty(
                            &self,
                            recursively: bool,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_empty(&target, recursively)
                        }
                        fn rasterize(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Raster, JsValue> {
                            let target: Item = self.into();
                            super::Item::rasterize(&target, options)
                        }
                        fn set_shadow_color(
                            &mut self,
                            value: super::ItemShadowColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_shadow_color(&target, value)
                        }
                        fn shadow_color(
                            &self,
                        ) -> std::result::Result<super::ItemShadowColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::shadow_color(&target)
                        }
                        fn set_miter_limit(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_miter_limit(&target, value)
                        }
                        fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::miter_limit(&target)
                        }
                        fn get_item(
                            &self,
                            options: super::ItemGetItemParamsOptions,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_item(&target, options)
                        }
                        fn import_json(
                            &self,
                            json: String,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_json(&target, json)
                        }
                        fn insert_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_above(&target, item)
                        }
                        fn set_on_mouse_drag(
                            &mut self,
                            value: super::ItemOnMouseDrag,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_drag(&target, value)
                        }
                        fn on_mouse_drag(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDrag, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_drag(&target)
                        }
                        fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inserted(&target)
                        }
                        fn set_apply_matrix(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_apply_matrix(&target, value)
                        }
                        fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::apply_matrix(&target)
                        }
                        fn transform(
                            &self,
                            matrix: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::transform(&target, matrix)
                        }
                        fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_visible(&target, value)
                        }
                        fn visible(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::visible(&target)
                        }
                        fn set_stroke_color(
                            &mut self,
                            value: super::ItemStrokeColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_color(&target, value)
                        }
                        fn stroke_color(
                            &self,
                        ) -> std::result::Result<super::ItemStrokeColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::stroke_color(&target)
                        }
                        fn set_on_mouse_leave(
                            &mut self,
                            value: super::ItemOnMouseLeave,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_leave(&target, value)
                        }
                        fn on_mouse_leave(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseLeave, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_leave(&target)
                        }
                        fn parent_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent_to_local(&target, point)
                        }
                        fn is_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_above(&target, item)
                        }
                        fn get_items(
                            &self,
                            options: super::ItemGetItemsParamsOptions,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_items(&target, options)
                        }
                        fn has_children(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_children(&target)
                        }
                        fn translate(
                            &self,
                            delta: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::translate(&target, delta)
                        }
                        fn set_parent(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_parent(&target, value)
                        }
                        fn parent(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent(&target)
                        }
                        fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_locked(&target, value)
                        }
                        fn locked(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::locked(&target)
                        }
                        fn local_to_global(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_global(&target, point)
                        }
                    }
                    impl RegularPolygon_Trait for RegularPolygon where RegularPolygon: Path_Trait {}
                    impl std::clone::Clone for RegularPolygon_Class {
                        fn clone(&self) -> Self {
                            Self {
                                obj: std::clone::Clone::clone(&self.obj),
                            }
                        }
                    }
                    impl serde::ser::Serialize for RegularPolygon_Class {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for RegularPolygon_Class {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                        }
                    }
                    #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                    extern "C" {
                        #[allow(non_camel_case_types)]
                        # [wasm_bindgen (js_name = "Rectangle" , extends = PathItem_Class , extends = Path_Class , extends = Item_Class)]
                        pub type Rectangle_Class;
                        #[wasm_bindgen(constructor, js_class = "Rectangle")]
                        pub fn new_FnSuperRectangleAndSuperSizeToRectangle(
                            rectangle: super::Rectangle,
                            radius: super::Size,
                        ) -> Rectangle_Class;
                        #[wasm_bindgen(constructor, js_class = "Rectangle")]
                        pub fn new_FnSuperPointAndSuperSizeToRectangle(
                            point: super::Point,
                            size: super::Size,
                        ) -> Rectangle_Class;
                        #[wasm_bindgen(constructor, js_class = "Rectangle")]
                        pub fn new_FnSuperPointAndSuperPointToRectangle(
                            from: super::Point,
                            to: super::Point,
                        ) -> Rectangle_Class;
                        #[wasm_bindgen(constructor, js_class = "Rectangle")]
                        pub fn new_FnJsValueToRectangle(object: JsValue) -> Rectangle_Class;
                    }
                    #[derive(std :: clone :: Clone)]
                    pub struct Rectangle(pub Rectangle_Class);
                    impl std::convert::From<&Rectangle> for super::PathItem {
                        fn from(src: &Rectangle) -> super::PathItem {
                            let src: &super::PathItem_Class = src.0.as_ref();
                            super::PathItem(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Rectangle> for super::PathItem {
                        fn from(src: &mut Rectangle) -> super::PathItem {
                            let src: &super::PathItem_Class = src.0.as_ref();
                            super::PathItem(src.clone())
                        }
                    }
                    impl std::convert::From<&Rectangle> for super::Item {
                        fn from(src: &Rectangle) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Rectangle> for super::Item {
                        fn from(src: &mut Rectangle) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&Rectangle> for super::Path {
                        fn from(src: &Rectangle) -> super::Path {
                            let src: &super::Path_Class = src.0.as_ref();
                            super::Path(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Rectangle> for super::Path {
                        fn from(src: &mut Rectangle) -> super::Path {
                            let src: &super::Path_Class = src.0.as_ref();
                            super::Path(src.clone())
                        }
                    }
                    impl std::convert::From<Rectangle> for JsValue {
                        fn from(src: Rectangle) -> JsValue {
                            JsValue::from(src.0)
                        }
                    }
                    impl std::convert::AsRef<JsValue> for Rectangle {
                        fn as_ref(&self) -> &JsValue {
                            self.0.as_ref()
                        }
                    }
                    impl wasm_bindgen::JsCast for Rectangle {
                        fn instanceof(val: &JsValue) -> bool {
                            Rectangle_Class::instanceof(val)
                        }
                        fn unchecked_from_js(val: JsValue) -> Self {
                            Rectangle(Rectangle_Class::unchecked_from_js(val))
                        }
                        fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                            unsafe {
                                &*(Rectangle_Class::unchecked_from_js_ref(val)
                                    as *const Rectangle_Class
                                    as *const Self)
                            }
                        }
                    }
                    impl Rectangle {
                        #[allow(dead_code, non_snake_case)]
                        pub fn new_FnSuperRectangleAndSuperSizeToRectangle(
                            rectangle: super::Rectangle,
                            radius: super::Size,
                        ) -> Rectangle {
                            let result =
                                Rectangle_Class::new_FnSuperRectangleAndSuperSizeToRectangle(
                                    rectangle, radius,
                                );
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            Rectangle(result)
                        }
                        #[allow(dead_code, non_snake_case)]
                        pub fn new_FnSuperPointAndSuperSizeToRectangle(
                            point: super::Point,
                            size: super::Size,
                        ) -> Rectangle {
                            let result = Rectangle_Class::new_FnSuperPointAndSuperSizeToRectangle(
                                point, size,
                            );
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            Rectangle(result)
                        }
                        #[allow(dead_code, non_snake_case)]
                        pub fn new_FnSuperPointAndSuperPointToRectangle(
                            from: super::Point,
                            to: super::Point,
                        ) -> Rectangle {
                            let result =
                                Rectangle_Class::new_FnSuperPointAndSuperPointToRectangle(from, to);
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            Rectangle(result)
                        }
                        #[allow(dead_code, non_snake_case)]
                        pub fn new_FnJsValueToRectangle(object: JsValue) -> Rectangle {
                            let result = Rectangle_Class::new_FnJsValueToRectangle(object);
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            Rectangle(result)
                        }
                    }
                    impl wasm_bindgen::describe::WasmDescribe for Rectangle {
                        fn describe() {
                            <Rectangle_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                        }
                    }
                    impl wasm_bindgen::convert::IntoWasmAbi for Rectangle {
                        type Abi = <Rectangle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                        }
                    }
                    impl wasm_bindgen::convert::FromWasmAbi for Rectangle {
                        type Abi = <Rectangle_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                        unsafe fn from_abi(js: Self::Abi) -> Self {
                            Rectangle(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                        }
                    }
                    impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Rectangle {
                        type Abi = <&'a Rectangle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                        }
                    }
                    impl serde::ser::Serialize for Rectangle {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde::ser::Serialize::serialize(&self.0, serializer)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Rectangle {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            let internal: Rectangle_Class =
                                <Rectangle_Class as serde::de::Deserialize>::deserialize(
                                    deserializer,
                                )?;
                            std::result::Result::Ok(Self(internal))
                        }
                    }
                    #[allow(non_camel_case_types, non_snake_case)]
                    pub trait Rectangle_Trait: Path_Trait {}
                    impl Path_Trait for Rectangle
                    where
                        Rectangle: PathItem_Trait,
                    {
                        fn set_last_segment(
                            &mut self,
                            value: super::Segment,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_last_segment(&target, value)
                        }
                        fn last_segment(&self) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::last_segment(&target)
                        }
                        fn insert_segments(
                            &self,
                            index: f64,
                            segments: Vec<Segment>,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::insert_segments(&target, index, segments)
                        }
                        fn set_curves(
                            &mut self,
                            value: Vec<Curve>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_curves(&target, value)
                        }
                        fn curves(&self) -> std::result::Result<Vec<Curve>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::curves(&target)
                        }
                        fn get_weighted_tangent_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_weighted_tangent_at(&target, offset)
                        }
                        fn set_fully_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_fully_selected(&target, value)
                        }
                        fn fully_selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::fully_selected(&target)
                        }
                        fn set_closed(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_closed(&target, value)
                        }
                        fn closed(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::closed(&target)
                        }
                        fn add(
                            &self,
                            segment: Vec<PathAddParamsSegment>,
                        ) -> std::result::Result<super::PathAddReturn, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::add(&target, segment)
                        }
                        fn get_offset_of(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_offset_of(&target, point)
                        }
                        fn add_segments(
                            &self,
                            segments: Vec<Segment>,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::add_segments(&target, segments)
                        }
                        fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::has_handles(&target)
                        }
                        fn set_first_segment(
                            &mut self,
                            value: super::Segment,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_first_segment(&target, value)
                        }
                        fn first_segment(&self) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::first_segment(&target)
                        }
                        fn set_last_curve(
                            &mut self,
                            value: super::Curve,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_last_curve(&target, value)
                        }
                        fn last_curve(&self) -> std::result::Result<super::Curve, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::last_curve(&target)
                        }
                        fn remove_segments_FnToVecOfSegment(
                            &self,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segments_FnToVecOfSegment(&target)
                        }
                        fn remove_segments_FnF64AndF64ToVecOfSegment(
                            &self,
                            from: f64,
                            to: f64,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segments_FnF64AndF64ToVecOfSegment(
                                &target, from, to,
                            )
                        }
                        fn divide_at(
                            &self,
                            location: super::PathDivideAtParamsLocation,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::divide_at(&target, location)
                        }
                        fn set_length(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_length(&target, value)
                        }
                        fn length(&self) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::length(&target)
                        }
                        fn split_at(
                            &self,
                            location: super::PathSplitAtParamsLocation,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::split_at(&target, location)
                        }
                        fn remove_segment(
                            &self,
                            index: f64,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segment(&target, index)
                        }
                        fn insert(
                            &self,
                            index: f64,
                            segment: super::PathInsertParamsSegment,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::insert(&target, index, segment)
                        }
                        fn get_location_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::get_location_at(&target, offset)
                        }
                        fn to_shape(
                            &self,
                            insert: bool,
                        ) -> std::result::Result<super::Shape, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::to_shape(&target, insert)
                        }
                        fn set_segments(
                            &mut self,
                            value: Vec<Segment>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_segments(&target, value)
                        }
                        fn segments(&self) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::segments(&target)
                        }
                        fn get_offsets_with_tangent(
                            &self,
                            tangent: super::Point,
                        ) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_offsets_with_tangent(&target, tangent)
                        }
                        fn get_weighted_normal_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_weighted_normal_at(&target, offset)
                        }
                        fn join(
                            &self,
                            path: super::Path,
                            tolerance: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::join(&target, path, tolerance)
                        }
                        fn set_area(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_area(&target, value)
                        }
                        fn area(&self) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::area(&target)
                        }
                        fn get_location_of(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::get_location_of(&target, point)
                        }
                        fn get_curvature_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_curvature_at(&target, offset)
                        }
                        fn get_normal_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_normal_at(&target, offset)
                        }
                        fn get_tangent_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_tangent_at(&target, offset)
                        }
                        fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::clear_handles(&target)
                        }
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::reduce(&target, options)
                        }
                        fn set_first_curve(
                            &mut self,
                            value: super::Curve,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_first_curve(&target, value)
                        }
                        fn first_curve(&self) -> std::result::Result<super::Curve, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::first_curve(&target)
                        }
                        fn get_point_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_point_at(&target, offset)
                        }
                    }
                    impl PathItem_Trait for Rectangle
                    where
                        Rectangle: Item_Trait,
                    {
                        fn unite(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::unite(&target, path, options)
                        }
                        fn line_by(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::line_by(&target, point)
                        }
                        fn move_to(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::move_to(&target, point)
                        }
                        fn set_path_data(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::set_path_data(&target, value)
                        }
                        fn path_data(&self) -> std::result::Result<String, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::path_data(&target)
                        }
                        fn intersect(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::intersect(&target, path, options)
                        }
                        fn create_FnStringToPathItemCreateReturn(
                            &self,
                            path_data: String,
                        ) -> std::result::Result<super::PathItemCreateReturn, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::create_FnStringToPathItemCreateReturn(
                                &target, path_data,
                            )
                        }
                        fn create_FnVecOfVecOfF64ToPathItemCreateReturn(
                            &self,
                            segments: Vec<Vec<f64>>,
                        ) -> std::result::Result<super::PathItemCreateReturn, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::create_FnVecOfVecOfF64ToPathItemCreateReturn(
                                &target, segments,
                            )
                        }
                        fn create_FnJsValueToPathItemCreateReturn(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<super::PathItemCreateReturn, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::create_FnJsValueToPathItemCreateReturn(&target, object)
                        }
                        fn smooth(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::smooth(&target, options)
                        }
                        fn compare(
                            &self,
                            path: super::PathItem,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::compare(&target, path)
                        }
                        fn arc_to_FnPointAndPointTo(
                            &self,
                            through: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_to_FnPointAndPointTo(&target, through, to)
                        }
                        fn arc_to_FnPointAndBoolTo(
                            &self,
                            to: super::Point,
                            clockwise: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_to_FnPointAndBoolTo(&target, to, clockwise)
                        }
                        fn quadratic_curve_to(
                            &self,
                            handle: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::quadratic_curve_to(&target, handle, to)
                        }
                        fn set_interior_point(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::set_interior_point(&target, value)
                        }
                        fn interior_point(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::interior_point(&target)
                        }
                        fn simplify(&self, tolerance: f64) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::simplify(&target, tolerance)
                        }
                        fn reorient(
                            &self,
                            non_zero: bool,
                            clockwise: bool,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::reorient(&target, non_zero, clockwise)
                        }
                        fn cubic_curve_by(
                            &self,
                            handle1: super::Point,
                            handle2: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::cubic_curve_by(&target, handle1, handle2, to)
                        }
                        fn close_path(&self) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::close_path(&target)
                        }
                        fn flatten(&self, flatness: f64) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::flatten(&target, flatness)
                        }
                        fn quadratic_curve_by(
                            &self,
                            handle: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::quadratic_curve_by(&target, handle, to)
                        }
                        fn cubic_curve_to(
                            &self,
                            handle1: super::Point,
                            handle2: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::cubic_curve_to(&target, handle1, handle2, to)
                        }
                        fn divide(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::divide(&target, path, options)
                        }
                        fn arc_by_FnPointAndPointTo(
                            &self,
                            through: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_by_FnPointAndPointTo(&target, through, to)
                        }
                        fn arc_by_FnPointAndBoolTo(
                            &self,
                            to: super::Point,
                            clockwise: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_by_FnPointAndBoolTo(&target, to, clockwise)
                        }
                        fn move_by(&self, to: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::move_by(&target, to)
                        }
                        fn get_nearest_location(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_nearest_location(&target, point)
                        }
                        fn reverse(&self) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::reverse(&target)
                        }
                        fn line_to(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::line_to(&target, point)
                        }
                        fn get_nearest_point(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::get_nearest_point(&target, point)
                        }
                        fn interpolate(
                            &self,
                            from: super::PathItem,
                            to: super::PathItem,
                            factor: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::interpolate(&target, from, to, factor)
                        }
                        fn get_crossings(
                            &self,
                            path: super::PathItem,
                        ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_crossings(&target, path)
                        }
                        fn curve_by(
                            &self,
                            through: super::Point,
                            to: super::Point,
                            time: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::curve_by(&target, through, to, time)
                        }
                        fn curve_to(
                            &self,
                            through: super::Point,
                            to: super::Point,
                            time: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::curve_to(&target, through, to, time)
                        }
                        fn subtract(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::subtract(&target, path, options)
                        }
                        fn get_intersections(
                            &self,
                            path: super::PathItem,
                            include: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_intersections(&target, path, include)
                        }
                        fn exclude(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::exclude(&target, path, options)
                        }
                        fn set_clockwise(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::set_clockwise(&target, value)
                        }
                        fn clockwise(&self) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::clockwise(&target)
                        }
                    }
                    impl Item_Trait for Rectangle {
                        fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::responds(&target, type_)
                        }
                        fn copy_content(
                            &self,
                            source: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_content(&target, source)
                        }
                        fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_opacity(&target, value)
                        }
                        fn opacity(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::opacity(&target)
                        }
                        fn set_on_frame(
                            &mut self,
                            value: super::ItemOnFrame,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_frame(&target, value)
                        }
                        fn on_frame(&self) -> std::result::Result<super::ItemOnFrame, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_frame(&target)
                        }
                        fn remove_children_FnToVecOfItem(
                            &self,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_children_FnToVecOfItem(&target)
                        }
                        fn remove_children_FnF64AndF64ToVecOfItem(
                            &self,
                            start: f64,
                            end: f64,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_children_FnF64AndF64ToVecOfItem(&target, start, end)
                        }
                        fn is_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_below(&target, item)
                        }
                        fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_stroke(&target)
                        }
                        fn set_global_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_global_matrix(&target, value)
                        }
                        fn global_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_matrix(&target)
                        }
                        fn copy_attributes(
                            &self,
                            source: super::Item,
                            exclude_matrix: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_attributes(&target, source, exclude_matrix)
                        }
                        fn set_on_mouse_move(
                            &mut self,
                            value: super::ItemOnMouseMove,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_move(&target, value)
                        }
                        fn on_mouse_move(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseMove, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_move(&target)
                        }
                        fn set_position(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_position(&target, value)
                        }
                        fn position(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::position(&target)
                        }
                        fn set_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_bounds(&target, value)
                        }
                        fn bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::bounds(&target)
                        }
                        fn set_shadow_blur(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_shadow_blur(&target, value)
                        }
                        fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_blur(&target)
                        }
                        fn set_selected_color(
                            &mut self,
                            value: super::ItemSelectedColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_selected_color(&target, value)
                        }
                        fn selected_color(
                            &self,
                        ) -> std::result::Result<super::ItemSelectedColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::selected_color(&target)
                        }
                        fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::reverse_children(&target)
                        }
                        fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::bring_to_front(&target)
                        }
                        fn set_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_selected(&target, value)
                        }
                        fn selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::selected(&target)
                        }
                        fn add_children(
                            &self,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_children(&target, items)
                        }
                        fn tween_to(
                            &self,
                            to: JsValue,
                            options: super::ItemTweenToParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_to(&target, to, options)
                        }
                        fn set_project(
                            &mut self,
                            value: super::Project,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_project(&target, value)
                        }
                        fn project(&self) -> std::result::Result<super::Project, JsValue> {
                            let target: Item = self.into();
                            super::Item::project(&target)
                        }
                        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_name(&target, value)
                        }
                        fn name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::name(&target)
                        }
                        fn set_stroke_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_bounds(&target, value)
                        }
                        fn stroke_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_bounds(&target)
                        }
                        fn insert_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_below(&target, item)
                        }
                        fn set_blend_mode(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_blend_mode(&target, value)
                        }
                        fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::blend_mode(&target)
                        }
                        fn set_clip_mask(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_clip_mask(&target, value)
                        }
                        fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::clip_mask(&target)
                        }
                        fn set_fill_color(
                            &mut self,
                            value: super::ItemFillColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_fill_color(&target, value)
                        }
                        fn fill_color(&self) -> std::result::Result<super::ItemFillColor, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_color(&target)
                        }
                        fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_drag(&target)
                        }
                        fn add_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_child(&target, item)
                        }
                        fn scale_FnF64AndPointTo(
                            &self,
                            scale: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::scale_FnF64AndPointTo(&target, scale, center)
                        }
                        fn scale_FnF64AndF64AndPointTo(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::scale_FnF64AndF64AndPointTo(&target, hor, ver, center)
                        }
                        fn set_first_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_first_child(&target, value)
                        }
                        fn first_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::first_child(&target)
                        }
                        fn set_style(
                            &mut self,
                            value: super::Style,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_style(&target, value)
                        }
                        fn style(&self) -> std::result::Result<super::Style, JsValue> {
                            let target: Item = self.into();
                            super::Item::style(&target)
                        }
                        fn set_class_name(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_class_name(&target, value)
                        }
                        fn class_name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::class_name(&target)
                        }
                        fn is_grouped_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_grouped_with(&target, item)
                        }
                        fn set_shadow_offset(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_shadow_offset(&target, value)
                        }
                        fn shadow_offset(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_offset(&target)
                        }
                        fn is_inside(
                            &self,
                            rect: super::Rectangle,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inside(&target, rect)
                        }
                        fn set_children(
                            &mut self,
                            value: Vec<Item>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_children(&target, value)
                        }
                        fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::children(&target)
                        }
                        fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_fill(&target)
                        }
                        fn matches_FnItemMatchesParamsOptionsToBool(
                            &self,
                            options: super::ItemMatchesParamsOptions,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::matches_FnItemMatchesParamsOptionsToBool(&target, options)
                        }
                        fn matches_FnStringAndJsValueToBool(
                            &self,
                            name: String,
                            compare: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::matches_FnStringAndJsValueToBool(&target, name, compare)
                        }
                        fn set_on_double_click(
                            &mut self,
                            value: super::ItemOnDoubleClick,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_double_click(&target, value)
                        }
                        fn on_double_click(
                            &self,
                        ) -> std::result::Result<super::ItemOnDoubleClick, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_double_click(&target)
                        }
                        fn intersects(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::intersects(&target, item)
                        }
                        fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_rotation(&target, value)
                        }
                        fn rotation(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::rotation(&target)
                        }
                        fn set_on_mouse_down(
                            &mut self,
                            value: super::ItemOnMouseDown,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_down(&target, value)
                        }
                        fn on_mouse_down(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDown, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_down(&target)
                        }
                        fn is_sibling(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_sibling(&target, item)
                        }
                        fn tween_from(
                            &self,
                            from: JsValue,
                            options: super::ItemTweenFromParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_from(&target, from, options)
                        }
                        fn set_layer(
                            &mut self,
                            value: super::Layer,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_layer(&target, value)
                        }
                        fn layer(&self) -> std::result::Result<super::Layer, JsValue> {
                            let target: Item = self.into();
                            super::Item::layer(&target)
                        }
                        fn contains(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::contains(&target, point)
                        }
                        fn set_on_click(
                            &mut self,
                            value: super::ItemOnClick,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_click(&target, value)
                        }
                        fn on_click(&self) -> std::result::Result<super::ItemOnClick, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_click(&target)
                        }
                        fn set_last_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_last_child(&target, value)
                        }
                        fn last_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::last_child(&target)
                        }
                        fn set_dash_offset(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_dash_offset(&target, value)
                        }
                        fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_offset(&target)
                        }
                        fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_id(&target, value)
                        }
                        fn id(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::id(&target)
                        }
                        fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_shadow(&target)
                        }
                        fn tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                            &self,
                            from: JsValue,
                            to: JsValue,
                            options: super::ItemTweenParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                                &target, from, to, options,
                            )
                        }
                        fn tween_FnJsValueAndItemTweenParamsOptionsToTween(
                            &self,
                            to: JsValue,
                            options: super::ItemTweenParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_FnJsValueAndItemTweenParamsOptionsToTween(
                                &target, to, options,
                            )
                        }
                        fn tween_FnItemTweenParamsOptionsToTween(
                            &self,
                            options: super::ItemTweenParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_FnItemTweenParamsOptionsToTween(&target, options)
                        }
                        fn set_scaling(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_scaling(&target, value)
                        }
                        fn scaling(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::scaling(&target)
                        }
                        fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::send_to_back(&target)
                        }
                        fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::set(&target, props)
                        }
                        fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_index(&target, value)
                        }
                        fn index(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::index(&target)
                        }
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::reduce(&target, options)
                        }
                        fn set_pivot(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_pivot(&target, value)
                        }
                        fn pivot(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::pivot(&target)
                        }
                        fn insert_children(
                            &self,
                            index: f64,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_children(&target, index, items)
                        }
                        fn set_on_mouse_up(
                            &mut self,
                            value: super::ItemOnMouseUp,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_up(&target, value)
                        }
                        fn on_mouse_up(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseUp, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_up(&target)
                        }
                        fn set_stroke_width(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_width(&target, value)
                        }
                        fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_width(&target)
                        }
                        fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on(&target, options)
                        }
                        fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_up(&target)
                        }
                        fn is_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_child(&target, item)
                        }
                        fn replace_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::replace_with(&target, item)
                        }
                        fn export_json(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::export_json(&target, options)
                        }
                        fn hit_test_all(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<Vec<HitResult>, JsValue> {
                            let target: Item = self.into();
                            super::Item::hit_test_all(&target, point, options)
                        }
                        fn export_svg(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::ItemExportSvgReturn, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::export_svg(&target, options)
                        }
                        fn copy_to(
                            &self,
                            owner: super::ItemCopyToParamsOwner,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_to(&target, owner)
                        }
                        fn set_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_matrix(&target, value)
                        }
                        fn matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::matrix(&target)
                        }
                        fn add_to(
                            &self,
                            owner: super::ItemAddToParamsOwner,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_to(&target, owner)
                        }
                        fn rotate(
                            &self,
                            angle: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::rotate(&target, angle, center)
                        }
                        fn set_view_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_view_matrix(&target, value)
                        }
                        fn view_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::view_matrix(&target)
                        }
                        fn set_previous_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_previous_sibling(&target, value)
                        }
                        fn previous_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::previous_sibling(&target)
                        }
                        fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_data(&target, value)
                        }
                        fn data(&self) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::data(&target)
                        }
                        fn off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                            &self,
                            type_: String,
                            callback: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super :: Item :: off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                        }
                        fn off_FnJsValueToJsValue(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::off_FnJsValueToJsValue(&target, object)
                        }
                        fn set_stroke_scaling(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_scaling(&target, value)
                        }
                        fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_scaling(&target)
                        }
                        fn insert_child(
                            &self,
                            index: f64,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_child(&target, index, item)
                        }
                        fn skew_FnPointAndPointTo(
                            &self,
                            skew: super::Point,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::skew_FnPointAndPointTo(&target, skew, center)
                        }
                        fn skew_FnF64AndF64AndPointTo(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::skew_FnF64AndF64AndPointTo(&target, hor, ver, center)
                        }
                        fn on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                            &self,
                            type_: String,
                            callback: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super :: Item :: on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                        }
                        fn on_FnJsValueToJsValue(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_FnJsValueToJsValue(&target, object)
                        }
                        fn remove(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove(&target)
                        }
                        fn global_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_to_local(&target, point)
                        }
                        fn emit(
                            &self,
                            type_: String,
                            event: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::emit(&target, type_, event)
                        }
                        fn hit_test(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<super::HitResult, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::hit_test(&target, point, options)
                        }
                        fn import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                            &self,
                            svg: super::ItemImportSvgParamsSvg,
                            options: JsValue,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                                &target, svg, options,
                            )
                        }
                        fn import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem(
                            &self,
                            svg: super::ItemImportSvgParamsSvg,
                            on_load: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super :: Item :: import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem (& target , svg , on_load)
                        }
                        fn set_dash_array(
                            &mut self,
                            value: Vec<f64>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_dash_array(&target, value)
                        }
                        fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_array(&target)
                        }
                        fn shear_FnPointAndPointTo(
                            &self,
                            shear: super::Point,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::shear_FnPointAndPointTo(&target, shear, center)
                        }
                        fn shear_FnF64AndF64AndPointTo(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::shear_FnF64AndF64AndPointTo(&target, hor, ver, center)
                        }
                        fn set_internal_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_internal_bounds(&target, value)
                        }
                        fn internal_bounds(
                            &self,
                        ) -> std::result::Result<super::Rectangle, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::internal_bounds(&target)
                        }
                        fn set_stroke_cap(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_cap(&target, value)
                        }
                        fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_cap(&target)
                        }
                        fn set_on_mouse_enter(
                            &mut self,
                            value: super::ItemOnMouseEnter,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_enter(&target, value)
                        }
                        fn on_mouse_enter(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseEnter, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_enter(&target)
                        }
                        fn set_view(
                            &mut self,
                            value: super::View,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_view(&target, value)
                        }
                        fn view(&self) -> std::result::Result<super::View, JsValue> {
                            let target: Item = self.into();
                            super::Item::view(&target)
                        }
                        fn set_stroke_join(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_join(&target, value)
                        }
                        fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_join(&target)
                        }
                        fn is_ancestor(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_ancestor(&target, item)
                        }
                        fn set_fill_rule(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_fill_rule(&target, value)
                        }
                        fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_rule(&target)
                        }
                        fn fit_bounds(
                            &self,
                            rectangle: super::Rectangle,
                            fill: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::fit_bounds(&target, rectangle, fill)
                        }
                        fn local_to_parent(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_parent(&target, point)
                        }
                        fn set_handle_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_handle_bounds(&target, value)
                        }
                        fn handle_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::handle_bounds(&target)
                        }
                        fn set_next_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_next_sibling(&target, value)
                        }
                        fn next_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::next_sibling(&target)
                        }
                        fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::clone(&target, options)
                        }
                        fn is_descendant(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_descendant(&target, item)
                        }
                        fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_down(&target)
                        }
                        fn is_parent(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_parent(&target, item)
                        }
                        fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_move(&target)
                        }
                        fn is_empty(
                            &self,
                            recursively: bool,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_empty(&target, recursively)
                        }
                        fn rasterize(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Raster, JsValue> {
                            let target: Item = self.into();
                            super::Item::rasterize(&target, options)
                        }
                        fn set_shadow_color(
                            &mut self,
                            value: super::ItemShadowColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_shadow_color(&target, value)
                        }
                        fn shadow_color(
                            &self,
                        ) -> std::result::Result<super::ItemShadowColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::shadow_color(&target)
                        }
                        fn set_miter_limit(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_miter_limit(&target, value)
                        }
                        fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::miter_limit(&target)
                        }
                        fn get_item(
                            &self,
                            options: super::ItemGetItemParamsOptions,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_item(&target, options)
                        }
                        fn import_json(
                            &self,
                            json: String,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_json(&target, json)
                        }
                        fn insert_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_above(&target, item)
                        }
                        fn set_on_mouse_drag(
                            &mut self,
                            value: super::ItemOnMouseDrag,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_drag(&target, value)
                        }
                        fn on_mouse_drag(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDrag, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_drag(&target)
                        }
                        fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inserted(&target)
                        }
                        fn set_apply_matrix(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_apply_matrix(&target, value)
                        }
                        fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::apply_matrix(&target)
                        }
                        fn transform(
                            &self,
                            matrix: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::transform(&target, matrix)
                        }
                        fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_visible(&target, value)
                        }
                        fn visible(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::visible(&target)
                        }
                        fn set_stroke_color(
                            &mut self,
                            value: super::ItemStrokeColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_color(&target, value)
                        }
                        fn stroke_color(
                            &self,
                        ) -> std::result::Result<super::ItemStrokeColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::stroke_color(&target)
                        }
                        fn set_on_mouse_leave(
                            &mut self,
                            value: super::ItemOnMouseLeave,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_leave(&target, value)
                        }
                        fn on_mouse_leave(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseLeave, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_leave(&target)
                        }
                        fn parent_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent_to_local(&target, point)
                        }
                        fn is_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_above(&target, item)
                        }
                        fn get_items(
                            &self,
                            options: super::ItemGetItemsParamsOptions,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_items(&target, options)
                        }
                        fn has_children(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_children(&target)
                        }
                        fn translate(
                            &self,
                            delta: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::translate(&target, delta)
                        }
                        fn set_parent(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_parent(&target, value)
                        }
                        fn parent(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent(&target)
                        }
                        fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_locked(&target, value)
                        }
                        fn locked(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::locked(&target)
                        }
                        fn local_to_global(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_global(&target, point)
                        }
                    }
                    impl Rectangle_Trait for Rectangle where Rectangle: Path_Trait {}
                    impl std::clone::Clone for Rectangle_Class {
                        fn clone(&self) -> Self {
                            Self {
                                obj: std::clone::Clone::clone(&self.obj),
                            }
                        }
                    }
                    impl serde::ser::Serialize for Rectangle_Class {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Rectangle_Class {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                        }
                    }
                    #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                    extern "C" {
                        #[allow(non_camel_case_types)]
                        # [wasm_bindgen (js_name = "Arc" , extends = Item_Class , extends = PathItem_Class , extends = Path_Class)]
                        pub type Arc_Class;
                        #[wasm_bindgen(constructor, js_class = "Arc")]
                        pub fn new_FnSuperPointAndSuperPointAndSuperPointToArc(
                            from: super::Point,
                            through: super::Point,
                            to: super::Point,
                        ) -> Arc_Class;
                        #[wasm_bindgen(constructor, js_class = "Arc")]
                        pub fn new_FnJsValueToArc(object: JsValue) -> Arc_Class;
                    }
                    #[derive(std :: clone :: Clone)]
                    pub struct Arc(pub Arc_Class);
                    impl std::convert::From<&Arc> for super::Item {
                        fn from(src: &Arc) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Arc> for super::Item {
                        fn from(src: &mut Arc) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&Arc> for super::PathItem {
                        fn from(src: &Arc) -> super::PathItem {
                            let src: &super::PathItem_Class = src.0.as_ref();
                            super::PathItem(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Arc> for super::PathItem {
                        fn from(src: &mut Arc) -> super::PathItem {
                            let src: &super::PathItem_Class = src.0.as_ref();
                            super::PathItem(src.clone())
                        }
                    }
                    impl std::convert::From<&Arc> for super::Path {
                        fn from(src: &Arc) -> super::Path {
                            let src: &super::Path_Class = src.0.as_ref();
                            super::Path(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Arc> for super::Path {
                        fn from(src: &mut Arc) -> super::Path {
                            let src: &super::Path_Class = src.0.as_ref();
                            super::Path(src.clone())
                        }
                    }
                    impl std::convert::From<Arc> for JsValue {
                        fn from(src: Arc) -> JsValue {
                            JsValue::from(src.0)
                        }
                    }
                    impl std::convert::AsRef<JsValue> for Arc {
                        fn as_ref(&self) -> &JsValue {
                            self.0.as_ref()
                        }
                    }
                    impl wasm_bindgen::JsCast for Arc {
                        fn instanceof(val: &JsValue) -> bool {
                            Arc_Class::instanceof(val)
                        }
                        fn unchecked_from_js(val: JsValue) -> Self {
                            Arc(Arc_Class::unchecked_from_js(val))
                        }
                        fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                            unsafe {
                                &*(Arc_Class::unchecked_from_js_ref(val) as *const Arc_Class
                                    as *const Self)
                            }
                        }
                    }
                    impl Arc {
                        #[allow(dead_code, non_snake_case)]
                        pub fn new_FnSuperPointAndSuperPointAndSuperPointToArc(
                            from: super::Point,
                            through: super::Point,
                            to: super::Point,
                        ) -> Arc {
                            let result = Arc_Class::new_FnSuperPointAndSuperPointAndSuperPointToArc(
                                from, through, to,
                            );
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            Arc(result)
                        }
                        #[allow(dead_code, non_snake_case)]
                        pub fn new_FnJsValueToArc(object: JsValue) -> Arc {
                            let result = Arc_Class::new_FnJsValueToArc(object);
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            Arc(result)
                        }
                    }
                    impl wasm_bindgen::describe::WasmDescribe for Arc {
                        fn describe() {
                            <Arc_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                        }
                    }
                    impl wasm_bindgen::convert::IntoWasmAbi for Arc {
                        type Abi = <Arc_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                        }
                    }
                    impl wasm_bindgen::convert::FromWasmAbi for Arc {
                        type Abi = <Arc_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                        unsafe fn from_abi(js: Self::Abi) -> Self {
                            Arc(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                        }
                    }
                    impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Arc {
                        type Abi = <&'a Arc_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                        }
                    }
                    impl serde::ser::Serialize for Arc {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde::ser::Serialize::serialize(&self.0, serializer)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Arc {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            let internal: Arc_Class =
                                <Arc_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                            std::result::Result::Ok(Self(internal))
                        }
                    }
                    #[allow(non_camel_case_types, non_snake_case)]
                    pub trait Arc_Trait: Path_Trait {}
                    impl Path_Trait for Arc
                    where
                        Arc: PathItem_Trait,
                    {
                        fn set_last_segment(
                            &mut self,
                            value: super::Segment,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_last_segment(&target, value)
                        }
                        fn last_segment(&self) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::last_segment(&target)
                        }
                        fn insert_segments(
                            &self,
                            index: f64,
                            segments: Vec<Segment>,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::insert_segments(&target, index, segments)
                        }
                        fn set_curves(
                            &mut self,
                            value: Vec<Curve>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_curves(&target, value)
                        }
                        fn curves(&self) -> std::result::Result<Vec<Curve>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::curves(&target)
                        }
                        fn get_weighted_tangent_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_weighted_tangent_at(&target, offset)
                        }
                        fn set_fully_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_fully_selected(&target, value)
                        }
                        fn fully_selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::fully_selected(&target)
                        }
                        fn set_closed(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_closed(&target, value)
                        }
                        fn closed(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::closed(&target)
                        }
                        fn add(
                            &self,
                            segment: Vec<PathAddParamsSegment>,
                        ) -> std::result::Result<super::PathAddReturn, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::add(&target, segment)
                        }
                        fn get_offset_of(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_offset_of(&target, point)
                        }
                        fn add_segments(
                            &self,
                            segments: Vec<Segment>,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::add_segments(&target, segments)
                        }
                        fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::has_handles(&target)
                        }
                        fn set_first_segment(
                            &mut self,
                            value: super::Segment,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_first_segment(&target, value)
                        }
                        fn first_segment(&self) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::first_segment(&target)
                        }
                        fn set_last_curve(
                            &mut self,
                            value: super::Curve,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_last_curve(&target, value)
                        }
                        fn last_curve(&self) -> std::result::Result<super::Curve, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::last_curve(&target)
                        }
                        fn remove_segments_FnToVecOfSegment(
                            &self,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segments_FnToVecOfSegment(&target)
                        }
                        fn remove_segments_FnF64AndF64ToVecOfSegment(
                            &self,
                            from: f64,
                            to: f64,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segments_FnF64AndF64ToVecOfSegment(
                                &target, from, to,
                            )
                        }
                        fn divide_at(
                            &self,
                            location: super::PathDivideAtParamsLocation,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::divide_at(&target, location)
                        }
                        fn set_length(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_length(&target, value)
                        }
                        fn length(&self) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::length(&target)
                        }
                        fn split_at(
                            &self,
                            location: super::PathSplitAtParamsLocation,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::split_at(&target, location)
                        }
                        fn remove_segment(
                            &self,
                            index: f64,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segment(&target, index)
                        }
                        fn insert(
                            &self,
                            index: f64,
                            segment: super::PathInsertParamsSegment,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::insert(&target, index, segment)
                        }
                        fn get_location_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::get_location_at(&target, offset)
                        }
                        fn to_shape(
                            &self,
                            insert: bool,
                        ) -> std::result::Result<super::Shape, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::to_shape(&target, insert)
                        }
                        fn set_segments(
                            &mut self,
                            value: Vec<Segment>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_segments(&target, value)
                        }
                        fn segments(&self) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::segments(&target)
                        }
                        fn get_offsets_with_tangent(
                            &self,
                            tangent: super::Point,
                        ) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_offsets_with_tangent(&target, tangent)
                        }
                        fn get_weighted_normal_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_weighted_normal_at(&target, offset)
                        }
                        fn join(
                            &self,
                            path: super::Path,
                            tolerance: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::join(&target, path, tolerance)
                        }
                        fn set_area(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_area(&target, value)
                        }
                        fn area(&self) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::area(&target)
                        }
                        fn get_location_of(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::get_location_of(&target, point)
                        }
                        fn get_curvature_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_curvature_at(&target, offset)
                        }
                        fn get_normal_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_normal_at(&target, offset)
                        }
                        fn get_tangent_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_tangent_at(&target, offset)
                        }
                        fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::clear_handles(&target)
                        }
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::reduce(&target, options)
                        }
                        fn set_first_curve(
                            &mut self,
                            value: super::Curve,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_first_curve(&target, value)
                        }
                        fn first_curve(&self) -> std::result::Result<super::Curve, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::first_curve(&target)
                        }
                        fn get_point_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_point_at(&target, offset)
                        }
                    }
                    impl PathItem_Trait for Arc
                    where
                        Arc: Item_Trait,
                    {
                        fn unite(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::unite(&target, path, options)
                        }
                        fn line_by(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::line_by(&target, point)
                        }
                        fn move_to(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::move_to(&target, point)
                        }
                        fn set_path_data(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::set_path_data(&target, value)
                        }
                        fn path_data(&self) -> std::result::Result<String, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::path_data(&target)
                        }
                        fn intersect(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::intersect(&target, path, options)
                        }
                        fn create_FnStringToPathItemCreateReturn(
                            &self,
                            path_data: String,
                        ) -> std::result::Result<super::PathItemCreateReturn, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::create_FnStringToPathItemCreateReturn(
                                &target, path_data,
                            )
                        }
                        fn create_FnVecOfVecOfF64ToPathItemCreateReturn(
                            &self,
                            segments: Vec<Vec<f64>>,
                        ) -> std::result::Result<super::PathItemCreateReturn, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::create_FnVecOfVecOfF64ToPathItemCreateReturn(
                                &target, segments,
                            )
                        }
                        fn create_FnJsValueToPathItemCreateReturn(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<super::PathItemCreateReturn, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::create_FnJsValueToPathItemCreateReturn(&target, object)
                        }
                        fn smooth(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::smooth(&target, options)
                        }
                        fn compare(
                            &self,
                            path: super::PathItem,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::compare(&target, path)
                        }
                        fn arc_to_FnPointAndPointTo(
                            &self,
                            through: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_to_FnPointAndPointTo(&target, through, to)
                        }
                        fn arc_to_FnPointAndBoolTo(
                            &self,
                            to: super::Point,
                            clockwise: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_to_FnPointAndBoolTo(&target, to, clockwise)
                        }
                        fn quadratic_curve_to(
                            &self,
                            handle: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::quadratic_curve_to(&target, handle, to)
                        }
                        fn set_interior_point(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::set_interior_point(&target, value)
                        }
                        fn interior_point(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::interior_point(&target)
                        }
                        fn simplify(&self, tolerance: f64) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::simplify(&target, tolerance)
                        }
                        fn reorient(
                            &self,
                            non_zero: bool,
                            clockwise: bool,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::reorient(&target, non_zero, clockwise)
                        }
                        fn cubic_curve_by(
                            &self,
                            handle1: super::Point,
                            handle2: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::cubic_curve_by(&target, handle1, handle2, to)
                        }
                        fn close_path(&self) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::close_path(&target)
                        }
                        fn flatten(&self, flatness: f64) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::flatten(&target, flatness)
                        }
                        fn quadratic_curve_by(
                            &self,
                            handle: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::quadratic_curve_by(&target, handle, to)
                        }
                        fn cubic_curve_to(
                            &self,
                            handle1: super::Point,
                            handle2: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::cubic_curve_to(&target, handle1, handle2, to)
                        }
                        fn divide(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::divide(&target, path, options)
                        }
                        fn arc_by_FnPointAndPointTo(
                            &self,
                            through: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_by_FnPointAndPointTo(&target, through, to)
                        }
                        fn arc_by_FnPointAndBoolTo(
                            &self,
                            to: super::Point,
                            clockwise: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_by_FnPointAndBoolTo(&target, to, clockwise)
                        }
                        fn move_by(&self, to: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::move_by(&target, to)
                        }
                        fn get_nearest_location(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_nearest_location(&target, point)
                        }
                        fn reverse(&self) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::reverse(&target)
                        }
                        fn line_to(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::line_to(&target, point)
                        }
                        fn get_nearest_point(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::get_nearest_point(&target, point)
                        }
                        fn interpolate(
                            &self,
                            from: super::PathItem,
                            to: super::PathItem,
                            factor: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::interpolate(&target, from, to, factor)
                        }
                        fn get_crossings(
                            &self,
                            path: super::PathItem,
                        ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_crossings(&target, path)
                        }
                        fn curve_by(
                            &self,
                            through: super::Point,
                            to: super::Point,
                            time: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::curve_by(&target, through, to, time)
                        }
                        fn curve_to(
                            &self,
                            through: super::Point,
                            to: super::Point,
                            time: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::curve_to(&target, through, to, time)
                        }
                        fn subtract(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::subtract(&target, path, options)
                        }
                        fn get_intersections(
                            &self,
                            path: super::PathItem,
                            include: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_intersections(&target, path, include)
                        }
                        fn exclude(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::exclude(&target, path, options)
                        }
                        fn set_clockwise(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::set_clockwise(&target, value)
                        }
                        fn clockwise(&self) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::clockwise(&target)
                        }
                    }
                    impl Item_Trait for Arc {
                        fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::responds(&target, type_)
                        }
                        fn copy_content(
                            &self,
                            source: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_content(&target, source)
                        }
                        fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_opacity(&target, value)
                        }
                        fn opacity(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::opacity(&target)
                        }
                        fn set_on_frame(
                            &mut self,
                            value: super::ItemOnFrame,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_frame(&target, value)
                        }
                        fn on_frame(&self) -> std::result::Result<super::ItemOnFrame, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_frame(&target)
                        }
                        fn remove_children_FnToVecOfItem(
                            &self,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_children_FnToVecOfItem(&target)
                        }
                        fn remove_children_FnF64AndF64ToVecOfItem(
                            &self,
                            start: f64,
                            end: f64,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_children_FnF64AndF64ToVecOfItem(&target, start, end)
                        }
                        fn is_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_below(&target, item)
                        }
                        fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_stroke(&target)
                        }
                        fn set_global_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_global_matrix(&target, value)
                        }
                        fn global_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_matrix(&target)
                        }
                        fn copy_attributes(
                            &self,
                            source: super::Item,
                            exclude_matrix: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_attributes(&target, source, exclude_matrix)
                        }
                        fn set_on_mouse_move(
                            &mut self,
                            value: super::ItemOnMouseMove,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_move(&target, value)
                        }
                        fn on_mouse_move(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseMove, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_move(&target)
                        }
                        fn set_position(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_position(&target, value)
                        }
                        fn position(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::position(&target)
                        }
                        fn set_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_bounds(&target, value)
                        }
                        fn bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::bounds(&target)
                        }
                        fn set_shadow_blur(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_shadow_blur(&target, value)
                        }
                        fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_blur(&target)
                        }
                        fn set_selected_color(
                            &mut self,
                            value: super::ItemSelectedColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_selected_color(&target, value)
                        }
                        fn selected_color(
                            &self,
                        ) -> std::result::Result<super::ItemSelectedColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::selected_color(&target)
                        }
                        fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::reverse_children(&target)
                        }
                        fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::bring_to_front(&target)
                        }
                        fn set_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_selected(&target, value)
                        }
                        fn selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::selected(&target)
                        }
                        fn add_children(
                            &self,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_children(&target, items)
                        }
                        fn tween_to(
                            &self,
                            to: JsValue,
                            options: super::ItemTweenToParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_to(&target, to, options)
                        }
                        fn set_project(
                            &mut self,
                            value: super::Project,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_project(&target, value)
                        }
                        fn project(&self) -> std::result::Result<super::Project, JsValue> {
                            let target: Item = self.into();
                            super::Item::project(&target)
                        }
                        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_name(&target, value)
                        }
                        fn name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::name(&target)
                        }
                        fn set_stroke_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_bounds(&target, value)
                        }
                        fn stroke_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_bounds(&target)
                        }
                        fn insert_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_below(&target, item)
                        }
                        fn set_blend_mode(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_blend_mode(&target, value)
                        }
                        fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::blend_mode(&target)
                        }
                        fn set_clip_mask(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_clip_mask(&target, value)
                        }
                        fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::clip_mask(&target)
                        }
                        fn set_fill_color(
                            &mut self,
                            value: super::ItemFillColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_fill_color(&target, value)
                        }
                        fn fill_color(&self) -> std::result::Result<super::ItemFillColor, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_color(&target)
                        }
                        fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_drag(&target)
                        }
                        fn add_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_child(&target, item)
                        }
                        fn scale_FnF64AndPointTo(
                            &self,
                            scale: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::scale_FnF64AndPointTo(&target, scale, center)
                        }
                        fn scale_FnF64AndF64AndPointTo(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::scale_FnF64AndF64AndPointTo(&target, hor, ver, center)
                        }
                        fn set_first_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_first_child(&target, value)
                        }
                        fn first_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::first_child(&target)
                        }
                        fn set_style(
                            &mut self,
                            value: super::Style,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_style(&target, value)
                        }
                        fn style(&self) -> std::result::Result<super::Style, JsValue> {
                            let target: Item = self.into();
                            super::Item::style(&target)
                        }
                        fn set_class_name(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_class_name(&target, value)
                        }
                        fn class_name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::class_name(&target)
                        }
                        fn is_grouped_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_grouped_with(&target, item)
                        }
                        fn set_shadow_offset(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_shadow_offset(&target, value)
                        }
                        fn shadow_offset(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_offset(&target)
                        }
                        fn is_inside(
                            &self,
                            rect: super::Rectangle,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inside(&target, rect)
                        }
                        fn set_children(
                            &mut self,
                            value: Vec<Item>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_children(&target, value)
                        }
                        fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::children(&target)
                        }
                        fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_fill(&target)
                        }
                        fn matches_FnItemMatchesParamsOptionsToBool(
                            &self,
                            options: super::ItemMatchesParamsOptions,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::matches_FnItemMatchesParamsOptionsToBool(&target, options)
                        }
                        fn matches_FnStringAndJsValueToBool(
                            &self,
                            name: String,
                            compare: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::matches_FnStringAndJsValueToBool(&target, name, compare)
                        }
                        fn set_on_double_click(
                            &mut self,
                            value: super::ItemOnDoubleClick,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_double_click(&target, value)
                        }
                        fn on_double_click(
                            &self,
                        ) -> std::result::Result<super::ItemOnDoubleClick, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_double_click(&target)
                        }
                        fn intersects(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::intersects(&target, item)
                        }
                        fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_rotation(&target, value)
                        }
                        fn rotation(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::rotation(&target)
                        }
                        fn set_on_mouse_down(
                            &mut self,
                            value: super::ItemOnMouseDown,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_down(&target, value)
                        }
                        fn on_mouse_down(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDown, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_down(&target)
                        }
                        fn is_sibling(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_sibling(&target, item)
                        }
                        fn tween_from(
                            &self,
                            from: JsValue,
                            options: super::ItemTweenFromParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_from(&target, from, options)
                        }
                        fn set_layer(
                            &mut self,
                            value: super::Layer,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_layer(&target, value)
                        }
                        fn layer(&self) -> std::result::Result<super::Layer, JsValue> {
                            let target: Item = self.into();
                            super::Item::layer(&target)
                        }
                        fn contains(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::contains(&target, point)
                        }
                        fn set_on_click(
                            &mut self,
                            value: super::ItemOnClick,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_click(&target, value)
                        }
                        fn on_click(&self) -> std::result::Result<super::ItemOnClick, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_click(&target)
                        }
                        fn set_last_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_last_child(&target, value)
                        }
                        fn last_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::last_child(&target)
                        }
                        fn set_dash_offset(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_dash_offset(&target, value)
                        }
                        fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_offset(&target)
                        }
                        fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_id(&target, value)
                        }
                        fn id(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::id(&target)
                        }
                        fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_shadow(&target)
                        }
                        fn tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                            &self,
                            from: JsValue,
                            to: JsValue,
                            options: super::ItemTweenParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                                &target, from, to, options,
                            )
                        }
                        fn tween_FnJsValueAndItemTweenParamsOptionsToTween(
                            &self,
                            to: JsValue,
                            options: super::ItemTweenParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_FnJsValueAndItemTweenParamsOptionsToTween(
                                &target, to, options,
                            )
                        }
                        fn tween_FnItemTweenParamsOptionsToTween(
                            &self,
                            options: super::ItemTweenParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_FnItemTweenParamsOptionsToTween(&target, options)
                        }
                        fn set_scaling(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_scaling(&target, value)
                        }
                        fn scaling(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::scaling(&target)
                        }
                        fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::send_to_back(&target)
                        }
                        fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::set(&target, props)
                        }
                        fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_index(&target, value)
                        }
                        fn index(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::index(&target)
                        }
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::reduce(&target, options)
                        }
                        fn set_pivot(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_pivot(&target, value)
                        }
                        fn pivot(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::pivot(&target)
                        }
                        fn insert_children(
                            &self,
                            index: f64,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_children(&target, index, items)
                        }
                        fn set_on_mouse_up(
                            &mut self,
                            value: super::ItemOnMouseUp,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_up(&target, value)
                        }
                        fn on_mouse_up(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseUp, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_up(&target)
                        }
                        fn set_stroke_width(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_width(&target, value)
                        }
                        fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_width(&target)
                        }
                        fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on(&target, options)
                        }
                        fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_up(&target)
                        }
                        fn is_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_child(&target, item)
                        }
                        fn replace_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::replace_with(&target, item)
                        }
                        fn export_json(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::export_json(&target, options)
                        }
                        fn hit_test_all(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<Vec<HitResult>, JsValue> {
                            let target: Item = self.into();
                            super::Item::hit_test_all(&target, point, options)
                        }
                        fn export_svg(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::ItemExportSvgReturn, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::export_svg(&target, options)
                        }
                        fn copy_to(
                            &self,
                            owner: super::ItemCopyToParamsOwner,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_to(&target, owner)
                        }
                        fn set_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_matrix(&target, value)
                        }
                        fn matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::matrix(&target)
                        }
                        fn add_to(
                            &self,
                            owner: super::ItemAddToParamsOwner,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_to(&target, owner)
                        }
                        fn rotate(
                            &self,
                            angle: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::rotate(&target, angle, center)
                        }
                        fn set_view_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_view_matrix(&target, value)
                        }
                        fn view_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::view_matrix(&target)
                        }
                        fn set_previous_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_previous_sibling(&target, value)
                        }
                        fn previous_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::previous_sibling(&target)
                        }
                        fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_data(&target, value)
                        }
                        fn data(&self) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::data(&target)
                        }
                        fn off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                            &self,
                            type_: String,
                            callback: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super :: Item :: off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                        }
                        fn off_FnJsValueToJsValue(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::off_FnJsValueToJsValue(&target, object)
                        }
                        fn set_stroke_scaling(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_scaling(&target, value)
                        }
                        fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_scaling(&target)
                        }
                        fn insert_child(
                            &self,
                            index: f64,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_child(&target, index, item)
                        }
                        fn skew_FnPointAndPointTo(
                            &self,
                            skew: super::Point,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::skew_FnPointAndPointTo(&target, skew, center)
                        }
                        fn skew_FnF64AndF64AndPointTo(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::skew_FnF64AndF64AndPointTo(&target, hor, ver, center)
                        }
                        fn on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                            &self,
                            type_: String,
                            callback: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super :: Item :: on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                        }
                        fn on_FnJsValueToJsValue(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_FnJsValueToJsValue(&target, object)
                        }
                        fn remove(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove(&target)
                        }
                        fn global_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_to_local(&target, point)
                        }
                        fn emit(
                            &self,
                            type_: String,
                            event: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::emit(&target, type_, event)
                        }
                        fn hit_test(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<super::HitResult, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::hit_test(&target, point, options)
                        }
                        fn import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                            &self,
                            svg: super::ItemImportSvgParamsSvg,
                            options: JsValue,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                                &target, svg, options,
                            )
                        }
                        fn import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem(
                            &self,
                            svg: super::ItemImportSvgParamsSvg,
                            on_load: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super :: Item :: import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem (& target , svg , on_load)
                        }
                        fn set_dash_array(
                            &mut self,
                            value: Vec<f64>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_dash_array(&target, value)
                        }
                        fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_array(&target)
                        }
                        fn shear_FnPointAndPointTo(
                            &self,
                            shear: super::Point,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::shear_FnPointAndPointTo(&target, shear, center)
                        }
                        fn shear_FnF64AndF64AndPointTo(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::shear_FnF64AndF64AndPointTo(&target, hor, ver, center)
                        }
                        fn set_internal_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_internal_bounds(&target, value)
                        }
                        fn internal_bounds(
                            &self,
                        ) -> std::result::Result<super::Rectangle, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::internal_bounds(&target)
                        }
                        fn set_stroke_cap(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_cap(&target, value)
                        }
                        fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_cap(&target)
                        }
                        fn set_on_mouse_enter(
                            &mut self,
                            value: super::ItemOnMouseEnter,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_enter(&target, value)
                        }
                        fn on_mouse_enter(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseEnter, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_enter(&target)
                        }
                        fn set_view(
                            &mut self,
                            value: super::View,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_view(&target, value)
                        }
                        fn view(&self) -> std::result::Result<super::View, JsValue> {
                            let target: Item = self.into();
                            super::Item::view(&target)
                        }
                        fn set_stroke_join(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_join(&target, value)
                        }
                        fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_join(&target)
                        }
                        fn is_ancestor(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_ancestor(&target, item)
                        }
                        fn set_fill_rule(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_fill_rule(&target, value)
                        }
                        fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_rule(&target)
                        }
                        fn fit_bounds(
                            &self,
                            rectangle: super::Rectangle,
                            fill: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::fit_bounds(&target, rectangle, fill)
                        }
                        fn local_to_parent(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_parent(&target, point)
                        }
                        fn set_handle_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_handle_bounds(&target, value)
                        }
                        fn handle_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::handle_bounds(&target)
                        }
                        fn set_next_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_next_sibling(&target, value)
                        }
                        fn next_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::next_sibling(&target)
                        }
                        fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::clone(&target, options)
                        }
                        fn is_descendant(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_descendant(&target, item)
                        }
                        fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_down(&target)
                        }
                        fn is_parent(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_parent(&target, item)
                        }
                        fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_move(&target)
                        }
                        fn is_empty(
                            &self,
                            recursively: bool,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_empty(&target, recursively)
                        }
                        fn rasterize(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Raster, JsValue> {
                            let target: Item = self.into();
                            super::Item::rasterize(&target, options)
                        }
                        fn set_shadow_color(
                            &mut self,
                            value: super::ItemShadowColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_shadow_color(&target, value)
                        }
                        fn shadow_color(
                            &self,
                        ) -> std::result::Result<super::ItemShadowColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::shadow_color(&target)
                        }
                        fn set_miter_limit(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_miter_limit(&target, value)
                        }
                        fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::miter_limit(&target)
                        }
                        fn get_item(
                            &self,
                            options: super::ItemGetItemParamsOptions,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_item(&target, options)
                        }
                        fn import_json(
                            &self,
                            json: String,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_json(&target, json)
                        }
                        fn insert_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_above(&target, item)
                        }
                        fn set_on_mouse_drag(
                            &mut self,
                            value: super::ItemOnMouseDrag,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_drag(&target, value)
                        }
                        fn on_mouse_drag(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDrag, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_drag(&target)
                        }
                        fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inserted(&target)
                        }
                        fn set_apply_matrix(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_apply_matrix(&target, value)
                        }
                        fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::apply_matrix(&target)
                        }
                        fn transform(
                            &self,
                            matrix: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::transform(&target, matrix)
                        }
                        fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_visible(&target, value)
                        }
                        fn visible(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::visible(&target)
                        }
                        fn set_stroke_color(
                            &mut self,
                            value: super::ItemStrokeColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_color(&target, value)
                        }
                        fn stroke_color(
                            &self,
                        ) -> std::result::Result<super::ItemStrokeColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::stroke_color(&target)
                        }
                        fn set_on_mouse_leave(
                            &mut self,
                            value: super::ItemOnMouseLeave,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_leave(&target, value)
                        }
                        fn on_mouse_leave(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseLeave, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_leave(&target)
                        }
                        fn parent_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent_to_local(&target, point)
                        }
                        fn is_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_above(&target, item)
                        }
                        fn get_items(
                            &self,
                            options: super::ItemGetItemsParamsOptions,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_items(&target, options)
                        }
                        fn has_children(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_children(&target)
                        }
                        fn translate(
                            &self,
                            delta: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::translate(&target, delta)
                        }
                        fn set_parent(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_parent(&target, value)
                        }
                        fn parent(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent(&target)
                        }
                        fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_locked(&target, value)
                        }
                        fn locked(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::locked(&target)
                        }
                        fn local_to_global(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_global(&target, point)
                        }
                    }
                    impl Arc_Trait for Arc where Arc: Path_Trait {}
                    impl std::clone::Clone for Arc_Class {
                        fn clone(&self) -> Self {
                            Self {
                                obj: std::clone::Clone::clone(&self.obj),
                            }
                        }
                    }
                    impl serde::ser::Serialize for Arc_Class {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Arc_Class {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                        }
                    }
                    #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                    extern "C" {
                        #[allow(non_camel_case_types)]
                        # [wasm_bindgen (js_name = "Star" , extends = PathItem_Class , extends = Item_Class , extends = Path_Class)]
                        pub type Star_Class;
                        #[wasm_bindgen(constructor, js_class = "Star")]
                        pub fn new_FnSuperPointAndF64AndF64AndF64ToStar(
                            center: super::Point,
                            points: f64,
                            radius1: f64,
                            radius2: f64,
                        ) -> Star_Class;
                        #[wasm_bindgen(constructor, js_class = "Star")]
                        pub fn new_FnJsValueToStar(object: JsValue) -> Star_Class;
                    }
                    #[derive(std :: clone :: Clone)]
                    pub struct Star(pub Star_Class);
                    impl std::convert::From<&Star> for super::Item {
                        fn from(src: &Star) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Star> for super::Item {
                        fn from(src: &mut Star) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&Star> for super::PathItem {
                        fn from(src: &Star) -> super::PathItem {
                            let src: &super::PathItem_Class = src.0.as_ref();
                            super::PathItem(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Star> for super::PathItem {
                        fn from(src: &mut Star) -> super::PathItem {
                            let src: &super::PathItem_Class = src.0.as_ref();
                            super::PathItem(src.clone())
                        }
                    }
                    impl std::convert::From<&Star> for super::Path {
                        fn from(src: &Star) -> super::Path {
                            let src: &super::Path_Class = src.0.as_ref();
                            super::Path(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Star> for super::Path {
                        fn from(src: &mut Star) -> super::Path {
                            let src: &super::Path_Class = src.0.as_ref();
                            super::Path(src.clone())
                        }
                    }
                    impl std::convert::From<Star> for JsValue {
                        fn from(src: Star) -> JsValue {
                            JsValue::from(src.0)
                        }
                    }
                    impl std::convert::AsRef<JsValue> for Star {
                        fn as_ref(&self) -> &JsValue {
                            self.0.as_ref()
                        }
                    }
                    impl wasm_bindgen::JsCast for Star {
                        fn instanceof(val: &JsValue) -> bool {
                            Star_Class::instanceof(val)
                        }
                        fn unchecked_from_js(val: JsValue) -> Self {
                            Star(Star_Class::unchecked_from_js(val))
                        }
                        fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                            unsafe {
                                &*(Star_Class::unchecked_from_js_ref(val) as *const Star_Class
                                    as *const Self)
                            }
                        }
                    }
                    impl Star {
                        #[allow(dead_code, non_snake_case)]
                        pub fn new_FnSuperPointAndF64AndF64AndF64ToStar(
                            center: super::Point,
                            points: f64,
                            radius1: f64,
                            radius2: f64,
                        ) -> Star {
                            let result = Star_Class::new_FnSuperPointAndF64AndF64AndF64ToStar(
                                center, points, radius1, radius2,
                            );
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            Star(result)
                        }
                        #[allow(dead_code, non_snake_case)]
                        pub fn new_FnJsValueToStar(object: JsValue) -> Star {
                            let result = Star_Class::new_FnJsValueToStar(object);
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            Star(result)
                        }
                    }
                    impl wasm_bindgen::describe::WasmDescribe for Star {
                        fn describe() {
                            <Star_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                        }
                    }
                    impl wasm_bindgen::convert::IntoWasmAbi for Star {
                        type Abi = <Star_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                        }
                    }
                    impl wasm_bindgen::convert::FromWasmAbi for Star {
                        type Abi = <Star_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                        unsafe fn from_abi(js: Self::Abi) -> Self {
                            Star(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                        }
                    }
                    impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Star {
                        type Abi = <&'a Star_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                        }
                    }
                    impl serde::ser::Serialize for Star {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde::ser::Serialize::serialize(&self.0, serializer)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Star {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            let internal: Star_Class =
                                <Star_Class as serde::de::Deserialize>::deserialize(deserializer)?;
                            std::result::Result::Ok(Self(internal))
                        }
                    }
                    #[allow(non_camel_case_types, non_snake_case)]
                    pub trait Star_Trait: Path_Trait {}
                    impl Path_Trait for Star
                    where
                        Star: PathItem_Trait,
                    {
                        fn set_last_segment(
                            &mut self,
                            value: super::Segment,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_last_segment(&target, value)
                        }
                        fn last_segment(&self) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::last_segment(&target)
                        }
                        fn insert_segments(
                            &self,
                            index: f64,
                            segments: Vec<Segment>,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::insert_segments(&target, index, segments)
                        }
                        fn set_curves(
                            &mut self,
                            value: Vec<Curve>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_curves(&target, value)
                        }
                        fn curves(&self) -> std::result::Result<Vec<Curve>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::curves(&target)
                        }
                        fn get_weighted_tangent_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_weighted_tangent_at(&target, offset)
                        }
                        fn set_fully_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_fully_selected(&target, value)
                        }
                        fn fully_selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::fully_selected(&target)
                        }
                        fn set_closed(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_closed(&target, value)
                        }
                        fn closed(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::closed(&target)
                        }
                        fn add(
                            &self,
                            segment: Vec<PathAddParamsSegment>,
                        ) -> std::result::Result<super::PathAddReturn, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::add(&target, segment)
                        }
                        fn get_offset_of(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_offset_of(&target, point)
                        }
                        fn add_segments(
                            &self,
                            segments: Vec<Segment>,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::add_segments(&target, segments)
                        }
                        fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::has_handles(&target)
                        }
                        fn set_first_segment(
                            &mut self,
                            value: super::Segment,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_first_segment(&target, value)
                        }
                        fn first_segment(&self) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::first_segment(&target)
                        }
                        fn set_last_curve(
                            &mut self,
                            value: super::Curve,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_last_curve(&target, value)
                        }
                        fn last_curve(&self) -> std::result::Result<super::Curve, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::last_curve(&target)
                        }
                        fn remove_segments_FnToVecOfSegment(
                            &self,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segments_FnToVecOfSegment(&target)
                        }
                        fn remove_segments_FnF64AndF64ToVecOfSegment(
                            &self,
                            from: f64,
                            to: f64,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segments_FnF64AndF64ToVecOfSegment(
                                &target, from, to,
                            )
                        }
                        fn divide_at(
                            &self,
                            location: super::PathDivideAtParamsLocation,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::divide_at(&target, location)
                        }
                        fn set_length(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_length(&target, value)
                        }
                        fn length(&self) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::length(&target)
                        }
                        fn split_at(
                            &self,
                            location: super::PathSplitAtParamsLocation,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::split_at(&target, location)
                        }
                        fn remove_segment(
                            &self,
                            index: f64,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segment(&target, index)
                        }
                        fn insert(
                            &self,
                            index: f64,
                            segment: super::PathInsertParamsSegment,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::insert(&target, index, segment)
                        }
                        fn get_location_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::get_location_at(&target, offset)
                        }
                        fn to_shape(
                            &self,
                            insert: bool,
                        ) -> std::result::Result<super::Shape, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::to_shape(&target, insert)
                        }
                        fn set_segments(
                            &mut self,
                            value: Vec<Segment>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_segments(&target, value)
                        }
                        fn segments(&self) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::segments(&target)
                        }
                        fn get_offsets_with_tangent(
                            &self,
                            tangent: super::Point,
                        ) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_offsets_with_tangent(&target, tangent)
                        }
                        fn get_weighted_normal_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_weighted_normal_at(&target, offset)
                        }
                        fn join(
                            &self,
                            path: super::Path,
                            tolerance: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::join(&target, path, tolerance)
                        }
                        fn set_area(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_area(&target, value)
                        }
                        fn area(&self) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::area(&target)
                        }
                        fn get_location_of(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::get_location_of(&target, point)
                        }
                        fn get_curvature_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_curvature_at(&target, offset)
                        }
                        fn get_normal_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_normal_at(&target, offset)
                        }
                        fn get_tangent_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_tangent_at(&target, offset)
                        }
                        fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::clear_handles(&target)
                        }
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::reduce(&target, options)
                        }
                        fn set_first_curve(
                            &mut self,
                            value: super::Curve,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_first_curve(&target, value)
                        }
                        fn first_curve(&self) -> std::result::Result<super::Curve, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::first_curve(&target)
                        }
                        fn get_point_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_point_at(&target, offset)
                        }
                    }
                    impl PathItem_Trait for Star
                    where
                        Star: Item_Trait,
                    {
                        fn unite(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::unite(&target, path, options)
                        }
                        fn line_by(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::line_by(&target, point)
                        }
                        fn move_to(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::move_to(&target, point)
                        }
                        fn set_path_data(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::set_path_data(&target, value)
                        }
                        fn path_data(&self) -> std::result::Result<String, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::path_data(&target)
                        }
                        fn intersect(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::intersect(&target, path, options)
                        }
                        fn create_FnStringToPathItemCreateReturn(
                            &self,
                            path_data: String,
                        ) -> std::result::Result<super::PathItemCreateReturn, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::create_FnStringToPathItemCreateReturn(
                                &target, path_data,
                            )
                        }
                        fn create_FnVecOfVecOfF64ToPathItemCreateReturn(
                            &self,
                            segments: Vec<Vec<f64>>,
                        ) -> std::result::Result<super::PathItemCreateReturn, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::create_FnVecOfVecOfF64ToPathItemCreateReturn(
                                &target, segments,
                            )
                        }
                        fn create_FnJsValueToPathItemCreateReturn(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<super::PathItemCreateReturn, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::create_FnJsValueToPathItemCreateReturn(&target, object)
                        }
                        fn smooth(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::smooth(&target, options)
                        }
                        fn compare(
                            &self,
                            path: super::PathItem,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::compare(&target, path)
                        }
                        fn arc_to_FnPointAndPointTo(
                            &self,
                            through: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_to_FnPointAndPointTo(&target, through, to)
                        }
                        fn arc_to_FnPointAndBoolTo(
                            &self,
                            to: super::Point,
                            clockwise: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_to_FnPointAndBoolTo(&target, to, clockwise)
                        }
                        fn quadratic_curve_to(
                            &self,
                            handle: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::quadratic_curve_to(&target, handle, to)
                        }
                        fn set_interior_point(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::set_interior_point(&target, value)
                        }
                        fn interior_point(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::interior_point(&target)
                        }
                        fn simplify(&self, tolerance: f64) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::simplify(&target, tolerance)
                        }
                        fn reorient(
                            &self,
                            non_zero: bool,
                            clockwise: bool,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::reorient(&target, non_zero, clockwise)
                        }
                        fn cubic_curve_by(
                            &self,
                            handle1: super::Point,
                            handle2: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::cubic_curve_by(&target, handle1, handle2, to)
                        }
                        fn close_path(&self) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::close_path(&target)
                        }
                        fn flatten(&self, flatness: f64) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::flatten(&target, flatness)
                        }
                        fn quadratic_curve_by(
                            &self,
                            handle: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::quadratic_curve_by(&target, handle, to)
                        }
                        fn cubic_curve_to(
                            &self,
                            handle1: super::Point,
                            handle2: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::cubic_curve_to(&target, handle1, handle2, to)
                        }
                        fn divide(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::divide(&target, path, options)
                        }
                        fn arc_by_FnPointAndPointTo(
                            &self,
                            through: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_by_FnPointAndPointTo(&target, through, to)
                        }
                        fn arc_by_FnPointAndBoolTo(
                            &self,
                            to: super::Point,
                            clockwise: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_by_FnPointAndBoolTo(&target, to, clockwise)
                        }
                        fn move_by(&self, to: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::move_by(&target, to)
                        }
                        fn get_nearest_location(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_nearest_location(&target, point)
                        }
                        fn reverse(&self) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::reverse(&target)
                        }
                        fn line_to(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::line_to(&target, point)
                        }
                        fn get_nearest_point(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::get_nearest_point(&target, point)
                        }
                        fn interpolate(
                            &self,
                            from: super::PathItem,
                            to: super::PathItem,
                            factor: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::interpolate(&target, from, to, factor)
                        }
                        fn get_crossings(
                            &self,
                            path: super::PathItem,
                        ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_crossings(&target, path)
                        }
                        fn curve_by(
                            &self,
                            through: super::Point,
                            to: super::Point,
                            time: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::curve_by(&target, through, to, time)
                        }
                        fn curve_to(
                            &self,
                            through: super::Point,
                            to: super::Point,
                            time: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::curve_to(&target, through, to, time)
                        }
                        fn subtract(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::subtract(&target, path, options)
                        }
                        fn get_intersections(
                            &self,
                            path: super::PathItem,
                            include: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_intersections(&target, path, include)
                        }
                        fn exclude(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::exclude(&target, path, options)
                        }
                        fn set_clockwise(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::set_clockwise(&target, value)
                        }
                        fn clockwise(&self) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::clockwise(&target)
                        }
                    }
                    impl Item_Trait for Star {
                        fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::responds(&target, type_)
                        }
                        fn copy_content(
                            &self,
                            source: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_content(&target, source)
                        }
                        fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_opacity(&target, value)
                        }
                        fn opacity(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::opacity(&target)
                        }
                        fn set_on_frame(
                            &mut self,
                            value: super::ItemOnFrame,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_frame(&target, value)
                        }
                        fn on_frame(&self) -> std::result::Result<super::ItemOnFrame, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_frame(&target)
                        }
                        fn remove_children_FnToVecOfItem(
                            &self,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_children_FnToVecOfItem(&target)
                        }
                        fn remove_children_FnF64AndF64ToVecOfItem(
                            &self,
                            start: f64,
                            end: f64,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_children_FnF64AndF64ToVecOfItem(&target, start, end)
                        }
                        fn is_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_below(&target, item)
                        }
                        fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_stroke(&target)
                        }
                        fn set_global_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_global_matrix(&target, value)
                        }
                        fn global_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_matrix(&target)
                        }
                        fn copy_attributes(
                            &self,
                            source: super::Item,
                            exclude_matrix: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_attributes(&target, source, exclude_matrix)
                        }
                        fn set_on_mouse_move(
                            &mut self,
                            value: super::ItemOnMouseMove,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_move(&target, value)
                        }
                        fn on_mouse_move(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseMove, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_move(&target)
                        }
                        fn set_position(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_position(&target, value)
                        }
                        fn position(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::position(&target)
                        }
                        fn set_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_bounds(&target, value)
                        }
                        fn bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::bounds(&target)
                        }
                        fn set_shadow_blur(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_shadow_blur(&target, value)
                        }
                        fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_blur(&target)
                        }
                        fn set_selected_color(
                            &mut self,
                            value: super::ItemSelectedColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_selected_color(&target, value)
                        }
                        fn selected_color(
                            &self,
                        ) -> std::result::Result<super::ItemSelectedColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::selected_color(&target)
                        }
                        fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::reverse_children(&target)
                        }
                        fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::bring_to_front(&target)
                        }
                        fn set_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_selected(&target, value)
                        }
                        fn selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::selected(&target)
                        }
                        fn add_children(
                            &self,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_children(&target, items)
                        }
                        fn tween_to(
                            &self,
                            to: JsValue,
                            options: super::ItemTweenToParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_to(&target, to, options)
                        }
                        fn set_project(
                            &mut self,
                            value: super::Project,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_project(&target, value)
                        }
                        fn project(&self) -> std::result::Result<super::Project, JsValue> {
                            let target: Item = self.into();
                            super::Item::project(&target)
                        }
                        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_name(&target, value)
                        }
                        fn name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::name(&target)
                        }
                        fn set_stroke_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_bounds(&target, value)
                        }
                        fn stroke_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_bounds(&target)
                        }
                        fn insert_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_below(&target, item)
                        }
                        fn set_blend_mode(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_blend_mode(&target, value)
                        }
                        fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::blend_mode(&target)
                        }
                        fn set_clip_mask(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_clip_mask(&target, value)
                        }
                        fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::clip_mask(&target)
                        }
                        fn set_fill_color(
                            &mut self,
                            value: super::ItemFillColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_fill_color(&target, value)
                        }
                        fn fill_color(&self) -> std::result::Result<super::ItemFillColor, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_color(&target)
                        }
                        fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_drag(&target)
                        }
                        fn add_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_child(&target, item)
                        }
                        fn scale_FnF64AndPointTo(
                            &self,
                            scale: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::scale_FnF64AndPointTo(&target, scale, center)
                        }
                        fn scale_FnF64AndF64AndPointTo(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::scale_FnF64AndF64AndPointTo(&target, hor, ver, center)
                        }
                        fn set_first_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_first_child(&target, value)
                        }
                        fn first_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::first_child(&target)
                        }
                        fn set_style(
                            &mut self,
                            value: super::Style,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_style(&target, value)
                        }
                        fn style(&self) -> std::result::Result<super::Style, JsValue> {
                            let target: Item = self.into();
                            super::Item::style(&target)
                        }
                        fn set_class_name(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_class_name(&target, value)
                        }
                        fn class_name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::class_name(&target)
                        }
                        fn is_grouped_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_grouped_with(&target, item)
                        }
                        fn set_shadow_offset(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_shadow_offset(&target, value)
                        }
                        fn shadow_offset(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_offset(&target)
                        }
                        fn is_inside(
                            &self,
                            rect: super::Rectangle,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inside(&target, rect)
                        }
                        fn set_children(
                            &mut self,
                            value: Vec<Item>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_children(&target, value)
                        }
                        fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::children(&target)
                        }
                        fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_fill(&target)
                        }
                        fn matches_FnItemMatchesParamsOptionsToBool(
                            &self,
                            options: super::ItemMatchesParamsOptions,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::matches_FnItemMatchesParamsOptionsToBool(&target, options)
                        }
                        fn matches_FnStringAndJsValueToBool(
                            &self,
                            name: String,
                            compare: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::matches_FnStringAndJsValueToBool(&target, name, compare)
                        }
                        fn set_on_double_click(
                            &mut self,
                            value: super::ItemOnDoubleClick,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_double_click(&target, value)
                        }
                        fn on_double_click(
                            &self,
                        ) -> std::result::Result<super::ItemOnDoubleClick, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_double_click(&target)
                        }
                        fn intersects(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::intersects(&target, item)
                        }
                        fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_rotation(&target, value)
                        }
                        fn rotation(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::rotation(&target)
                        }
                        fn set_on_mouse_down(
                            &mut self,
                            value: super::ItemOnMouseDown,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_down(&target, value)
                        }
                        fn on_mouse_down(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDown, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_down(&target)
                        }
                        fn is_sibling(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_sibling(&target, item)
                        }
                        fn tween_from(
                            &self,
                            from: JsValue,
                            options: super::ItemTweenFromParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_from(&target, from, options)
                        }
                        fn set_layer(
                            &mut self,
                            value: super::Layer,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_layer(&target, value)
                        }
                        fn layer(&self) -> std::result::Result<super::Layer, JsValue> {
                            let target: Item = self.into();
                            super::Item::layer(&target)
                        }
                        fn contains(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::contains(&target, point)
                        }
                        fn set_on_click(
                            &mut self,
                            value: super::ItemOnClick,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_click(&target, value)
                        }
                        fn on_click(&self) -> std::result::Result<super::ItemOnClick, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_click(&target)
                        }
                        fn set_last_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_last_child(&target, value)
                        }
                        fn last_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::last_child(&target)
                        }
                        fn set_dash_offset(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_dash_offset(&target, value)
                        }
                        fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_offset(&target)
                        }
                        fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_id(&target, value)
                        }
                        fn id(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::id(&target)
                        }
                        fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_shadow(&target)
                        }
                        fn tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                            &self,
                            from: JsValue,
                            to: JsValue,
                            options: super::ItemTweenParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                                &target, from, to, options,
                            )
                        }
                        fn tween_FnJsValueAndItemTweenParamsOptionsToTween(
                            &self,
                            to: JsValue,
                            options: super::ItemTweenParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_FnJsValueAndItemTweenParamsOptionsToTween(
                                &target, to, options,
                            )
                        }
                        fn tween_FnItemTweenParamsOptionsToTween(
                            &self,
                            options: super::ItemTweenParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_FnItemTweenParamsOptionsToTween(&target, options)
                        }
                        fn set_scaling(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_scaling(&target, value)
                        }
                        fn scaling(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::scaling(&target)
                        }
                        fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::send_to_back(&target)
                        }
                        fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::set(&target, props)
                        }
                        fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_index(&target, value)
                        }
                        fn index(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::index(&target)
                        }
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::reduce(&target, options)
                        }
                        fn set_pivot(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_pivot(&target, value)
                        }
                        fn pivot(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::pivot(&target)
                        }
                        fn insert_children(
                            &self,
                            index: f64,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_children(&target, index, items)
                        }
                        fn set_on_mouse_up(
                            &mut self,
                            value: super::ItemOnMouseUp,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_up(&target, value)
                        }
                        fn on_mouse_up(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseUp, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_up(&target)
                        }
                        fn set_stroke_width(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_width(&target, value)
                        }
                        fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_width(&target)
                        }
                        fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on(&target, options)
                        }
                        fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_up(&target)
                        }
                        fn is_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_child(&target, item)
                        }
                        fn replace_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::replace_with(&target, item)
                        }
                        fn export_json(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::export_json(&target, options)
                        }
                        fn hit_test_all(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<Vec<HitResult>, JsValue> {
                            let target: Item = self.into();
                            super::Item::hit_test_all(&target, point, options)
                        }
                        fn export_svg(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::ItemExportSvgReturn, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::export_svg(&target, options)
                        }
                        fn copy_to(
                            &self,
                            owner: super::ItemCopyToParamsOwner,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_to(&target, owner)
                        }
                        fn set_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_matrix(&target, value)
                        }
                        fn matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::matrix(&target)
                        }
                        fn add_to(
                            &self,
                            owner: super::ItemAddToParamsOwner,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_to(&target, owner)
                        }
                        fn rotate(
                            &self,
                            angle: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::rotate(&target, angle, center)
                        }
                        fn set_view_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_view_matrix(&target, value)
                        }
                        fn view_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::view_matrix(&target)
                        }
                        fn set_previous_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_previous_sibling(&target, value)
                        }
                        fn previous_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::previous_sibling(&target)
                        }
                        fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_data(&target, value)
                        }
                        fn data(&self) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::data(&target)
                        }
                        fn off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                            &self,
                            type_: String,
                            callback: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super :: Item :: off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                        }
                        fn off_FnJsValueToJsValue(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::off_FnJsValueToJsValue(&target, object)
                        }
                        fn set_stroke_scaling(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_scaling(&target, value)
                        }
                        fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_scaling(&target)
                        }
                        fn insert_child(
                            &self,
                            index: f64,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_child(&target, index, item)
                        }
                        fn skew_FnPointAndPointTo(
                            &self,
                            skew: super::Point,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::skew_FnPointAndPointTo(&target, skew, center)
                        }
                        fn skew_FnF64AndF64AndPointTo(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::skew_FnF64AndF64AndPointTo(&target, hor, ver, center)
                        }
                        fn on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                            &self,
                            type_: String,
                            callback: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super :: Item :: on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                        }
                        fn on_FnJsValueToJsValue(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_FnJsValueToJsValue(&target, object)
                        }
                        fn remove(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove(&target)
                        }
                        fn global_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_to_local(&target, point)
                        }
                        fn emit(
                            &self,
                            type_: String,
                            event: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::emit(&target, type_, event)
                        }
                        fn hit_test(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<super::HitResult, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::hit_test(&target, point, options)
                        }
                        fn import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                            &self,
                            svg: super::ItemImportSvgParamsSvg,
                            options: JsValue,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                                &target, svg, options,
                            )
                        }
                        fn import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem(
                            &self,
                            svg: super::ItemImportSvgParamsSvg,
                            on_load: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super :: Item :: import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem (& target , svg , on_load)
                        }
                        fn set_dash_array(
                            &mut self,
                            value: Vec<f64>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_dash_array(&target, value)
                        }
                        fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_array(&target)
                        }
                        fn shear_FnPointAndPointTo(
                            &self,
                            shear: super::Point,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::shear_FnPointAndPointTo(&target, shear, center)
                        }
                        fn shear_FnF64AndF64AndPointTo(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::shear_FnF64AndF64AndPointTo(&target, hor, ver, center)
                        }
                        fn set_internal_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_internal_bounds(&target, value)
                        }
                        fn internal_bounds(
                            &self,
                        ) -> std::result::Result<super::Rectangle, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::internal_bounds(&target)
                        }
                        fn set_stroke_cap(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_cap(&target, value)
                        }
                        fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_cap(&target)
                        }
                        fn set_on_mouse_enter(
                            &mut self,
                            value: super::ItemOnMouseEnter,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_enter(&target, value)
                        }
                        fn on_mouse_enter(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseEnter, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_enter(&target)
                        }
                        fn set_view(
                            &mut self,
                            value: super::View,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_view(&target, value)
                        }
                        fn view(&self) -> std::result::Result<super::View, JsValue> {
                            let target: Item = self.into();
                            super::Item::view(&target)
                        }
                        fn set_stroke_join(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_join(&target, value)
                        }
                        fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_join(&target)
                        }
                        fn is_ancestor(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_ancestor(&target, item)
                        }
                        fn set_fill_rule(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_fill_rule(&target, value)
                        }
                        fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_rule(&target)
                        }
                        fn fit_bounds(
                            &self,
                            rectangle: super::Rectangle,
                            fill: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::fit_bounds(&target, rectangle, fill)
                        }
                        fn local_to_parent(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_parent(&target, point)
                        }
                        fn set_handle_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_handle_bounds(&target, value)
                        }
                        fn handle_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::handle_bounds(&target)
                        }
                        fn set_next_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_next_sibling(&target, value)
                        }
                        fn next_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::next_sibling(&target)
                        }
                        fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::clone(&target, options)
                        }
                        fn is_descendant(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_descendant(&target, item)
                        }
                        fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_down(&target)
                        }
                        fn is_parent(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_parent(&target, item)
                        }
                        fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_move(&target)
                        }
                        fn is_empty(
                            &self,
                            recursively: bool,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_empty(&target, recursively)
                        }
                        fn rasterize(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Raster, JsValue> {
                            let target: Item = self.into();
                            super::Item::rasterize(&target, options)
                        }
                        fn set_shadow_color(
                            &mut self,
                            value: super::ItemShadowColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_shadow_color(&target, value)
                        }
                        fn shadow_color(
                            &self,
                        ) -> std::result::Result<super::ItemShadowColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::shadow_color(&target)
                        }
                        fn set_miter_limit(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_miter_limit(&target, value)
                        }
                        fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::miter_limit(&target)
                        }
                        fn get_item(
                            &self,
                            options: super::ItemGetItemParamsOptions,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_item(&target, options)
                        }
                        fn import_json(
                            &self,
                            json: String,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_json(&target, json)
                        }
                        fn insert_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_above(&target, item)
                        }
                        fn set_on_mouse_drag(
                            &mut self,
                            value: super::ItemOnMouseDrag,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_drag(&target, value)
                        }
                        fn on_mouse_drag(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDrag, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_drag(&target)
                        }
                        fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inserted(&target)
                        }
                        fn set_apply_matrix(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_apply_matrix(&target, value)
                        }
                        fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::apply_matrix(&target)
                        }
                        fn transform(
                            &self,
                            matrix: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::transform(&target, matrix)
                        }
                        fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_visible(&target, value)
                        }
                        fn visible(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::visible(&target)
                        }
                        fn set_stroke_color(
                            &mut self,
                            value: super::ItemStrokeColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_color(&target, value)
                        }
                        fn stroke_color(
                            &self,
                        ) -> std::result::Result<super::ItemStrokeColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::stroke_color(&target)
                        }
                        fn set_on_mouse_leave(
                            &mut self,
                            value: super::ItemOnMouseLeave,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_leave(&target, value)
                        }
                        fn on_mouse_leave(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseLeave, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_leave(&target)
                        }
                        fn parent_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent_to_local(&target, point)
                        }
                        fn is_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_above(&target, item)
                        }
                        fn get_items(
                            &self,
                            options: super::ItemGetItemsParamsOptions,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_items(&target, options)
                        }
                        fn has_children(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_children(&target)
                        }
                        fn translate(
                            &self,
                            delta: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::translate(&target, delta)
                        }
                        fn set_parent(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_parent(&target, value)
                        }
                        fn parent(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent(&target)
                        }
                        fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_locked(&target, value)
                        }
                        fn locked(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::locked(&target)
                        }
                        fn local_to_global(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_global(&target, point)
                        }
                    }
                    impl Star_Trait for Star where Star: Path_Trait {}
                    impl std::clone::Clone for Star_Class {
                        fn clone(&self) -> Self {
                            Self {
                                obj: std::clone::Clone::clone(&self.obj),
                            }
                        }
                    }
                    impl serde::ser::Serialize for Star_Class {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Star_Class {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                        }
                    }
                    #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                    extern "C" {
                        #[allow(non_camel_case_types)]
                        # [wasm_bindgen (js_name = "Circle" , extends = Item_Class , extends = Path_Class , extends = PathItem_Class)]
                        pub type Circle_Class;
                        #[wasm_bindgen(constructor, js_class = "Circle")]
                        pub fn new_FnSuperPointAndF64ToCircle(
                            center: super::Point,
                            radius: f64,
                        ) -> Circle_Class;
                        #[wasm_bindgen(constructor, js_class = "Circle")]
                        pub fn new_FnJsValueToCircle(object: JsValue) -> Circle_Class;
                    }
                    #[derive(std :: clone :: Clone)]
                    pub struct Circle(pub Circle_Class);
                    impl std::convert::From<&Circle> for super::PathItem {
                        fn from(src: &Circle) -> super::PathItem {
                            let src: &super::PathItem_Class = src.0.as_ref();
                            super::PathItem(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Circle> for super::PathItem {
                        fn from(src: &mut Circle) -> super::PathItem {
                            let src: &super::PathItem_Class = src.0.as_ref();
                            super::PathItem(src.clone())
                        }
                    }
                    impl std::convert::From<&Circle> for super::Item {
                        fn from(src: &Circle) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Circle> for super::Item {
                        fn from(src: &mut Circle) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&Circle> for super::Path {
                        fn from(src: &Circle) -> super::Path {
                            let src: &super::Path_Class = src.0.as_ref();
                            super::Path(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Circle> for super::Path {
                        fn from(src: &mut Circle) -> super::Path {
                            let src: &super::Path_Class = src.0.as_ref();
                            super::Path(src.clone())
                        }
                    }
                    impl std::convert::From<Circle> for JsValue {
                        fn from(src: Circle) -> JsValue {
                            JsValue::from(src.0)
                        }
                    }
                    impl std::convert::AsRef<JsValue> for Circle {
                        fn as_ref(&self) -> &JsValue {
                            self.0.as_ref()
                        }
                    }
                    impl wasm_bindgen::JsCast for Circle {
                        fn instanceof(val: &JsValue) -> bool {
                            Circle_Class::instanceof(val)
                        }
                        fn unchecked_from_js(val: JsValue) -> Self {
                            Circle(Circle_Class::unchecked_from_js(val))
                        }
                        fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                            unsafe {
                                &*(Circle_Class::unchecked_from_js_ref(val) as *const Circle_Class
                                    as *const Self)
                            }
                        }
                    }
                    impl Circle {
                        #[allow(dead_code, non_snake_case)]
                        pub fn new_FnSuperPointAndF64ToCircle(
                            center: super::Point,
                            radius: f64,
                        ) -> Circle {
                            let result =
                                Circle_Class::new_FnSuperPointAndF64ToCircle(center, radius);
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            Circle(result)
                        }
                        #[allow(dead_code, non_snake_case)]
                        pub fn new_FnJsValueToCircle(object: JsValue) -> Circle {
                            let result = Circle_Class::new_FnJsValueToCircle(object);
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            Circle(result)
                        }
                    }
                    impl wasm_bindgen::describe::WasmDescribe for Circle {
                        fn describe() {
                            <Circle_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                        }
                    }
                    impl wasm_bindgen::convert::IntoWasmAbi for Circle {
                        type Abi = <Circle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                        }
                    }
                    impl wasm_bindgen::convert::FromWasmAbi for Circle {
                        type Abi = <Circle_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                        unsafe fn from_abi(js: Self::Abi) -> Self {
                            Circle(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                        }
                    }
                    impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Circle {
                        type Abi = <&'a Circle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                        }
                    }
                    impl serde::ser::Serialize for Circle {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde::ser::Serialize::serialize(&self.0, serializer)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Circle {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            let internal: Circle_Class =
                                <Circle_Class as serde::de::Deserialize>::deserialize(
                                    deserializer,
                                )?;
                            std::result::Result::Ok(Self(internal))
                        }
                    }
                    #[allow(non_camel_case_types, non_snake_case)]
                    pub trait Circle_Trait: Path_Trait {}
                    impl Path_Trait for Circle
                    where
                        Circle: PathItem_Trait,
                    {
                        fn set_last_segment(
                            &mut self,
                            value: super::Segment,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_last_segment(&target, value)
                        }
                        fn last_segment(&self) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::last_segment(&target)
                        }
                        fn insert_segments(
                            &self,
                            index: f64,
                            segments: Vec<Segment>,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::insert_segments(&target, index, segments)
                        }
                        fn set_curves(
                            &mut self,
                            value: Vec<Curve>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_curves(&target, value)
                        }
                        fn curves(&self) -> std::result::Result<Vec<Curve>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::curves(&target)
                        }
                        fn get_weighted_tangent_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_weighted_tangent_at(&target, offset)
                        }
                        fn set_fully_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_fully_selected(&target, value)
                        }
                        fn fully_selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::fully_selected(&target)
                        }
                        fn set_closed(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_closed(&target, value)
                        }
                        fn closed(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::closed(&target)
                        }
                        fn add(
                            &self,
                            segment: Vec<PathAddParamsSegment>,
                        ) -> std::result::Result<super::PathAddReturn, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::add(&target, segment)
                        }
                        fn get_offset_of(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_offset_of(&target, point)
                        }
                        fn add_segments(
                            &self,
                            segments: Vec<Segment>,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::add_segments(&target, segments)
                        }
                        fn has_handles(&self) -> std::result::Result<bool, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::has_handles(&target)
                        }
                        fn set_first_segment(
                            &mut self,
                            value: super::Segment,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_first_segment(&target, value)
                        }
                        fn first_segment(&self) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::first_segment(&target)
                        }
                        fn set_last_curve(
                            &mut self,
                            value: super::Curve,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_last_curve(&target, value)
                        }
                        fn last_curve(&self) -> std::result::Result<super::Curve, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::last_curve(&target)
                        }
                        fn remove_segments_FnToVecOfSegment(
                            &self,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segments_FnToVecOfSegment(&target)
                        }
                        fn remove_segments_FnF64AndF64ToVecOfSegment(
                            &self,
                            from: f64,
                            to: f64,
                        ) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segments_FnF64AndF64ToVecOfSegment(
                                &target, from, to,
                            )
                        }
                        fn divide_at(
                            &self,
                            location: super::PathDivideAtParamsLocation,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::divide_at(&target, location)
                        }
                        fn set_length(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_length(&target, value)
                        }
                        fn length(&self) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::length(&target)
                        }
                        fn split_at(
                            &self,
                            location: super::PathSplitAtParamsLocation,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::split_at(&target, location)
                        }
                        fn remove_segment(
                            &self,
                            index: f64,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::remove_segment(&target, index)
                        }
                        fn insert(
                            &self,
                            index: f64,
                            segment: super::PathInsertParamsSegment,
                        ) -> std::result::Result<super::Segment, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::insert(&target, index, segment)
                        }
                        fn get_location_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::get_location_at(&target, offset)
                        }
                        fn to_shape(
                            &self,
                            insert: bool,
                        ) -> std::result::Result<super::Shape, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::to_shape(&target, insert)
                        }
                        fn set_segments(
                            &mut self,
                            value: Vec<Segment>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_segments(&target, value)
                        }
                        fn segments(&self) -> std::result::Result<Vec<Segment>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::segments(&target)
                        }
                        fn get_offsets_with_tangent(
                            &self,
                            tangent: super::Point,
                        ) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_offsets_with_tangent(&target, tangent)
                        }
                        fn get_weighted_normal_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_weighted_normal_at(&target, offset)
                        }
                        fn join(
                            &self,
                            path: super::Path,
                            tolerance: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::join(&target, path, tolerance)
                        }
                        fn set_area(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_area(&target, value)
                        }
                        fn area(&self) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::area(&target)
                        }
                        fn get_location_of(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: super::Path = self.into();
                            super::Path::get_location_of(&target, point)
                        }
                        fn get_curvature_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<f64, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_curvature_at(&target, offset)
                        }
                        fn get_normal_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_normal_at(&target, offset)
                        }
                        fn get_tangent_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_tangent_at(&target, offset)
                        }
                        fn clear_handles(&self) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::clear_handles(&target)
                        }
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::reduce(&target, options)
                        }
                        fn set_first_curve(
                            &mut self,
                            value: super::Curve,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Path = self.into();
                            super::Path::set_first_curve(&target, value)
                        }
                        fn first_curve(&self) -> std::result::Result<super::Curve, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::first_curve(&target)
                        }
                        fn get_point_at(
                            &self,
                            offset: f64,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: super::Path = self.into();
                            super::Path::get_point_at(&target, offset)
                        }
                    }
                    impl PathItem_Trait for Circle
                    where
                        Circle: Item_Trait,
                    {
                        fn unite(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::unite(&target, path, options)
                        }
                        fn line_by(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::line_by(&target, point)
                        }
                        fn move_to(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::move_to(&target, point)
                        }
                        fn set_path_data(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::set_path_data(&target, value)
                        }
                        fn path_data(&self) -> std::result::Result<String, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::path_data(&target)
                        }
                        fn intersect(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::intersect(&target, path, options)
                        }
                        fn create_FnStringToPathItemCreateReturn(
                            &self,
                            path_data: String,
                        ) -> std::result::Result<super::PathItemCreateReturn, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::create_FnStringToPathItemCreateReturn(
                                &target, path_data,
                            )
                        }
                        fn create_FnVecOfVecOfF64ToPathItemCreateReturn(
                            &self,
                            segments: Vec<Vec<f64>>,
                        ) -> std::result::Result<super::PathItemCreateReturn, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::create_FnVecOfVecOfF64ToPathItemCreateReturn(
                                &target, segments,
                            )
                        }
                        fn create_FnJsValueToPathItemCreateReturn(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<super::PathItemCreateReturn, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::create_FnJsValueToPathItemCreateReturn(&target, object)
                        }
                        fn smooth(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::smooth(&target, options)
                        }
                        fn compare(
                            &self,
                            path: super::PathItem,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::compare(&target, path)
                        }
                        fn arc_to_FnPointAndPointTo(
                            &self,
                            through: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_to_FnPointAndPointTo(&target, through, to)
                        }
                        fn arc_to_FnPointAndBoolTo(
                            &self,
                            to: super::Point,
                            clockwise: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_to_FnPointAndBoolTo(&target, to, clockwise)
                        }
                        fn quadratic_curve_to(
                            &self,
                            handle: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::quadratic_curve_to(&target, handle, to)
                        }
                        fn set_interior_point(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::set_interior_point(&target, value)
                        }
                        fn interior_point(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::interior_point(&target)
                        }
                        fn simplify(&self, tolerance: f64) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::simplify(&target, tolerance)
                        }
                        fn reorient(
                            &self,
                            non_zero: bool,
                            clockwise: bool,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::reorient(&target, non_zero, clockwise)
                        }
                        fn cubic_curve_by(
                            &self,
                            handle1: super::Point,
                            handle2: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::cubic_curve_by(&target, handle1, handle2, to)
                        }
                        fn close_path(&self) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::close_path(&target)
                        }
                        fn flatten(&self, flatness: f64) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::flatten(&target, flatness)
                        }
                        fn quadratic_curve_by(
                            &self,
                            handle: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::quadratic_curve_by(&target, handle, to)
                        }
                        fn cubic_curve_to(
                            &self,
                            handle1: super::Point,
                            handle2: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::cubic_curve_to(&target, handle1, handle2, to)
                        }
                        fn divide(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::divide(&target, path, options)
                        }
                        fn arc_by_FnPointAndPointTo(
                            &self,
                            through: super::Point,
                            to: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_by_FnPointAndPointTo(&target, through, to)
                        }
                        fn arc_by_FnPointAndBoolTo(
                            &self,
                            to: super::Point,
                            clockwise: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::arc_by_FnPointAndBoolTo(&target, to, clockwise)
                        }
                        fn move_by(&self, to: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::move_by(&target, to)
                        }
                        fn get_nearest_location(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::CurveLocation, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_nearest_location(&target, point)
                        }
                        fn reverse(&self) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::reverse(&target)
                        }
                        fn line_to(&self, point: super::Point) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::line_to(&target, point)
                        }
                        fn get_nearest_point(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::get_nearest_point(&target, point)
                        }
                        fn interpolate(
                            &self,
                            from: super::PathItem,
                            to: super::PathItem,
                            factor: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::interpolate(&target, from, to, factor)
                        }
                        fn get_crossings(
                            &self,
                            path: super::PathItem,
                        ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_crossings(&target, path)
                        }
                        fn curve_by(
                            &self,
                            through: super::Point,
                            to: super::Point,
                            time: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::curve_by(&target, through, to, time)
                        }
                        fn curve_to(
                            &self,
                            through: super::Point,
                            to: super::Point,
                            time: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::curve_to(&target, through, to, time)
                        }
                        fn subtract(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::subtract(&target, path, options)
                        }
                        fn get_intersections(
                            &self,
                            path: super::PathItem,
                            include: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<Vec<CurveLocation>, JsValue>
                        {
                            let target: PathItem = self.into();
                            super::PathItem::get_intersections(&target, path, include)
                        }
                        fn exclude(
                            &self,
                            path: super::PathItem,
                            options: JsValue,
                        ) -> std::result::Result<super::PathItem, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::exclude(&target, path, options)
                        }
                        fn set_clockwise(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::set_clockwise(&target, value)
                        }
                        fn clockwise(&self) -> std::result::Result<bool, JsValue> {
                            let target: PathItem = self.into();
                            super::PathItem::clockwise(&target)
                        }
                    }
                    impl Item_Trait for Circle {
                        fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::responds(&target, type_)
                        }
                        fn copy_content(
                            &self,
                            source: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_content(&target, source)
                        }
                        fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_opacity(&target, value)
                        }
                        fn opacity(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::opacity(&target)
                        }
                        fn set_on_frame(
                            &mut self,
                            value: super::ItemOnFrame,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_frame(&target, value)
                        }
                        fn on_frame(&self) -> std::result::Result<super::ItemOnFrame, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_frame(&target)
                        }
                        fn remove_children_FnToVecOfItem(
                            &self,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_children_FnToVecOfItem(&target)
                        }
                        fn remove_children_FnF64AndF64ToVecOfItem(
                            &self,
                            start: f64,
                            end: f64,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_children_FnF64AndF64ToVecOfItem(&target, start, end)
                        }
                        fn is_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_below(&target, item)
                        }
                        fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_stroke(&target)
                        }
                        fn set_global_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_global_matrix(&target, value)
                        }
                        fn global_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_matrix(&target)
                        }
                        fn copy_attributes(
                            &self,
                            source: super::Item,
                            exclude_matrix: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_attributes(&target, source, exclude_matrix)
                        }
                        fn set_on_mouse_move(
                            &mut self,
                            value: super::ItemOnMouseMove,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_move(&target, value)
                        }
                        fn on_mouse_move(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseMove, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_move(&target)
                        }
                        fn set_position(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_position(&target, value)
                        }
                        fn position(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::position(&target)
                        }
                        fn set_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_bounds(&target, value)
                        }
                        fn bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::bounds(&target)
                        }
                        fn set_shadow_blur(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_shadow_blur(&target, value)
                        }
                        fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_blur(&target)
                        }
                        fn set_selected_color(
                            &mut self,
                            value: super::ItemSelectedColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_selected_color(&target, value)
                        }
                        fn selected_color(
                            &self,
                        ) -> std::result::Result<super::ItemSelectedColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::selected_color(&target)
                        }
                        fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::reverse_children(&target)
                        }
                        fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::bring_to_front(&target)
                        }
                        fn set_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_selected(&target, value)
                        }
                        fn selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::selected(&target)
                        }
                        fn add_children(
                            &self,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_children(&target, items)
                        }
                        fn tween_to(
                            &self,
                            to: JsValue,
                            options: super::ItemTweenToParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_to(&target, to, options)
                        }
                        fn set_project(
                            &mut self,
                            value: super::Project,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_project(&target, value)
                        }
                        fn project(&self) -> std::result::Result<super::Project, JsValue> {
                            let target: Item = self.into();
                            super::Item::project(&target)
                        }
                        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_name(&target, value)
                        }
                        fn name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::name(&target)
                        }
                        fn set_stroke_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_bounds(&target, value)
                        }
                        fn stroke_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_bounds(&target)
                        }
                        fn insert_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_below(&target, item)
                        }
                        fn set_blend_mode(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_blend_mode(&target, value)
                        }
                        fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::blend_mode(&target)
                        }
                        fn set_clip_mask(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_clip_mask(&target, value)
                        }
                        fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::clip_mask(&target)
                        }
                        fn set_fill_color(
                            &mut self,
                            value: super::ItemFillColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_fill_color(&target, value)
                        }
                        fn fill_color(&self) -> std::result::Result<super::ItemFillColor, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_color(&target)
                        }
                        fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_drag(&target)
                        }
                        fn add_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_child(&target, item)
                        }
                        fn scale_FnF64AndPointTo(
                            &self,
                            scale: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::scale_FnF64AndPointTo(&target, scale, center)
                        }
                        fn scale_FnF64AndF64AndPointTo(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::scale_FnF64AndF64AndPointTo(&target, hor, ver, center)
                        }
                        fn set_first_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_first_child(&target, value)
                        }
                        fn first_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::first_child(&target)
                        }
                        fn set_style(
                            &mut self,
                            value: super::Style,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_style(&target, value)
                        }
                        fn style(&self) -> std::result::Result<super::Style, JsValue> {
                            let target: Item = self.into();
                            super::Item::style(&target)
                        }
                        fn set_class_name(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_class_name(&target, value)
                        }
                        fn class_name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::class_name(&target)
                        }
                        fn is_grouped_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_grouped_with(&target, item)
                        }
                        fn set_shadow_offset(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_shadow_offset(&target, value)
                        }
                        fn shadow_offset(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_offset(&target)
                        }
                        fn is_inside(
                            &self,
                            rect: super::Rectangle,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inside(&target, rect)
                        }
                        fn set_children(
                            &mut self,
                            value: Vec<Item>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_children(&target, value)
                        }
                        fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::children(&target)
                        }
                        fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_fill(&target)
                        }
                        fn matches_FnItemMatchesParamsOptionsToBool(
                            &self,
                            options: super::ItemMatchesParamsOptions,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::matches_FnItemMatchesParamsOptionsToBool(&target, options)
                        }
                        fn matches_FnStringAndJsValueToBool(
                            &self,
                            name: String,
                            compare: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::matches_FnStringAndJsValueToBool(&target, name, compare)
                        }
                        fn set_on_double_click(
                            &mut self,
                            value: super::ItemOnDoubleClick,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_double_click(&target, value)
                        }
                        fn on_double_click(
                            &self,
                        ) -> std::result::Result<super::ItemOnDoubleClick, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_double_click(&target)
                        }
                        fn intersects(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::intersects(&target, item)
                        }
                        fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_rotation(&target, value)
                        }
                        fn rotation(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::rotation(&target)
                        }
                        fn set_on_mouse_down(
                            &mut self,
                            value: super::ItemOnMouseDown,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_down(&target, value)
                        }
                        fn on_mouse_down(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDown, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_down(&target)
                        }
                        fn is_sibling(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_sibling(&target, item)
                        }
                        fn tween_from(
                            &self,
                            from: JsValue,
                            options: super::ItemTweenFromParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_from(&target, from, options)
                        }
                        fn set_layer(
                            &mut self,
                            value: super::Layer,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_layer(&target, value)
                        }
                        fn layer(&self) -> std::result::Result<super::Layer, JsValue> {
                            let target: Item = self.into();
                            super::Item::layer(&target)
                        }
                        fn contains(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::contains(&target, point)
                        }
                        fn set_on_click(
                            &mut self,
                            value: super::ItemOnClick,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_click(&target, value)
                        }
                        fn on_click(&self) -> std::result::Result<super::ItemOnClick, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_click(&target)
                        }
                        fn set_last_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_last_child(&target, value)
                        }
                        fn last_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::last_child(&target)
                        }
                        fn set_dash_offset(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_dash_offset(&target, value)
                        }
                        fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_offset(&target)
                        }
                        fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_id(&target, value)
                        }
                        fn id(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::id(&target)
                        }
                        fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_shadow(&target)
                        }
                        fn tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                            &self,
                            from: JsValue,
                            to: JsValue,
                            options: super::ItemTweenParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                                &target, from, to, options,
                            )
                        }
                        fn tween_FnJsValueAndItemTweenParamsOptionsToTween(
                            &self,
                            to: JsValue,
                            options: super::ItemTweenParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_FnJsValueAndItemTweenParamsOptionsToTween(
                                &target, to, options,
                            )
                        }
                        fn tween_FnItemTweenParamsOptionsToTween(
                            &self,
                            options: super::ItemTweenParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_FnItemTweenParamsOptionsToTween(&target, options)
                        }
                        fn set_scaling(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_scaling(&target, value)
                        }
                        fn scaling(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::scaling(&target)
                        }
                        fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::send_to_back(&target)
                        }
                        fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::set(&target, props)
                        }
                        fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_index(&target, value)
                        }
                        fn index(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::index(&target)
                        }
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::reduce(&target, options)
                        }
                        fn set_pivot(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_pivot(&target, value)
                        }
                        fn pivot(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::pivot(&target)
                        }
                        fn insert_children(
                            &self,
                            index: f64,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_children(&target, index, items)
                        }
                        fn set_on_mouse_up(
                            &mut self,
                            value: super::ItemOnMouseUp,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_up(&target, value)
                        }
                        fn on_mouse_up(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseUp, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_up(&target)
                        }
                        fn set_stroke_width(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_width(&target, value)
                        }
                        fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_width(&target)
                        }
                        fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on(&target, options)
                        }
                        fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_up(&target)
                        }
                        fn is_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_child(&target, item)
                        }
                        fn replace_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::replace_with(&target, item)
                        }
                        fn export_json(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::export_json(&target, options)
                        }
                        fn hit_test_all(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<Vec<HitResult>, JsValue> {
                            let target: Item = self.into();
                            super::Item::hit_test_all(&target, point, options)
                        }
                        fn export_svg(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::ItemExportSvgReturn, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::export_svg(&target, options)
                        }
                        fn copy_to(
                            &self,
                            owner: super::ItemCopyToParamsOwner,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_to(&target, owner)
                        }
                        fn set_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_matrix(&target, value)
                        }
                        fn matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::matrix(&target)
                        }
                        fn add_to(
                            &self,
                            owner: super::ItemAddToParamsOwner,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_to(&target, owner)
                        }
                        fn rotate(
                            &self,
                            angle: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::rotate(&target, angle, center)
                        }
                        fn set_view_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_view_matrix(&target, value)
                        }
                        fn view_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::view_matrix(&target)
                        }
                        fn set_previous_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_previous_sibling(&target, value)
                        }
                        fn previous_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::previous_sibling(&target)
                        }
                        fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_data(&target, value)
                        }
                        fn data(&self) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::data(&target)
                        }
                        fn off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                            &self,
                            type_: String,
                            callback: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super :: Item :: off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                        }
                        fn off_FnJsValueToJsValue(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::off_FnJsValueToJsValue(&target, object)
                        }
                        fn set_stroke_scaling(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_scaling(&target, value)
                        }
                        fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_scaling(&target)
                        }
                        fn insert_child(
                            &self,
                            index: f64,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_child(&target, index, item)
                        }
                        fn skew_FnPointAndPointTo(
                            &self,
                            skew: super::Point,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::skew_FnPointAndPointTo(&target, skew, center)
                        }
                        fn skew_FnF64AndF64AndPointTo(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::skew_FnF64AndF64AndPointTo(&target, hor, ver, center)
                        }
                        fn on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                            &self,
                            type_: String,
                            callback: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super :: Item :: on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                        }
                        fn on_FnJsValueToJsValue(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_FnJsValueToJsValue(&target, object)
                        }
                        fn remove(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove(&target)
                        }
                        fn global_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_to_local(&target, point)
                        }
                        fn emit(
                            &self,
                            type_: String,
                            event: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::emit(&target, type_, event)
                        }
                        fn hit_test(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<super::HitResult, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::hit_test(&target, point, options)
                        }
                        fn import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                            &self,
                            svg: super::ItemImportSvgParamsSvg,
                            options: JsValue,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                                &target, svg, options,
                            )
                        }
                        fn import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem(
                            &self,
                            svg: super::ItemImportSvgParamsSvg,
                            on_load: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super :: Item :: import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem (& target , svg , on_load)
                        }
                        fn set_dash_array(
                            &mut self,
                            value: Vec<f64>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_dash_array(&target, value)
                        }
                        fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_array(&target)
                        }
                        fn shear_FnPointAndPointTo(
                            &self,
                            shear: super::Point,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::shear_FnPointAndPointTo(&target, shear, center)
                        }
                        fn shear_FnF64AndF64AndPointTo(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::shear_FnF64AndF64AndPointTo(&target, hor, ver, center)
                        }
                        fn set_internal_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_internal_bounds(&target, value)
                        }
                        fn internal_bounds(
                            &self,
                        ) -> std::result::Result<super::Rectangle, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::internal_bounds(&target)
                        }
                        fn set_stroke_cap(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_cap(&target, value)
                        }
                        fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_cap(&target)
                        }
                        fn set_on_mouse_enter(
                            &mut self,
                            value: super::ItemOnMouseEnter,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_enter(&target, value)
                        }
                        fn on_mouse_enter(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseEnter, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_enter(&target)
                        }
                        fn set_view(
                            &mut self,
                            value: super::View,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_view(&target, value)
                        }
                        fn view(&self) -> std::result::Result<super::View, JsValue> {
                            let target: Item = self.into();
                            super::Item::view(&target)
                        }
                        fn set_stroke_join(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_join(&target, value)
                        }
                        fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_join(&target)
                        }
                        fn is_ancestor(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_ancestor(&target, item)
                        }
                        fn set_fill_rule(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_fill_rule(&target, value)
                        }
                        fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_rule(&target)
                        }
                        fn fit_bounds(
                            &self,
                            rectangle: super::Rectangle,
                            fill: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::fit_bounds(&target, rectangle, fill)
                        }
                        fn local_to_parent(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_parent(&target, point)
                        }
                        fn set_handle_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_handle_bounds(&target, value)
                        }
                        fn handle_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::handle_bounds(&target)
                        }
                        fn set_next_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_next_sibling(&target, value)
                        }
                        fn next_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::next_sibling(&target)
                        }
                        fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::clone(&target, options)
                        }
                        fn is_descendant(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_descendant(&target, item)
                        }
                        fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_down(&target)
                        }
                        fn is_parent(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_parent(&target, item)
                        }
                        fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_move(&target)
                        }
                        fn is_empty(
                            &self,
                            recursively: bool,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_empty(&target, recursively)
                        }
                        fn rasterize(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Raster, JsValue> {
                            let target: Item = self.into();
                            super::Item::rasterize(&target, options)
                        }
                        fn set_shadow_color(
                            &mut self,
                            value: super::ItemShadowColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_shadow_color(&target, value)
                        }
                        fn shadow_color(
                            &self,
                        ) -> std::result::Result<super::ItemShadowColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::shadow_color(&target)
                        }
                        fn set_miter_limit(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_miter_limit(&target, value)
                        }
                        fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::miter_limit(&target)
                        }
                        fn get_item(
                            &self,
                            options: super::ItemGetItemParamsOptions,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_item(&target, options)
                        }
                        fn import_json(
                            &self,
                            json: String,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_json(&target, json)
                        }
                        fn insert_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_above(&target, item)
                        }
                        fn set_on_mouse_drag(
                            &mut self,
                            value: super::ItemOnMouseDrag,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_drag(&target, value)
                        }
                        fn on_mouse_drag(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDrag, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_drag(&target)
                        }
                        fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inserted(&target)
                        }
                        fn set_apply_matrix(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_apply_matrix(&target, value)
                        }
                        fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::apply_matrix(&target)
                        }
                        fn transform(
                            &self,
                            matrix: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::transform(&target, matrix)
                        }
                        fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_visible(&target, value)
                        }
                        fn visible(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::visible(&target)
                        }
                        fn set_stroke_color(
                            &mut self,
                            value: super::ItemStrokeColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_color(&target, value)
                        }
                        fn stroke_color(
                            &self,
                        ) -> std::result::Result<super::ItemStrokeColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::stroke_color(&target)
                        }
                        fn set_on_mouse_leave(
                            &mut self,
                            value: super::ItemOnMouseLeave,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_leave(&target, value)
                        }
                        fn on_mouse_leave(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseLeave, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_leave(&target)
                        }
                        fn parent_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent_to_local(&target, point)
                        }
                        fn is_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_above(&target, item)
                        }
                        fn get_items(
                            &self,
                            options: super::ItemGetItemsParamsOptions,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_items(&target, options)
                        }
                        fn has_children(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_children(&target)
                        }
                        fn translate(
                            &self,
                            delta: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::translate(&target, delta)
                        }
                        fn set_parent(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_parent(&target, value)
                        }
                        fn parent(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent(&target)
                        }
                        fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_locked(&target, value)
                        }
                        fn locked(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::locked(&target)
                        }
                        fn local_to_global(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_global(&target, point)
                        }
                    }
                    impl Circle_Trait for Circle where Circle: Path_Trait {}
                    impl std::clone::Clone for Circle_Class {
                        fn clone(&self) -> Self {
                            Self {
                                obj: std::clone::Clone::clone(&self.obj),
                            }
                        }
                    }
                    impl serde::ser::Serialize for Circle_Class {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Circle_Class {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                        }
                    }
                }
                #[cfg(target_family = "wasm")]
                pub mod shape {
                    #[allow(unused)]
                    use super::*;
                    #[allow(unused)]
                    use wasm_bindgen::prelude::*;
                    #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                    extern "C" {
                        #[allow(non_camel_case_types)]
                        # [wasm_bindgen (js_name = "Rectangle" , extends = Item_Class , extends = Shape_Class)]
                        pub type Rectangle_Class;
                        #[wasm_bindgen(constructor, js_class = "Rectangle")]
                        pub fn new_FnSuperRectangleAndSuperSizeToRectangle(
                            rectangle: super::Rectangle,
                            radius: super::Size,
                        ) -> Rectangle_Class;
                        #[wasm_bindgen(constructor, js_class = "Rectangle")]
                        pub fn new_FnSuperPointAndSuperSizeToRectangle(
                            point: super::Point,
                            size: super::Size,
                        ) -> Rectangle_Class;
                        #[wasm_bindgen(constructor, js_class = "Rectangle")]
                        pub fn new_FnSuperPointAndSuperPointToRectangle(
                            from: super::Point,
                            to: super::Point,
                        ) -> Rectangle_Class;
                        #[wasm_bindgen(constructor, js_class = "Rectangle")]
                        pub fn new_FnJsValueToRectangle(object: JsValue) -> Rectangle_Class;
                    }
                    #[derive(std :: clone :: Clone)]
                    pub struct Rectangle(pub Rectangle_Class);
                    impl std::convert::From<&Rectangle> for super::Shape {
                        fn from(src: &Rectangle) -> super::Shape {
                            let src: &super::Shape_Class = src.0.as_ref();
                            super::Shape(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Rectangle> for super::Shape {
                        fn from(src: &mut Rectangle) -> super::Shape {
                            let src: &super::Shape_Class = src.0.as_ref();
                            super::Shape(src.clone())
                        }
                    }
                    impl std::convert::From<&Rectangle> for super::Item {
                        fn from(src: &Rectangle) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Rectangle> for super::Item {
                        fn from(src: &mut Rectangle) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<Rectangle> for JsValue {
                        fn from(src: Rectangle) -> JsValue {
                            JsValue::from(src.0)
                        }
                    }
                    impl std::convert::AsRef<JsValue> for Rectangle {
                        fn as_ref(&self) -> &JsValue {
                            self.0.as_ref()
                        }
                    }
                    impl wasm_bindgen::JsCast for Rectangle {
                        fn instanceof(val: &JsValue) -> bool {
                            Rectangle_Class::instanceof(val)
                        }
                        fn unchecked_from_js(val: JsValue) -> Self {
                            Rectangle(Rectangle_Class::unchecked_from_js(val))
                        }
                        fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                            unsafe {
                                &*(Rectangle_Class::unchecked_from_js_ref(val)
                                    as *const Rectangle_Class
                                    as *const Self)
                            }
                        }
                    }
                    impl Rectangle {
                        #[allow(dead_code, non_snake_case)]
                        pub fn new_FnSuperRectangleAndSuperSizeToRectangle(
                            rectangle: super::Rectangle,
                            radius: super::Size,
                        ) -> Rectangle {
                            let result =
                                Rectangle_Class::new_FnSuperRectangleAndSuperSizeToRectangle(
                                    rectangle, radius,
                                );
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            Rectangle(result)
                        }
                        #[allow(dead_code, non_snake_case)]
                        pub fn new_FnSuperPointAndSuperSizeToRectangle(
                            point: super::Point,
                            size: super::Size,
                        ) -> Rectangle {
                            let result = Rectangle_Class::new_FnSuperPointAndSuperSizeToRectangle(
                                point, size,
                            );
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            Rectangle(result)
                        }
                        #[allow(dead_code, non_snake_case)]
                        pub fn new_FnSuperPointAndSuperPointToRectangle(
                            from: super::Point,
                            to: super::Point,
                        ) -> Rectangle {
                            let result =
                                Rectangle_Class::new_FnSuperPointAndSuperPointToRectangle(from, to);
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            Rectangle(result)
                        }
                        #[allow(dead_code, non_snake_case)]
                        pub fn new_FnJsValueToRectangle(object: JsValue) -> Rectangle {
                            let result = Rectangle_Class::new_FnJsValueToRectangle(object);
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            Rectangle(result)
                        }
                    }
                    impl wasm_bindgen::describe::WasmDescribe for Rectangle {
                        fn describe() {
                            <Rectangle_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                        }
                    }
                    impl wasm_bindgen::convert::IntoWasmAbi for Rectangle {
                        type Abi = <Rectangle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                        }
                    }
                    impl wasm_bindgen::convert::FromWasmAbi for Rectangle {
                        type Abi = <Rectangle_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                        unsafe fn from_abi(js: Self::Abi) -> Self {
                            Rectangle(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                        }
                    }
                    impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Rectangle {
                        type Abi = <&'a Rectangle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                        }
                    }
                    impl serde::ser::Serialize for Rectangle {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde::ser::Serialize::serialize(&self.0, serializer)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Rectangle {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            let internal: Rectangle_Class =
                                <Rectangle_Class as serde::de::Deserialize>::deserialize(
                                    deserializer,
                                )?;
                            std::result::Result::Ok(Self(internal))
                        }
                    }
                    #[allow(non_camel_case_types, non_snake_case)]
                    pub trait Rectangle_Trait: Shape_Trait {}
                    impl Shape_Trait for Rectangle
                    where
                        Rectangle: Item_Trait,
                    {
                        fn set_radius(
                            &mut self,
                            value: super::ShapeRadius,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::set_radius(&target, value)
                        }
                        fn radius(&self) -> std::result::Result<super::ShapeRadius, JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::radius(&target)
                        }
                        fn to_path(
                            &self,
                            insert: bool,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::to_path(&target, insert)
                        }
                        fn set_size(
                            &mut self,
                            value: super::Size,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::set_size(&target, value)
                        }
                        fn size(&self) -> std::result::Result<super::Size, JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::size(&target)
                        }
                        fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::set_type_(&target, value)
                        }
                        fn type_(&self) -> std::result::Result<String, JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::type_(&target)
                        }
                    }
                    impl Item_Trait for Rectangle {
                        fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::responds(&target, type_)
                        }
                        fn copy_content(
                            &self,
                            source: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_content(&target, source)
                        }
                        fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_opacity(&target, value)
                        }
                        fn opacity(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::opacity(&target)
                        }
                        fn set_on_frame(
                            &mut self,
                            value: super::ItemOnFrame,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_frame(&target, value)
                        }
                        fn on_frame(&self) -> std::result::Result<super::ItemOnFrame, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_frame(&target)
                        }
                        fn remove_children_FnToVecOfItem(
                            &self,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_children_FnToVecOfItem(&target)
                        }
                        fn remove_children_FnF64AndF64ToVecOfItem(
                            &self,
                            start: f64,
                            end: f64,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_children_FnF64AndF64ToVecOfItem(&target, start, end)
                        }
                        fn is_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_below(&target, item)
                        }
                        fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_stroke(&target)
                        }
                        fn set_global_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_global_matrix(&target, value)
                        }
                        fn global_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_matrix(&target)
                        }
                        fn copy_attributes(
                            &self,
                            source: super::Item,
                            exclude_matrix: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_attributes(&target, source, exclude_matrix)
                        }
                        fn set_on_mouse_move(
                            &mut self,
                            value: super::ItemOnMouseMove,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_move(&target, value)
                        }
                        fn on_mouse_move(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseMove, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_move(&target)
                        }
                        fn set_position(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_position(&target, value)
                        }
                        fn position(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::position(&target)
                        }
                        fn set_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_bounds(&target, value)
                        }
                        fn bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::bounds(&target)
                        }
                        fn set_shadow_blur(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_shadow_blur(&target, value)
                        }
                        fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_blur(&target)
                        }
                        fn set_selected_color(
                            &mut self,
                            value: super::ItemSelectedColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_selected_color(&target, value)
                        }
                        fn selected_color(
                            &self,
                        ) -> std::result::Result<super::ItemSelectedColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::selected_color(&target)
                        }
                        fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::reverse_children(&target)
                        }
                        fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::bring_to_front(&target)
                        }
                        fn set_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_selected(&target, value)
                        }
                        fn selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::selected(&target)
                        }
                        fn add_children(
                            &self,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_children(&target, items)
                        }
                        fn tween_to(
                            &self,
                            to: JsValue,
                            options: super::ItemTweenToParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_to(&target, to, options)
                        }
                        fn set_project(
                            &mut self,
                            value: super::Project,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_project(&target, value)
                        }
                        fn project(&self) -> std::result::Result<super::Project, JsValue> {
                            let target: Item = self.into();
                            super::Item::project(&target)
                        }
                        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_name(&target, value)
                        }
                        fn name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::name(&target)
                        }
                        fn set_stroke_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_bounds(&target, value)
                        }
                        fn stroke_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_bounds(&target)
                        }
                        fn insert_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_below(&target, item)
                        }
                        fn set_blend_mode(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_blend_mode(&target, value)
                        }
                        fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::blend_mode(&target)
                        }
                        fn set_clip_mask(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_clip_mask(&target, value)
                        }
                        fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::clip_mask(&target)
                        }
                        fn set_fill_color(
                            &mut self,
                            value: super::ItemFillColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_fill_color(&target, value)
                        }
                        fn fill_color(&self) -> std::result::Result<super::ItemFillColor, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_color(&target)
                        }
                        fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_drag(&target)
                        }
                        fn add_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_child(&target, item)
                        }
                        fn scale_FnF64AndPointTo(
                            &self,
                            scale: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::scale_FnF64AndPointTo(&target, scale, center)
                        }
                        fn scale_FnF64AndF64AndPointTo(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::scale_FnF64AndF64AndPointTo(&target, hor, ver, center)
                        }
                        fn set_first_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_first_child(&target, value)
                        }
                        fn first_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::first_child(&target)
                        }
                        fn set_style(
                            &mut self,
                            value: super::Style,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_style(&target, value)
                        }
                        fn style(&self) -> std::result::Result<super::Style, JsValue> {
                            let target: Item = self.into();
                            super::Item::style(&target)
                        }
                        fn set_class_name(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_class_name(&target, value)
                        }
                        fn class_name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::class_name(&target)
                        }
                        fn is_grouped_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_grouped_with(&target, item)
                        }
                        fn set_shadow_offset(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_shadow_offset(&target, value)
                        }
                        fn shadow_offset(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_offset(&target)
                        }
                        fn is_inside(
                            &self,
                            rect: super::Rectangle,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inside(&target, rect)
                        }
                        fn set_children(
                            &mut self,
                            value: Vec<Item>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_children(&target, value)
                        }
                        fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::children(&target)
                        }
                        fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_fill(&target)
                        }
                        fn matches_FnItemMatchesParamsOptionsToBool(
                            &self,
                            options: super::ItemMatchesParamsOptions,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::matches_FnItemMatchesParamsOptionsToBool(&target, options)
                        }
                        fn matches_FnStringAndJsValueToBool(
                            &self,
                            name: String,
                            compare: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::matches_FnStringAndJsValueToBool(&target, name, compare)
                        }
                        fn set_on_double_click(
                            &mut self,
                            value: super::ItemOnDoubleClick,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_double_click(&target, value)
                        }
                        fn on_double_click(
                            &self,
                        ) -> std::result::Result<super::ItemOnDoubleClick, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_double_click(&target)
                        }
                        fn intersects(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::intersects(&target, item)
                        }
                        fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_rotation(&target, value)
                        }
                        fn rotation(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::rotation(&target)
                        }
                        fn set_on_mouse_down(
                            &mut self,
                            value: super::ItemOnMouseDown,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_down(&target, value)
                        }
                        fn on_mouse_down(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDown, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_down(&target)
                        }
                        fn is_sibling(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_sibling(&target, item)
                        }
                        fn tween_from(
                            &self,
                            from: JsValue,
                            options: super::ItemTweenFromParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_from(&target, from, options)
                        }
                        fn set_layer(
                            &mut self,
                            value: super::Layer,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_layer(&target, value)
                        }
                        fn layer(&self) -> std::result::Result<super::Layer, JsValue> {
                            let target: Item = self.into();
                            super::Item::layer(&target)
                        }
                        fn contains(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::contains(&target, point)
                        }
                        fn set_on_click(
                            &mut self,
                            value: super::ItemOnClick,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_click(&target, value)
                        }
                        fn on_click(&self) -> std::result::Result<super::ItemOnClick, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_click(&target)
                        }
                        fn set_last_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_last_child(&target, value)
                        }
                        fn last_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::last_child(&target)
                        }
                        fn set_dash_offset(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_dash_offset(&target, value)
                        }
                        fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_offset(&target)
                        }
                        fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_id(&target, value)
                        }
                        fn id(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::id(&target)
                        }
                        fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_shadow(&target)
                        }
                        fn tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                            &self,
                            from: JsValue,
                            to: JsValue,
                            options: super::ItemTweenParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                                &target, from, to, options,
                            )
                        }
                        fn tween_FnJsValueAndItemTweenParamsOptionsToTween(
                            &self,
                            to: JsValue,
                            options: super::ItemTweenParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_FnJsValueAndItemTweenParamsOptionsToTween(
                                &target, to, options,
                            )
                        }
                        fn tween_FnItemTweenParamsOptionsToTween(
                            &self,
                            options: super::ItemTweenParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_FnItemTweenParamsOptionsToTween(&target, options)
                        }
                        fn set_scaling(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_scaling(&target, value)
                        }
                        fn scaling(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::scaling(&target)
                        }
                        fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::send_to_back(&target)
                        }
                        fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::set(&target, props)
                        }
                        fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_index(&target, value)
                        }
                        fn index(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::index(&target)
                        }
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::reduce(&target, options)
                        }
                        fn set_pivot(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_pivot(&target, value)
                        }
                        fn pivot(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::pivot(&target)
                        }
                        fn insert_children(
                            &self,
                            index: f64,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_children(&target, index, items)
                        }
                        fn set_on_mouse_up(
                            &mut self,
                            value: super::ItemOnMouseUp,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_up(&target, value)
                        }
                        fn on_mouse_up(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseUp, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_up(&target)
                        }
                        fn set_stroke_width(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_width(&target, value)
                        }
                        fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_width(&target)
                        }
                        fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on(&target, options)
                        }
                        fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_up(&target)
                        }
                        fn is_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_child(&target, item)
                        }
                        fn replace_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::replace_with(&target, item)
                        }
                        fn export_json(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::export_json(&target, options)
                        }
                        fn hit_test_all(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<Vec<HitResult>, JsValue> {
                            let target: Item = self.into();
                            super::Item::hit_test_all(&target, point, options)
                        }
                        fn export_svg(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::ItemExportSvgReturn, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::export_svg(&target, options)
                        }
                        fn copy_to(
                            &self,
                            owner: super::ItemCopyToParamsOwner,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_to(&target, owner)
                        }
                        fn set_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_matrix(&target, value)
                        }
                        fn matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::matrix(&target)
                        }
                        fn add_to(
                            &self,
                            owner: super::ItemAddToParamsOwner,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_to(&target, owner)
                        }
                        fn rotate(
                            &self,
                            angle: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::rotate(&target, angle, center)
                        }
                        fn set_view_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_view_matrix(&target, value)
                        }
                        fn view_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::view_matrix(&target)
                        }
                        fn set_previous_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_previous_sibling(&target, value)
                        }
                        fn previous_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::previous_sibling(&target)
                        }
                        fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_data(&target, value)
                        }
                        fn data(&self) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::data(&target)
                        }
                        fn off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                            &self,
                            type_: String,
                            callback: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super :: Item :: off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                        }
                        fn off_FnJsValueToJsValue(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::off_FnJsValueToJsValue(&target, object)
                        }
                        fn set_stroke_scaling(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_scaling(&target, value)
                        }
                        fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_scaling(&target)
                        }
                        fn insert_child(
                            &self,
                            index: f64,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_child(&target, index, item)
                        }
                        fn skew_FnPointAndPointTo(
                            &self,
                            skew: super::Point,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::skew_FnPointAndPointTo(&target, skew, center)
                        }
                        fn skew_FnF64AndF64AndPointTo(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::skew_FnF64AndF64AndPointTo(&target, hor, ver, center)
                        }
                        fn on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                            &self,
                            type_: String,
                            callback: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super :: Item :: on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                        }
                        fn on_FnJsValueToJsValue(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_FnJsValueToJsValue(&target, object)
                        }
                        fn remove(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove(&target)
                        }
                        fn global_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_to_local(&target, point)
                        }
                        fn emit(
                            &self,
                            type_: String,
                            event: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::emit(&target, type_, event)
                        }
                        fn hit_test(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<super::HitResult, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::hit_test(&target, point, options)
                        }
                        fn import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                            &self,
                            svg: super::ItemImportSvgParamsSvg,
                            options: JsValue,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                                &target, svg, options,
                            )
                        }
                        fn import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem(
                            &self,
                            svg: super::ItemImportSvgParamsSvg,
                            on_load: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super :: Item :: import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem (& target , svg , on_load)
                        }
                        fn set_dash_array(
                            &mut self,
                            value: Vec<f64>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_dash_array(&target, value)
                        }
                        fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_array(&target)
                        }
                        fn shear_FnPointAndPointTo(
                            &self,
                            shear: super::Point,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::shear_FnPointAndPointTo(&target, shear, center)
                        }
                        fn shear_FnF64AndF64AndPointTo(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::shear_FnF64AndF64AndPointTo(&target, hor, ver, center)
                        }
                        fn set_internal_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_internal_bounds(&target, value)
                        }
                        fn internal_bounds(
                            &self,
                        ) -> std::result::Result<super::Rectangle, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::internal_bounds(&target)
                        }
                        fn set_stroke_cap(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_cap(&target, value)
                        }
                        fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_cap(&target)
                        }
                        fn set_on_mouse_enter(
                            &mut self,
                            value: super::ItemOnMouseEnter,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_enter(&target, value)
                        }
                        fn on_mouse_enter(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseEnter, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_enter(&target)
                        }
                        fn set_view(
                            &mut self,
                            value: super::View,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_view(&target, value)
                        }
                        fn view(&self) -> std::result::Result<super::View, JsValue> {
                            let target: Item = self.into();
                            super::Item::view(&target)
                        }
                        fn set_stroke_join(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_join(&target, value)
                        }
                        fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_join(&target)
                        }
                        fn is_ancestor(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_ancestor(&target, item)
                        }
                        fn set_fill_rule(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_fill_rule(&target, value)
                        }
                        fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_rule(&target)
                        }
                        fn fit_bounds(
                            &self,
                            rectangle: super::Rectangle,
                            fill: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::fit_bounds(&target, rectangle, fill)
                        }
                        fn local_to_parent(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_parent(&target, point)
                        }
                        fn set_handle_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_handle_bounds(&target, value)
                        }
                        fn handle_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::handle_bounds(&target)
                        }
                        fn set_next_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_next_sibling(&target, value)
                        }
                        fn next_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::next_sibling(&target)
                        }
                        fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::clone(&target, options)
                        }
                        fn is_descendant(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_descendant(&target, item)
                        }
                        fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_down(&target)
                        }
                        fn is_parent(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_parent(&target, item)
                        }
                        fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_move(&target)
                        }
                        fn is_empty(
                            &self,
                            recursively: bool,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_empty(&target, recursively)
                        }
                        fn rasterize(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Raster, JsValue> {
                            let target: Item = self.into();
                            super::Item::rasterize(&target, options)
                        }
                        fn set_shadow_color(
                            &mut self,
                            value: super::ItemShadowColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_shadow_color(&target, value)
                        }
                        fn shadow_color(
                            &self,
                        ) -> std::result::Result<super::ItemShadowColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::shadow_color(&target)
                        }
                        fn set_miter_limit(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_miter_limit(&target, value)
                        }
                        fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::miter_limit(&target)
                        }
                        fn get_item(
                            &self,
                            options: super::ItemGetItemParamsOptions,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_item(&target, options)
                        }
                        fn import_json(
                            &self,
                            json: String,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_json(&target, json)
                        }
                        fn insert_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_above(&target, item)
                        }
                        fn set_on_mouse_drag(
                            &mut self,
                            value: super::ItemOnMouseDrag,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_drag(&target, value)
                        }
                        fn on_mouse_drag(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDrag, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_drag(&target)
                        }
                        fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inserted(&target)
                        }
                        fn set_apply_matrix(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_apply_matrix(&target, value)
                        }
                        fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::apply_matrix(&target)
                        }
                        fn transform(
                            &self,
                            matrix: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::transform(&target, matrix)
                        }
                        fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_visible(&target, value)
                        }
                        fn visible(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::visible(&target)
                        }
                        fn set_stroke_color(
                            &mut self,
                            value: super::ItemStrokeColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_color(&target, value)
                        }
                        fn stroke_color(
                            &self,
                        ) -> std::result::Result<super::ItemStrokeColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::stroke_color(&target)
                        }
                        fn set_on_mouse_leave(
                            &mut self,
                            value: super::ItemOnMouseLeave,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_leave(&target, value)
                        }
                        fn on_mouse_leave(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseLeave, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_leave(&target)
                        }
                        fn parent_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent_to_local(&target, point)
                        }
                        fn is_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_above(&target, item)
                        }
                        fn get_items(
                            &self,
                            options: super::ItemGetItemsParamsOptions,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_items(&target, options)
                        }
                        fn has_children(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_children(&target)
                        }
                        fn translate(
                            &self,
                            delta: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::translate(&target, delta)
                        }
                        fn set_parent(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_parent(&target, value)
                        }
                        fn parent(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent(&target)
                        }
                        fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_locked(&target, value)
                        }
                        fn locked(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::locked(&target)
                        }
                        fn local_to_global(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_global(&target, point)
                        }
                    }
                    impl Rectangle_Trait for Rectangle where Rectangle: Shape_Trait {}
                    impl std::clone::Clone for Rectangle_Class {
                        fn clone(&self) -> Self {
                            Self {
                                obj: std::clone::Clone::clone(&self.obj),
                            }
                        }
                    }
                    impl serde::ser::Serialize for Rectangle_Class {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Rectangle_Class {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                        }
                    }
                    #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                    extern "C" {
                        #[allow(non_camel_case_types)]
                        # [wasm_bindgen (js_name = "Ellipse" , extends = Shape_Class , extends = Item_Class)]
                        pub type Ellipse_Class;
                        #[wasm_bindgen(constructor, js_class = "Ellipse")]
                        pub fn new_FnSuperRectangleToEllipse(
                            rectangle: super::Rectangle,
                        ) -> Ellipse_Class;
                        #[wasm_bindgen(constructor, js_class = "Ellipse")]
                        pub fn new_FnJsValueToEllipse(object: JsValue) -> Ellipse_Class;
                    }
                    #[derive(std :: clone :: Clone)]
                    pub struct Ellipse(pub Ellipse_Class);
                    impl std::convert::From<&Ellipse> for super::Shape {
                        fn from(src: &Ellipse) -> super::Shape {
                            let src: &super::Shape_Class = src.0.as_ref();
                            super::Shape(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Ellipse> for super::Shape {
                        fn from(src: &mut Ellipse) -> super::Shape {
                            let src: &super::Shape_Class = src.0.as_ref();
                            super::Shape(src.clone())
                        }
                    }
                    impl std::convert::From<&Ellipse> for super::Item {
                        fn from(src: &Ellipse) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Ellipse> for super::Item {
                        fn from(src: &mut Ellipse) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<Ellipse> for JsValue {
                        fn from(src: Ellipse) -> JsValue {
                            JsValue::from(src.0)
                        }
                    }
                    impl std::convert::AsRef<JsValue> for Ellipse {
                        fn as_ref(&self) -> &JsValue {
                            self.0.as_ref()
                        }
                    }
                    impl wasm_bindgen::JsCast for Ellipse {
                        fn instanceof(val: &JsValue) -> bool {
                            Ellipse_Class::instanceof(val)
                        }
                        fn unchecked_from_js(val: JsValue) -> Self {
                            Ellipse(Ellipse_Class::unchecked_from_js(val))
                        }
                        fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                            unsafe {
                                &*(Ellipse_Class::unchecked_from_js_ref(val) as *const Ellipse_Class
                                    as *const Self)
                            }
                        }
                    }
                    impl Ellipse {
                        #[allow(dead_code, non_snake_case)]
                        pub fn new_FnSuperRectangleToEllipse(
                            rectangle: super::Rectangle,
                        ) -> Ellipse {
                            let result = Ellipse_Class::new_FnSuperRectangleToEllipse(rectangle);
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            Ellipse(result)
                        }
                        #[allow(dead_code, non_snake_case)]
                        pub fn new_FnJsValueToEllipse(object: JsValue) -> Ellipse {
                            let result = Ellipse_Class::new_FnJsValueToEllipse(object);
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            Ellipse(result)
                        }
                    }
                    impl wasm_bindgen::describe::WasmDescribe for Ellipse {
                        fn describe() {
                            <Ellipse_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                        }
                    }
                    impl wasm_bindgen::convert::IntoWasmAbi for Ellipse {
                        type Abi = <Ellipse_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                        }
                    }
                    impl wasm_bindgen::convert::FromWasmAbi for Ellipse {
                        type Abi = <Ellipse_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                        unsafe fn from_abi(js: Self::Abi) -> Self {
                            Ellipse(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                        }
                    }
                    impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Ellipse {
                        type Abi = <&'a Ellipse_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                        }
                    }
                    impl serde::ser::Serialize for Ellipse {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde::ser::Serialize::serialize(&self.0, serializer)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Ellipse {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            let internal: Ellipse_Class =
                                <Ellipse_Class as serde::de::Deserialize>::deserialize(
                                    deserializer,
                                )?;
                            std::result::Result::Ok(Self(internal))
                        }
                    }
                    #[allow(non_camel_case_types, non_snake_case)]
                    pub trait Ellipse_Trait: Shape_Trait {}
                    impl Shape_Trait for Ellipse
                    where
                        Ellipse: Item_Trait,
                    {
                        fn set_radius(
                            &mut self,
                            value: super::ShapeRadius,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::set_radius(&target, value)
                        }
                        fn radius(&self) -> std::result::Result<super::ShapeRadius, JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::radius(&target)
                        }
                        fn to_path(
                            &self,
                            insert: bool,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::to_path(&target, insert)
                        }
                        fn set_size(
                            &mut self,
                            value: super::Size,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::set_size(&target, value)
                        }
                        fn size(&self) -> std::result::Result<super::Size, JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::size(&target)
                        }
                        fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::set_type_(&target, value)
                        }
                        fn type_(&self) -> std::result::Result<String, JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::type_(&target)
                        }
                    }
                    impl Item_Trait for Ellipse {
                        fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::responds(&target, type_)
                        }
                        fn copy_content(
                            &self,
                            source: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_content(&target, source)
                        }
                        fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_opacity(&target, value)
                        }
                        fn opacity(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::opacity(&target)
                        }
                        fn set_on_frame(
                            &mut self,
                            value: super::ItemOnFrame,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_frame(&target, value)
                        }
                        fn on_frame(&self) -> std::result::Result<super::ItemOnFrame, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_frame(&target)
                        }
                        fn remove_children_FnToVecOfItem(
                            &self,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_children_FnToVecOfItem(&target)
                        }
                        fn remove_children_FnF64AndF64ToVecOfItem(
                            &self,
                            start: f64,
                            end: f64,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_children_FnF64AndF64ToVecOfItem(&target, start, end)
                        }
                        fn is_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_below(&target, item)
                        }
                        fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_stroke(&target)
                        }
                        fn set_global_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_global_matrix(&target, value)
                        }
                        fn global_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_matrix(&target)
                        }
                        fn copy_attributes(
                            &self,
                            source: super::Item,
                            exclude_matrix: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_attributes(&target, source, exclude_matrix)
                        }
                        fn set_on_mouse_move(
                            &mut self,
                            value: super::ItemOnMouseMove,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_move(&target, value)
                        }
                        fn on_mouse_move(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseMove, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_move(&target)
                        }
                        fn set_position(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_position(&target, value)
                        }
                        fn position(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::position(&target)
                        }
                        fn set_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_bounds(&target, value)
                        }
                        fn bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::bounds(&target)
                        }
                        fn set_shadow_blur(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_shadow_blur(&target, value)
                        }
                        fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_blur(&target)
                        }
                        fn set_selected_color(
                            &mut self,
                            value: super::ItemSelectedColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_selected_color(&target, value)
                        }
                        fn selected_color(
                            &self,
                        ) -> std::result::Result<super::ItemSelectedColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::selected_color(&target)
                        }
                        fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::reverse_children(&target)
                        }
                        fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::bring_to_front(&target)
                        }
                        fn set_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_selected(&target, value)
                        }
                        fn selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::selected(&target)
                        }
                        fn add_children(
                            &self,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_children(&target, items)
                        }
                        fn tween_to(
                            &self,
                            to: JsValue,
                            options: super::ItemTweenToParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_to(&target, to, options)
                        }
                        fn set_project(
                            &mut self,
                            value: super::Project,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_project(&target, value)
                        }
                        fn project(&self) -> std::result::Result<super::Project, JsValue> {
                            let target: Item = self.into();
                            super::Item::project(&target)
                        }
                        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_name(&target, value)
                        }
                        fn name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::name(&target)
                        }
                        fn set_stroke_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_bounds(&target, value)
                        }
                        fn stroke_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_bounds(&target)
                        }
                        fn insert_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_below(&target, item)
                        }
                        fn set_blend_mode(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_blend_mode(&target, value)
                        }
                        fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::blend_mode(&target)
                        }
                        fn set_clip_mask(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_clip_mask(&target, value)
                        }
                        fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::clip_mask(&target)
                        }
                        fn set_fill_color(
                            &mut self,
                            value: super::ItemFillColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_fill_color(&target, value)
                        }
                        fn fill_color(&self) -> std::result::Result<super::ItemFillColor, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_color(&target)
                        }
                        fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_drag(&target)
                        }
                        fn add_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_child(&target, item)
                        }
                        fn scale_FnF64AndPointTo(
                            &self,
                            scale: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::scale_FnF64AndPointTo(&target, scale, center)
                        }
                        fn scale_FnF64AndF64AndPointTo(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::scale_FnF64AndF64AndPointTo(&target, hor, ver, center)
                        }
                        fn set_first_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_first_child(&target, value)
                        }
                        fn first_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::first_child(&target)
                        }
                        fn set_style(
                            &mut self,
                            value: super::Style,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_style(&target, value)
                        }
                        fn style(&self) -> std::result::Result<super::Style, JsValue> {
                            let target: Item = self.into();
                            super::Item::style(&target)
                        }
                        fn set_class_name(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_class_name(&target, value)
                        }
                        fn class_name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::class_name(&target)
                        }
                        fn is_grouped_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_grouped_with(&target, item)
                        }
                        fn set_shadow_offset(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_shadow_offset(&target, value)
                        }
                        fn shadow_offset(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_offset(&target)
                        }
                        fn is_inside(
                            &self,
                            rect: super::Rectangle,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inside(&target, rect)
                        }
                        fn set_children(
                            &mut self,
                            value: Vec<Item>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_children(&target, value)
                        }
                        fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::children(&target)
                        }
                        fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_fill(&target)
                        }
                        fn matches_FnItemMatchesParamsOptionsToBool(
                            &self,
                            options: super::ItemMatchesParamsOptions,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::matches_FnItemMatchesParamsOptionsToBool(&target, options)
                        }
                        fn matches_FnStringAndJsValueToBool(
                            &self,
                            name: String,
                            compare: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::matches_FnStringAndJsValueToBool(&target, name, compare)
                        }
                        fn set_on_double_click(
                            &mut self,
                            value: super::ItemOnDoubleClick,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_double_click(&target, value)
                        }
                        fn on_double_click(
                            &self,
                        ) -> std::result::Result<super::ItemOnDoubleClick, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_double_click(&target)
                        }
                        fn intersects(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::intersects(&target, item)
                        }
                        fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_rotation(&target, value)
                        }
                        fn rotation(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::rotation(&target)
                        }
                        fn set_on_mouse_down(
                            &mut self,
                            value: super::ItemOnMouseDown,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_down(&target, value)
                        }
                        fn on_mouse_down(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDown, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_down(&target)
                        }
                        fn is_sibling(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_sibling(&target, item)
                        }
                        fn tween_from(
                            &self,
                            from: JsValue,
                            options: super::ItemTweenFromParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_from(&target, from, options)
                        }
                        fn set_layer(
                            &mut self,
                            value: super::Layer,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_layer(&target, value)
                        }
                        fn layer(&self) -> std::result::Result<super::Layer, JsValue> {
                            let target: Item = self.into();
                            super::Item::layer(&target)
                        }
                        fn contains(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::contains(&target, point)
                        }
                        fn set_on_click(
                            &mut self,
                            value: super::ItemOnClick,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_click(&target, value)
                        }
                        fn on_click(&self) -> std::result::Result<super::ItemOnClick, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_click(&target)
                        }
                        fn set_last_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_last_child(&target, value)
                        }
                        fn last_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::last_child(&target)
                        }
                        fn set_dash_offset(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_dash_offset(&target, value)
                        }
                        fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_offset(&target)
                        }
                        fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_id(&target, value)
                        }
                        fn id(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::id(&target)
                        }
                        fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_shadow(&target)
                        }
                        fn tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                            &self,
                            from: JsValue,
                            to: JsValue,
                            options: super::ItemTweenParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                                &target, from, to, options,
                            )
                        }
                        fn tween_FnJsValueAndItemTweenParamsOptionsToTween(
                            &self,
                            to: JsValue,
                            options: super::ItemTweenParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_FnJsValueAndItemTweenParamsOptionsToTween(
                                &target, to, options,
                            )
                        }
                        fn tween_FnItemTweenParamsOptionsToTween(
                            &self,
                            options: super::ItemTweenParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_FnItemTweenParamsOptionsToTween(&target, options)
                        }
                        fn set_scaling(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_scaling(&target, value)
                        }
                        fn scaling(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::scaling(&target)
                        }
                        fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::send_to_back(&target)
                        }
                        fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::set(&target, props)
                        }
                        fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_index(&target, value)
                        }
                        fn index(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::index(&target)
                        }
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::reduce(&target, options)
                        }
                        fn set_pivot(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_pivot(&target, value)
                        }
                        fn pivot(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::pivot(&target)
                        }
                        fn insert_children(
                            &self,
                            index: f64,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_children(&target, index, items)
                        }
                        fn set_on_mouse_up(
                            &mut self,
                            value: super::ItemOnMouseUp,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_up(&target, value)
                        }
                        fn on_mouse_up(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseUp, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_up(&target)
                        }
                        fn set_stroke_width(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_width(&target, value)
                        }
                        fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_width(&target)
                        }
                        fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on(&target, options)
                        }
                        fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_up(&target)
                        }
                        fn is_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_child(&target, item)
                        }
                        fn replace_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::replace_with(&target, item)
                        }
                        fn export_json(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::export_json(&target, options)
                        }
                        fn hit_test_all(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<Vec<HitResult>, JsValue> {
                            let target: Item = self.into();
                            super::Item::hit_test_all(&target, point, options)
                        }
                        fn export_svg(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::ItemExportSvgReturn, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::export_svg(&target, options)
                        }
                        fn copy_to(
                            &self,
                            owner: super::ItemCopyToParamsOwner,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_to(&target, owner)
                        }
                        fn set_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_matrix(&target, value)
                        }
                        fn matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::matrix(&target)
                        }
                        fn add_to(
                            &self,
                            owner: super::ItemAddToParamsOwner,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_to(&target, owner)
                        }
                        fn rotate(
                            &self,
                            angle: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::rotate(&target, angle, center)
                        }
                        fn set_view_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_view_matrix(&target, value)
                        }
                        fn view_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::view_matrix(&target)
                        }
                        fn set_previous_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_previous_sibling(&target, value)
                        }
                        fn previous_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::previous_sibling(&target)
                        }
                        fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_data(&target, value)
                        }
                        fn data(&self) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::data(&target)
                        }
                        fn off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                            &self,
                            type_: String,
                            callback: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super :: Item :: off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                        }
                        fn off_FnJsValueToJsValue(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::off_FnJsValueToJsValue(&target, object)
                        }
                        fn set_stroke_scaling(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_scaling(&target, value)
                        }
                        fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_scaling(&target)
                        }
                        fn insert_child(
                            &self,
                            index: f64,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_child(&target, index, item)
                        }
                        fn skew_FnPointAndPointTo(
                            &self,
                            skew: super::Point,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::skew_FnPointAndPointTo(&target, skew, center)
                        }
                        fn skew_FnF64AndF64AndPointTo(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::skew_FnF64AndF64AndPointTo(&target, hor, ver, center)
                        }
                        fn on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                            &self,
                            type_: String,
                            callback: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super :: Item :: on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                        }
                        fn on_FnJsValueToJsValue(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_FnJsValueToJsValue(&target, object)
                        }
                        fn remove(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove(&target)
                        }
                        fn global_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_to_local(&target, point)
                        }
                        fn emit(
                            &self,
                            type_: String,
                            event: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::emit(&target, type_, event)
                        }
                        fn hit_test(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<super::HitResult, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::hit_test(&target, point, options)
                        }
                        fn import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                            &self,
                            svg: super::ItemImportSvgParamsSvg,
                            options: JsValue,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                                &target, svg, options,
                            )
                        }
                        fn import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem(
                            &self,
                            svg: super::ItemImportSvgParamsSvg,
                            on_load: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super :: Item :: import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem (& target , svg , on_load)
                        }
                        fn set_dash_array(
                            &mut self,
                            value: Vec<f64>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_dash_array(&target, value)
                        }
                        fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_array(&target)
                        }
                        fn shear_FnPointAndPointTo(
                            &self,
                            shear: super::Point,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::shear_FnPointAndPointTo(&target, shear, center)
                        }
                        fn shear_FnF64AndF64AndPointTo(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::shear_FnF64AndF64AndPointTo(&target, hor, ver, center)
                        }
                        fn set_internal_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_internal_bounds(&target, value)
                        }
                        fn internal_bounds(
                            &self,
                        ) -> std::result::Result<super::Rectangle, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::internal_bounds(&target)
                        }
                        fn set_stroke_cap(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_cap(&target, value)
                        }
                        fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_cap(&target)
                        }
                        fn set_on_mouse_enter(
                            &mut self,
                            value: super::ItemOnMouseEnter,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_enter(&target, value)
                        }
                        fn on_mouse_enter(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseEnter, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_enter(&target)
                        }
                        fn set_view(
                            &mut self,
                            value: super::View,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_view(&target, value)
                        }
                        fn view(&self) -> std::result::Result<super::View, JsValue> {
                            let target: Item = self.into();
                            super::Item::view(&target)
                        }
                        fn set_stroke_join(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_join(&target, value)
                        }
                        fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_join(&target)
                        }
                        fn is_ancestor(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_ancestor(&target, item)
                        }
                        fn set_fill_rule(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_fill_rule(&target, value)
                        }
                        fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_rule(&target)
                        }
                        fn fit_bounds(
                            &self,
                            rectangle: super::Rectangle,
                            fill: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::fit_bounds(&target, rectangle, fill)
                        }
                        fn local_to_parent(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_parent(&target, point)
                        }
                        fn set_handle_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_handle_bounds(&target, value)
                        }
                        fn handle_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::handle_bounds(&target)
                        }
                        fn set_next_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_next_sibling(&target, value)
                        }
                        fn next_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::next_sibling(&target)
                        }
                        fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::clone(&target, options)
                        }
                        fn is_descendant(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_descendant(&target, item)
                        }
                        fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_down(&target)
                        }
                        fn is_parent(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_parent(&target, item)
                        }
                        fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_move(&target)
                        }
                        fn is_empty(
                            &self,
                            recursively: bool,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_empty(&target, recursively)
                        }
                        fn rasterize(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Raster, JsValue> {
                            let target: Item = self.into();
                            super::Item::rasterize(&target, options)
                        }
                        fn set_shadow_color(
                            &mut self,
                            value: super::ItemShadowColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_shadow_color(&target, value)
                        }
                        fn shadow_color(
                            &self,
                        ) -> std::result::Result<super::ItemShadowColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::shadow_color(&target)
                        }
                        fn set_miter_limit(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_miter_limit(&target, value)
                        }
                        fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::miter_limit(&target)
                        }
                        fn get_item(
                            &self,
                            options: super::ItemGetItemParamsOptions,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_item(&target, options)
                        }
                        fn import_json(
                            &self,
                            json: String,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_json(&target, json)
                        }
                        fn insert_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_above(&target, item)
                        }
                        fn set_on_mouse_drag(
                            &mut self,
                            value: super::ItemOnMouseDrag,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_drag(&target, value)
                        }
                        fn on_mouse_drag(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDrag, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_drag(&target)
                        }
                        fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inserted(&target)
                        }
                        fn set_apply_matrix(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_apply_matrix(&target, value)
                        }
                        fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::apply_matrix(&target)
                        }
                        fn transform(
                            &self,
                            matrix: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::transform(&target, matrix)
                        }
                        fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_visible(&target, value)
                        }
                        fn visible(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::visible(&target)
                        }
                        fn set_stroke_color(
                            &mut self,
                            value: super::ItemStrokeColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_color(&target, value)
                        }
                        fn stroke_color(
                            &self,
                        ) -> std::result::Result<super::ItemStrokeColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::stroke_color(&target)
                        }
                        fn set_on_mouse_leave(
                            &mut self,
                            value: super::ItemOnMouseLeave,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_leave(&target, value)
                        }
                        fn on_mouse_leave(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseLeave, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_leave(&target)
                        }
                        fn parent_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent_to_local(&target, point)
                        }
                        fn is_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_above(&target, item)
                        }
                        fn get_items(
                            &self,
                            options: super::ItemGetItemsParamsOptions,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_items(&target, options)
                        }
                        fn has_children(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_children(&target)
                        }
                        fn translate(
                            &self,
                            delta: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::translate(&target, delta)
                        }
                        fn set_parent(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_parent(&target, value)
                        }
                        fn parent(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent(&target)
                        }
                        fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_locked(&target, value)
                        }
                        fn locked(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::locked(&target)
                        }
                        fn local_to_global(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_global(&target, point)
                        }
                    }
                    impl Ellipse_Trait for Ellipse where Ellipse: Shape_Trait {}
                    impl std::clone::Clone for Ellipse_Class {
                        fn clone(&self) -> Self {
                            Self {
                                obj: std::clone::Clone::clone(&self.obj),
                            }
                        }
                    }
                    impl serde::ser::Serialize for Ellipse_Class {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Ellipse_Class {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                        }
                    }
                    #[wasm_bindgen(module = "node_modules/paper/dist/paper.js")]
                    extern "C" {
                        #[allow(non_camel_case_types)]
                        # [wasm_bindgen (js_name = "Circle" , extends = Shape_Class , extends = Item_Class)]
                        pub type Circle_Class;
                        #[wasm_bindgen(constructor, js_class = "Circle")]
                        pub fn new_FnSuperPointAndF64ToCircle(
                            center: super::Point,
                            radius: f64,
                        ) -> Circle_Class;
                        #[wasm_bindgen(constructor, js_class = "Circle")]
                        pub fn new_FnJsValueToCircle(object: JsValue) -> Circle_Class;
                    }
                    #[derive(std :: clone :: Clone)]
                    pub struct Circle(pub Circle_Class);
                    impl std::convert::From<&Circle> for super::Item {
                        fn from(src: &Circle) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Circle> for super::Item {
                        fn from(src: &mut Circle) -> super::Item {
                            let src: &super::Item_Class = src.0.as_ref();
                            super::Item(src.clone())
                        }
                    }
                    impl std::convert::From<&Circle> for super::Shape {
                        fn from(src: &Circle) -> super::Shape {
                            let src: &super::Shape_Class = src.0.as_ref();
                            super::Shape(src.clone())
                        }
                    }
                    impl std::convert::From<&mut Circle> for super::Shape {
                        fn from(src: &mut Circle) -> super::Shape {
                            let src: &super::Shape_Class = src.0.as_ref();
                            super::Shape(src.clone())
                        }
                    }
                    impl std::convert::From<Circle> for JsValue {
                        fn from(src: Circle) -> JsValue {
                            JsValue::from(src.0)
                        }
                    }
                    impl std::convert::AsRef<JsValue> for Circle {
                        fn as_ref(&self) -> &JsValue {
                            self.0.as_ref()
                        }
                    }
                    impl wasm_bindgen::JsCast for Circle {
                        fn instanceof(val: &JsValue) -> bool {
                            Circle_Class::instanceof(val)
                        }
                        fn unchecked_from_js(val: JsValue) -> Self {
                            Circle(Circle_Class::unchecked_from_js(val))
                        }
                        fn unchecked_from_js_ref(val: &JsValue) -> &Self {
                            unsafe {
                                &*(Circle_Class::unchecked_from_js_ref(val) as *const Circle_Class
                                    as *const Self)
                            }
                        }
                    }
                    impl Circle {
                        #[allow(dead_code, non_snake_case)]
                        pub fn new_FnSuperPointAndF64ToCircle(
                            center: super::Point,
                            radius: f64,
                        ) -> Circle {
                            let result =
                                Circle_Class::new_FnSuperPointAndF64ToCircle(center, radius);
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            Circle(result)
                        }
                        #[allow(dead_code, non_snake_case)]
                        pub fn new_FnJsValueToCircle(object: JsValue) -> Circle {
                            let result = Circle_Class::new_FnJsValueToCircle(object);
                            let result =
                                ts_bindgen_rt::jsvalue_serde::from_jsvalue(&result).unwrap();
                            Circle(result)
                        }
                    }
                    impl wasm_bindgen::describe::WasmDescribe for Circle {
                        fn describe() {
                            <Circle_Class as wasm_bindgen::describe::WasmDescribe>::describe()
                        }
                    }
                    impl wasm_bindgen::convert::IntoWasmAbi for Circle {
                        type Abi = <Circle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(self.0)
                        }
                    }
                    impl wasm_bindgen::convert::FromWasmAbi for Circle {
                        type Abi = <Circle_Class as wasm_bindgen::convert::FromWasmAbi>::Abi;
                        unsafe fn from_abi(js: Self::Abi) -> Self {
                            Circle(wasm_bindgen::convert::FromWasmAbi::from_abi(js))
                        }
                    }
                    impl<'a> wasm_bindgen::convert::IntoWasmAbi for &'a Circle {
                        type Abi = <&'a Circle_Class as wasm_bindgen::convert::IntoWasmAbi>::Abi;
                        fn into_abi(self) -> Self::Abi {
                            wasm_bindgen::convert::IntoWasmAbi::into_abi(&self.0)
                        }
                    }
                    impl serde::ser::Serialize for Circle {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde::ser::Serialize::serialize(&self.0, serializer)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Circle {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            let internal: Circle_Class =
                                <Circle_Class as serde::de::Deserialize>::deserialize(
                                    deserializer,
                                )?;
                            std::result::Result::Ok(Self(internal))
                        }
                    }
                    #[allow(non_camel_case_types, non_snake_case)]
                    pub trait Circle_Trait: Shape_Trait {}
                    impl Shape_Trait for Circle
                    where
                        Circle: Item_Trait,
                    {
                        fn set_radius(
                            &mut self,
                            value: super::ShapeRadius,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::set_radius(&target, value)
                        }
                        fn radius(&self) -> std::result::Result<super::ShapeRadius, JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::radius(&target)
                        }
                        fn to_path(
                            &self,
                            insert: bool,
                        ) -> std::result::Result<super::Path, JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::to_path(&target, insert)
                        }
                        fn set_size(
                            &mut self,
                            value: super::Size,
                        ) -> std::result::Result<(), JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::set_size(&target, value)
                        }
                        fn size(&self) -> std::result::Result<super::Size, JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::size(&target)
                        }
                        fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::set_type_(&target, value)
                        }
                        fn type_(&self) -> std::result::Result<String, JsValue> {
                            let target: super::Shape = self.into();
                            super::Shape::type_(&target)
                        }
                    }
                    impl Item_Trait for Circle {
                        fn responds(&self, type_: String) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::responds(&target, type_)
                        }
                        fn copy_content(
                            &self,
                            source: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_content(&target, source)
                        }
                        fn set_opacity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_opacity(&target, value)
                        }
                        fn opacity(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::opacity(&target)
                        }
                        fn set_on_frame(
                            &mut self,
                            value: super::ItemOnFrame,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_frame(&target, value)
                        }
                        fn on_frame(&self) -> std::result::Result<super::ItemOnFrame, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_frame(&target)
                        }
                        fn remove_children_FnToVecOfItem(
                            &self,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_children_FnToVecOfItem(&target)
                        }
                        fn remove_children_FnF64AndF64ToVecOfItem(
                            &self,
                            start: f64,
                            end: f64,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_children_FnF64AndF64ToVecOfItem(&target, start, end)
                        }
                        fn is_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_below(&target, item)
                        }
                        fn has_stroke(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_stroke(&target)
                        }
                        fn set_global_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_global_matrix(&target, value)
                        }
                        fn global_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_matrix(&target)
                        }
                        fn copy_attributes(
                            &self,
                            source: super::Item,
                            exclude_matrix: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_attributes(&target, source, exclude_matrix)
                        }
                        fn set_on_mouse_move(
                            &mut self,
                            value: super::ItemOnMouseMove,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_move(&target, value)
                        }
                        fn on_mouse_move(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseMove, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_move(&target)
                        }
                        fn set_position(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_position(&target, value)
                        }
                        fn position(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::position(&target)
                        }
                        fn set_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_bounds(&target, value)
                        }
                        fn bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::bounds(&target)
                        }
                        fn set_shadow_blur(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_shadow_blur(&target, value)
                        }
                        fn shadow_blur(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_blur(&target)
                        }
                        fn set_selected_color(
                            &mut self,
                            value: super::ItemSelectedColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_selected_color(&target, value)
                        }
                        fn selected_color(
                            &self,
                        ) -> std::result::Result<super::ItemSelectedColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::selected_color(&target)
                        }
                        fn reverse_children(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::reverse_children(&target)
                        }
                        fn bring_to_front(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::bring_to_front(&target)
                        }
                        fn set_selected(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_selected(&target, value)
                        }
                        fn selected(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::selected(&target)
                        }
                        fn add_children(
                            &self,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_children(&target, items)
                        }
                        fn tween_to(
                            &self,
                            to: JsValue,
                            options: super::ItemTweenToParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_to(&target, to, options)
                        }
                        fn set_project(
                            &mut self,
                            value: super::Project,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_project(&target, value)
                        }
                        fn project(&self) -> std::result::Result<super::Project, JsValue> {
                            let target: Item = self.into();
                            super::Item::project(&target)
                        }
                        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_name(&target, value)
                        }
                        fn name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::name(&target)
                        }
                        fn set_stroke_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_bounds(&target, value)
                        }
                        fn stroke_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_bounds(&target)
                        }
                        fn insert_below(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_below(&target, item)
                        }
                        fn set_blend_mode(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_blend_mode(&target, value)
                        }
                        fn blend_mode(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::blend_mode(&target)
                        }
                        fn set_clip_mask(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_clip_mask(&target, value)
                        }
                        fn clip_mask(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::clip_mask(&target)
                        }
                        fn set_fill_color(
                            &mut self,
                            value: super::ItemFillColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_fill_color(&target, value)
                        }
                        fn fill_color(&self) -> std::result::Result<super::ItemFillColor, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_color(&target)
                        }
                        fn remove_on_drag(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_drag(&target)
                        }
                        fn add_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_child(&target, item)
                        }
                        fn scale_FnF64AndPointTo(
                            &self,
                            scale: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::scale_FnF64AndPointTo(&target, scale, center)
                        }
                        fn scale_FnF64AndF64AndPointTo(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::scale_FnF64AndF64AndPointTo(&target, hor, ver, center)
                        }
                        fn set_first_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_first_child(&target, value)
                        }
                        fn first_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::first_child(&target)
                        }
                        fn set_style(
                            &mut self,
                            value: super::Style,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_style(&target, value)
                        }
                        fn style(&self) -> std::result::Result<super::Style, JsValue> {
                            let target: Item = self.into();
                            super::Item::style(&target)
                        }
                        fn set_class_name(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_class_name(&target, value)
                        }
                        fn class_name(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::class_name(&target)
                        }
                        fn is_grouped_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_grouped_with(&target, item)
                        }
                        fn set_shadow_offset(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_shadow_offset(&target, value)
                        }
                        fn shadow_offset(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::shadow_offset(&target)
                        }
                        fn is_inside(
                            &self,
                            rect: super::Rectangle,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inside(&target, rect)
                        }
                        fn set_children(
                            &mut self,
                            value: Vec<Item>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_children(&target, value)
                        }
                        fn children(&self) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::children(&target)
                        }
                        fn has_fill(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_fill(&target)
                        }
                        fn matches_FnItemMatchesParamsOptionsToBool(
                            &self,
                            options: super::ItemMatchesParamsOptions,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::matches_FnItemMatchesParamsOptionsToBool(&target, options)
                        }
                        fn matches_FnStringAndJsValueToBool(
                            &self,
                            name: String,
                            compare: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::matches_FnStringAndJsValueToBool(&target, name, compare)
                        }
                        fn set_on_double_click(
                            &mut self,
                            value: super::ItemOnDoubleClick,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_double_click(&target, value)
                        }
                        fn on_double_click(
                            &self,
                        ) -> std::result::Result<super::ItemOnDoubleClick, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_double_click(&target)
                        }
                        fn intersects(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::intersects(&target, item)
                        }
                        fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_rotation(&target, value)
                        }
                        fn rotation(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::rotation(&target)
                        }
                        fn set_on_mouse_down(
                            &mut self,
                            value: super::ItemOnMouseDown,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_down(&target, value)
                        }
                        fn on_mouse_down(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDown, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_down(&target)
                        }
                        fn is_sibling(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_sibling(&target, item)
                        }
                        fn tween_from(
                            &self,
                            from: JsValue,
                            options: super::ItemTweenFromParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_from(&target, from, options)
                        }
                        fn set_layer(
                            &mut self,
                            value: super::Layer,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_layer(&target, value)
                        }
                        fn layer(&self) -> std::result::Result<super::Layer, JsValue> {
                            let target: Item = self.into();
                            super::Item::layer(&target)
                        }
                        fn contains(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::contains(&target, point)
                        }
                        fn set_on_click(
                            &mut self,
                            value: super::ItemOnClick,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_click(&target, value)
                        }
                        fn on_click(&self) -> std::result::Result<super::ItemOnClick, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_click(&target)
                        }
                        fn set_last_child(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_last_child(&target, value)
                        }
                        fn last_child(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::last_child(&target)
                        }
                        fn set_dash_offset(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_dash_offset(&target, value)
                        }
                        fn dash_offset(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_offset(&target)
                        }
                        fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_id(&target, value)
                        }
                        fn id(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::id(&target)
                        }
                        fn has_shadow(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_shadow(&target)
                        }
                        fn tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                            &self,
                            from: JsValue,
                            to: JsValue,
                            options: super::ItemTweenParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_FnJsValueAndJsValueAndItemTweenParamsOptionsToTween(
                                &target, from, to, options,
                            )
                        }
                        fn tween_FnJsValueAndItemTweenParamsOptionsToTween(
                            &self,
                            to: JsValue,
                            options: super::ItemTweenParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_FnJsValueAndItemTweenParamsOptionsToTween(
                                &target, to, options,
                            )
                        }
                        fn tween_FnItemTweenParamsOptionsToTween(
                            &self,
                            options: super::ItemTweenParamsOptions,
                        ) -> std::result::Result<super::Tween, JsValue> {
                            let target: Item = self.into();
                            super::Item::tween_FnItemTweenParamsOptionsToTween(&target, options)
                        }
                        fn set_scaling(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_scaling(&target, value)
                        }
                        fn scaling(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::scaling(&target)
                        }
                        fn send_to_back(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::send_to_back(&target)
                        }
                        fn set(&self, props: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::set(&target, props)
                        }
                        fn set_index(&mut self, value: f64) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_index(&target, value)
                        }
                        fn index(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::index(&target)
                        }
                        fn reduce(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::reduce(&target, options)
                        }
                        fn set_pivot(
                            &mut self,
                            value: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_pivot(&target, value)
                        }
                        fn pivot(&self) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::pivot(&target)
                        }
                        fn insert_children(
                            &self,
                            index: f64,
                            items: Vec<Item>,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_children(&target, index, items)
                        }
                        fn set_on_mouse_up(
                            &mut self,
                            value: super::ItemOnMouseUp,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_up(&target, value)
                        }
                        fn on_mouse_up(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseUp, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_up(&target)
                        }
                        fn set_stroke_width(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_width(&target, value)
                        }
                        fn stroke_width(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_width(&target)
                        }
                        fn remove_on(&self, options: JsValue) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on(&target, options)
                        }
                        fn remove_on_up(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_up(&target)
                        }
                        fn is_child(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_child(&target, item)
                        }
                        fn replace_with(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::replace_with(&target, item)
                        }
                        fn export_json(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::export_json(&target, options)
                        }
                        fn hit_test_all(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<Vec<HitResult>, JsValue> {
                            let target: Item = self.into();
                            super::Item::hit_test_all(&target, point, options)
                        }
                        fn export_svg(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::ItemExportSvgReturn, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::export_svg(&target, options)
                        }
                        fn copy_to(
                            &self,
                            owner: super::ItemCopyToParamsOwner,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::copy_to(&target, owner)
                        }
                        fn set_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_matrix(&target, value)
                        }
                        fn matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::matrix(&target)
                        }
                        fn add_to(
                            &self,
                            owner: super::ItemAddToParamsOwner,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::add_to(&target, owner)
                        }
                        fn rotate(
                            &self,
                            angle: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::rotate(&target, angle, center)
                        }
                        fn set_view_matrix(
                            &mut self,
                            value: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_view_matrix(&target, value)
                        }
                        fn view_matrix(&self) -> std::result::Result<super::Matrix, JsValue> {
                            let target: Item = self.into();
                            super::Item::view_matrix(&target)
                        }
                        fn set_previous_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_previous_sibling(&target, value)
                        }
                        fn previous_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::previous_sibling(&target)
                        }
                        fn set_data(&mut self, value: JsValue) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_data(&target, value)
                        }
                        fn data(&self) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::data(&target)
                        }
                        fn off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                            &self,
                            type_: String,
                            callback: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super :: Item :: off_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                        }
                        fn off_FnJsValueToJsValue(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::off_FnJsValueToJsValue(&target, object)
                        }
                        fn set_stroke_scaling(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_scaling(&target, value)
                        }
                        fn stroke_scaling(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_scaling(&target)
                        }
                        fn insert_child(
                            &self,
                            index: f64,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_child(&target, index, item)
                        }
                        fn skew_FnPointAndPointTo(
                            &self,
                            skew: super::Point,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::skew_FnPointAndPointTo(&target, skew, center)
                        }
                        fn skew_FnF64AndF64AndPointTo(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::skew_FnF64AndF64AndPointTo(&target, hor, ver, center)
                        }
                        fn on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue(
                            &self,
                            type_: String,
                            callback: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super :: Item :: on_FnStringAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToJsValue (& target , type_ , callback)
                        }
                        fn on_FnJsValueToJsValue(
                            &self,
                            object: JsValue,
                        ) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::on_FnJsValueToJsValue(&target, object)
                        }
                        fn remove(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::remove(&target)
                        }
                        fn global_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::global_to_local(&target, point)
                        }
                        fn emit(
                            &self,
                            type_: String,
                            event: JsValue,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::emit(&target, type_, event)
                        }
                        fn hit_test(
                            &self,
                            point: super::Point,
                            options: JsValue,
                        ) -> std::result::Result<super::HitResult, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::hit_test(&target, point, options)
                        }
                        fn import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                            &self,
                            svg: super::ItemImportSvgParamsSvg,
                            options: JsValue,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_svg_FnItemImportSvgParamsSvgAndJsValueToItem(
                                &target, svg, options,
                            )
                        }
                        fn import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem(
                            &self,
                            svg: super::ItemImportSvgParamsSvg,
                            on_load: &'static dyn Fn(
                                Vec<JsValue>,
                            )
                                -> std::result::Result<JsValue, JsValue>,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super :: Item :: import_svg_FnItemImportSvgParamsSvgAndDynFnVecOfJsValueToStdResultResultOfJsValueAndJsValueToItem (& target , svg , on_load)
                        }
                        fn set_dash_array(
                            &mut self,
                            value: Vec<f64>,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_dash_array(&target, value)
                        }
                        fn dash_array(&self) -> std::result::Result<Vec<f64>, JsValue> {
                            let target: Item = self.into();
                            super::Item::dash_array(&target)
                        }
                        fn shear_FnPointAndPointTo(
                            &self,
                            shear: super::Point,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::shear_FnPointAndPointTo(&target, shear, center)
                        }
                        fn shear_FnF64AndF64AndPointTo(
                            &self,
                            hor: f64,
                            ver: f64,
                            center: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::shear_FnF64AndF64AndPointTo(&target, hor, ver, center)
                        }
                        fn set_internal_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_internal_bounds(&target, value)
                        }
                        fn internal_bounds(
                            &self,
                        ) -> std::result::Result<super::Rectangle, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::internal_bounds(&target)
                        }
                        fn set_stroke_cap(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_cap(&target, value)
                        }
                        fn stroke_cap(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_cap(&target)
                        }
                        fn set_on_mouse_enter(
                            &mut self,
                            value: super::ItemOnMouseEnter,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_enter(&target, value)
                        }
                        fn on_mouse_enter(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseEnter, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_enter(&target)
                        }
                        fn set_view(
                            &mut self,
                            value: super::View,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_view(&target, value)
                        }
                        fn view(&self) -> std::result::Result<super::View, JsValue> {
                            let target: Item = self.into();
                            super::Item::view(&target)
                        }
                        fn set_stroke_join(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_join(&target, value)
                        }
                        fn stroke_join(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::stroke_join(&target)
                        }
                        fn is_ancestor(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_ancestor(&target, item)
                        }
                        fn set_fill_rule(
                            &mut self,
                            value: String,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_fill_rule(&target, value)
                        }
                        fn fill_rule(&self) -> std::result::Result<String, JsValue> {
                            let target: Item = self.into();
                            super::Item::fill_rule(&target)
                        }
                        fn fit_bounds(
                            &self,
                            rectangle: super::Rectangle,
                            fill: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::fit_bounds(&target, rectangle, fill)
                        }
                        fn local_to_parent(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_parent(&target, point)
                        }
                        fn set_handle_bounds(
                            &mut self,
                            value: super::Rectangle,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_handle_bounds(&target, value)
                        }
                        fn handle_bounds(&self) -> std::result::Result<super::Rectangle, JsValue> {
                            let target: Item = self.into();
                            super::Item::handle_bounds(&target)
                        }
                        fn set_next_sibling(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_next_sibling(&target, value)
                        }
                        fn next_sibling(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::next_sibling(&target)
                        }
                        fn clone(&self, options: JsValue) -> std::result::Result<JsValue, JsValue> {
                            let target: Item = self.into();
                            super::Item::clone(&target, options)
                        }
                        fn is_descendant(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_descendant(&target, item)
                        }
                        fn remove_on_down(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_down(&target)
                        }
                        fn is_parent(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_parent(&target, item)
                        }
                        fn remove_on_move(&self) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::remove_on_move(&target)
                        }
                        fn is_empty(
                            &self,
                            recursively: bool,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_empty(&target, recursively)
                        }
                        fn rasterize(
                            &self,
                            options: JsValue,
                        ) -> std::result::Result<super::Raster, JsValue> {
                            let target: Item = self.into();
                            super::Item::rasterize(&target, options)
                        }
                        fn set_shadow_color(
                            &mut self,
                            value: super::ItemShadowColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_shadow_color(&target, value)
                        }
                        fn shadow_color(
                            &self,
                        ) -> std::result::Result<super::ItemShadowColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::shadow_color(&target)
                        }
                        fn set_miter_limit(
                            &mut self,
                            value: f64,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_miter_limit(&target, value)
                        }
                        fn miter_limit(&self) -> std::result::Result<f64, JsValue> {
                            let target: Item = self.into();
                            super::Item::miter_limit(&target)
                        }
                        fn get_item(
                            &self,
                            options: super::ItemGetItemParamsOptions,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_item(&target, options)
                        }
                        fn import_json(
                            &self,
                            json: String,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::import_json(&target, json)
                        }
                        fn insert_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::insert_above(&target, item)
                        }
                        fn set_on_mouse_drag(
                            &mut self,
                            value: super::ItemOnMouseDrag,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_drag(&target, value)
                        }
                        fn on_mouse_drag(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseDrag, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_drag(&target)
                        }
                        fn is_inserted(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_inserted(&target)
                        }
                        fn set_apply_matrix(
                            &mut self,
                            value: bool,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_apply_matrix(&target, value)
                        }
                        fn apply_matrix(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::apply_matrix(&target)
                        }
                        fn transform(
                            &self,
                            matrix: super::Matrix,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::transform(&target, matrix)
                        }
                        fn set_visible(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_visible(&target, value)
                        }
                        fn visible(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::visible(&target)
                        }
                        fn set_stroke_color(
                            &mut self,
                            value: super::ItemStrokeColor,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_stroke_color(&target, value)
                        }
                        fn stroke_color(
                            &self,
                        ) -> std::result::Result<super::ItemStrokeColor, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::stroke_color(&target)
                        }
                        fn set_on_mouse_leave(
                            &mut self,
                            value: super::ItemOnMouseLeave,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_on_mouse_leave(&target, value)
                        }
                        fn on_mouse_leave(
                            &self,
                        ) -> std::result::Result<super::ItemOnMouseLeave, JsValue>
                        {
                            let target: Item = self.into();
                            super::Item::on_mouse_leave(&target)
                        }
                        fn parent_to_local(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent_to_local(&target, point)
                        }
                        fn is_above(
                            &self,
                            item: super::Item,
                        ) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::is_above(&target, item)
                        }
                        fn get_items(
                            &self,
                            options: super::ItemGetItemsParamsOptions,
                        ) -> std::result::Result<Vec<Item>, JsValue> {
                            let target: Item = self.into();
                            super::Item::get_items(&target, options)
                        }
                        fn has_children(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::has_children(&target)
                        }
                        fn translate(
                            &self,
                            delta: super::Point,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::translate(&target, delta)
                        }
                        fn set_parent(
                            &mut self,
                            value: super::Item,
                        ) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_parent(&target, value)
                        }
                        fn parent(&self) -> std::result::Result<super::Item, JsValue> {
                            let target: Item = self.into();
                            super::Item::parent(&target)
                        }
                        fn set_locked(&mut self, value: bool) -> std::result::Result<(), JsValue> {
                            let target: Item = self.into();
                            super::Item::set_locked(&target, value)
                        }
                        fn locked(&self) -> std::result::Result<bool, JsValue> {
                            let target: Item = self.into();
                            super::Item::locked(&target)
                        }
                        fn local_to_global(
                            &self,
                            point: super::Point,
                        ) -> std::result::Result<super::Point, JsValue> {
                            let target: Item = self.into();
                            super::Item::local_to_global(&target, point)
                        }
                    }
                    impl Circle_Trait for Circle where Circle: Shape_Trait {}
                    impl std::clone::Clone for Circle_Class {
                        fn clone(&self) -> Self {
                            Self {
                                obj: std::clone::Clone::clone(&self.obj),
                            }
                        }
                    }
                    impl serde::ser::Serialize for Circle_Class {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            ts_bindgen_rt::serialize_as_jsvalue(serializer, self)
                        }
                    }
                    impl<'de> serde::de::Deserialize<'de> for Circle_Class {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::de::Deserializer<'de>,
                        {
                            ts_bindgen_rt::deserialize_as_jsvalue(deserializer)
                        }
                    }
                }
            }
        }
        #[cfg(target_family = "wasm")]
        pub mod paper_core {
            #[allow(unused)]
            use super::*;
            #[allow(unused)]
            use wasm_bindgen::prelude::*;
        }
    }
}
